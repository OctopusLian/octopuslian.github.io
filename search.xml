<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年计划要做的事</title>
    <url>/2019/01/15/2019-demand-do-something/</url>
    <content><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>目前了解到的会涉及以下方面：  </p>
<ul>
<li>流媒体服务<br>以Go语言为主；熟练掌握TCP&#x2F;IP，HTTP原理；常用的MySQL和Redis数据库用法。  </li>
<li>视音频编解码<br>C&#x2F;C++语言为主；  </li>
<li>图形图像<br>C&#x2F;C++语言，OpenGL；OpenCV。</li>
</ul>
<h2 id="业余安排"><a href="#业余安排" class="headerlink" title="业余安排"></a>业余安排</h2><p>业余时间计划完成以下事情：  </p>
<h3 id="附加技能"><a href="#附加技能" class="headerlink" title="附加技能"></a>附加技能</h3><ul>
<li>熟悉JavaScript，争取能完成一个在线简历模板；  </li>
<li>熟练Java语言，希望能接1-2个毕设赚些零花钱；  </li>
<li>LeetCode每周一题；</li>
</ul>
<h3 id="阅读提升"><a href="#阅读提升" class="headerlink" title="阅读提升"></a>阅读提升</h3><ul>
<li>极客时间上的四个专栏（左耳听风，趣谈网络，数据结构算法，数学基础）研读；  </li>
<li>开始阅读大部头经典书籍，例如CSAPP和UNP，并认真完成章节的课后练习题；  </li>
<li>Medium上争取两周内翻译一篇和自己学习工作相关的技术文章；  </li>
<li>每天半小时学习口语；</li>
</ul>
<h3 id="培养兴趣爱好"><a href="#培养兴趣爱好" class="headerlink" title="培养兴趣爱好"></a>培养兴趣爱好</h3><ul>
<li>学习下拍照摄影，争取给女友拍出美美的照片～  </li>
<li>继续在健身房练习街舞，希望今年可以练出托马斯回旋和大风车；</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>继续维护我的英语学习项目<a href="https://github.com/OctopusLian/VocabularyMap">VocabularyMap</a>，争取在九月底国庆前完成词根词汇的拓展并加上中文释义。  </li>
<li>继续坚持创作，幻想和思考。</li>
</ul>
<p><img src="/2019/01/15/2019-demand-do-something/%E5%8A%A0%E6%B2%B9.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年终总结——All is well</title>
    <url>/2020/12/31/2020-year-summary-all-is-well/</url>
    <content><![CDATA[<p>兰彻：那天我懂了，心很脆弱，你得学会哄它，不管遇到多大困难，告诉你的心，All is well 一切顺利。<br>拉朱：那能解决问题吗<br>兰彻：不能啊，但你得到了面对问题的勇气。  </p>
<pre><code>                                                 ——《三傻大闹宝莱坞》  
</code></pre>
<p>今年发生了许多事，面试、离职、裸辞、备考…，写以此文，纪念我已经逝去的2020。 </p>
<p>从毕业到职场，已经过去了两年半，从满心欢喜的实现了我小时候的梦想——工程师，到如今开始对大环境的迷茫和怀疑，我一时不知所措。  </p>
<h2 id="疫情期间的无所事事"><a href="#疫情期间的无所事事" class="headerlink" title="疫情期间的无所事事"></a>疫情期间的无所事事</h2><p>最开始提醒我要戴口罩的是一位在武汉某人民医院工作的朋友，虽然新闻上没报道，但他还是及时把这条信息传达给了我，于是我下班就去街上的药店买口罩，结果第二天上班再去买时已经卖光了，庆幸自己提前一天买到了。  </p>
<p>疫情期间是我从工作以来和家人待的最久的一次，基本上是吃玩睡循环往复，偶尔刷一刷leetcode，因为我有工作，所以不着急跳槽。只是没有想到这场疫情会持续一年之久…  </p>
<h2 id="裸辞的萌芽"><a href="#裸辞的萌芽" class="headerlink" title="裸辞的萌芽"></a>裸辞的萌芽</h2><p>最开始有离职的想法，是因为没给发发年终奖，虽然兢兢业业的工作一年，写了不少bug，但至少都修复了，然而当这最后的底线被突破后，我已经无所留恋，于是开始物色下一家，然而尴尬的是大厂缩招，小厂看不上，于是陷入了这样的死循环，直到11月研究生网上报名通过，才正式提出离职。  </p>
<p>So，为什么会选择离职去考研呢？  </p>
<p>有些事情当时做不知所以然，只有经历了才知道曾经原来一直生活在天堂里，比如读书，比如学历。  </p>
<p>如果你也像我一样，感到慌张，感到无助，请将右手放在左心房这，对自己说一句“All is well”，因为接下来我将对我遇到的情况进行全面辩证地分析。  </p>
<p>以下内容将以对话采访形式进行论述。  </p>
<h2 id="如果研究生读完出来年龄大怎么办？"><a href="#如果研究生读完出来年龄大怎么办？" class="headerlink" title="如果研究生读完出来年龄大怎么办？"></a>如果研究生读完出来年龄大怎么办？</h2><p>什么是年龄大，怎么定义年龄大。有些人年过20却整天唉声叹气，像看破了红尘似的，有些人年过80还想着诗和远方，所以我认为年龄大小与身份证上的数字无关。  </p>
<p>言归正传，如果想考，就尽力去考，虽然有时候也许复试会因为你的年龄大而pass你，但这足以证明不是你能力的问题，因为学习是终身要做的事情。  </p>
<h2 id="如果没考上怎么办？"><a href="#如果没考上怎么办？" class="headerlink" title="如果没考上怎么办？"></a>如果没考上怎么办？</h2><p>这个问题我12月初想过，我想很多考研的人都想过。  </p>
<p>没考上如果还想考，就做好规划接着考，<strong>不管被自己的懦弱和不中用再怎么狠狠的打击，你都要燃烧你的心，咬紧牙关向前走，就算你听下脚步蹲坐下来，时间的流动也不会为你停止，时间不会陪伴你承受悲伤。</strong></p>
<h2 id="你有过35岁的危机感吗？"><a href="#你有过35岁的危机感吗？" class="headerlink" title="你有过35岁的危机感吗？"></a>你有过35岁的危机感吗？</h2><p>这个问题我问了不下三个人，虽然我有技术在身，虽然我的学历也不低，虽然我读了很多书，但是面对这样的现实问题，我不得不停下来思考，如果我到35岁了，会被淘汰吗？  </p>
<p>师哥M：适当焦虑是正常的，但不需要过度焦虑，做好当下该做的事情；<br>极客时间直播：踏踏实实做事，没有心思去担心35岁；  </p>
<p>虽然我目前离35还有11年的距离，但这就是132个月，四万多天，所以我根据以上两位的看法，做出了以下规划：  </p>
<ul>
<li>做好眼前的事，提升核心竞争力；  </li>
<li>根据职业和兴趣爱好搭建自己的副业体系，例如翻译、技术培训和理财；  </li>
<li>写文章，扩展人脉；  </li>
<li>多读有深度的书，比如豆瓣TOP250；  </li>
<li>打造个人品牌影响力，例如公众号、博客；</li>
</ul>
<p>种一棵树最好在十年前，其次是现在，于是我今天先将大树的种子洒进时光的泥土里。  </p>
<h2 id="坚持做一件事真的有意义吗？"><a href="#坚持做一件事真的有意义吗？" class="headerlink" title="坚持做一件事真的有意义吗？"></a>坚持做一件事真的有意义吗？</h2><p>有的。  </p>
<p>至少会让自己很有成就感。  </p>
<p>比如大学二年级坚持在博客园创作，比如今年3月坚持每天至少一道的算法题，比如坚持生日来临和年底的创作，虽然曾经的想法很单纯，就是记录下来方便以后查阅，但后来阅读量的飙升，让我借此结识大佬和得到了新的就业机会。  </p>
<p>也许你曾迷茫后悔做了这些无用功，但是高中物理告诉我：一种能量不会凭空消失，也不会凭空产生，它只会以一种形式传递到另一种形式去，努力亦是如此。  </p>
<h2 id="真的是越老记忆就越衰退吗？"><a href="#真的是越老记忆就越衰退吗？" class="headerlink" title="真的是越老记忆就越衰退吗？"></a>真的是越老记忆就越衰退吗？</h2><p>是的，所以一定要趁年轻把想做的事情做了。  </p>
<p>我曾以为我的记忆力就此为止只能记住于几百个英文单词，可是当我离考前一个小时的时候，我惊喜的发现我竟然可以默背下来两篇英语模板作文，所以说记忆力这东西，给点压力会记得更牢。  </p>
<h2 id="焦虑和担忧是如何克服的？"><a href="#焦虑和担忧是如何克服的？" class="headerlink" title="焦虑和担忧是如何克服的？"></a>焦虑和担忧是如何克服的？</h2><p>《三傻大闹宝莱坞》这部电影对我影响很大，小时候只沉溺于它带给我的喜剧欢乐，直到考前我才明白，我曾经就像剧中的拉朱，对于未知的事情总是充满着担忧与恐惧————考试前总是希望再多背一个单词、一个公式，庆幸于也许就能挽救我于及格线的边缘；职场上总是装作老好人，背了锅也只能自己悄悄的扛；对于领导有时的偏见，丢工作的恐惧已经大于了为自己辩解…直到我将这一切都抛弃，将自己曾经固有的体系打破，才发现原来不过如此。  </p>
<p>人无完人，有些人太过完美，也只是由于他的亮点几乎遮住了瑕疵。我曾做过两次心理沙盘，在沙盘上楼房、小河、游艇应有尽有，而老师给我的建议是我的内心情感世界是非常丰富的，然而太过丰富就会导致我对待一些事物会过度要求完美，我当时心想这不是好事情吗，为何要用“然而、但是”这种词表示转折呢？  </p>
<p>直到现在我才摸索出一些边缘，我一直活成了教科书里要求的样子，殊不知每个人都有各自的特点，为了约束和规范，就制定了这一套标准的流程，有点像郑渊洁童话里的一段变兔子的故事。 </p>
<p>综上所述，不要给自己太大压力，适当焦虑，遇到问题对自己的心安慰一句”All is well”，期待我在新的一年里继续披荆斩棘。  </p>
<p><img src="/2020/12/31/2020-year-summary-all-is-well/dengning-keluge.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title>2021读书计划</title>
    <url>/2021/01/02/2021-read-books-plan/</url>
    <content><![CDATA[<p>2020年，我利用上下班和等车时间，读了很多书，发现时间虽然碎片，有时看不起眼的3-5分钟，其实如果加以利用的话，就是200-300秒的思考时间，将这几百秒的时间乘以每天十几个时间碎片片段，也是一块不小的时间空隙呢。  </p>
<p>当然碎片化也不好，就是不能集中注意力，也许看了第三章，打断阅读后再回过头来已经忘记了第一章节的内容，因此我个人建议可以给每一章末尾或印象深刻的段落加上笔记，这样当我看到我写过的东西，就会立刻回想起原先的内容。  </p>
<p>下面是我利用思维导图工具制定的一份2021阅读计划，希望年底前可以完成它。  </p>
<p>GOOD LUCK.  </p>
<p><img src="/2021/01/02/2021-read-books-plan/2021-book-plan.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>读书</tag>
        <tag>阅读</tag>
        <tag>豆瓣TOP250</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的内存泄露及解决方案</title>
    <url>/2019/05/14/Golang-memory-leak-solution/</url>
    <content><![CDATA[<p>工作中记一次碰到内存泄漏的解决过程。  </p>
<h1 id="发现内存泄露"><a href="#发现内存泄露" class="headerlink" title="发现内存泄露"></a>发现内存泄露</h1><p>写的一个定时删除文件的服务，结果无缘无故被系统杀死了。  </p>
<p>于是我设置了参数，每隔30s启动一次。并用<code>dmesg</code>命令查看  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1700172.849656] Out of memory: Kill process 1195 (SliceDyson) score 730 or sacrifice child</span><br><span class="line">[1700172.849665] Killed process 1195 (SliceDyson) total-vm:13314968kB, anon-rss:8693980kB, file-rss:116kB</span><br></pre></td></tr></table></figure>
<p>确定是内存泄露造成的。  </p>
<h1 id="使用pprof分析造成内存泄露的原因"><a href="#使用pprof分析造成内存泄露的原因" class="headerlink" title="使用pprof分析造成内存泄露的原因"></a>使用pprof分析造成内存泄露的原因</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p><a href="https://golang.org/pkg/runtime/pprof/">golang pprof 的文档</a> 里面给了一个例子，如何把  <code>pprof</code> 信息输出到文件里面   </p>
</li>
<li><p><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/">Reddit 上这篇文章</a>，提到了如何通过对比两次 <code>heap</code> 的结构，来判断到底哪些内存没有释放：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One thing you can do is to compare 2 heap pprofs. You can do it like this:</span><br><span class="line"></span><br><span class="line">    Extract a heap profile heap0.pprof</span><br><span class="line"></span><br><span class="line">    Add some load to the application</span><br><span class="line"></span><br><span class="line">    Extract another heap profile heap1.pprof</span><br><span class="line"></span><br><span class="line">    Compare them with go tool pprof -base heap0.pprof &lt;bin&gt; heap1.pprof</span><br><span class="line"></span><br><span class="line">This way you can see exactly what is increasing over time.</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>分析生成的<code>.pprof</code>文件</li>
</ul>
<p>　　</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go tool pprof 120.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 9:27pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 603.20MB, 99.67% of 605.20MB total</span><br><span class="line">Dropped 1 node (cum &lt;= 3.03MB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  603.20MB 99.67% 99.67%   605.20MB   100%  main.main</span><br><span class="line">         0     0% 99.67%   605.20MB   100%  runtime.main</span><br><span class="line">(pprof) ^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ go tool pprof 240.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 11:42pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 2.81GB, 99.86% of 2.81GB total</span><br><span class="line">Dropped 6 nodes (cum &lt;= 0.01GB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2.81GB 99.86% 99.86%     2.81GB   100%  main.main</span><br><span class="line">         0     0% 99.86%     2.81GB   100%  runtime.main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>分析各个函数的占比情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File: SliceDyson</span><br><span class="line">Type: inuse_objects</span><br><span class="line">Time: Mar 7, 2019 at 2:52pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 6810, 100% of 6810 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      6554 96.24% 96.24%       6554 96.24%  main.GetXMLFiles</span><br><span class="line">       256  3.76%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.addDecoderNode</span><br><span class="line">         0     0%   100%        256  3.76%  main.init</span><br><span class="line">         0     0%   100%       6554 96.24%  main.main</span><br><span class="line">         0     0%   100%        256  3.76%  net/http.init</span><br><span class="line">         0     0%   100%       6810   100%  runtime.main</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后定位到造成内存泄露的原因，是<code>GetXMLFiles</code>函数造成的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlFilesPath []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LoopGetXmlFilesPath []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> AllTasks []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> tasks []*Task</span><br><span class="line"><span class="keyword">for</span> _, RootPath := <span class="keyword">range</span> ParseStorageINI(StorageINIPath) &#123;</span><br><span class="line">	xmlFilesPath = GetXMLFiles(RootPath)</span><br><span class="line">	<span class="keyword">for</span> _, xmlFilesPath_str := <span class="keyword">range</span> xmlFilesPath &#123;</span><br><span class="line">		LoopGetXmlFilesPath = <span class="built_in">append</span>(LoopGetXmlFilesPath, xmlFilesPath_str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>把<code>xmlFilesPath</code>放到<code>for range</code>循环里面声明初始化即可  </p>
<h1 id="是什么原因会导致内存泄露"><a href="#是什么原因会导致内存泄露" class="headerlink" title="是什么原因会导致内存泄露"></a>是什么原因会导致内存泄露</h1><h1 id="什么时候需要垃圾回收-GC"><a href="#什么时候需要垃圾回收-GC" class="headerlink" title="什么时候需要垃圾回收(GC)"></a>什么时候需要垃圾回收(GC)</h1><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul>
<li><a href="https://stackoverflow.com/questions/48618201/how-to-release-memory-allocated-by-a-slice">how-to-release-memory-allocated-by-a-slice</a>  </li>
<li><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer">cannot-free-memory-once-occupied-by-bytes-buffer</a>  </li>
<li><a href="http://legendtkl.com/2017/04/28/golang-gc/">Golang垃圾回收剖析</a>  </li>
<li><a href="https://golang.org/pkg/runtime/pprof/">pprof</a>  </li>
<li><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/">my_app_has_memory_leaks_how_to_find_them</a></li>
</ul>
]]></content>
      <categories>
        <category>Solution-notes</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>2021春招找工作计划</title>
    <url>/2021/03/04/2021-spring-find-job/</url>
    <content><![CDATA[<p>三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。  </p>
<p>找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事就拒绝加班，没事但是一天的工作没做完肯定是会自觉加班的，但我最讨厌最讨厌最讨厌那种磨洋工式的加班。  </p>
<p>今天就收到了一位很有礼貌的猎头小哥问我“有家游戏公司995可以接受吗？” 我果断拒绝，因为说是995，有可能就临上线就变成996甚至997，人的欲望是无穷无尽的，所以如何摆脱困境，就是要找到从根源上就拒绝加班的企业。  </p>
<p>犹记得我在第一家游戏公司的时候，美其名曰加班，实际上是因为一个人回去也没啥意思，就跟着同事一块在公司看书学习敲代码，顺便拿加班补贴和打车补助；第二家公司，刚开始基本7点就准时下班了，但后面逐渐开始那种毫无意义的加班，甚至根据加班来看工作态度、年终考核的时候，我放弃了，放弃了那可有可无的年终奖。  </p>
<p>因此，我看透了国内这种加班的本质，要么高效完成工作，要么加班按照劳动法给加班费，否则一切强制无意义的加班就是压榨。  </p>
<p>今天写下这篇文章，拒绝无意义的加班，不知道以后正在屠龙的少年是否会变成恶龙，以此当做一个记录吧。  </p>
<p>新的一年，祝自己能顺利拿到满意的<code>offer</code>！  </p>
<p><img src="/2021/03/04/2021-spring-find-job/reject-996.jpg">  </p>
]]></content>
      <categories>
        <category>Work-Career</category>
      </categories>
      <tags>
        <tag>找工作</tag>
        <tag>春招</tag>
      </tags>
  </entry>
  <entry>
    <title>一位朋友面试字节跳动游戏开发岗经验</title>
    <url>/2020/06/26/a-friend-interview-bytedance-game-develop-experience/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一位好友在西安某211读研究生，主攻图形学方向，下面是他面试字节跳动游戏开发岗的流程。  </p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>注：此处略去有关项目经验的问题。  </p>
<ul>
<li><p>C#接口、抽象类的区别  </p>
</li>
<li><p>学习Unity的途径和方式  </p>
</li>
<li><p>面向对象中class和struct的区别  </p>
</li>
<li><p>C#的垃圾回收机制  </p>
</li>
<li><p>引用类型、值类型和内存分配  </p>
</li>
<li><p>堆和栈的区别  </p>
</li>
<li><p>C++多态、虚表  </p>
</li>
<li><p>list和vector的区别  </p>
</li>
<li><p>为什么数组插入数据效率慢，而链表插入数据效率快  </p>
</li>
<li><p>使用链表插入数据的过程  </p>
</li>
<li><p>检查一个链表是否形成环路的方法  </p>
</li>
<li><p>C++：Map和<code>Hash Map</code>的区别_对应_数据结构：红黑树和<code>Hash Map</code>的区别  </p>
</li>
<li><p>哈希表的原理  </p>
</li>
<li><p>模板测试和深度测试  </p>
</li>
<li><p>场景题：在游戏中，怎么判断一次AOE攻击有没有命中这些单位  </p>
</li>
<li><p>什么叫世界坐标转为局部坐标  </p>
</li>
<li><p>进程和线程的区别</p>
</li>
</ul>
<p>答疑：  </p>
<ul>
<li><p>怎么系统学习渲染？<br><code>OpenGL</code>是一个很好的切入点，然后看一下<a href="https://book.douban.com/subject/30296179/">《Real-Time Rendering, Fourth Edition》</a>  </p>
</li>
<li><p>贵公司的游戏部门2018年新成立，请问做游戏的类型有哪些？<br>北京、杭州、广州、上海都有研发中心，有轻度、中毒、重度游戏，合作发布会多一些。  </p>
</li>
<li><p>游戏引擎开发的学习路线<br>语言层面：引擎源码需要熟悉，还有C++；其次是渲染，就是读一下<a href="https://book.douban.com/subject/30296179/">《Real-Time Rendering, Fourth Edition》</a></p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>大概40分钟的面试，问了<code>C#</code>和<code>C++</code>基础+数据结构+网络，然后是图形学方面的问题。总的来说我个人觉得这位面试官非常和蔼，即使他不知道为什么链表插入效率快，但会通过让他思考链表的插入方式对比数组的插入方式，从而得出链表插入快的结论（虽然到最后这层窗户纸还是没有捅破）。接着便问了很多语言特性和项目上的问题，答疑阶段也给了一些书籍和技术指点，总之给我带来的启发就是：  </p>
<ul>
<li><p>如果要走游戏引擎开发，<code>C++</code>必不可少；  </p>
</li>
<li><p>最好做一些和图形学相关的项目；  </p>
</li>
<li><p>平时刷题时，首先保证要提交通过，其次需要考虑优化。例如插入数据时先考虑数组，其次链表，二叉树，这样也可以帮助自己理清各个数据结构的优缺点；  </p>
</li>
<li><p>一面主要还是以理论为主，但不可放松对编码能力的训练；  </p>
</li>
<li><p>最好准备两套回答问题的模板，一套用于回答自己擅长的问题，另一道用于回答自己不擅长的问题。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview-experience</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>校招</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>一点进展</title>
    <url>/2019/03/25/a-little-progress/</url>
    <content><![CDATA[<p>今天部门老大问我项目进展怎样，我说有点慢，一个需求正在测试，还有四个需求没有开始实施。（我为什么要这么诚实？！）  </p>
<p>中午和同事出去吃饭，他建议我先把接口列出来，然后把每一步要做的注释写出来，再将注释翻译成代码。  </p>
<p>散步快结束时，董说你已经过了让我们告诉你如何做的阶段，现在只能是自己去探索，而我们告诉你是<code>true</code>或<code>false</code>。  </p>
<p>当我听到这句话的时候，我竟然心中油然升起一种莫名其妙的喜悦。  </p>
<p>是的，我已经转正了，已经离开学校九个多月了，应该学会独立解决问题和培养随机应变的能力。  </p>
<p>企业不是学校，没有责任和义务告诉你每一步该怎么做。  </p>
<p>谢谢给我指导的部门老哥们。  </p>
<p>是我自己太矫情了，一直沉溺在学校的幻想中，不愿意走出来。  </p>
<p>今天终于解决了第一个需求，不知明天能不能把第二个需求做完。  </p>
<p>坚持，并学会改变。  </p>
<p><img src="/2019/03/25/a-little-progress/smile.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>进步</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次项目演示前赶deadline的经历</title>
    <url>/2019/05/31/a-project-deadline-note/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>给新疆广电做的流媒体收录系统，原定于六月二十日研发完毕，无奈要提前演示，定到了五月底。所以我负责的地方需要抓紧进度。<br>同时下周一要做芒果TV的演示，我这里负责的模块网络端没有跑通。  </p>
<h2 id="紧张"><a href="#紧张" class="headerlink" title="紧张"></a>紧张</h2><p>由于我之前在根据芒果TV的需求修改我负责的流媒体服务，改动较大（确切地说我已经改晕了），已经把最原始的功能都已经无法复现了，导致新疆广电的需求也无法完成。我在想，我该怎么办？  </p>
<h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>在我即将感到绝望的一刻，产品负责人把部门的两位大佬打电话叫来，他看了下我的代码，改删的删，改增的增，在本地跑通后，放到测试环境上跑了一下，看了下日志，修改了几处异常，测试环境就跑通了，新疆广电的演示算是完成了。<br>而芒果TV的需求，涉及把业务流程搞懂再添加业务判断逻辑，和数据的封装和请求的发送，而我的问题就在于不知道这段逻辑代码放在哪里。不过还好最后有老哥带我一步步跟代码，最终把代码放到了正确的位置，测试也跑通了。</p>
<h2 id="经验教训和感受"><a href="#经验教训和感受" class="headerlink" title="经验教训和感受"></a>经验教训和感受</h2><ul>
<li>用<code>Go</code>写一个服务，应当首先用<code>curl</code>命令在本地跑通，接着写一个<code>Test</code>测试函数针对核心逻辑就行测试和修改，如果需要依赖其他服务，要么把需要的服务也部署起来，或者用<code>Nginx</code>去模拟<code>Mock</code>它（这个我还不会）。</li>
<li>越紧急的事情，一定要放宽心，深呼吸两次，不然很容易犯低级错误，比如该打日志的地方没有打，或者数据库查询语句写错，或者是变量名的格式没有写对，或者是<code>curl</code>命令请求时忘记在每一个出现<code>&quot;</code>加<code>\</code>（<code>curl</code>命令请求发<code>json</code>时的格式）。而这些细微的出错，最终都将导致自己，或者陪同的其他研发人员，甚至测试人员白忙活一阵。  </li>
<li>一定要对服务器业务逻辑熟悉，一定要经常打断点去跟代码。</li>
<li>遇到<code>Panic</code>空指针报错，一定是一些值没有初始化造成的，而我是犯了一个低级错误：没有<code>error</code>，自己在日志中打了个<code>error.Error()</code>导致的，为此我付出了代价，全局搜索了<code>error.Error()</code>字段，把有问题的语句全部改了。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是错误的，一定要注意，直接会抛异常</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(xxx) == <span class="number">0</span> &#123;</span><br><span class="line">    Log.Error(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>遇到想不通的问题，多在存在疑惑的代码片段周围打满日志。  </li>
<li>遇到的每一个<code>bug</code>，详细记录错误发生的原因，以及找到错误解决的方式，还有解决过程，记录完后要及时回看。  </li>
<li>熟练使用<code>git</code>指令，不只满足于<code>add commit push</code>三步，还应该涉及合并，<code>cherry-pick</code>等比较危险的指令，这有益于减少管理代码和发版时瞎忙活的概率。  </li>
<li>相比于研发，测试运维这些人在体力上都比较辛苦，所以建议能自己解决的就少给他们增添麻烦。也许是我看到他们一个电脑开着十几台虚拟机，远程连接里套着远程连接再套着远程连接，周围做前后端和产品都围着他时，才有的感触吧。</li>
</ul>
<p>问题警报解除后，同事问我，有没有是在给家乡做贡献的感觉。我说，有那么一点。但我心里更多的是对他们的感激与深深的惭愧，交代给我负责的项目，没有完成，同时也暴露了我的诸多开发上的问题。这些坑，我需要尽快填上。  </p>
<p>希望项目演示一切顺利！</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>项目</tag>
        <tag>演示</tag>
        <tag>收获</tag>
      </tags>
  </entry>
  <entry>
    <title>关于996，我想说</title>
    <url>/2019/04/07/about-996-i-want-to-say/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近Github上有一个叫<a href="https://github.com/996icu/996.ICU">996.ICU</a>的项目很火，原因是它公开抵制国内的996工作制，这严重违反了劳动法。工作996，住院ICU。  </p>
<p>于是我身边有朋友问我，996到底是什么意思，那么我先说下我个人的亲身经历吧。  </p>
<h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>去年六月大学本科毕业后，幸运的入职一家上市游戏公司，从事游戏服务端开发，刚开始对新公司，新工作充满好奇，想着下班回去也没什么事，就多待会，熟悉公司的业务流程。于是在公司内，我算是比较活跃的一类。  </p>
<p>游戏公司与其他互联网公司最大的不同在于，活动非常多，各种节日庆祝，生日庆祝，下午茶，大家其乐融融，嬉戏打闹，品尝美食，氛围很融洽…  </p>
<p>2018年8月，隔壁一工作室出了一款暗黑类手游，IOS端零点开服，于是我看着他们工作室从早忙到深夜，要么服务器崩了，要么数据有误急需修改，有些策划兼当游戏客服，而我看到一小伙子有时还披着被子工作，莫不是凌晨都睡在公司了吧。  </p>
<p>后来，我也要开始加班了，虽然我也并不知道为什么加班，明明可以六点半走的，莫不是为了八点的餐补，还是九点的滴滴打车报销？  </p>
<p>再后来，我经常晚上回来，同租的老哥每次看我拖着疲惫的身子回来，一脸倦容，就知道我又加班了。  </p>
<p>八月底，做了两个梦  </p>
<ul>
<li>第一个梦是让我两天把《Java编程思想》看完，我被吓醒了；  </li>
<li>第二个梦是半醒中，突然摸到了一双手在我后脑勺处，我吓的大叫了一声，后来才发现是我那双已经被压麻的手，因为太累，躺床上还没有调整好睡姿就已经睡着了。</li>
</ul>
<p>八月三十一号，我记得很清楚，那是我离猝死最近的距离…  </p>
<p>那天，我坐在工位前，一直在看服务端主程用<code>Lua</code>语言写的球球大作战源码，虽然看不懂，但我还是坚持把这四千行的代码都过了一遍，吃晚饭的时候一激动，起身起的太快，感到心脏隐隐作痛，头昏脑涨，恍恍惚惚间已经不知道自己在哪里，在干什么。旁边的客户端同事告诉我赶紧休息下，不能再工作了。我想也是。  </p>
<p>在回去的路上，我将我今天的症状对学西医的朋友描述的一遍，他说你这离猝死不远了，得好好休息。  </p>
<p>我慌了，我再也不敢透支身体了！  </p>
<p>九月初，转正答辩，虽然我列举了我这三个月的改变，和完成的事情，但当他们一脸不屑，以及对我提出的问题，我就能猜出我能否通过转正了，虽然我每天都在拼命加班，但产出在他们看来微乎其微，公司不养闲人，于是我光荣的提了离职申请。  </p>
<p>九月十一号，我办好离职手续，出了公司，成了一名工作经验仅只有三个月的社会人士。  </p>
<p>我很想找个没人的地方哭一次，但我知道，塞翁失马，焉知非福。如果这就是我所了解到的游戏生涯，那我的游戏开发的梦也可以就此宣告结束了。  </p>
<h1 id="工作996，生病ICU"><a href="#工作996，生病ICU" class="headerlink" title="工作996，生病ICU"></a>工作996，生病ICU</h1><p>我觉得这个比喻真的很好，说的更直白点，就是有命赚钱，没命花钱。  </p>
<p>曾经我以为996就是累点而已，多学点东西也是极好的。  </p>
<p>现在想想错了。  </p>
<p>996在消耗你的体力的同时，也在消耗你的自由支配时间。在你本应该下班好好玩耍或吃顿美食开始看书学习的时候，你却要在嘈杂的环境下持续输出。可想而知，在精力和体力都枯竭的情况下，怎么能高产出呢？  </p>
<p>然后负责人觉得你每天工作十二个小时，产出还这么低，看来你能力不行嘛，明天可以走人了，我再招一批年轻的实习生进来。  </p>
<p>于是最终吃亏的还是自己。  </p>
<h1 id="关于996，我想说"><a href="#关于996，我想说" class="headerlink" title="关于996，我想说"></a>关于996，我想说</h1><ul>
<li><p>跟对<code>leader</code>很重要。在我看来，一个好<code>leader</code>可以成为自己学习的榜样。虽然我无法全面定义一个好<code>leader</code>到底是什么样子，但是有一点是可以证明的：就是不会总是在他人面前炫耀自己曾经获得过什么荣誉。毕竟那都是过去的事情，一个人总沉浸在过去，会影响现在以及对未来的判断。  </p>
</li>
<li><p>对不应该加的班说不。工作重要的一点是能力，另一点就是沟通。对于不是自己负责的任务，及时说明原因，让负责人定夺，而不是一股脑的全都接下。  </p>
</li>
<li><p>抓紧一切时间去学习，去提升自我。我相信那些大厂年薪过百万的人，即使不加班领导也不会拿他怎样，毕竟这种人是无法短期被替代的，同时掌握着公司内最核心的技术。  </p>
</li>
<li><p>加班多工资多，加班少工作也低，放佛总不能找到一个完美的选择，那么就请平衡好自己的能力和野心。  </p>
</li>
<li><p>提升工作效率是关键。比如设立番茄钟，遇到不懂的赶紧问。</p>
</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>转眼间我已经工作快十一个月了，有时还会把自己想象是在校大学生。  </p>
<p>从996到955，从睡眠不足到睡到自然醒精神的去上班，我知道我找到了适合自己的工作方式。  </p>
<p>曾经看着红的蓝的绿的共享单车如三条颜色的河流缓缓的流向软件园，中间有分流到xx大厦，xx集团，我曾想过上班的意义是什么？  </p>
<p>直到现在我也没彻底想明白，但我知道，上班绝不是去医院住ICU。  </p>
<p>希望996这样的工作制能成为个例，也希望以后的程序员们可以早点下班。  </p>
<p>Good Luck.</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生活</tag>
        <tag>工作</tag>
        <tag>加班</tag>
      </tags>
  </entry>
  <entry>
    <title>重新正视自己的知识焦虑</title>
    <url>/2019/01/21/agagin-face-my-knowledge-anxiety/</url>
    <content><![CDATA[<p>今天在豆瓣上看到一篇文章，分享一下：<a href="https://www.douban.com/note/704294887/">高效学习成长的丰沃土壤长什么样</a>  </p>
<h2 id="与知识付费的相识"><a href="#与知识付费的相识" class="headerlink" title="与知识付费的相识"></a>与知识付费的相识</h2><p>记得是大二的时候，下载了得到app，打开后看到里面琳琅满目的付费专栏，内容主要涉及管理学，经济学，科技和做人做事，价格基本是199元&#x2F;年，我说“好贵！学生党买不起。”  </p>
<p>后来经不住app里对专栏的介绍，我买了下吴军的《硅谷来信》，想跟着专栏学习下大师的思考方式和处世之道。不得不说，大师思考问题的维度和方式的确与我们不一样，因此拓宽了我的知识面，于是在一年后，我又坚持订阅了他的《谷歌方法论》。  </p>
<p>再到后来大学毕业，我做了和服务器开发和算法相关的工作，在工作中深深感受到基础知识的匮乏，这时候一款名叫极客时间的app映入眼帘，在这里我看了相关介绍，陆续订阅了《数据结构与算法之美》和《程序员的基础数学》两个专栏。  </p>
<p>还有其他类似的知识付费栏目，比如简书的付费阅读原创小说最后30%的章节内容；GitChat；知识星球。  </p>
<h2 id="为什么需要付费"><a href="#为什么需要付费" class="headerlink" title="为什么需要付费"></a>为什么需要付费</h2><p>曾经我很纳闷，这些知识网上都可以找到的，为什么还需要知识付费呢？  </p>
<p>我想主要原因有以下几个方面：  </p>
<ul>
<li>作者辛辛苦苦写出来的，我们总要回馈一些财富出来；（20%）  </li>
<li>网上内容良莠不齐，而作者是一路走过来的，因此有经验，会帮你整理出来，让你少走弯路；（60%）  </li>
<li>对版权的一种保护；（20%）</li>
</ul>
<p>所以归根结底，是我们对获取知识的途径比较匮乏，需要有个人（比如专栏作者）把自己的学习心得和经验共享出来，供需要的人吸收，那么问题又来了，你吸收的这些知识，就一定是正确且有用的吗？  </p>
<h2 id="正视焦虑"><a href="#正视焦虑" class="headerlink" title="正视焦虑"></a>正视焦虑</h2><p>我是一个喜欢有成就感持续驱动学习的人，这种成就感不是满足于一群人对我说“大佬 666”，而是每解决一个bug或close一个issue，搞懂一个模块的功能或者比昨天对框架有了更深入的理解。  </p>
<p>然而，当我逐渐在学习底层的时候，我就会愈发现知识的不足，例如并发编程的原理，常用算法的核心思想，模块功能类比上的失误，以及对协议的认知偏差等等，这时候我很想一步登天，例如狂刷CSAPP，算法，但此时我已经产生了知识焦虑，犯了欲速则不达的错误。  </p>
<h2 id="学会分辨正确但无用的知识"><a href="#学会分辨正确但无用的知识" class="headerlink" title="学会分辨正确但无用的知识"></a>学会分辨正确但无用的知识</h2><p>“学会分辨正确但无用的知识”——这时一位前辈给我提的建议。  </p>
<p>现在，我终于明白了这句话的含义。  </p>
<p>无用，其实绝大多数是因为自己没有经过深度思考，只是别人告诉你，有这么个知识，你可以拿来套用和当谈资。但是这个知识到底有什么用，在什么场合下适用，都是要经过自己思考和实践出来的。  </p>
<h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我有位高中玩的很要好的朋友，我当时总会调侃他的英语，然而我很佩服他的数学，虽然我做的数学题比他多，周末还报了数学辅导班，但是每当考试时，他都比我考的高。  </p>
<p>我私下请教他学习数学的方法，他说你做题只满足做对就行，却没有从出题人的角度思考这道题，而我做这道题只花了五分钟，想这道题背后的用意以及举一反三的过程却花了我45分钟的时间。  </p>
<p>的确，他经过深度思考了，所以知识是他的，而我是花钱（买课外资料，报辅导班）买了别人的解题思路，走了个捷径，现在想想，其实是走了弯路。  </p>
<h2 id="关于知识焦虑的感触"><a href="#关于知识焦虑的感触" class="headerlink" title="关于知识焦虑的感触"></a>关于知识焦虑的感触</h2><ul>
<li><p>正视自己的焦虑，因为有焦虑，所以才有强烈的求知欲和学习的动力；  </p>
</li>
<li><p>集中自己的时间和注意力，对枯燥的原理和底层的知识，进行深度思考；  </p>
</li>
<li><p>对那种表面业务逻辑部分，花最少的时间把它做好，后面就抽更少的时间维护即可；  </p>
</li>
<li><p>从源头开始阅读，尽量获取第一手的资料；  </p>
</li>
<li><p>正视自己的不足，扎扎实实一步一个脚印坚持走下去；</p>
</li>
</ul>
<p>GOOD LUCK !  </p>
<p><img src="/2019/01/21/agagin-face-my-knowledge-anxiety/alone.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>知识付费</tag>
        <tag>焦虑</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试评分标准</title>
    <url>/2021/11/15/algo-interview-scoring-criteria/</url>
    <content><![CDATA[<h2 id="面试评分和-Offer-的关系"><a href="#面试评分和-Offer-的关系" class="headerlink" title="面试评分和 Offer 的关系"></a>面试评分和 Offer 的关系</h2><ul>
<li>有 &gt;&#x3D; 1 个 Strong No Hire &#x3D;&gt; No offer  </li>
<li>有 &gt;&#x3D; 2 个 No hire &#x3D;&gt; No offer  </li>
<li>有 1 个 No Hire + 1 个 Weak Hire &#x3D;&gt; No Offer  </li>
<li>有 1 个 No Hire，其他都是 Hire &#x3D;&gt; Offer or 加面（取决于公司招人多不多，门槛高不高）  </li>
<li>有 1 个 Weak Hire &#x3D;&gt; Offer or 加面<br>特殊情况：  </li>
<li>一个 Strong Hire + 一个 Strong No Hire &#x3D;&gt; 开个会一起讨论一下，通常结果是加面或者No Offer。</li>
</ul>
<h2 id="快速提高-Coding-Quality的十二个技巧"><a href="#快速提高-Coding-Quality的十二个技巧" class="headerlink" title="快速提高 Coding Quality的十二个技巧"></a>快速提高 Coding Quality的十二个技巧</h2><h3 id="Coding-Style-相关"><a href="#Coding-Style-相关" class="headerlink" title="Coding Style 相关"></a>Coding Style 相关</h3><ul>
<li>二元运算符两边加空格，单元运算符不加空格  </li>
<li>花括号和 for, if 之间要加空格(Java)，圆括号和 if 之间要加空格  </li>
<li>用空行分隔开不同的逻辑块  </li>
<li>逗号后面加空格</li>
</ul>
<h3 id="Readability-相关"><a href="#Readability-相关" class="headerlink" title="Readability 相关"></a>Readability 相关</h3><ul>
<li>函数名和变量名用1-2个单词作为名称  </li>
<li>确保一个函数内部不超过 3 层缩进（indention）  </li>
<li>多用子函数来减少入口函数的代码量  </li>
<li>多用 continue 少用 if</li>
</ul>
<h3 id="Bug-Free-相关"><a href="#Bug-Free-相关" class="headerlink" title="Bug Free 相关"></a>Bug Free 相关</h3><ul>
<li>不管有没有可能出问题，都要对入口函数的参数进行异常检测</li>
<li>访问一个下标的时候，一定要确保这个下标不会越界</li>
<li>访问一个对象的属性或者方法时，一定要确保这个对象不是空</li>
<li>不用全局变量</li>
</ul>
]]></content>
      <categories>
        <category>Learn-algo</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一定要有B计划 -&gt; 再见，天真的我</title>
    <url>/2021/07/14/always-to-have-plan-B/</url>
    <content><![CDATA[<p>记得最开始看到这句话，是在《小时代1》中那个帅气的混血儿，因为拿错演讲稿，但依旧有条不紊的说了自己准备的<code>planB</code>开场白。  </p>
<p>当时觉得不以为然，心想秘书都帮你安排好了，何必多此一举，现在想想，我真是天真啊…  </p>
<p>感谢社会大学在这一周给我上了精彩的一课，为了等这一刻，你们估计也已经蓄谋很久了吧，没关系的，我心态很好，我有家人，有朋友，有一定的资源人脉，而你们也只能在这里继续啃食下一个天真的灵魂。  </p>
<p>再一次，对这块天府之国上的企业感到失望，我不会哭，因为我要假装坚强，我不会气馁，因为打不死的会让我变的更强，我也不会随意的发牢骚，而是要在黑夜里坚持不懈的练拳头。  </p>
<p>再见了，天真的自己。</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>危机意识</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师训练营_第0周_是什么奠定了架构师的地位</title>
    <url>/2021/11/07/artc-week0-architect-status/</url>
    <content><![CDATA[<h2 id="学习架构能带来什么"><a href="#学习架构能带来什么" class="headerlink" title="学习架构能带来什么"></a>学习架构能带来什么</h2><p>夸夸其谈能帮你带来掌声<br>解决棘手问题能帮你带来名声<br>奠定架构师地位，是让别人依赖你写的代码  </p>
<h2 id="优秀的架构师必须是软件开发的全才"><a href="#优秀的架构师必须是软件开发的全才" class="headerlink" title="优秀的架构师必须是软件开发的全才"></a>优秀的架构师必须是软件开发的全才</h2><ul>
<li>卓越的编程能力  </li>
<li>解决棘手问题的能力  </li>
<li>广阔的知识面  </li>
<li>洞悉技术背后的本质和规律  </li>
<li>沟通和打动人心的能力</li>
</ul>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="全栈和全才的区别？"><a href="#全栈和全才的区别？" class="headerlink" title="全栈和全才的区别？"></a>全栈和全才的区别？</h3><ul>
<li>全栈是前端+后端都能写；  </li>
<li>全才是会写代码，同时可以搞定系统，其他开发，以及老板。</li>
</ul>
<h3 id="学习架构的前提条件？"><a href="#学习架构的前提条件？" class="headerlink" title="学习架构的前提条件？"></a>学习架构的前提条件？</h3><ul>
<li>熟悉一种面向对象的编程语言；  </li>
<li>有一定的项目经验；  </li>
<li>有为什么要这样设计的好奇感存在。</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Architecture</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>提问学习带给我的收获</title>
    <url>/2019/02/01/ask-questions-learn-bring-me-harvest/</url>
    <content><![CDATA[<p>写以此文，记录我这三天（1.30-2.1）的收获和感悟。  </p>
<p>上周把一个定时删除的服务的版本提交了，本以为在过年前的一周基本没什么事了。然而部门老哥告诉我，之前我负责的一个流媒体服务还存在两处bug  </p>
<ul>
<li><p>不支持多用户同时拉取视频流；  </p>
</li>
<li><p>不支持重新连接；</p>
</li>
</ul>
<p>所以这周我又忙着修改bug,然而在前两天，我还是束手无策，找不到应对方案，一筹莫展。  </p>
<p>到了第三天老哥带我一步步熟悉整体流程，细致到每个函数，每个入参，以及每个重要的代码。不断的提问，不断的思考，再不断的提出新的问题，时间过得飞快，我也饿得快。不过最终还是蛮开心的，通过这两处bug，让我重新回顾了流媒体服务的整体工作流程，以及Go语言中对<code>goroutine</code>和<code>channel</code>机制，印象最深的是以下两点：  </p>
<h3 id="管道中的-lt"><a href="#管道中的-lt" class="headerlink" title="管道中的&lt;-"></a>管道中的<code>&lt;-</code></h3><p>简单来说就是这样子的：接受者&lt;-发送者。  </p>
<p>然而中间会多个管道，所以我借用Go语言圣经中的三处例子做解释  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// x作为发送者发送给管道</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 管道作为发送者发送数据给接受者x</span></span><br><span class="line">&lt;-ch  <span class="comment">// 管道发送数据，没有接收者，丢弃，同时造成管道堵塞，等待接收者</span></span><br></pre></td></tr></table></figure>

<p>所以我们可以具体化刚才说的发送接收流程，它应该为：接收者 &lt;- 管道 &lt;- 发送者。如果缺了接收者或发送者，都会造成管道堵塞。  </p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>举个例子  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mu sync.Mutex   <span class="comment">// guards balance</span></span><br><span class="line">balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先Lock锁住，再使用Unlock解锁。  </p>
<p>如果Lock中再套一个Lock，就会造成死锁，需要将前一个Lock解开才行。  </p>
<h3 id="dlv调试流程"><a href="#dlv调试流程" class="headerlink" title="dlv调试流程"></a>dlv调试流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,./dlv debug xxxx(程序名)  ##启动dlv调试</span><br><span class="line"></span><br><span class="line">2,r(restart)  </span><br><span class="line"></span><br><span class="line">3,c(continue)</span><br><span class="line"></span><br><span class="line">4,b(break)   ##打断点，可以打函数名，也可以打文件下对应的行号</span><br><span class="line"></span><br><span class="line">5,n(next)或s(step)  ##n按一次单步执行，后面只需一直按回车；遇到需要深究的函数按s进去查看</span><br><span class="line">##如果碰到多线程，建议在线程内打个断点</span><br><span class="line"></span><br><span class="line">6,bt(stack)  ##查看堆栈</span><br><span class="line"></span><br><span class="line">7,frame  ##查看指定堆栈的内容</span><br><span class="line"></span><br><span class="line">8,q(exit)     ##退出调试</span><br></pre></td></tr></table></figure>

<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul>
<li><p>接触一个新东西，除了保证理解了流程，还要对每个函数的作用，影响范围都要了然于胸才行；  </p>
</li>
<li><p>流程这东西，光知道不行，最好的办法是自己画个流程图出来，一步步跟着代码走；  </p>
</li>
<li><p>IDE有时会因为环境参数或内在bug而报错，所以推荐使用dlv(针对go)和gdb进行调试；  </p>
</li>
<li><p>多对自己提几个为什么，有助于理解技术的本质；  </p>
</li>
<li><p>心态放平和，坦然接受bug和不足，耐心寻求突破。</p>
</li>
</ul>
<p>最后附一组测试成功的图片^_^</p>
<p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E8%83%8C%E5%BD%B1.png">  </p>
<p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E5%9B%BE.png">  </p>
<p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E7%AC%91.png"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>Go</tag>
        <tag>收获</tag>
        <tag>提问</tag>
      </tags>
  </entry>
  <entry>
    <title>ASU Intro to Cybersecurity Talking Web</title>
    <url>/2023/09/21/asu-cse365-talking-web/</url>
    <content><![CDATA[<h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>Send an HTTP request using curl  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:80</span><br><span class="line">pwn.college&#123;sc9zRb7KF1lZSGtDWOxSGGTAeYp.dhjNyMDL3ATN3MzW&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>Send an HTTP request using nc  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;GET / HTTP/1.1\r\nHost: 127.0.0.1\r\n\r\n&quot;</span> | nc 127.0.0.1 80</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ASU-CSE365</category>
      </categories>
      <tags>
        <tag>cybersecurity</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>以终为始</title>
    <url>/2021/12/07/begin-with-the-end-in-mind/</url>
    <content><![CDATA[<p>10月份面试偶然遇见一个做基础架构的实验室的招聘，意外结识了三位面试官，上周去了这家公司所在的位置，与负责人<code>S</code>老哥做了一次长达三个小时的谈话，我将内容分块提炼了出来。  </p>
<h2 id="你到底想要做什么"><a href="#你到底想要做什么" class="headerlink" title="你到底想要做什么"></a>你到底想要做什么</h2><p>这是一个很简单的问题，却有很多人想不明白，包括我在内。  </p>
<p>谈话结束后，我想了想，放佛找不到到底想要做什么，本科毕业工作三年，我只能说，我不想做频繁的<code>CRUD</code>工作，我想做有深度、有成长、有成就感的工作，但我现在还没有找到这个工作是什么。  </p>
<h2 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h2><p>谈到我的职业规划，我给<code>S</code>先生画了一幅图：<br>1，首先，我目前有2-3个完整的项目经验，都是用<code>Go</code>语言开发，目前定级是<code>P5</code>；  </p>
<p>2，短期目标是争取在一年左右的时间，成长到<code>P6</code>，可以独立承担一些项目的研发和维护；  </p>
<p>3，后期会考一些证书，例如软考高项、<code>PMP</code>，以备不时之需，比如带两个新人之类的；  </p>
<p>4，主路线还是希望以技术为中心，沟通、演讲、管理为副路线，形成一个<code>T</code>字形的发展。  </p>
<p>所以问题来了，<code>S</code>先生谈到了一个<code>domain</code>的概念，也就是平时说的技术积累：  </p>
<ul>
<li>比如我曾经做图形学，研究<code>LUT</code>算法，也是完成项目而已，没有做出啥成就；  </li>
<li>做音视频开发项目的开发，熟练运用了<code>ffmpeg</code>，但是对它的核心原理是一知半解；  </li>
<li>做分布式云存储，也只是会<code>ipfs</code>的使用，它的核心原理是什么，还是凯云实验室的<code>Ben</code>先生给我讲了一遍。</li>
</ul>
<p>综上所述，我好像哪个领域都没有做出点成绩来，只是像一个工人一样， 完成需求，解决<code>bug</code>…，当然这是一个技术工作者的基本素养，但直觉告诉我这样不对，果然<code>S</code>指出了问题——你没有<code>domain</code>。  </p>
<p>他说：他学习任何一个知识，都是往深的钻研，比如<code>Windows</code>编程、Java语言、C语言、架构、网络编程，分布式系统等，都是把市面上能买到的相关的书都买回来，看一遍，做对比，然后提炼。  </p>
<p>只有这样，你才能与那些人拉开距离，你的优势与价值才能脱颖而出。  </p>
<p>所以你要以你的目标为起点，然后在对应的时间节点，做对应的事情，才能在最后那个时间点，无限接近于你的目标，我把这个叫做——<strong>以终为始</strong>（原话说的很长，我过滤了一下）  </p>
<h2 id="解答的疑惑"><a href="#解答的疑惑" class="headerlink" title="解答的疑惑"></a>解答的疑惑</h2><h3 id="如何才能达到S先生您说的有技术的底蕴？"><a href="#如何才能达到S先生您说的有技术的底蕴？" class="headerlink" title="如何才能达到S先生您说的有技术的底蕴？"></a>如何才能达到<code>S</code>先生您说的有技术的底蕴？</h3><p>答：不需要问，直接做就是，功夫和时间下足够，自会有人证明出你的技术深度。  </p>
<h3 id="你平时是怎样学习的？"><a href="#你平时是怎样学习的？" class="headerlink" title="你平时是怎样学习的？"></a>你平时是怎样学习的？</h3><ul>
<li>公司上，把能学的东西都学到，内网的知识库是公开的；  </li>
<li>平时钻研对应的技术领域，早上学英语，晚上睡前看会书，一周编程时长不低于70h，当然github上的大佬的编程时长还有比这个更长的</li>
</ul>
<h3 id="微服务和分布式的关系"><a href="#微服务和分布式的关系" class="headerlink" title="微服务和分布式的关系"></a>微服务和分布式的关系</h3><p>微服务是架构的概念，分布式是领域行业的概念，一个是术，一个是道，不能混淆。建议让我可以看下历年图灵奖获得者的发表的谈话。  </p>
<h3 id="关于学习方法"><a href="#关于学习方法" class="headerlink" title="关于学习方法"></a>关于学习方法</h3><ul>
<li>综合对比法：比如我要学习分布式，我就会把所有这方面的书籍看一遍，综合对比，得出结论；  </li>
<li>演绎法：类似《理想国》，通过不断的探讨，不断深度吸收要学习的知识</li>
</ul>
<h3 id="关于学历"><a href="#关于学历" class="headerlink" title="关于学历"></a>关于学历</h3><p><code>S</code>先生是某C9院校毕业的硕士，但他从来不看重学历，觉得这很虚，所以不要太在意这些。  </p>
<h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>很久没有遇到这种有深度且触及自己灵魂的谈话，尤其是当<code>S</code>先生谈到你到底想要什么的时候了，我是懵的，我想说我要钱，钱越多的工作也好，但好像又不对，一时之间陷入了迷茫。  </p>
<p>曾经我看过一本书，作者说她在30多岁的时候，有次坐在地上冥想，突然触及到了灵魂深处的某个东西后，泪流满面，然后果断选择去做自己想做的事情。  </p>
<p>我们往往是忙忙碌碌中，忘记了为什么要出发。  </p>
<p>是的，我想要薪资很高的工作，我想在35岁之前实现财务自由，但这又不是我的终极目标，我想要做有一个有成就感的事情，但目前的我仿佛又达不到那样的水平…</p>
<p>不过现在的我至少明白了多读书，多学习新知识，对自己是有利而无害的，虽然看似收获甚微，但有些事情往往需要长时间的投入方可见效，英语水平以及道与术的结合，以及坚持不懈的写代码…我会放弃很多东西，同时也会收获我想要的，相信时间会见证这一切。  </p>
<p>最后，非常感谢<code>S</code>先生和我聊了这么多。  </p>
<p><img src="/2021/12/07/begin-with-the-end-in-mind/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>规划</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>博客尘埃落定</title>
    <url>/2019/10/13/blog-decision/</url>
    <content><![CDATA[<h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>2019年1月停更博客园，到现在为止已经接近十个月了。  </p>
<p>在此期间试过<code>冰水鉴心</code>给我推荐的<code>hexo</code>，<code>ghost</code>这些风格的博客，最终从经济和简约的角度，选择了<code>hexo</code>。感谢他的热心帮助和答疑。  </p>
<p>在搭建博客的过程，我发现前端真是很有意思，也许是给我带来的持续反馈机制吧。所以后面不光要关注后端和底层，可以适当去学习下前端的知识。  </p>
<p>目前博客风格已尘埃落定，以后计划所有的学习收获和感想都优先发布在这里。  </p>
<p>明天又是崭新的一天，坚持。  </p>
<h3 id="2019年10月18日更新"><a href="#2019年10月18日更新" class="headerlink" title="2019年10月18日更新"></a>2019年10月18日更新</h3><p>感谢@枫林无归提供的<code>hexo-plugin-gitalk</code>插件。</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解切片原理并高效使用</title>
    <url>/2022/10/06/book-go-programming-from-beginner-to-master-13/</url>
    <content><![CDATA[<h1 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h1><h2 id="数组有哪些基本特性"><a href="#数组有哪些基本特性" class="headerlink" title="数组有哪些基本特性"></a>数组有哪些基本特性</h2><p>Go 语言的数组是一个长度固定的、由同构类型元素组成的连续序列。<br>因此Go 的数组类型包含两个重要属性：元素的类型和数组长度（元素的个数）。<br>所以，Go 语言中数组类型变量的声明：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [N]T <span class="comment">//声明了一个数组变量 arr，它的类型为[N]T，其中元素的类型为 T，数组的长度为N。</span></span><br></pre></td></tr></table></figure>

<p>通过声明，我们可以得出一个结论：<strong>如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</strong>  </p>
<p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。<br>Go 编译器在为数组类型的变量实际分配内存时，会为 Go 数组分配一整块、可以容纳它所有元素的连续内存，如下图所示：<br><img src="/2022/10/06/book-go-programming-from-beginner-to-master-13/array.png">  </p>
<p>我们从这个数组类型的内存表示中可以看出来，这块内存全部空间都被用来表示数组元素，所以说这块内存的大小，就等于各个数组元素的大小之和。如果两个数组所分配的内存大小不同，那么它们肯定是不同的数组类型。  </p>
<p>Go 提供了预定义函数 len 可以用于获取一个数组类型变量的长度，通过 unsafe 包提供的 Sizeof 函数，我们可以获得一个数组变量的总大小。  </p>
<h2 id="多维数组怎么解？"><a href="#多维数组怎么解？" class="headerlink" title="多维数组怎么解？"></a>多维数组怎么解？</h2><p>例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mArr [<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/06/book-go-programming-from-beginner-to-master-13/marr.png">  </p>
<h1 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h1><p>数组作为最基本同构类型在 Go 语言中被保留了下来，但数组在使用上确有两点不足：<strong>固定的元素个数，以及传值机制下导致的开销较大</strong>。于是，引入了另外一种同构复合类型：切片（slice），来弥补数组的这两处不足。  </p>
<p>声明并初始化一个切片变量：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p>与数组声明相比，切片声明仅仅是少了一个“长度”属性。去掉“长度”这一束缚后，切片展现出更为灵活的特性。  </p>
<p>虽然切片变量缺少了“长度”属性，但不代表它没有长度，而是长度一直在变化。  </p>
<p>我们可以通过 len 函数获得切片类型变量的长度，通过 Go 内置函数 append，我们可以动态地向切片中添加元素。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 6</span></span><br><span class="line">nums = <span class="built_in">append</span>(nums,<span class="number">7</span>) <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h1 id="Go是如何实现切片类型的"><a href="#Go是如何实现切片类型的" class="headerlink" title="Go是如何实现切片类型的"></a>Go是如何实现切片类型的</h1><p>Go 切片在运行时其实是一个三元组结构，它在 Go 运行时中的表示如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer  <span class="comment">//指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span>  <span class="comment">//是切片的长度，即切片中当前元素的个数</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span>  <span class="comment">//是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/06/book-go-programming-from-beginner-to-master-13/slice1.png">  </p>
<p>Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同。  </p>
<h2 id="通过-make-函数来创建切片，并指定底层数组的长度"><a href="#通过-make-函数来创建切片，并指定底层数组的长度" class="headerlink" title="通过 make 函数来创建切片，并指定底层数组的长度"></a>通过 make 函数来创建切片，并指定底层数组的长度</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sl := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">6</span>,<span class="number">10</span>)  <span class="comment">//其中10为cap值，即底层数组长度，6为切片的初始长度</span></span><br></pre></td></tr></table></figure>

<p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len，比如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sl := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">6</span>)  <span class="comment">// cap = len = 6</span></span><br></pre></td></tr></table></figure>

<h2 id="采用-array-low-high-max-语法基于一个已存在的数组创建切片"><a href="#采用-array-low-high-max-语法基于一个已存在的数组创建切片" class="headerlink" title="采用 array[low : high : max]语法基于一个已存在的数组创建切片"></a>采用 array[low : high : max]语法基于一个已存在的数组创建切片</h2><p>这种方式被称为数组的切片化。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">sl := arr[<span class="number">3</span>:<span class="number">7</span>:<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/06/book-go-programming-from-beginner-to-master-13/slice2.png">  </p>
<p>通过类比，发现切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。  </p>
<p>在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。  </p>
<p>另外，针对一个已存在的数组，我们还可以建立多个操作数组的切片，这些切片共享同一底层数组，切片对底层数组的操作也同样会反映到其他切片中。<br><img src="/2022/10/06/book-go-programming-from-beginner-to-master-13/slice3.png">  </p>
<h2 id="基于切片创建切片"><a href="#基于切片创建切片" class="headerlink" title="基于切片创建切片"></a>基于切片创建切片</h2><h1 id="切片的动态扩容"><a href="#切片的动态扩容" class="headerlink" title="切片的动态扩容"></a>切片的动态扩容</h1><p>“动态扩容”指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。<br>例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))  <span class="comment">//1 1</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))  <span class="comment">//2 2</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))  <span class="comment">//3 4</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))  <span class="comment">//4 4</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))  <span class="comment">//5 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，append 会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定规律扩展。在上面这段代码中，针对元素是 int 型的数组，新数组的容量是当前数组的 2 倍。  </p>
<p>新数组建立后，append 会把旧数组中的数据拷贝到新数组中，之后新数组便成为了切片的底层数组，旧数组会被垃圾回收掉。  </p>
<h2 id="小陷阱"><a href="#小陷阱" class="headerlink" title="小陷阱"></a>小陷阱</h2><p>不过 append 操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := [...]<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;array:&quot;</span>, u) <span class="comment">// array: [11 12 13 14 15]</span></span><br><span class="line">	s := u[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Printf(<span class="string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s),s) <span class="comment">// slice(len=2, cap=4): [12 13]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">24</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after append 24, array:&quot;</span>, u)  <span class="comment">// after append 24, array: [11 12 13 24 15]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)  <span class="comment">// after append 24, slice(len=3, cap=4): [12 13 24]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">25</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after append 25, array:&quot;</span>, u)  <span class="comment">// after append 25, array: [11 12 13 24 25]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)  <span class="comment">// after append 25, slice(len=4, cap=4): [12 13 24 25]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">26</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after append 26, array:&quot;</span>, u)  <span class="comment">// after append 26, array: [11 12 13 24 25]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)  <span class="comment">// after append 26, slice(len=5, cap=8): [12 13 24 25 26]</span></span><br><span class="line"></span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">22</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)  <span class="comment">// after reassign 1st elem of slice, array: [11 12 13 24 25]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)  <span class="comment">// after reassign 1st elem of slice, slice(len=5, cap=8): [22 13 24 25 26]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 append 25 之后，切片的元素已经触碰到了底层数组 u 的边界了。<br>然后我们再append 26 之后，append 发现底层数组已经无法满足 append 的要求，于是新创建了一个底层数组（数组长度为 cap(s) 的 2 倍，即 8），并将 slice 的元素拷贝到新数组中了。  </p>
<p>在这之后，我们即便再修改切片的第一个元素值，原数组 u 的元素也不会发生改变了，因为这个时候切片 s 与数组 u 已经解除了“绑定关系”，s 已经不再是数组 u 的“描述符”了。  </p>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>切片</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解string实现原理并高效使用</title>
    <url>/2022/10/08/book-go-programming-from-beginner-to-master-15/</url>
    <content><![CDATA[<h1 id="Go语言的字符串类型"><a href="#Go语言的字符串类型" class="headerlink" title="Go语言的字符串类型"></a>Go语言的字符串类型</h1><p>统一设置为<code>string</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	s = <span class="string">&quot;string constant&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 <span class="type">string</span> = <span class="string">&quot;string variable&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, s)                          <span class="comment">// string</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, s1)                         <span class="comment">// string</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="string">&quot;temporary string literal&quot;</span>) <span class="comment">// string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能特点：  </p>
<ul>
<li>string类型的数据是不可变的；  </li>
<li>零值可用；  </li>
<li>获取长度的时间复杂度是O(1)级别  </li>
<li>支持通过 +&#x2F;+&#x3D; 操作符进行字符串连接  </li>
<li>支持各种比较关系操作符：&#x3D;&#x3D;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;、&lt;、&gt;  </li>
<li>对非ASCII字符提供原生支持  </li>
<li>原生支持多行字符串</li>
</ul>
<h1 id="字符串的内部表示"><a href="#字符串的内部表示" class="headerlink" title="字符串的内部表示"></a>字符串的内部表示</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/reflect/value.go</span></span><br><span class="line"><span class="comment">// StringHeader是一个string的运行时表示</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。  </p>
<p>string 类型变量在 Go 内存中的存储：<br><img src="/2022/10/08/book-go-programming-from-beginner-to-master-15/str1.png">  </p>
<p>Go 编译器把源码中的 string 类型映射为运行时的一个二元组（Data, Len），真实的字符串值数据就存储在一个被 Data 指向的底层数组中。通过 Data 字段，我们可以得到这个数组的内容。  </p>
<h1 id="字符串的高效构造"><a href="#字符串的高效构造" class="headerlink" title="字符串的高效构造"></a>字符串的高效构造</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sl []<span class="type">string</span> = []<span class="type">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;Rob Pike &quot;</span>,</span><br><span class="line">	<span class="string">&quot;Robert Griesemer &quot;</span>,</span><br><span class="line">	<span class="string">&quot;Ken Thompson &quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByOperator</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringBySprintf</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		s = fmt.Sprintf(<span class="string">&quot;%s%s&quot;</span>, s, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByJoin</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(sl, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByStringsBuilder</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b strings.Builder</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		b.WriteString(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByStringsBuilderWithInitSize</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b strings.Builder</span><br><span class="line">	b.Grow(<span class="number">64</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		b.WriteString(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByBytesBuffer</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		b.WriteString(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatStringByBytesBufferWithInitSize</span><span class="params">(sl []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	b := bytes.NewBuffer(buf)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">		b.WriteString(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByOperator</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByOperator(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringBySprintf</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringBySprintf(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByJoin</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByJoin(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByStringsBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByStringsBuilder(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByStringsBuilderWithInitSize</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByStringsBuilderWithInitSize(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByBytesBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByBytesBuffer(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByBytesBufferWithInitSize</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		concatStringByBytesBufferWithInitSize(sl)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ go test -bench . -benchmem string_concat_benchmark_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByOperator-8                       16233814                74.30 ns/op           80 B/op          2 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringBySprintf-8                         3572353               339.8 ns/op           176 B/op          8 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByJoin-8                           28999772                45.75 ns/op           48 B/op          1 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByStringsBuilder-8                 14822047                85.82 ns/op          112 B/op          3 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByStringsBuilderWithInitSize-8     31907448                36.64 ns/op           64 B/op          1 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByBytesBuffer-8                    19904794                66.63 ns/op          112 B/op          2 allocs/op</span></span><br><span class="line"><span class="comment">BenchmarkConcatStringByBytesBufferWithInitSize-8        30484027                39.38 ns/op           48 B/op          1 allocs/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  9.405s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从基准测试的输入结果的第三列，即每次操作耗时的数值来看：  </p>
<ul>
<li>做了预初始化的<code>strings.Builder</code>连接构造字符串的效率最高；  </li>
<li>带有预初始化的<code>bytes.Buffer</code>和<code>strings.Join</code>这两种方法效率接近；  </li>
<li>未做预初始化的<code>strings.Builder</code>、<code>bytes.Buffer</code>和操作符连接在第三档次；  </li>
<li><code>fmt.Sprintf</code>性能最差。</li>
</ul>
<p>结论：  </p>
<ul>
<li>在能预估出最终字符串长度的情况下，使用预初始化的<code>strings.Builder</code>连接构建字符串效率最高；  </li>
<li><code>strings.Join</code>连接构建字符串的平均性能最稳定；  </li>
<li>使用操作符连接的方式最直观，并且可以得到编译器的优化处理；  </li>
<li><code>fmt.Sprintf</code>效率不高，但适合由多种不同类型的变量来构建特定格式的字符串。</li>
</ul>
<h1 id="字符串相关的高效转换"><a href="#字符串相关的高效转换" class="headerlink" title="字符串相关的高效转换"></a>字符串相关的高效转换</h1><p>[]rune或[]byte 反向转换为 string：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rs := []<span class="type">rune</span>&#123;</span><br><span class="line">		<span class="number">0x4E2D</span>,</span><br><span class="line">		<span class="number">0x56FD</span>,</span><br><span class="line">		<span class="number">0x6B22</span>,</span><br><span class="line">		<span class="number">0x8FCE</span>,</span><br><span class="line">		<span class="number">0x60A8</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := <span class="type">string</span>(rs)</span><br><span class="line">	fmt.Println(s) <span class="comment">// 中国欢迎您</span></span><br><span class="line"></span><br><span class="line">	sl := []<span class="type">byte</span>&#123;</span><br><span class="line">		<span class="number">0xE4</span>, <span class="number">0xB8</span>, <span class="number">0xAD</span>,</span><br><span class="line">		<span class="number">0xE5</span>, <span class="number">0x9B</span>, <span class="number">0xBD</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>,</span><br><span class="line">		<span class="number">0xE8</span>, <span class="number">0xBF</span>, <span class="number">0x8E</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0x82</span>, <span class="number">0xA8</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = <span class="type">string</span>(sl)</span><br><span class="line">	fmt.Println(s) <span class="comment">// 中国欢迎您</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换是要付出代价的，根源在于string是不可变的，运行时要为转换后的类型分配新内存。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteSliceToString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sl := []<span class="type">byte</span>&#123;</span><br><span class="line">		<span class="number">0xE4</span>, <span class="number">0xB8</span>, <span class="number">0xAD</span>,</span><br><span class="line">		<span class="number">0xE5</span>, <span class="number">0x9B</span>, <span class="number">0xBD</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>,</span><br><span class="line">		<span class="number">0xE8</span>, <span class="number">0xBF</span>, <span class="number">0x8E</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0x82</span>, <span class="number">0xA8</span>,</span><br><span class="line">		<span class="number">0xEF</span>, <span class="number">0xBC</span>, <span class="number">0x8C</span>,</span><br><span class="line">		<span class="number">0xE5</span>, <span class="number">0x8C</span>, <span class="number">0x97</span>,</span><br><span class="line">		<span class="number">0xE4</span>, <span class="number">0xBA</span>, <span class="number">0xAC</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>,</span><br><span class="line">		<span class="number">0xE8</span>, <span class="number">0xBF</span>, <span class="number">0x8E</span>,</span><br><span class="line">		<span class="number">0xE6</span>, <span class="number">0x82</span>, <span class="number">0xA8</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_ = <span class="type">string</span>(sl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringToByteSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;中国欢迎您，北京换欢您&quot;</span></span><br><span class="line">	_ = []<span class="type">byte</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, byteSliceToString))  <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, stringToByteSlice))  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对“中国欢迎您，北京欢迎您”这个长度的字符串，在string与byte slice互转的过程中都要有一次内存分配操作。  </p>
<p>因此，<strong>想要更高效地进行转换，唯一的办法就是减少甚至避免额外的内存分配操作</strong>。  </p>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>string</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解map原理并高效使用</title>
    <url>/2022/10/07/book-go-programming-from-beginner-to-master-14/</url>
    <content><![CDATA[<h1 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h1><p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。  </p>
<p><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map1.png">  </p>
<p><code>map</code>的声明：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key_type]value_type</span><br></pre></td></tr></table></figure>

<p>key 与 value 的类型可以相同，也可以不同：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>  <span class="comment">// key与value元素的类型相同</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>     <span class="comment">// key与value元素的类型不同</span></span><br></pre></td></tr></table></figure>
<p>如果两个 map 类型的 key 元素类型相同，value 元素类型也相同，那么我们可以说它们是同一个 map 类型，否则就是不同的 map 类型。  </p>
<p>map 类型对 value 的类型没有限制，但是对 key 的类型却有严格要求，因为 map 类型要保证 key 的唯一性。<strong>Go 语言中要求，key 的类型必须支持“&#x3D;&#x3D;”和“!&#x3D;”两种比较操作符</strong>。  </p>
<p>在Go语言中，函数类型、map类型本身，以及切片只支持与nil的比较，而不支持同类型两个变量的比较：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">	f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">	m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">	<span class="built_in">println</span>(s1 == s2) <span class="comment">// invalid operation: s1 == s2 (slice can only be compared to nil)</span></span><br><span class="line">	<span class="built_in">println</span>(f1 == f2) <span class="comment">// invalid operation: f1 == f2 (func can only be compared to nil)</span></span><br><span class="line">	<span class="built_in">println</span>(m1 == m2) <span class="comment">// invalid operation: m1 == m2 (map can only be compared to nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：<strong>函数类型、map 类型自身，以及切片类型是不能作为 map的 key 类型的</strong>。  </p>
<h1 id="map基本操作"><a href="#map基本操作" class="headerlink" title="map基本操作"></a>map基本操作</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个map</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// 一个 map[string]int 类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值会报错</span></span><br><span class="line">m[<span class="string">&quot;keys&quot;</span>] = <span class="number">1</span>  <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>

<h2 id="使用复合字面值初始化-map-类型变量"><a href="#使用复合字面值初始化-map-类型变量" class="headerlink" title="使用复合字面值初始化 map 类型变量"></a>使用复合字面值初始化 map 类型变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-make-为-map-类型变量进行显式初始化"><a href="#使用-make-为-map-类型变量进行显式初始化" class="headerlink" title="使用 make 为 map 类型变量进行显式初始化"></a>使用 make 为 map 类型变量进行显式初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)  <span class="comment">// 未指定初始容量</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>,<span class="number">8</span>) <span class="comment">// 指定初始容量为8</span></span><br></pre></td></tr></table></figure>

<h2 id="插入新键值对"><a href="#插入新键值对" class="headerlink" title="插入新键值对"></a>插入新键值对</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;v1&quot;</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;v2&quot;</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;v3&quot;</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;v1-back&quot;</span>  <span class="comment">// 会覆盖掉1所对应的值</span></span><br></pre></td></tr></table></figure>

<h2 id="获取键值对数量"><a href="#获取键值对数量" class="headerlink" title="获取键值对数量"></a>获取键值对数量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;key2&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(m))  <span class="comment">// 2</span></span><br><span class="line">	m[<span class="string">&quot;key3&quot;</span>] = <span class="number">3</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：我们不能对 map 类型变量调用 cap，来获取当前容量。  </p>
<h2 id="查找和数据读取"><a href="#查找和数据读取" class="headerlink" title="查找和数据读取"></a>查找和数据读取</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;not exist&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>在 Go 语言中，请使用“comma ok”惯用法对 map 进行键查找和键值读取操作</strong>。  </p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(m) <span class="comment">// map[key1:1 key2:2 key3:3]</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">// map[key2:2 key3:3]</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>delete 函数是从 map 中删除键的唯一方法</strong>。即便传给 delete 的键在map 中并不存在，delete 函数的执行也不会失败，更不会抛出运行时的异常。  </p>
<h2 id="遍历-map-中的键值数据"><a href="#遍历-map-中的键值数据" class="headerlink" title="遍历 map 中的键值数据"></a>遍历 map 中的键值数据</h2><p>像对待切片那样通过 for range 语句对 map 数据进行遍历：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">&quot;&#123; &quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;&#125;\n&quot;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; key1: 1</span></span><br><span class="line"><span class="comment">key2: 2</span></span><br><span class="line"><span class="comment">key3: 3</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="map的内部实现"><a href="#map的内部实现" class="headerlink" title="map的内部实现"></a>map的内部实现</h1><p>Go 运行时使用一张哈希表来实现抽象的map 类型。运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makemap implements Go map creation for make(map[k]v, hint).</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span></span><br><span class="line"><span class="comment">// it will return a reference to the zero object for the elem type if</span></span><br><span class="line"><span class="comment">// the key is not in the map.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The returned pointer may keep the whole map live, so don&#x27;t</span></span><br><span class="line"><span class="comment">// hold onto it for very long.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-类型在-Go-运行时层实现的示意图"><a href="#map-类型在-Go-运行时层实现的示意图" class="headerlink" title="map 类型在 Go 运行时层实现的示意图"></a>map 类型在 Go 运行时层实现的示意图</h2><p><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map2.png">  </p>
<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>与语法层面 map 类型变量（m）一一对应的是 runtime.hmap 的实例。<br>hmap 类型是 map 类型的头部结构（header），也就是map 类型的描述符，它存储了后续 map 类型操作所需的所有信息，包括：<br><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map3.png">  </p>
<p>真正用来存储键值对数据的是桶，也就是 bucket，每个 bucket 中存储的是 Hash 值低<br>bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE(值为 8，在$GOROOT&#x2F;src&#x2F;cmd&#x2F;compile&#x2F;internal&#x2F;gc&#x2F;reflect.go 中定义，与 runtime&#x2F;map.go 中常量 bucketCnt 保持一致）  </p>
<p><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map4.png">  </p>
<p>当某个 bucket（比如 buckets[0]) 的 8 个空槽 slot）都填满了，且 map 尚未达到扩容的条件的情况下，运行时会建立 overflow bucket，并将这个 overflow bucket 挂在上面bucket（如 buckets[0]）末尾的 overflow 指针上，这样两个 buckets 形成了一个链表结构，直到下一次 map 扩容之前，这个结构都会一直存在。  </p>
<p>从图中我们可以看到，每个 bucket 由三部分组成，从上到下分别是 tophash 区域、<br>key存储区域和 value 存储区域。  </p>
<h4 id="tophash-区域"><a href="#tophash-区域" class="headerlink" title="tophash 区域"></a>tophash 区域</h4><p>当我们向 map 插入一条数据，或者是从 map 按 key 查询数据的时候，运行时都会使用哈希函数对 key 做哈希运算，并获得一个哈希值（hashcode）。这个 hashcode 非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置。  </p>
<p><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map5.png">  </p>
<p>因此，每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的，这样就避免了逐个key 进行比较这种代价较大的操作。尤其是当 key 是 size 较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。  </p>
<h4 id="key-存储区域"><a href="#key-存储区域" class="headerlink" title="key 存储区域"></a>key 存储区域</h4><p>tophash 区域下面是一块连续的内存区域，存储的是这个 bucket 承载的所有 key 数据。运行时在分配 bucket 的时候需要知道 key 的 Size。——<strong>Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的</strong>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ    _type</span><br><span class="line">	key    *_type</span><br><span class="line">	elem   *_type</span><br><span class="line">	bucket *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	<span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></span><br><span class="line">	hasher     <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	elemsize   <span class="type">uint8</span>  <span class="comment">// size of elem slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="value-存储区域"><a href="#value-存储区域" class="headerlink" title="value 存储区域"></a>value 存储区域</h4><p>key 存储区域下方的另外一块连续的内存区域，这个区域存储的是 key 对应的 value。<br>和 key 一样，这个区域的创建也是得到了 maptype 中信息的帮助。Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式<br>存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。  </p>
<p>我们以 map[int8]int64 为例，看看下面的存储空间利用率对比图：<br><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map6.png">  </p>
<p>当前 Go 运行时使用的方案内存利用效率很高，而 kv 紧邻存储的方案在map[int8]int64 这样的例子中内存浪费十分严重，它的内存利用率是 72&#x2F;128&#x3D;56.25%，有近一半的空间都浪费掉了。  </p>
<p>注意：<strong>如果 key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket 中直接存储数据，而是会存储 key 或 value 数据的指针。</strong><br>目前 Go 运行时定义的最大 key 和 value 的长度是这样的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/map.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    maxKeySize  = <span class="number">128</span></span><br><span class="line">	maxElemSize = <span class="number">128</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="map扩容"><a href="#map扩容" class="headerlink" title="map扩容"></a>map扩容</h1><p>map 会对底层使用的内存进行自动管理。<br>因此，在使用过程中，当插入元素个数超出一定数值后，map 一定会存在自动扩容的问题，也就是怎么扩充 bucket 的数量，并重新在 bucket 间均衡分配数据的问题。  </p>
<p>那么 map 在什么情况下会进行扩容呢？<br>Go 运行时的 map 实现中引入了一个LoadFactor（负载因子），当count &gt; LoadFactor * 2^B或 overflow bucket 过多时，运行时会自动对 map 进行扩容。  </p>
<p>目前 Go 最新 1.17 版本以上 LoadFactor 设置为6.5（loadFactorNumloadFactorDen）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/map.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    loadFactorNum = <span class="number">13</span></span><br><span class="line">	loadFactorDen = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果是因为 overflowbucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的 bucket 数组，然后在 assign 和 delete 时做排空和迁移。  </p>
</li>
<li><p>如果是因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会立一个两倍于现有规模的 bucket 数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。原 bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets 数组中所有数据都迁移到新数组后，原 buckets 数组才会被释放。<br><img src="/2022/10/07/book-go-programming-from-beginner-to-master-14/map7.png"></p>
</li>
</ul>
<h1 id="map与并发"><a href="#map与并发" class="headerlink" title="map与并发"></a>map与并发</h1><p>从上面的实现原理来看，充当 map 描述符角色的 hmap实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以，map实例不是并发写安全的，也不支持并发读写。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIteration</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		_ = fmt.Sprintf(<span class="string">&quot;[%d, %d] &quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWrite</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		m[k] = v + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="number">1</span>: <span class="number">11</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="number">12</span>,</span><br><span class="line">		<span class="number">3</span>: <span class="number">13</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			doIteration(m)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			doWrite(m)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fatal error: concurrent map iteration and map write</span></span><br></pre></td></tr></table></figure>

<p>如果我们仅仅是进行并发读，map 是没有问题的。  </p>
<p>Go 1.9 版本中引入了支持并发写安全的 sync.Map 类型，可以用来在并发读写的场景下替换掉 map。  </p>
<p>注意：考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以<strong>Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的</strong>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := &amp;m[key]<span class="comment">//can not take the address of m[key]</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——使用defer让函数更简洁、更健壮</title>
    <url>/2022/10/08/book-go-programming-from-beginner-to-master-22/</url>
    <content><![CDATA[<h1 id="defer的运作机制"><a href="#defer的运作机制" class="headerlink" title="defer的运作机制"></a>defer的运作机制</h1><ul>
<li>在 Go 中，只有在函数（和方法）内部才能使用 defer；  </li>
<li>defer 关键字后面只能接函数（或方法），这些函数被称为deferred 函数。defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行：<br><img src="/2022/10/08/book-go-programming-from-beginner-to-master-22/defer1.png"></li>
</ul>
<h1 id="defer的常见用法"><a href="#defer的常见用法" class="headerlink" title="defer的常见用法"></a>defer的常见用法</h1><h2 id="拦截panic"><a href="#拦截panic" class="headerlink" title="拦截panic"></a>拦截panic</h2><p>按需要对<code>panic</code>进行处理，可以尝试从<code>panic</code>中恢复。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;raise a panic&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;recovered from a panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exit normally&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">raise a panic</span></span><br><span class="line"><span class="comment">recovered from a panic</span></span><br><span class="line"><span class="comment">main exit normally</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="修改函数的具名返回值"><a href="#修改函数的具名返回值" class="headerlink" title="修改函数的具名返回值"></a>修改函数的具名返回值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		x = x * <span class="number">5</span></span><br><span class="line">		y = y * <span class="number">10</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	x = a + <span class="number">5</span>  <span class="comment">// 6</span></span><br><span class="line">	y = b + <span class="number">6</span>  <span class="comment">// 8</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot;y=&quot;</span>, y)  <span class="comment">// x= 30 y= 80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deferred函数在foo真正将执行权返回给main函数之前，将foo的两个返回值x和y分别放大了5倍和10倍。  </p>
<h2 id="输出调试信息"><a href="#输出调试信息" class="headerlink" title="输出调试信息"></a>输出调试信息</h2><h2 id="还原变量旧值"><a href="#还原变量旧值" class="headerlink" title="还原变量旧值"></a>还原变量旧值</h2><h1 id="关于defer的几个关键问题"><a href="#关于defer的几个关键问题" class="headerlink" title="关于defer的几个关键问题"></a>关于defer的几个关键问题</h1><h2 id="明确哪些函数可以作为deferred函数"><a href="#明确哪些函数可以作为deferred函数" class="headerlink" title="明确哪些函数可以作为deferred函数"></a>明确哪些函数可以作为deferred函数</h2><h2 id="把握好defer关键字后表达式的求值时机"><a href="#把握好defer关键字后表达式的求值时机" class="headerlink" title="把握好defer关键字后表达式的求值时机"></a>把握好defer关键字后表达式的求值时机</h2><h2 id="知晓defer带来的性能损耗"><a href="#知晓defer带来的性能损耗" class="headerlink" title="知晓defer带来的性能损耗"></a>知晓defer带来的性能损耗</h2>]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——优先考虑并发设计</title>
    <url>/2022/10/08/book-go-programming-from-beginner-to-master-31/</url>
    <content><![CDATA[<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><h2 id="并行方案"><a href="#并行方案" class="headerlink" title="并行方案"></a>并行方案</h2><p>在处理器核数充足的情况下启动多个单线程应用的实例，这样每个实例运行在一个核上，尽可能多地利用多核计算资源。  </p>
<p><img src="/2022/10/08/book-go-programming-from-beginner-to-master-31/%E5%8D%95%E8%BF%9B%E7%A8%8B.png">  </p>
<p><img src="/2022/10/08/book-go-programming-from-beginner-to-master-31/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png">  </p>
<h2 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h2><p>重新做应用结构设计，即将应用分解成多个在基本执行单元中执行的、可能有一定关联关系的代码片段。  </p>
<h2 id="goroutine相比线程具有的优势"><a href="#goroutine相比线程具有的优势" class="headerlink" title="goroutine相比线程具有的优势"></a>goroutine相比线程具有的优势</h2><ul>
<li>资源占用小，每个<code>goroutine</code>的初始栈大小为2KB  </li>
<li>由Go运行时而不是操作系统调度，<code>goroutine</code>上下文切换代价较小  </li>
<li>语言原生支持  </li>
<li>内置<code>channel</code>作为<code>goroutine</code>之间的通信原语，为并发设计提供强大支撑</li>
</ul>
<h1 id="Go并发设计实例"><a href="#Go并发设计实例" class="headerlink" title="Go并发设计实例"></a>Go并发设计实例</h1><p>模拟机场安检  </p>
<h2 id="第一版：顺序设计"><a href="#第一版：顺序设计" class="headerlink" title="第一版：顺序设计"></a>第一版：顺序设计</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	idCheckTmCost   = <span class="number">60</span></span><br><span class="line">	bodyCheckTmCost = <span class="number">120</span></span><br><span class="line">	xRayCheckTmCost = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">idCheck</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(idCheckTmCost))</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;\tidCheck ok&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> idCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyCheck</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(bodyCheckTmCost))</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;\tbodyCheck ok&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> bodyCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xRayCheck</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(xRayCheckTmCost))</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;\txRayCheck ok&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> xRayCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">airportSecurityCheck</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;airportSecurityCheck ...&quot;</span>)</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	total += idCheck()</span><br><span class="line">	total += bodyCheck()</span><br><span class="line">	total += xRayCheck()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;airportSecurityCheck ok&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	passengers := <span class="number">30</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; passengers; i++ &#123;</span><br><span class="line">		total += airportSecurityCheck()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;total time cost:&quot;</span>, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// total time cost: 10800</span></span><br></pre></td></tr></table></figure>

<h2 id="第二版：并行方案"><a href="#第二版：并行方案" class="headerlink" title="第二版：并行方案"></a>第二版：并行方案</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	idCheckTmCost   = <span class="number">60</span></span><br><span class="line">	bodyCheckTmCost = <span class="number">120</span></span><br><span class="line">	xRayCheckTmCost = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">idCheck</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(idCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;: idCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> idCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyCheck</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(bodyCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;: bodyCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> bodyCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xRayCheck</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(xRayCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;: xRayCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> xRayCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">airportSecurityCheck</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;goroutine-&quot;</span>, id, <span class="string">&quot;: airportSecurityCheck ...\n&quot;</span>)</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	total += idCheck(id)</span><br><span class="line">	total += bodyCheck(id)</span><br><span class="line">	total += xRayCheck(id)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;goroutine-&quot;</span>, id, <span class="string">&quot;: airportSecurityCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(id <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">int</span>, queue &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		total := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_, ok := &lt;-queue</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				c &lt;- total</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			total += f(id)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; n &#123;</span><br><span class="line">			n = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	passengers := <span class="number">30</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	c1 := start(<span class="number">1</span>, airportSecurityCheck, c)</span><br><span class="line">	c2 := start(<span class="number">2</span>, airportSecurityCheck, c)</span><br><span class="line">	c3 := start(<span class="number">3</span>, airportSecurityCheck, c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; passengers; i++ &#123;</span><br><span class="line">		c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	total = max(&lt;-c1, &lt;-c2, &lt;-c3)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;total time cost:&quot;</span>, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// total time cost: 3600</span></span><br></pre></td></tr></table></figure>

<h2 id="第三版：并发方案"><a href="#第三版：并发方案" class="headerlink" title="第三版：并发方案"></a>第三版：并发方案</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	idCheckTmCost   = <span class="number">60</span></span><br><span class="line">	bodyCheckTmCost = <span class="number">120</span></span><br><span class="line">	xRayCheckTmCost = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">idCheck</span><span class="params">(id <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(idCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;-idCheck: idCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> idCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyCheck</span><span class="params">(id <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(bodyCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;-bodyCheck: bodyCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> bodyCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xRayCheck</span><span class="params">(id <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * time.Duration(xRayCheckTmCost))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;\tgoroutine-&quot;</span>, id, <span class="string">&quot;-xRayCheck: xRayCheck ok\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> xRayCheckTmCost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(id <span class="type">string</span>, f <span class="keyword">func</span>(<span class="type">string</span>)</span></span> <span class="type">int</span>, next <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">int</span>) &#123;</span><br><span class="line">	queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		total := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">				result &lt;- total</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> v := &lt;-queue:</span><br><span class="line">				total += f(id)</span><br><span class="line">				<span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">					next &lt;- v</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> queue, quit, result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAirportSecurityCheckChannel</span><span class="params">(id <span class="type">string</span>, queue &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;goroutine-&quot;</span>, id, <span class="string">&quot;: airportSecurityCheckChannel is ready...\n&quot;</span>)</span><br><span class="line">		<span class="comment">// start xRayCheck routine</span></span><br><span class="line">		queue3, quit3, result3 := start(id, xRayCheck, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// start bodyCheck routine</span></span><br><span class="line">		queue2, quit2, result2 := start(id, bodyCheck, queue3)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// start idCheck routine</span></span><br><span class="line">		queue1, quit1, result1 := start(id, idCheck, queue2)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v, ok := &lt;-queue:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="built_in">close</span>(quit1)</span><br><span class="line">					<span class="built_in">close</span>(quit2)</span><br><span class="line">					<span class="built_in">close</span>(quit3)</span><br><span class="line">					total := max(&lt;-result1, &lt;-result2, &lt;-result3)</span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&quot;goroutine-&quot;</span>, id, <span class="string">&quot;: airportSecurityCheckChannel time cost:&quot;</span>, total, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&quot;goroutine-&quot;</span>, id, <span class="string">&quot;: airportSecurityCheckChannel closed\n&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				queue1 &lt;- v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; n &#123;</span><br><span class="line">			n = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	passengers := <span class="number">30</span></span><br><span class="line">	queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">30</span>)</span><br><span class="line">	newAirportSecurityCheckChannel(<span class="string">&quot;channel1&quot;</span>, queue)</span><br><span class="line">	newAirportSecurityCheckChannel(<span class="string">&quot;channel2&quot;</span>, queue)</span><br><span class="line">	newAirportSecurityCheckChannel(<span class="string">&quot;channel3&quot;</span>, queue)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 保证上述三个goroutine都已经处于ready状态</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; passengers; i++ &#123;</span><br><span class="line">		queue &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(queue) <span class="comment">// 为了打印各通道的处理时长</span></span><br><span class="line">	time.Sleep(<span class="number">1000</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">goroutine-channel2: airportSecurityCheckChannel time cost:2160</span></span><br><span class="line"><span class="comment">goroutine-channel1: airportSecurityCheckChannel time cost:1080</span></span><br><span class="line"><span class="comment">goroutine-channel3: airportSecurityCheckChannel time cost:2160</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解goroutine的调度原理</title>
    <url>/2022/10/06/book-go-programming-from-beginner-to-master-32/</url>
    <content><![CDATA[<h1 id="什么是goroutine"><a href="#什么是goroutine" class="headerlink" title="什么是goroutine"></a>什么是goroutine</h1><p><code>goroutine</code>是由Go运行时管理的用户层轻量级线程。  </p>
<p>相比较于操作系统线程，<code>goroutine</code>的资源占用和使用代价都要小得多，可以创建几十个、几百个甚至成千上万个<code>goroutine</code>也不会造成系统资源的枯竭，<code>Go</code>的运行时负责对<code>goroutine</code>进行管理。而所谓的管理 &#x3D;&#x3D; 调度。  </p>
<h1 id="goroutine调度器"><a href="#goroutine调度器" class="headerlink" title="goroutine调度器"></a>goroutine调度器</h1><p>一个Go程序中可以创建成千上万个并发的<code>goroutine</code>，而将这些<code>goroutine</code>按照一定算法放到CPU上执行的程序就称为<strong>goroutine调度器</strong>。  </p>
<p>一个Go程序对于操作系统来说只是一个用户层程序，操作系统眼中只有线程，<code>goroutine</code>的调度全要靠Go自己完成。  </p>
<h1 id="goroutine调度器原理"><a href="#goroutine调度器原理" class="headerlink" title="goroutine调度器原理"></a>goroutine调度器原理</h1><h2 id="G、P、M"><a href="#G、P、M" class="headerlink" title="G、P、M"></a>G、P、M</h2><ul>
<li>G：代表<code>goroutine</code>，存储了<code>goroutine</code>的执行栈信息，<code>goroutine</code>状态以及<code>goroutine</code>的任务函数等。另外G对象是可以重用的。  </li>
<li>P：代表逻辑<code>processor</code>，P的数量决定了系统内最大可并行的G的数量。P中最有用的是其拥有的各种G对象队列、链表、一些缓存和状态。  </li>
<li>M：代表真正的执行计算资源。在绑定有效的P后，进入一个调度循环；而调度循环的机制大致是从各种队列、P的本地运行队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M。如此返回。M不保留G的状态，这是G可以跨M调度的基础。</li>
</ul>
<h2 id="G被抢占调度"><a href="#G被抢占调度" class="headerlink" title="G被抢占调度"></a>G被抢占调度</h2><p>如果某个G没有进行系统调用、没有进行I&#x2F;O操作、没有阻塞在一个channel的操作上，那么M是如何让G停下来并调度下一个可运行的G的呢？——G是被抢占调度的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forcePreemptNS is the time slice given to a G before it is</span></span><br><span class="line"><span class="comment">// preempted.</span></span><br><span class="line"><span class="keyword">const</span> forcePreemptNS = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> <span class="comment">// 10ms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">			<span class="comment">// Preempt G if it&#x27;s running for too long.</span></span><br><span class="line">			t := <span class="type">int64</span>(_p_.schedtick)</span><br><span class="line">			<span class="keyword">if</span> <span class="type">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">				pd.schedtick = <span class="type">uint32</span>(t)</span><br><span class="line">				pd.schedwhen = now</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">				preemptone(_p_)</span><br><span class="line">				<span class="comment">// In case of syscall, preemptone() doesn&#x27;t</span></span><br><span class="line">				<span class="comment">// work, because there is no M wired to P.</span></span><br><span class="line">				sysretake = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个G任务运行超过10ms，<code>sysmon</code>就会认为其运行时间太久而发出抢占式调度的请求。一旦G的抢占标志被设为true，那么在这个G下一次调用函数或方法时，运行时便可以将G抢占并移出运行状态，放入P的本地运行队列中，等待下一次被调度。  </p>
<h2 id="channel阻塞或网络I-x2F-O情况下的调度"><a href="#channel阻塞或网络I-x2F-O情况下的调度" class="headerlink" title="channel阻塞或网络I&#x2F;O情况下的调度"></a>channel阻塞或网络I&#x2F;O情况下的调度</h2><p>如果G被阻塞在某个channel操作或网络I&#x2F;O操作上，那么G会被放置到某个等待队列中，而M会尝试运行P的下一个可运行的G。如果此时P没有可运行的G供M运行，那么M将解绑P，并进入挂起状态。当I&#x2F;O操作完成或channel操作完成，在等待队列中的G会被唤醒，标记为runnable-可运行，并被放入某个P的队列中，绑定一个M后继续执行。  </p>
<h2 id="系统调用阻塞情况下的调度"><a href="#系统调用阻塞情况下的调度" class="headerlink" title="系统调用阻塞情况下的调度"></a>系统调用阻塞情况下的调度</h2><p>如果G被阻塞在某个系统调用上，那么不仅G会阻塞，执行该G的M也会解绑P，与G一起进入阻塞状态。<br>如果此时有空闲的M，则P会与其绑定并继续执行其他G；如果没有空闲的M，但仍然有其他G要执行，那么就会创建一个新M（线程）。<br>当系统调用返回后，阻塞在该系统调用上的G会尝试获取一个可用的P，如果有可用P，之前运行该G的M将绑定P继续运行G；如果没有可用的P，那么G与M之间的关联将解除，同时G会被标记为runnable，放入全局的运行队列中，等待调度器的再次调度。  </p>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解channel的妙用</title>
    <url>/2022/10/06/book-go-programming-from-beginner-to-master-34/</url>
    <content><![CDATA[<h1 id="什么是channel"><a href="#什么是channel" class="headerlink" title="什么是channel"></a>什么是channel</h1><p><code>channel</code>是Go语言提供的一种重要的并发原语。它在Go语言的<code>CSP</code>模型中扮演者重要的角色：  </p>
<ul>
<li>可以实现<code>goroutine</code>之间的通信；  </li>
<li>可以实现<code>goroutine</code>之间的同步。</li>
</ul>
<p><code>channel</code>原语的使用：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  <span class="comment">// 创建一个无缓冲的int类型的channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>) <span class="comment">// 创建一个带缓冲的int类型的channel</span></span><br><span class="line">c &lt;- x  <span class="comment">// 向channel c 中发送一个值</span></span><br><span class="line">&lt;- c    <span class="comment">// 从channel c 中接收一个值</span></span><br><span class="line">x = &lt;- c  <span class="comment">// 从channel c 接收一个值并将其存储到变量x中</span></span><br><span class="line">x,ok = &lt;- c  <span class="comment">// 从channel c 接收一个值。若channel关闭了，ok将被置为false</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;...&#125;</span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// 关闭channel c</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">int</span>)  <span class="comment">// 创建一个无缓冲的chan int类型的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span></span> <span class="type">error</span>  <span class="comment">// 将只发送channel作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spwn</span><span class="params">(...)</span></span> &lt;-<span class="keyword">chan</span> T  <span class="comment">// 将只接收类型channel作为返回值</span></span><br></pre></td></tr></table></figure>

<p>当需要同时对多个<code>channel</code>进行操作时，我们将使用另一个<code>CSP</code>模型提供的原语<code>select</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x := &lt;-c1:  <span class="comment">// 从channel c1接收数据</span></span><br><span class="line">    <span class="keyword">case</span> y,ok := &lt;-c2: <span class="comment">// 从channel c2接收数据，并根据ok值判断c2是否已经关闭</span></span><br><span class="line">    <span class="keyword">case</span> c3 &lt;- z: <span class="comment">// 将z值发送到channel c3中</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// 当上面的case中的channel通信无法实施时，执行该默认分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无缓冲channel"><a href="#无缓冲channel" class="headerlink" title="无缓冲channel"></a>无缓冲channel</h1><ul>
<li>发送动作一定发生在接收动作完成之前；  </li>
<li>接收动作一定发生在发送动作完成之前。</li>
</ul>
<h2 id="用作信号传递"><a href="#用作信号传递" class="headerlink" title="用作信号传递"></a>用作信号传递</h2><h3 id="一对一通知信号"><a href="#一对一通知信号" class="headerlink" title="一对一通知信号"></a>一对一通知信号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;worker is working...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &lt;-<span class="keyword">chan</span> signal &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;worker start to work...&quot;</span>)</span><br><span class="line">		f()</span><br><span class="line">		c &lt;- signal(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c  <span class="comment">// 新goroutine退出的通知信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;start a worker...&quot;</span>)</span><br><span class="line">	c := spawn(worker)</span><br><span class="line">	&lt;-c</span><br><span class="line">	fmt.Println(<span class="string">&quot;worker work done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一对多通知信号"><a href="#一对多通知信号" class="headerlink" title="一对多通知信号"></a>一对多通知信号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;worker %d: is working...\n&quot;</span>, i)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;worker %d: works done\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(f <span class="keyword">func</span>(i <span class="type">int</span>)</span></span>, num <span class="type">int</span>, groupSignal &lt;-<span class="keyword">chan</span> signal) &lt;-<span class="keyword">chan</span> signal &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			&lt;-groupSignal</span><br><span class="line">			fmt.Printf(<span class="string">&quot;worker %d: start to work...\n&quot;</span>, i)</span><br><span class="line">			f(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		c &lt;- signal(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start a group of workers...&quot;</span>)</span><br><span class="line">	groupSignal := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">	c := spawnGroup(worker, <span class="number">5</span>, groupSignal)  <span class="comment">// 创建一组5个 work goroutine</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;the group of workers start to work...&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(groupSignal)  <span class="comment">// 一起开始工作</span></span><br><span class="line">	&lt;-c</span><br><span class="line">	fmt.Println(<span class="string">&quot;the group of workers work done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">start a group of workers...</span></span><br><span class="line"><span class="comment">the group of workers start to work...</span></span><br><span class="line"><span class="comment">worker 4: start to work...</span></span><br><span class="line"><span class="comment">worker 4: is working...</span></span><br><span class="line"><span class="comment">worker 1: start to work...</span></span><br><span class="line"><span class="comment">worker 2: start to work...</span></span><br><span class="line"><span class="comment">worker 2: is working...</span></span><br><span class="line"><span class="comment">worker 1: is working...</span></span><br><span class="line"><span class="comment">worker 5: start to work...</span></span><br><span class="line"><span class="comment">worker 5: is working...</span></span><br><span class="line"><span class="comment">worker 3: start to work...</span></span><br><span class="line"><span class="comment">worker 3: is working...</span></span><br><span class="line"><span class="comment">worker 3: works done</span></span><br><span class="line"><span class="comment">worker 4: works done</span></span><br><span class="line"><span class="comment">worker 5: works done</span></span><br><span class="line"><span class="comment">worker 1: works done</span></span><br><span class="line"><span class="comment">worker 2: works done</span></span><br><span class="line"><span class="comment">the group of workers work done!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="用于替代锁机制"><a href="#用于替代锁机制" class="headerlink" title="用于替代锁机制"></a>用于替代锁机制</h2><p>计数器实现方式  </p>
<h3 id="基于共享内存-锁"><a href="#基于共享内存-锁" class="headerlink" title="基于共享内存+锁"></a>基于共享内存+锁</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	i <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cter counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increase</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	cter.Lock()</span><br><span class="line">	<span class="keyword">defer</span> cter.Unlock()</span><br><span class="line">	cter.i++</span><br><span class="line">	<span class="keyword">return</span> cter.i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			v := Increase()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;goroutine-%d: current counter value is %d\n&quot;</span>, i, v)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无缓冲channel-1"><a href="#无缓冲channel-1" class="headerlink" title="无缓冲channel"></a>无缓冲channel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	i <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cter counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cter = counter&#123;</span><br><span class="line">		c: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			cter.i++</span><br><span class="line">			cter.c &lt;- cter.i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;counter init ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increase</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &lt;-cter.c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	InitCounter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			v := Increase()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;goroutine-%d: current counter value is %d\n&quot;</span>, i, v)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将计数器操作全部交给一个独立的<code>goroutine</code>处理，并通过无缓冲<code>channel</code>的同步阻塞特性实现计数器的控制。  </p>
<p>这种设计更符合Go语言的原则——<strong>不要通过共享内存来通信，而应该通过通信来共享内存</strong>。  </p>
<h1 id="带缓冲channel"><a href="#带缓冲channel" class="headerlink" title="带缓冲channel"></a>带缓冲channel</h1><p>通过带有capacity参数的内置make函数创建：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> T,capacity)</span><br></pre></td></tr></table></figure>

<p>由于带缓冲channel的运行时层实现带有缓冲区，因此对带缓冲channel的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是异步的。因此：  </p>
<ul>
<li>在缓冲区无数据或有数据但未满的情况下，对其进行发送操作的goroutine不会阻塞；  </li>
<li>在缓冲区已满的情况下，对其进行发送操作的goroutine会阻塞；  </li>
<li>在缓冲区为空的情况下，对其进行接收操作的goroutine也会阻塞。</li>
</ul>
<h2 id="用作消息队列"><a href="#用作消息队列" class="headerlink" title="用作消息队列"></a>用作消息队列</h2><h3 id="单收单发性能基准测试"><a href="#单收单发性能基准测试" class="headerlink" title="单收单发性能基准测试"></a>单收单发性能基准测试</h3><h4 id="一对一无缓冲"><a href="#一对一无缓冲" class="headerlink" title="一对一无缓冲"></a>一对一无缓冲</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for send benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for recv benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-c1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	c2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			c2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	c1 &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-c2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnbufferedChan1To1Send</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnbufferedChan1To1Recv</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		recv()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*$ go test -bench . one_to_one_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkUnbufferedChan1To1Send-8        3983892               281.5 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkUnbufferedChan1To1Recv-8        4622538               272.9 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="一对一有缓冲"><a href="#一对一有缓冲" class="headerlink" title="一对一有缓冲"></a>一对一有缓冲</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for send benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for recv benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-c1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	c2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			c2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	c1 &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-c2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBufferedChan1To1SendCap10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBufferedChan1To1RecvCap10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		recv()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ go test -bench . one_to_one_cap_10_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChan1To1SendCap10-8    11304949               105.1 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChan1To1RecvCap10-8    12171568                95.44 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . one_to_one_cap_100_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChan1To1SendCap100-8           17385675                67.87 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChan1To1RecvCap100-8           18351138                68.77 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="多对多无缓冲"><a href="#多对多无缓冲" class="headerlink" title="多对多无缓冲"></a>多对多无缓冲</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for send benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for recv benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				&lt;-c1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				c1 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				c2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				&lt;-c2</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	c1 &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-c2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnbufferedChanNToNSend</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnbufferedChanNToNRecv</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		recv()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ go test -bench . multi_to_multi_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkUnbufferedChanNToNSend-8         197262              5600 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkUnbufferedChanNToNRecv-8         187816              5794 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="多对多有缓冲"><a href="#多对多有缓冲" class="headerlink" title="多对多有缓冲"></a>多对多有缓冲</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for send benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for recv benchmark test</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				&lt;-c1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				c1 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				c2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				&lt;-c2</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	c1 &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-c2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBufferedChanNToNSendCap10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBufferedChanNToNRecvCap10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		recv()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ go test -bench . multi_to_multi_cap_10_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChanNToNSendCap10-8      638821              1924 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChanNToNRecvCap10-8      544150              1925 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . multi_to_multi_cap_100_test.go </span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChanNToNSendCap100-8            1109060              1186 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkBufferedChanNToNRecvCap100-8             877389              1269 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结论：  </p>
<ul>
<li>无论是单收单发还是多收多发，带缓冲channel的收发性能都要好于无缓冲的channel；   </li>
<li>对于带缓冲channel而言，选择适当容量会在一定程度上提升收发性能。</li>
</ul>
<h2 id="用作计数信号量"><a href="#用作计数信号量" class="headerlink" title="用作计数信号量"></a>用作计数信号量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> active = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">			jobs &lt;- (i + <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(jobs)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			active &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			log.Printf(<span class="string">&quot;handle job: %d\n&quot;</span>, j)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&lt;-active</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(j)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:45 handle job: 2</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:45 handle job: 8</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:45 handle job: 6</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:47 handle job: 7</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:47 handle job: 3</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:47 handle job: 1</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:49 handle job: 4</span></span><br><span class="line"><span class="comment">2022/10/08 15:43:49 handle job: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="len-channel-的应用"><a href="#len-channel-的应用" class="headerlink" title="len(channel)的应用"></a>len(channel)的应用</h2><ul>
<li>当channel为无缓冲时，len(channel)返回的是0；  </li>
<li>当channel为有缓冲时，len(channel)返回当前channel中尚未读取的元素个数。</li>
</ul>
<h1 id="nil-channel的用法"><a href="#nil-channel的用法" class="headerlink" title="nil channel的用法"></a>nil channel的用法</h1><p>对于没有初始化的<code>channel</code>进行读写操作会发生阻塞，比如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    &lt;-c</span><br><span class="line"></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与select结合"><a href="#与select结合" class="headerlink" title="与select结合"></a>与select结合</h1><h2 id="利用default分支避免阻塞"><a href="#利用default分支避免阻塞" class="headerlink" title="利用default分支避免阻塞"></a>利用default分支避免阻塞</h2><h2 id="实现超时机制"><a href="#实现超时机制" class="headerlink" title="实现超时机制"></a>实现超时机制</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- c:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(<span class="number">30</span> * time.Second):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现心跳机制"><a href="#实现心跳机制" class="headerlink" title="实现心跳机制"></a>实现心跳机制</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    heartbeat := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> heartbeat.Stop()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;- c:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> &lt;- heartbeat.C:</span><br><span class="line">                <span class="comment">// 处理心跳</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言精进——了解sync包的正确用法</title>
    <url>/2022/10/09/book-go-programming-from-beginner-to-master-35/</url>
    <content><![CDATA[<h1 id="sync包还是channel"><a href="#sync包还是channel" class="headerlink" title="sync包还是channel"></a>sync包还是channel</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cs = <span class="number">0</span> <span class="comment">// 模拟临界区要保护的数据</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">criticalSectionSyncByMutex</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	cs++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">criticalSectionSyncByChan</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	cs++</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCriticalSectionSyncByMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		criticalSectionSyncByMutex()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCriticalSectionSyncByChan</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		criticalSectionSyncByChan()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BenchmarkCriticalSectionSyncByMutex-8   	76766581	        15.41 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkCriticalSectionSyncByChan-8   	    32243965	        37.59 ns/op</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="使用sync包的注意事项"><a href="#使用sync包的注意事项" class="headerlink" title="使用sync包的注意事项"></a>使用sync包的注意事项</h1><p>在<code>sync</code>包源文件中，我们看到以下注释：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A RWMutex must not be copied after first use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Cond must not be copied after first use.</span></span><br></pre></td></tr></table></figure>

<p>为什么在<code>Mutex</code>等<code>sync</code>包中定义的结构类型首次使用后不应该对其进行复制操作呢？  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="type">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := foo&#123;n: <span class="number">17</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f foo)</span></span> &#123;  <span class="comment">// 创建协程2</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;g2: try to lock foo...&quot;</span>)</span><br><span class="line">			f.Lock()</span><br><span class="line">			log.Println(<span class="string">&quot;g2: lock foo ok&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">			f.Unlock()</span><br><span class="line">			log.Println(<span class="string">&quot;g2: unlock foo ok&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(f)</span><br><span class="line"></span><br><span class="line">	f.Lock()</span><br><span class="line">	log.Println(<span class="string">&quot;g1: lock foo ok&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在mutex首次使用后复制其值</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f foo)</span></span> &#123;  <span class="comment">// 创建协程3</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;g3: try to lock foo...&quot;</span>)</span><br><span class="line">			f.Lock()  <span class="comment">// 阻塞</span></span><br><span class="line">			log.Println(<span class="string">&quot;g3: lock foo ok&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">			f.Unlock()</span><br><span class="line">			log.Println(<span class="string">&quot;g3: unlock foo ok&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(f)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1000</span> * time.Second)</span><br><span class="line">	f.Unlock()</span><br><span class="line">	log.Println(<span class="string">&quot;g1: unlock foo ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:50 g1: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:50 g3: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:50 g2: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:50 g2: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:53 g2: unlock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:53 g2: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:53 g2: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:56 g2: unlock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:56 g2: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:56 g2: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:59 g2: unlock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:59 g2: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:21:59 g2: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:22:02 g2: unlock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:22:02 g2: try to lock foo...</span></span><br><span class="line"><span class="comment">2022/10/11 17:22:02 g2: lock foo ok</span></span><br><span class="line"><span class="comment">2022/10/11 17:22:05 g2: unlock foo ok</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结果显示：g3阻塞在加锁操作上，g2则正常运行。  </p>
<p>原因分析：  </p>
<p>Go标准库的<code>sync.Mutex</code>定义如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span>    <span class="comment">// 表示当前互斥锁的状态</span></span><br><span class="line">	sema  <span class="type">uint32</span>   <span class="comment">// 用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>Mutex</code>实例的复制就是对两个整型字段的复制。<br>在初始状态下，<code>Mutex</code>实例处于<code>Unlocked</code>状态（state和sema均为0）。<br>g2复制了处于初始状态的<code>Mutex</code>实例，副本的state和sema均为0，与g2自定义一个新的<code>Mutex</code>无异，因此可以按预期正常运行；后续主程序调用了<code>Lock</code>方法，<code>Mutex</code>实例变为<code>Locked</code>状态（state值改变），而后面g3创建时正好复制了处于<code>Locked</code>状态的<code>Mutex</code>实例，因此g3再对其实例副本调用<code>Lock</code>方法将会阻塞。  </p>
<p>结论：<strong>使用sync包中类型时，推荐通过闭包方式或传递类型实例（或包裹该类型的类型实例）的地址或指针的方法进行</strong>。  </p>
<h1 id="互斥锁还是读写锁"><a href="#互斥锁还是读写锁" class="headerlink" title="互斥锁还是读写锁"></a>互斥锁还是读写锁</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cs1 = <span class="number">0</span> <span class="comment">// 模拟临界区要保护的数据</span></span><br><span class="line"><span class="keyword">var</span> mu1 sync.Mutex</span><br><span class="line"><span class="keyword">var</span> cs2 = <span class="number">0</span> <span class="comment">// 模拟临界区要保护的数据</span></span><br><span class="line"><span class="keyword">var</span> mu2 sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkReadSyncByMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			mu1.Lock()</span><br><span class="line">			_ = cs1</span><br><span class="line">			mu1.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkReadSyncByRWMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			mu2.RLock()</span><br><span class="line">			_ = cs2</span><br><span class="line">			mu2.RUnlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWriteSyncByRWMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			mu2.Lock()</span><br><span class="line">			cs2++</span><br><span class="line">			mu2.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 2</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-2              66311919                16.16 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-2            100000000               28.93 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-2           37036560                34.01 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  5.290s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 8</span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-8              20932657                56.80 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-8            43208829                27.58 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-8           19324240                63.63 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  3.765s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 16</span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-16             15072116                73.57 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-16           40002030                29.30 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-16          16487802                77.27 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  3.745s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 32</span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-32             10650474               108.4 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-32           40073268                29.98 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-32          11371809               102.0 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  3.773s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 64</span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-64             10868832               118.0 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-64           39970500                29.89 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-64           7829715               139.1 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  3.872s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$ go test -bench . go-sync-package-3_test.go -cpu 128</span></span><br><span class="line"><span class="comment">goos: linux</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByMutex-128            11568276               118.7 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkReadSyncByRWMutex-128          42309298                27.27 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWriteSyncByRWMutex-128          7173530               160.3 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">ok      command-line-arguments  3.996s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结论：  </p>
<ul>
<li>在并发量较小的情况下，互斥锁性能更好；随着并发量增大，互斥锁竞争激烈，导致加锁和解锁性能下降；  </li>
<li>读写锁的读锁性能并未随着并发量的增大而发生较大变化，性能始终恒定在29ns左右；  </li>
<li>在并发量较大的情况下，读写锁的写锁性能比互斥锁、读写锁的读锁性能都差，并且随着并发量的增大，其写锁性能有持续下降的趋势</li>
</ul>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>sync包</tag>
      </tags>
  </entry>
  <entry>
    <title>Chengdu Shihao English Corner, June 24, 2025</title>
    <url>/2025/06/24/chengdu-shi-hao-english-corner-2025-06-24/</url>
    <content><![CDATA[<h1 id="How-it-started"><a href="#How-it-started" class="headerlink" title="How it started"></a>How it started</h1><p>Yesterday, I listened to a talk by a PhD who has learned five foreign languages. He said:  </p>
<ul>
<li>Be brave to speak and don’t be afraid of making mistakes;  </li>
<li>Do some preparation before coming to the English corner.</li>
</ul>
<p>Therefore, I am writing this blog to record the preparations I am making for today’s English corner.</p>
<h1 id="Introduce-myself"><a href="#Introduce-myself" class="headerlink" title="Introduce myself"></a>Introduce myself</h1><blockquote>
<p>Hello everyone, my name is Neo. I am a senior software engineer. I used to work for a multinational company, and now I am an independent developer. In my free time, I enjoy reading books, watching movies, playing video games, and writing articles. I am looking forward to making new friends and improving my English here. Thank you!</p>
</blockquote>
<p>If someone asks why I want to leave：  </p>
<blockquote>
<p>I decided to leave because I was under a lot of pressure and I felt that my contributions were not fully recognized. I wanted to find an environment where I could grow and feel more appreciated.  </p>
</blockquote>
<h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><h2 id="How-can-I-cheer-myself-up-if-it’s-raining-and-I-have-to-go-to-work-in-the-morning"><a href="#How-can-I-cheer-myself-up-if-it’s-raining-and-I-have-to-go-to-work-in-the-morning" class="headerlink" title="How can I cheer myself up if it’s raining and I have to go to work in the morning?"></a>How can I cheer myself up if it’s raining and I have to go to work in the morning?</h2><blockquote>
<p>Another important reason for my decision was financial. I wanted to earn more money and have greater control over my income. By becoming an independent developer, I have the opportunity to take on different projects, explore new possibilities, and improve my financial situation while doing what I enjoy.  </p>
</blockquote>
<h2 id="Why-do-I-always-stay-up-late-even-when-I-know-it’s-bad-for-me"><a href="#Why-do-I-always-stay-up-late-even-when-I-know-it’s-bad-for-me" class="headerlink" title="Why do I always stay up late even when I know it’s bad for me?"></a>Why do I always stay up late even when I know it’s bad for me?</h2><blockquote>
<p>Another reason was that I was overconfident about my health. I thought I could handle the stress and long working hours without any problems, but later I realized that I had underestimated the impact on my well-being.</p>
</blockquote>
<h2 id="If-you-met-a-10-year-younger-version-of-yourself-what-would-you-say-to-him-or-her"><a href="#If-you-met-a-10-year-younger-version-of-yourself-what-would-you-say-to-him-or-her" class="headerlink" title="If you met a 10-year-younger version of yourself,what would you say to him or her?"></a>If you met a 10-year-younger version of yourself,what would you say to him or her?</h2><blockquote>
<p>My advice is: don’t panic, and don’t compare yourself to others. Instead, focus on your own goals and do what you really want to do.  </p>
</blockquote>
]]></content>
      <categories>
        <category>EnglishCorner</category>
      </categories>
  </entry>
  <entry>
    <title>程前朋友圈：程序员的一天是怎么样的？</title>
    <url>/2023/07/25/chengqian-programmer-a-day/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>采访了一位哈尔滨工业大学毕业的程序员，在上海工作三年，与两位合伙人一起创业做了一个长达十年的项目，有着十几个人的公司，年收入300~400万，相对来说算成功。</p>
<h1 id="采访"><a href="#采访" class="headerlink" title="采访"></a>采访</h1><h2 id="你觉得你处在这个年龄层的程序员里面算什么水平？"><a href="#你觉得你处在这个年龄层的程序员里面算什么水平？" class="headerlink" title="你觉得你处在这个年龄层的程序员里面算什么水平？"></a>你觉得你处在这个年龄层的程序员里面算什么水平？</h2><p>中等吧，顶多能算中等。</p>
<p>因为在好多大厂的我也挺羡慕，觉得他们可以参与一些改变世界的项目。</p>
<p>一方面是赚钱，另一方面你需要有成就感。</p>
<h2 id="程序员在职业发展过程中会遇到哪些问题？"><a href="#程序员在职业发展过程中会遇到哪些问题？" class="headerlink" title="程序员在职业发展过程中会遇到哪些问题？"></a>程序员在职业发展过程中会遇到哪些问题？</h2><p>两方面，一个是技术瓶颈，就是你到达了一定的年龄，你的学习能力可能就变差了。</p>
<p>如果能在35岁之前做到管理层，就不会被圈子所束缚。（努力学习，争取达到这个成就。）</p>
<h2 id="程序员是不是大多晚婚？"><a href="#程序员是不是大多晚婚？" class="headerlink" title="程序员是不是大多晚婚？"></a>程序员是不是大多晚婚？</h2><p>我觉得大多都是这样的。</p>
<p>他们在年轻的时候，用太多的精力花在事业上，甚至是加班，没日没夜的加班，他根本就没有这种社交圈子。</p>
<h2 id="程序员群体的平均收入，在目前这个时间节点上是不是仍然比其他行业高很多？"><a href="#程序员群体的平均收入，在目前这个时间节点上是不是仍然比其他行业高很多？" class="headerlink" title="程序员群体的平均收入，在目前这个时间节点上是不是仍然比其他行业高很多？"></a>程序员群体的平均收入，在目前这个时间节点上是不是仍然比其他行业高很多？</h2><p>我觉得卷的挺厉害。</p>
<p>达到一定级别可以，普通码农比较困难。</p>
<h2 id="没升到管理层的程序员有什么出路呢？"><a href="#没升到管理层的程序员有什么出路呢？" class="headerlink" title="没升到管理层的程序员有什么出路呢？"></a>没升到管理层的程序员有什么出路呢？</h2><p>跳槽，涨薪资。（理论）</p>
<h2 id="升上去的人和没升上去的人主要差在什么？"><a href="#升上去的人和没升上去的人主要差在什么？" class="headerlink" title="升上去的人和没升上去的人主要差在什么？"></a>升上去的人和没升上去的人主要差在什么？</h2><p>我觉得真正能升上去的人，他在对于人际交往，或者一个整个的统筹的方面是比别人出色的。</p>
<p>程序员比较难处理人际关系，好多程序员是不喜欢社交的，甚至是做完事情马上就回家，什么事情都不想接触。</p>
<h2 id="所以说能升上去，得是一个懂技术又会管人的人？"><a href="#所以说能升上去，得是一个懂技术又会管人的人？" class="headerlink" title="所以说能升上去，得是一个懂技术又会管人的人？"></a>所以说能升上去，得是一个懂技术又会管人的人？</h2><p>而且还得有人格魅力。</p>
<h2 id="从本质上讲，追求技术的精进和追求性格和情商的丰满，这两个是冲突吗？"><a href="#从本质上讲，追求技术的精进和追求性格和情商的丰满，这两个是冲突吗？" class="headerlink" title="从本质上讲，追求技术的精进和追求性格和情商的丰满，这两个是冲突吗？"></a>从本质上讲，追求技术的精进和追求性格和情商的丰满，这两个是冲突吗？</h2><p>有些方面是有冲突的。</p>
<p>在技术方面做的很好的人，他一定是轴。</p>
<p>但太轴的人很难成为主管。</p>
<p>很多人会把追求技术的性格带到他的生活中，那这样他就会变成一个不受欢迎的人。</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>程前朋友圈</tag>
        <tag>采访</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>成都Zadig Meetup</title>
    <url>/2022/08/28/china-chengdu-zadig-meetup/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>2022.8.24（周三）晚上，我参加了<code>Zadig</code>的线下MeetUp。  </p>
<p>而与<code>Zadig</code>结缘是因为关注了一个云原生公众号，他们推送了有关<code>Zadig</code>的消息后，我想，既然在成都，而且是晚上，那就去参加一下呗，见一见各位大佬，结果确实是大佬云集的一次线下聚会。  </p>
<h1 id="缘聚"><a href="#缘聚" class="headerlink" title="缘聚"></a>缘聚</h1><p>周三晚上，我和周如约而至在成都市大跃啤酒。  </p>
<p>首先见到了<code>Min Min</code>，他带领我们到了指定位置，然后是满脸络腮胡的主持人<code>Grant</code>介绍了整体流程，虽然看着40岁的人，但感觉很有干劲，且阳光向上。  </p>
<p>首先是自我介绍环节，有像我们这样95后刚接触<code>CI/CD</code>，想提升效率的；有90后老哥分享在他公司使用<code>Zadig</code>后效率提升翻倍的爽感；有80后大佬分享自己对35岁“被退休”的看法；有开源项目负责人分享自己如何和<code>Zadig</code>结缘。  </p>
<p>然后是对话<code>Min Min</code>环节，这位在国外某计算机名校本科毕业的老哥，可谓是真正的全栈（产品+运营+剪视频+前后端）。  </p>
<p>最后是远程对话<code>Zidig</code>项目创始人<code>Landy</code>环节，一位非常厉害的女程序员，解答了许多困惑。  </p>
<h1 id="MeetUp收获"><a href="#MeetUp收获" class="headerlink" title="MeetUp收获"></a>MeetUp收获</h1><ul>
<li>永远对未来充满希望，充满干劲  </li>
<li>不要对“35岁被退休”产生恐惧和迷茫，只要一步一个脚印，迷茫不攻自破  </li>
<li>选择对一家企业真的很重要  </li>
<li>一定要想清楚自己的商业模式，从客户需求-客户规模-如何盈利-如何拓展，形成闭环  </li>
<li><code>Grant</code>给我说，做开源项目可以前期吃亏一些，比如<code>Zadig</code>开源后，前期是全部免费给企业用，后面因为客户体验超爽，直接找<code>Zadig</code>做企业级服务和产品，我觉得这块和我老爸做生意的想法有着相似之处  </li>
<li>基础要打扎实，这样你面试名企的时候，基础就是你谈薪资的上限  </li>
<li>最后，感谢这次成都<code>Meet up</code>，扫清了未来3-5年存在的困惑，也希望后期可以为<code>Zadig</code>开源贡献自己的一份力量！  </li>
<li>入门陌生的领域，先学会听，然后不懂的再请教，最后再说出自己的想法</li>
</ul>
<p><img src="/2022/08/28/china-chengdu-zadig-meetup/heying.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.koderover.com/">Zadig官网</a><br><a href="https://gitee.com/koderover/zadig">码云-Zadig</a><br><a href="https://github.com/koderover/zadig">Github-Zadig</a></p>
]]></content>
      <categories>
        <category>MeetUp</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>云原生</tag>
        <tag>meetup</tag>
      </tags>
  </entry>
  <entry>
    <title>初三语文上人教版第19课《范进中举》续写</title>
    <url>/2011/01/28/chu-san-yu-wen-lesson-19-fan-jin-zhong-ju-continue-writing/</url>
    <content><![CDATA[<p>范进中举以后，地位、房子、金钱接蹱而来，打得他措手不及。范进其母由于年龄已过古稀，受尽饥寒，后却家庭条件突然变好，一时难以接受，突发心脏病而死。  </p>
<p>再说范进中举之后，攀附来贺者，奉金求赐笔墨者络绎不绝。连其岳丈所经营的肉铺生意，之前被卫生部门查出含有苏丹红；而现在却说所售之肉为上等佳货，味道纯正，口味绝顶，食之定可强筋壮骨、养颜延寿，是居家及餐厅必备的肉为佳品。其岳丈特从范进处讨得一幅字“天下第一屠”，红匾高挂，一时名噪数县。  </p>
<p>再说张乡绅知道范进中举以后，立马备好八抬大轿和一些重礼飞奔过去拉拢自己的业务。只见那张乡绅下了轿进来，他头戴纱帽，身穿葵花色圆领、金带、皂靴，他是举人出身，做过一任教育厅厅长的。他下轿以后，见到范进犹如见到自己的亲爸一样狂奔过去，然后面带微笑着说：“你就是范老爷吧，我对你的敬佩犹如滔滔江水连绵不断。”范进一时语塞，但为了不失面子，说：“晚辈甚有同感。”随后张乡绅送了他100两黄金的支票，附带一栋豪华别墅的房产证和钥匙。范进再三推辞，最后却欣然收下，然后说：”晚辈深感侥幸，实是有愧，希望前辈以后能与我有福同享。”  </p>
<p>在与张乡绅道别以后，岳丈又请范进去醉仙楼喝茅台。对酒痛饮之后才歇。翌日晌午方醒，却觉百骸发痛，浑身乏软，恍惚间见一小鬼推门而入，放下一帖便走，上书：“汝时限将至，子时招汝魂归”。范进一个冷激，大感不安。想到自己这一生受尽饥寒，数次落榜，遭尽白眼，却享了这几星期的荣华富贵，甚是不甘，正想提笔写遗书时，忽然眼前一黑，范进伏案而逝。  </p>
<p>注:本故事纯属虚构，仅供娱乐；<br>如有雷同，纯属巧合  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>娱乐</tag>
        <tag>脑洞</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营_如何系统学习云原生技术</title>
    <url>/2021/11/21/cloud-native-0-introduce/</url>
    <content><![CDATA[<h1 id="什么是云原生"><a href="#什么是云原生" class="headerlink" title="什么是云原生"></a>什么是云原生</h1><ul>
<li>在包括公有云、私有云、混合云等动态环境中构建和运行规模化应用的能力。  </li>
<li>云原生是一种思想，是技术、企业管理方法的集合。</li>
</ul>
<p>技术层面：  </p>
<ul>
<li>应用程序从设计之初就为在云上运行而做好准备。  </li>
<li>云平台基于自动化体系。</li>
</ul>
<p>流程层面：  </p>
<ul>
<li>基于 DevOps, CI&#x2F;CD。</li>
</ul>
<h2 id="基于多种手段"><a href="#基于多种手段" class="headerlink" title="基于多种手段"></a>基于多种手段</h2><ul>
<li>应用容器化封装；  </li>
<li>服务网格；  </li>
<li>不可变基础架构；  </li>
<li>声明式 API。</li>
</ul>
<h2 id="云原生的意义"><a href="#云原生的意义" class="headerlink" title="云原生的意义"></a>云原生的意义</h2><ul>
<li>提升系统的适应性、可管理性、可观察性；  </li>
<li>使工程师能以最小成本进行频繁和可预测的系统变更。  </li>
<li>提升速度和效率，助力业务成长，缩短 I2M（Idea to Market）。</li>
</ul>
<h1 id="云原生核心项目概览"><a href="#云原生核心项目概览" class="headerlink" title="云原生核心项目概览"></a>云原生核心项目概览</h1><p><img src="/2021/11/21/cloud-native-0-introduce/cloud-project.png">  </p>
<h1 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h1><ul>
<li>云原生中基础架构的部分是计算机领域最复杂的领域之一，学习云原生是突破自我的机会！  </li>
<li>云原生涉及到的知识面很广，不懂的概念不用急于求成，反复训练可强化理解。  </li>
<li>实践出真知，多听，多学，多练。</li>
</ul>
<h2 id="持续学习是一个不同重复的-Loop"><a href="#持续学习是一个不同重复的-Loop" class="headerlink" title="持续学习是一个不同重复的 Loop"></a>持续学习是一个不同重复的 Loop</h2><p><img src="/2021/11/21/cloud-native-0-introduce/wwh.png">  </p>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul>
<li>多动手：试试看，怎么用。  </li>
<li>看理论：读博客，理解背后的技术总结。看代码，理解真实实现，总结出自己的理解。  </li>
<li>理思路：不断的总结，把别人的东西变成自己的东西。分享是让你快速提升的手段。  </li>
<li>有取舍  </li>
<li>自我驱动：兴趣很重要。使命感。</li>
</ul>
<p><img src="/2021/11/21/cloud-native-0-introduce/%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF%E5%9B%BE.png">  </p>
<h1 id="举例：kube-proxy-是干啥用的？"><a href="#举例：kube-proxy-是干啥用的？" class="headerlink" title="举例：kube-proxy 是干啥用的？"></a>举例：kube-proxy 是干啥用的？</h1><h2 id="第一步：官方文档"><a href="#第一步：官方文档" class="headerlink" title="第一步：官方文档"></a>第一步：官方文档</h2><p>看官方文档，没有太多收获：  </p>
<p><a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a>  </p>
<blockquote>
<p>kube-proxy uses the operating system packet filtering layer if there is one and it’s available. Otherwise, kube-proxy forwards the traffic itself.  </p>
</blockquote>
<h2 id="第二步：看看前人是怎么解读的？"><a href="#第二步：看看前人是怎么解读的？" class="headerlink" title="第二步：看看前人是怎么解读的？"></a>第二步：看看前人是怎么解读的？</h2><ul>
<li>搜中文文档，知乎，CSDN，简书都有比较高质量的文章，可以多看一些文档，并理解不同人的理解差异。  </li>
<li>随便找了一篇zhihu专栏。<br><a href="https://zhuanlan.zhihu.com/p/337806843">https://zhuanlan.zhihu.com/p/337806843</a></li>
</ul>
<h2 id="第三步：找关键知识点"><a href="#第三步：找关键知识点" class="headerlink" title="第三步：找关键知识点"></a>第三步：找关键知识点</h2><ul>
<li><p>先对大概的框架有认识  </p>
</li>
<li><p>负载均衡  </p>
</li>
<li><p>kube-proxy 监听 API server 中 资源对象的变化情况，包括以下三种：<br>service<br>endpoint&#x2F;endpointslices<br>node  </p>
</li>
<li><p>目前 Kube-proxy 支持4中代理模式：<br>userspace<br>iptables<br>ipvs<br>kernelspace（windows）</p>
</li>
</ul>
<h2 id="第四步：由点到面稍稍展开一下"><a href="#第四步：由点到面稍稍展开一下" class="headerlink" title="第四步：由点到面稍稍展开一下"></a>第四步：由点到面稍稍展开一下</h2><ul>
<li>入门：可以使用，知道怎么用，大概做了什么。  </li>
<li>初级：粗略理解配置方法。  </li>
<li>高级：理解不同模式的差异，理解为什么要有多种模式，理解配置细节。  </li>
<li>专家级：理解完整的内核协议栈处理数据包的流程，能够举一反三。</li>
</ul>
<p><img src="/2021/11/21/cloud-native-0-introduce/kube-proxy.png">  </p>
<h1 id="如何学习云原生技术"><a href="#如何学习云原生技术" class="headerlink" title="如何学习云原生技术"></a>如何学习云原生技术</h1><h2 id="代码驱动"><a href="#代码驱动" class="headerlink" title="代码驱动"></a>代码驱动</h2><ul>
<li>掌握 Go 语言编程能力</li>
</ul>
<h2 id="从点到面"><a href="#从点到面" class="headerlink" title="从点到面"></a>从点到面</h2><p>学习容器技术  </p>
<ul>
<li>cgroup、namespace  </li>
<li>网络协议栈  </li>
<li>文件系统</li>
</ul>
<h2 id="抓住核心掌控全局"><a href="#抓住核心掌控全局" class="headerlink" title="抓住核心掌控全局"></a>抓住核心掌控全局</h2><p>深入理解 Kubernetes  </p>
<ul>
<li>API 定义  </li>
<li>控制器模式  </li>
<li>核心组件</li>
</ul>
<h2 id="大规模生产化"><a href="#大规模生产化" class="headerlink" title="大规模生产化"></a>大规模生产化</h2><ul>
<li>多集群  </li>
<li>服务网格和多网格</li>
</ul>
<h2 id="多重视角"><a href="#多重视角" class="headerlink" title="多重视角"></a>多重视角</h2><p>管理员角度：  </p>
<ul>
<li>如何构建和运维支持生产化作业的多租户集群。  </li>
<li>如何应对规模化所带来的挑战。</li>
</ul>
<p>研发人员角度：  </p>
<ul>
<li>如何将不同类型应用的接入到容器化平台。  </li>
<li>理解如何保证应用的服务可用性。</li>
</ul>
<p>不同角色如何做好协同，避免出现生产故障。  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营_第1课_Go语言特性</title>
    <url>/2021/11/21/cloud-native-1-go-features/</url>
    <content><![CDATA[<h1 id="为什么需要-Go-语言"><a href="#为什么需要-Go-语言" class="headerlink" title="为什么需要 Go 语言"></a>为什么需要 Go 语言</h1><h2 id="Go-语言的原则"><a href="#Go-语言的原则" class="headerlink" title="Go 语言的原则"></a>Go 语言的原则</h2><p>Less is exponentially more<br>– Rob Pike, Go Designer  </p>
<p>Do Less, Enable More<br>– Russ Cox, Go Tech Lead  </p>
<h2 id="为什么需要-Go-语言-1"><a href="#为什么需要-Go-语言-1" class="headerlink" title="为什么需要 Go 语言"></a>为什么需要 Go 语言</h2><p>其他编程语言的弊端：  </p>
<ul>
<li>硬件发展速度远远超过软件。  </li>
<li>C 语言等原生语言缺乏好的依赖管理 (依赖头文件）。  </li>
<li>Java 和 C++ 等语言过于笨重。  </li>
<li>系统语言对垃圾回收和并行计算等基础功能缺乏支持。  </li>
<li>对多核计算机缺乏支持。</li>
</ul>
<p>Go 语言是一个<strong>可以编译高效，支持高并发的，面向垃圾回收</strong>的全新语言：  </p>
<ul>
<li>秒级完成大型程序的单节点编译。  </li>
<li>依赖管理清晰。  </li>
<li>不支持继承，程序员无需花费精力定义不同类型之间的关系。  </li>
<li>支持垃圾回收，支持并发执行，支持多线程通讯。  </li>
<li>对多核计算机支持友好。</li>
</ul>
<h2 id="Go-语言不支持的特性"><a href="#Go-语言不支持的特性" class="headerlink" title="Go 语言不支持的特性"></a>Go 语言不支持的特性</h2><ul>
<li>不支持函数重载和操作符重载</li>
<li>为了避免在 C&#x2F;C++ 开发中的一些 Bug 和混乱，不支持隐式转换  </li>
<li>支持接口抽象，不支持继承  </li>
<li>不支持动态加载代码  </li>
<li>不支持动态链接库  </li>
<li>通过 recover 和 panic 来替代异常机制  </li>
<li>不支持断言  </li>
<li>不支持静态变量</li>
</ul>
<h2 id="Go-语言特性衍生来源"><a href="#Go-语言特性衍生来源" class="headerlink" title="Go 语言特性衍生来源"></a>Go 语言特性衍生来源</h2><p><img src="/2021/11/21/cloud-native-1-go-features/Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E8%A1%8D%E7%94%9F%E6%9D%A5%E6%BA%90.png">  </p>
<h1 id="Go-语言编译环境设置"><a href="#Go-语言编译环境设置" class="headerlink" title="Go 语言编译环境设置"></a>Go 语言编译环境设置</h1><p>下载编译运行可以参考这篇文章<a href="https://octopuslian.github.io/2021/07/16/golang-vscode-setting-and-git-feature/">VSCode下Golang的配置以及Git分支合并注意事项</a>  </p>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>基本形式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line"><span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if 的简短语句：<br>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v := x - <span class="number">100</span>; v &lt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1: <span class="comment">//空分支</span></span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line"><span class="keyword">fallthrough</span> <span class="comment">//执行case3中的f()</span></span><br><span class="line"><span class="keyword">case</span> val3:</span><br><span class="line">f()</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//默认分支</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For"><a href="#For" class="headerlink" title="For"></a>For</h2><p>Go 只有一种循环结构：for 循环。  </p>
<h3 id="计入计时器的循环"><a href="#计入计时器的循环" class="headerlink" title="计入计时器的循环"></a>计入计时器的循环</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化语句和后置语句是可选的，此场景与-while-等价（Go-语言不支持-while）"><a href="#初始化语句和后置语句是可选的，此场景与-while-等价（Go-语言不支持-while）" class="headerlink" title="初始化语句和后置语句是可选的，此场景与 while 等价（Go 语言不支持 while）"></a>初始化语句和后置语句是可选的，此场景与 while 等价（Go 语言不支持 while）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h2><p>遍历数组，切片，字符串，Map 等  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, char := <span class="keyword">range</span> myString &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> MyMap &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> MyArray &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意：如果 for range 遍历指针数组，则 value 取出的指针地址为原指针地址的拷贝。  </p>
<h1 id="Go-语言常用数据结构"><a href="#Go-语言常用数据结构" class="headerlink" title="Go 语言常用数据结构"></a>Go 语言常用数据结构</h1><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>常量：<code>const identifier type</code>  </p>
<p>变量：<code>var identifier type</code>  </p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</li>
<li>var c, python, java bool</li>
</ul>
<h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><ul>
<li>变量声明可以包含初始值，每个变量对应一个。  </li>
<li>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。  </li>
<li>var i, j int &#x3D; 1, 2</li>
</ul>
<h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><ul>
<li>在函数中，简洁赋值语句 :&#x3D; 可在类型明确的地方代替 var 声明。  </li>
<li>函数外的每个语句都必须以关键字开始（var, func 等等），因此 :&#x3D; 结构不能在函数外使用。  </li>
<li>c, python, java :&#x3D; true, false, “no!”</li>
</ul>
<h2 id="类型转换与推导"><a href="#类型转换与推导" class="headerlink" title="类型转换与推导"></a>类型转换与推导</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 T(v) 将值 v 转换为类型 T。  </p>
<p>一些关于数值的转换：  </p>
<ul>
<li>var i int &#x3D; 42  </li>
<li>var f float64 &#x3D; float64(i)  </li>
<li>var u uint &#x3D; uint(f)</li>
</ul>
<p>或者，更加简单的形式：  </p>
<ul>
<li>i :&#x3D; 42  </li>
<li>f :&#x3D; float64(i)  </li>
<li>u :&#x3D; uint(f)</li>
</ul>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在声明一个变量而不指定其类型时（即使用不带类型的 :&#x3D; 语法或 var &#x3D; 表达式语法），变量的类型由右值推导得出。  </p>
<ul>
<li>var i int  </li>
<li>j :&#x3D; i &#x2F;&#x2F; j 也是一个 int</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>相同类型且长度固定连续内存片段  </li>
<li>以编号访问每个元素  </li>
<li>定义方法：<code>var identifier [len]type</code>  </li>
<li>示例<br>myArray :&#x3D; [3]int{1,2,3}</li>
</ul>
<h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片(slice)"></a>切片(slice)</h2><ul>
<li><p>切片是对数组一个连续片段的引用  </p>
</li>
<li><p>数组定义中不指定长度即为切片<br>var identifier []type  </p>
</li>
<li><p>切片在未初始化之前默认为nil， 长度为0  </p>
</li>
<li><p>常用方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myArray := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    mySlice := myArray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line">    fullSlice := myArray[:]</span><br><span class="line">    remove3rdItem := deleteItem(fullSlice, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;remove3rdItem %+v\n&quot;</span>,</span><br><span class="line">    remove3rdItem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteItem</span><span class="params">(slice []<span class="type">int</span>, index <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(slice[:index], slice[index+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Make-和-New"><a href="#Make-和-New" class="headerlink" title="Make 和 New"></a>Make 和 New</h2><ul>
<li>New 返回指针地址  </li>
<li>Make 返回第一个元素，可预设内存空间，避免未来的内存拷贝  </li>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mySlice1 := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">mySlice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">mySlice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">mySlice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/21/cloud-native-1-go-features/mySlice.png">  </p>
<h2 id="关于切片的常见问题"><a href="#关于切片的常见问题" class="headerlink" title="关于切片的常见问题"></a>关于切片的常见问题</h2><ul>
<li>切片是连续内存并且可以动态扩展，由此引发的问题？</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">int</span></span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">c := a</span><br><span class="line">a = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改切片的值？</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">    value *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">    mySlice[index] *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>声明方法：<code>var map1 map[keytype]valuetype</code>  </li>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">myFuncMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;funcA&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(myFuncMap)</span><br><span class="line">f := myFuncMap[<span class="string">&quot;funcA&quot;</span>]</span><br><span class="line">fmt.Println(f())</span><br></pre></td></tr></table></figure>

<h2 id="访问-Map-元素"><a href="#访问-Map-元素" class="headerlink" title="访问 Map 元素"></a>访问 Map 元素</h2><p>按 Key 取值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, exists := myMap[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">    <span class="built_in">println</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历 Map：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    <span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h2><ul>
<li>通过 type … struct 关键字自定义结构体  </li>
<li>Go 语言支持指针，但不支持指针运算：指针变量的值为内存地址；未赋值的指针为 nil。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyType</span><span class="params">(t *MyType)</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(t.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">    printMyType(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h2><ul>
<li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）  </li>
<li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag<br>NodeName string <code>json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mt := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">    myType := reflect.TypeOf(mt)</span><br><span class="line">    name := myType.Field(<span class="number">0</span>)</span><br><span class="line">    tag := name.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service Type string describes ingress methods for a service</span></span><br><span class="line"><span class="keyword">type</span> ServiceType <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span></span><br><span class="line">    <span class="comment">// cluster, via the ClusterIP.</span></span><br><span class="line">    ServiceTypeClusterIP ServiceType = <span class="string">&quot;ClusterIP&quot;</span></span><br><span class="line">    <span class="comment">// ServiceTypeNodePort means a service will be exposed on one port of</span></span><br><span class="line">    <span class="comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span></span><br><span class="line">    ServiceTypeNodePort ServiceType = <span class="string">&quot;NodePort&quot;</span></span><br><span class="line">    <span class="comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span></span><br><span class="line">    <span class="comment">// external load balancer (if the cloud provider supports it), in addition</span></span><br><span class="line">    <span class="comment">// to &#x27;NodePort&#x27; type.</span></span><br><span class="line">    ServiceTypeLoadBalancer ServiceType = <span class="string">&quot;LoadBalancer&quot;</span></span><br><span class="line">    <span class="comment">// ServiceTypeExternalName means a service consists of only a reference to</span></span><br><span class="line">    <span class="comment">// an external name that kubedns or equivalent will return as a CNAME</span></span><br><span class="line">    <span class="comment">// record, with no exposing or proxying of any pods involved.</span></span><br><span class="line">    ServiceTypeExternalName ServiceType = <span class="string">&quot;ExternalName&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="课后练习1-1"><a href="#课后练习1-1" class="headerlink" title="课后练习1.1"></a>课后练习1.1</h2><p>编写一个小程序，给定一个字符串数组<code>[&quot;I&quot;,&quot;am&quot;,&quot;stupid&quot;,&quot;and&quot;,&quot;weak&quot;]</code>，用 for 循环遍历该数组并修改为<code>[&quot;I&quot;,&quot;am&quot;,&quot;smart&quot;,&quot;and&quot;,&quot;strong&quot;]</code>。  </p>
<h1 id="Go-语言函数调用"><a href="#Go-语言函数调用" class="headerlink" title="Go 语言函数调用"></a>Go 语言函数调用</h1><h2 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h2><ul>
<li>每个 Go 语言程序都应该有个 main package  </li>
<li>Main package 里的 main 函数是 Go 语言程序入口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">args := os.Args</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;Do not accept any argument&quot;</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><ul>
<li>请注意 main 函数与其他语言不同，没有类似 java 的 []string args 参数  </li>
<li>Go 语言如何传入参数呢？</li>
</ul>
<p>方法1：<code>fmt.Println(&quot;os args is:&quot;, os.Args)</code><br>方法2：<code>name := flag.String(&quot;name&quot;, &quot;world&quot;, &quot;specify the name you want to say hi&quot;)</code>；<code>flag.Parse()</code>  </p>
<h2 id="Init-函数"><a href="#Init-函数" class="headerlink" title="Init 函数"></a>Init 函数</h2><ul>
<li>Init 函数：会在包初始化时运行  </li>
<li>谨慎使用 init 函数<br>当多个依赖项目引用统一项目，且被引用项目的初始化在 init 中完成，并且不可重复运行时，会导致启动错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">var</span> myVariable = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myVariable = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li><p>多值返回：函数可以返回任意数量的返回值  </p>
</li>
<li><p>命名返回值：<br>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。<br>返回值的名称应当具有一定的意义，它可以作为文档使用。<br>没有参数的 return 语句返回已命名的返回值。也就是直接返回。  </p>
</li>
<li><p>调用者忽略部分返回值：<code>result, _ = strconv.Atoi(origStr)</code></p>
</li>
</ul>
<h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><p>Go 语言中的可变长参数允许调用方传递任意多个相同类型的参数  </p>
<ul>
<li>函数定义：func append(slice []Type, elems …Type) []Type  </li>
<li>调用方法：<code>myArray := []string&#123;&#125;</code>；<code>myArray = append(myArray, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;)</code></li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p><img src="/2021/11/21/cloud-native-1-go-features/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.png">  </p>
<h2 id="回调函数-Callback"><a href="#回调函数-Callback" class="headerlink" title="回调函数(Callback)"></a>回调函数(Callback)</h2><ul>
<li>函数作为参数传入其它函数，并在其他函数内部调用执行<br><code>strings.IndexFunc(line, unicode.IsSpace)</code><br><code>Kubernetes controller的leaderelection</code></li>
</ul>
<p>示例：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DoOperation(<span class="number">1</span>, increase)</span><br><span class="line">    DoOperation(<span class="number">1</span>, decrease)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(“increase result is:”, a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoOperation</span><span class="params">(y <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">    (y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;decrease result is:&quot;</span>, a-b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li>不能独立存在  </li>
<li>可以赋值给其他变量：<code>x:= func()&#123;&#125;</code>  </li>
<li>可以直接调用：<code>func(x,y int)&#123;println(x+y)&#125;(1,2)</code>  </li>
<li>可作为函数返回值<code>func Add() (func(b int) int)</code>  </li>
<li>使用场景</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(“recovered in FuncX”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法：作用在接收者上的函数<code>func (recv receiver_type) methodName(parameter_list) (return_value_list)</code>  </li>
<li>使用场景<br>很多场景下，函数需要的上下文可以保存在receiver属性中，通过定义 receiver 的方法，该方法可以直接访问 receiver 属性，减少参数传递需求</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StartTLS starts TLS on a server from NewUnstartedServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> StartTLS() &#123;</span><br><span class="line">    <span class="keyword">if</span> s.URL != “” &#123;</span><br><span class="line">        <span class="built_in">panic</span>(“Server already started”)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.client == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.client = &amp;http.Client&#123;Transport: &amp;http.Transport&#123;&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值还是传指针"><a href="#传值还是传指针" class="headerlink" title="传值还是传指针"></a>传值还是传指针</h2><ul>
<li>Go 语言只有一种规则-传值  </li>
<li>函数内修改参数的值不会影响函数外原始变量的值  </li>
<li>可以传递指针参数将变量地址传递给调用函数，Go 语言会复制该指针作为函数内的地址，但指向同一地址  </li>
<li>思考：当我们写代码的时候，函数的参数传递应该用struct还是pointer？</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>接口定义一组方法集合  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>适用场景：Kubernetes 中有大量的接口抽象和多种实现  </p>
</li>
<li><p>Struct 无需显示声明实现 interface，只需直接实现方法  </p>
</li>
<li><p>Struct 除实现 interface 定义的接口外，还可以有额外的方法  </p>
</li>
<li><p>一个类型可实现多个接口（Go 语言的多重继承）  </p>
</li>
<li><p>Go 语言中接口不接受属性定义  </p>
</li>
<li><p>接口可以嵌套其他接口</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName, lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.firstName + <span class="string">&quot;,&quot;</span> + h.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory, model <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.factory + <span class="string">&quot;-&quot;</span> + c.model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	interfaces := []IF&#123;&#125;</span><br><span class="line">	h := <span class="built_in">new</span>(Human)</span><br><span class="line">	h.firstName = <span class="string">&quot;first&quot;</span></span><br><span class="line"></span><br><span class="line">	h.lastName = <span class="string">&quot;last&quot;</span></span><br><span class="line"></span><br><span class="line">	interfaces = <span class="built_in">append</span>(interfaces, h)</span><br><span class="line">	c := <span class="built_in">new</span>(Car)</span><br><span class="line"></span><br><span class="line">	c.factory = <span class="string">&quot;benz&quot;</span></span><br><span class="line">	c.model = <span class="string">&quot;s&quot;</span></span><br><span class="line">	interfaces = <span class="built_in">append</span>(interfaces, c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> interfaces &#123;</span><br><span class="line">		fmt.Println(f.getName())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>Interface 是可能为 nil 的，所以针对 interface 的使用一定要预先判空，否则会引起程序 crash(nil panic)  </li>
<li>Struct 初始化意味着空间分配，对 struct 的引用不会出现空指针</li>
</ul>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ul>
<li>reflect.TypeOf ()返回被检查对象的类型  </li>
<li>reflect.ValueOf()返回被检查对象的值  </li>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">t := reflect.TypeOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, t)</span><br><span class="line">v := reflect.ValueOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br></pre></td></tr></table></figure>

<h2 id="基于-struct-的反射"><a href="#基于-struct-的反射" class="headerlink" title="基于 struct 的反射"></a>基于 struct 的反射</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct</span></span><br><span class="line">myStruct := T&#123;A: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">v1 := reflect.ValueOf(myStruct)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumField(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumMethod(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要注意 receive 是 struct 还是指针</span></span><br><span class="line">result := v1.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br></pre></td></tr></table></figure>

<h2 id="Go-语言中的面向对象编程"><a href="#Go-语言中的面向对象编程" class="headerlink" title="Go 语言中的面向对象编程"></a>Go 语言中的面向对象编程</h2><ul>
<li><p>可见性控制<br>public - 常量、变量、类型、接口、结构、函数等的名称大写<br>private - 非大写就只能在包内使用  </p>
</li>
<li><p>继承<br>通过组合实现，内嵌一个或多个 struct  </p>
</li>
<li><p>多态<br>通过接口实现，通过接口定义方法集，编写多套实现</p>
</li>
</ul>
<h2 id="Json-编解码"><a href="#Json-编解码" class="headerlink" title="Json 编解码"></a>Json 编解码</h2><ul>
<li>Unmarshal: 从 string 转换至 struct</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshal2Struct</span><span class="params">(humanStr <span class="type">string</span>)</span></span>Human &#123;</span><br><span class="line">    h := Human&#123;&#125;</span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;h)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Marshal: 从 struct 转换至 string</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal2JsonString</span><span class="params">(h Human)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    h.Age = <span class="number">30</span></span><br><span class="line">    updatedBytes, err := json.Marshal(&amp;h)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(updatedBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>json 包使用 map[string]interface{} 和 []interface{} 类型保存任意对象  </li>
<li>可通过如下逻辑解析任意 json</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;obj)</span><br><span class="line">objMap, ok := obj.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> objMap &#123;</span><br><span class="line">    <span class="keyword">switch</span> value := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li>Go 语言无内置 exceptio 机制，只提供 error 接口供定义错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可通过 errors.New 或 fmt.Errorf 创建新的 error：<code>var errNotFound error = errors.New(&quot;NotFound&quot;)</code>  </li>
<li>通常应用程序对 error 的处理大部分是判断 error 是否为 nil</li>
</ul>
<p>如需将 error 归类，通常交给应用程序自定义，比如 kubernetes 自定义了与 apiserver 交互的不同类型错误  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StatusError <span class="keyword">struct</span> &#123;</span><br><span class="line">    ErrStatus metav1.Status</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ <span class="type">error</span> = &amp;StatusError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error implements the Error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *StatusError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.ErrStatus.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ul>
<li>函数返回之前执行某个语句或函数：<code>等同于 Java 和 C# 的 finally</code>  </li>
<li>常见的 defer 使用场景：<strong>记得关闭你打开的资源</strong><br>defer file.Close()<br>defer mu.Unlock()<br>defer println(“”)</li>
</ul>
<h2 id="Panic-和-Recover"><a href="#Panic-和-Recover" class="headerlink" title="Panic 和 Recover"></a>Panic 和 Recover</h2><ul>
<li>panic: 可在系统出现不可恢复错误时主动调用 panic, panic 会使当前线程直接 crash  </li>
<li>defer: 保证执行并把控制权交还给接收到 panic 的函数调用者  </li>
<li>recover: 函数从 panic 或 错误场景中恢复</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;defer func is called&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;a panic is triggered&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><img src="/2021/11/21/cloud-native-1-go-features/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.png">  </p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>分配系统资源（CPU 时间、内存等）基本单位  </li>
<li>有独立的内存空间，切换开销大</li>
</ul>
<h3 id="线程：进程的一个执行流，是-CPU-调度并能独立运行的的基本单位"><a href="#线程：进程的一个执行流，是-CPU-调度并能独立运行的的基本单位" class="headerlink" title="线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位"></a>线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位</h3><ul>
<li>同一进程中的多线程共享内存空间，线程切换代价小  </li>
<li>多线程通信方便  </li>
<li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数</li>
</ul>
<h3 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h3><ul>
<li>Go 语言中的轻量级线程实现  </li>
<li>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程</li>
</ul>
<h2 id="Communicating-Sequential-Process"><a href="#Communicating-Sequential-Process" class="headerlink" title="Communicating Sequential Process"></a>Communicating Sequential Process</h2><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>描述两个独立的并发实体通过共享的通讯 channel 进行通信的并发模型。  </p>
<h3 id="Go-协程-goroutine"><a href="#Go-协程-goroutine" class="headerlink" title="Go 协程 goroutine"></a>Go 协程 goroutine</h3><ul>
<li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。  </li>
<li>是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程。</li>
</ul>
<h3 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道 channel"></a>通道 channel</h3><ul>
<li>类似 Unix 的 Pipe，用于协程之间通讯和同步。  </li>
<li>协程之间虽然解耦，但是它们和 Channel 有着耦合。</li>
</ul>
<h2 id="线程和协程的差异"><a href="#线程和协程的差异" class="headerlink" title="线程和协程的差异"></a>线程和协程的差异</h2><p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。  </p>
<ul>
<li>goroutine：2KB  </li>
<li>线程：8MB</li>
</ul>
<p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小  </p>
<ul>
<li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新  </li>
<li>goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</li>
</ul>
<p>GOMAXPROCS：控制并行线程数量  </p>
<h2 id="协程示例"><a href="#协程示例" class="headerlink" title="协程示例"></a>协程示例</h2><p>启动新协程：go functionName()  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure>

<h2 id="channel-多线程通信"><a href="#channel-多线程通信" class="headerlink" title="channel - 多线程通信"></a>channel - 多线程通信</h2><h3 id="Channel-是多个协程之间通讯的管道"><a href="#Channel-是多个协程之间通讯的管道" class="headerlink" title="Channel 是多个协程之间通讯的管道"></a>Channel 是多个协程之间通讯的管道</h3><ul>
<li>一端发送数据，一端接收数据  </li>
<li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争  </li>
<li>协调协程的执行顺序</li>
</ul>
<h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><ul>
<li>var identifier chan datatype  </li>
<li>操作符&lt;-</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello from goroutine&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="number">0</span> <span class="comment">//数据写入Channel</span></span><br><span class="line">&#125;()</span><br><span class="line">i := &lt;-ch<span class="comment">//从Channel中取数据并赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h2><ul>
<li>基于 Channel 的通信是同步的  </li>
<li>当缓冲区满时，数据的发送是阻塞的  </li>
<li>通过 make 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0  </li>
<li>下面两个定义的区别？  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="遍历通道缓冲区"><a href="#遍历通道缓冲区" class="headerlink" title="遍历通道缓冲区"></a>遍历通道缓冲区</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		rand.Seed(time.Now().UnixNano())</span><br><span class="line">		n := rand.Intn(<span class="number">10</span>) <span class="comment">// n will be between 0 and 10</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;putting: &quot;</span>, n)</span><br><span class="line">		ch &lt;- n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;hello from main&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;receiving: &quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h2><p>只发送通道：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sendOnly <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>只接收通道：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>Istio webhook controller：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WebhookCertPatcher)</span></span> runWebhookController(stopChan &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如何用: 双向通道转换：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> prod(c)</span><br><span class="line"><span class="keyword">go</span> consume(c)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prod</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><ul>
<li>通道无需每次关闭  </li>
<li>关闭的作用是告诉接收者该通道再无新数据发送  </li>
<li>只有发送方需要关闭通道</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>当多个协程同时运行时，可通过 select 轮询多个通道  </p>
<ul>
<li>如果所有通道都阻塞则等待，如定义了 default 则执行 default  </li>
<li>如多个通道就绪则随机选择</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v:= &lt;- ch1:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h2><ul>
<li>time.Ticker 以指定的时间间隔重复的向通道 C 发送时间值  </li>
<li>使用场景：为协程设定超时时间</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// check normal channel</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;received from ch&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout waiting from channel ch&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文 Context"></a>上下文 Context</h2><ul>
<li><p>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作  </p>
</li>
<li><p>Context 是设置截止日期、同步信号，传递请求相关值的结构体  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用法  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">context.Background</span><br><span class="line">context.TODO</span><br><span class="line">context.WithDeadline</span><br><span class="line">context.WithValue</span><br><span class="line">context.WithCancel</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何停止一个子协程"><a href="#如何停止一个子协程" class="headerlink" title="如何停止一个子协程"></a>如何停止一个子协程</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:</span><br><span class="line">			fmt.Println(<span class="string">&quot;done channel is triggerred, exit child go routine&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(done)</span><br></pre></td></tr></table></figure>

<h2 id="基于-Context-停止子协程"><a href="#基于-Context-停止子协程" class="headerlink" title="基于 Context 停止子协程"></a>基于 Context 停止子协程</h2><p>Context 是 Go 语言对 go routine 和 timer 的封装  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> process(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;main:&quot;</span>, ctx.Err())</span><br></pre></td></tr></table></figure>

<h2 id="课后练习1-2"><a href="#课后练习1-2" class="headerlink" title="课后练习1.2"></a>课后练习1.2</h2><ul>
<li>基于 Channel 编写一个简单的单线程生产者消费者模型  </li>
<li>队列：<br>队列长度10，队列元素类型为 int  </li>
<li>生产者：<br>每1秒往队列中放入一个类型为 int 的元素，队列满时生产者可以阻塞  </li>
<li>消费者：<br>每一秒从队列中获取一个元素并打印，队列为空时消费者阻塞</li>
</ul>
<p><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson1/range">作业1.1</a><br><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson1/single-producer-customer">作业1.2</a>  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>特性</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营_第2课_Go进阶</title>
    <url>/2021/11/22/cloud-native-2-go-advanced/</url>
    <content><![CDATA[<h1 id="线程加锁"><a href="#线程加锁" class="headerlink" title="线程加锁"></a>线程加锁</h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问  </p>
</li>
<li><p>Sync 包提供了锁的基本原语  </p>
</li>
<li><p>sync.Mutex 互斥锁<br>Lock()加锁，Unlock 解锁  </p>
</li>
<li><p>sync.RWMutex 读写分离锁<br>不限制并发读，只限制并发写和并发读写  </p>
</li>
<li><p>sync.WaitGroup<br>等待一组 goroutine 返回  </p>
</li>
<li><p>sync.Once<br>保证某段代码只执行一次  </p>
</li>
<li><p>sync.Cond<br>让一组 goroutine 在满足特定条件时被唤醒</p>
</li>
</ul>
<h2 id="Mutex-示例"><a href="#Mutex-示例" class="headerlink" title="Mutex 示例"></a>Mutex 示例</h2><p>Kubernetes 中的 informer factory  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup-示例"><a href="#WaitGroup-示例" class="headerlink" title="WaitGroup 示例"></a>WaitGroup 示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateBatch create a batch of pods. All pods are created before waiting.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;</span><br><span class="line">    ps := <span class="built_in">make</span>([]*v1.Pod, <span class="built_in">len</span>(pods))</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, pod *v1.Pod)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">defer</span> GinkgoRecover()</span><br><span class="line">            ps[i] = c.CreateSync(pod)</span><br><span class="line">        &#125;(i, pod)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> ps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cond-示例"><a href="#Cond-示例" class="headerlink" title="Cond 示例"></a>Cond 示例</h2><p>Kubernetes 中的队列，标准的生产者消费者模式<br>cond: sync.NewCond(&amp;sync.Mutex{}),  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add marks item as needing processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	<span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q.metrics.add(item)</span><br><span class="line">	q.dirty.insert(item)</span><br><span class="line">	<span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">	q.cond.Signal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get blocks until it can return an item to be processed. If shutdown = true,</span></span><br><span class="line"><span class="comment">// the caller should end their goroutine. You must call Done with item when you</span></span><br><span class="line"><span class="comment">// have finished processing it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">		q.cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// We must be shutting down.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">	q.metrics.get(item)</span><br><span class="line">	q.processing.insert(item)</span><br><span class="line">	q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line">	<span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="深入理解-Go-语言线程调度"><a href="#深入理解-Go-语言线程调度" class="headerlink" title="深入理解 Go 语言线程调度"></a>深入理解 Go 语言线程调度</h2><ul>
<li>进程：资源分配的基本单位  </li>
<li>线程：调度的基本单位  </li>
<li>无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别  </li>
<li>Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持</li>
</ul>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B.png">  </p>
<h2 id="Linux-进程的内存使用"><a href="#Linux-进程的内存使用" class="headerlink" title="Linux 进程的内存使用"></a>Linux 进程的内存使用</h2><p><img src="/2021/11/22/cloud-native-2-go-advanced/linux%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%AF%95%E7%94%A8.png">  </p>
<h2 id="CPU-对内存的访问"><a href="#CPU-对内存的访问" class="headerlink" title="CPU 对内存的访问"></a>CPU 对内存的访问</h2><ul>
<li>CPU 上有个 Memory Management Unit（MMU） 单元  </li>
<li>CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址  </li>
<li>CPU 维护一份缓存 Translation Lookaside Buffer（TLB），缓存虚拟地址和物理地址的映射关系</li>
</ul>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/cpu%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE.png">  </p>
<h2 id="进程切换开销"><a href="#进程切换开销" class="headerlink" title="进程切换开销"></a>进程切换开销</h2><h3 id="直接开销"><a href="#直接开销" class="headerlink" title="直接开销"></a>直接开销</h3><ul>
<li>切换页表全局目录（PGD）  </li>
<li>切换内核态堆栈  </li>
<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）  </li>
<li>刷新 TLB  </li>
<li>系统调度器的代码执行</li>
</ul>
<h3 id="间接开销"><a href="#间接开销" class="headerlink" title="间接开销"></a>间接开销</h3><ul>
<li>CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多</li>
</ul>
<h2 id="线程切换开销"><a href="#线程切换开销" class="headerlink" title="线程切换开销"></a>线程切换开销</h2><ul>
<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换  </li>
<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，<strong>主要节省了虚拟地址空间的切换</strong></li>
</ul>
<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成。  </p>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.png">  </p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Go 语言基于 GMP 模型实现用户态线程  </p>
<ul>
<li>G：表示 goroutine，每个 goroutine 都有自己的栈空间，定时器，初始化的栈空间在 2k 左右，空间会随着需求增长。  </li>
<li>M：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。  </li>
<li>P：代表调度器，负责调度 goroutine，维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理。</li>
</ul>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/GMP.png">  </p>
<h2 id="GMP-模型细节"><a href="#GMP-模型细节" class="headerlink" title="GMP 模型细节"></a>GMP 模型细节</h2><p><img src="/2021/11/22/cloud-native-2-go-advanced/GMP%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82.png">  </p>
<h2 id="G-所处的位置"><a href="#G-所处的位置" class="headerlink" title="G 所处的位置"></a>G 所处的位置</h2><ul>
<li>进程都有一个全局的 G 队列  </li>
<li>每个 P 拥有自己的本地执行队列  </li>
<li>有不在运行队列中的 G<br>处于 channel 阻塞态的 G 被放在 sudog<br>脱离 P 绑定在 M 上的 G，如系统调用<br>为了复用，执行结束进入 P 的 gFree 列表中的 G</li>
</ul>
<h2 id="Goroutine-创建过程"><a href="#Goroutine-创建过程" class="headerlink" title="Goroutine 创建过程"></a>Goroutine 创建过程</h2><ul>
<li><p>获取或者创建新的 Goroutine 结构体<br>从处理器的 gFree 列表中查找空闲的 Goroutine<br>如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体  </p>
</li>
<li><p>将函数传入的参数移到 Goroutine 的栈上  </p>
</li>
<li><p>更新 Goroutine 调度相关的属性，更新状态为_Grunnable  </p>
</li>
<li><p>返回的 Goroutine 会存储到全局变量 allgs 中</p>
</li>
</ul>
<h2 id="将-Goroutine-放到运行队列上"><a href="#将-Goroutine-放到运行队列上" class="headerlink" title="将 Goroutine 放到运行队列上"></a>将 Goroutine 放到运行队列上</h2><ul>
<li>Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务  </li>
<li>当处理器的本地运行队列已经没有剩余空间时，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine通过 runtime.runqputslow 添加到调度器持有的全局运行队列上</li>
</ul>
<h2 id="调度器行为"><a href="#调度器行为" class="headerlink" title="调度器行为"></a>调度器行为</h2><ul>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine  </li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine  </li>
<li>如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找Goroutine<br>从本地运行队列、全局运行队列中查找<br>从网络轮询器中查找是否有 Goroutine 等待运行<br>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine</li>
</ul>
<h2 id="课后练习-2-1"><a href="#课后练习-2-1" class="headerlink" title="课后练习 2.1"></a>课后练习 2.1</h2><p>将练习1.2中的生产者消费者模型修改成为多个生产者和多个消费者模式  </p>
<p><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson2/more-producer-customer">作业2.1</a>  </p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="关于内存管理的争论"><a href="#关于内存管理的争论" class="headerlink" title="关于内存管理的争论"></a>关于内存管理的争论</h2><ul>
<li>java&#x2F;golang：内存管理太重要了！手动管理麻烦且容易出错，所以我们应该交给机器去管理！  </li>
<li>c&#x2F;c++：内存管理太重要了！所以如果交给机器管理我不能放心！</li>
</ul>
<h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><p><img src="/2021/11/22/cloud-native-2-go-advanced/%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png">  </p>
<ul>
<li>初始化连续内存块作为堆  </li>
<li>有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块  </li>
<li>用链表将已分配内存连接起来  </li>
<li>需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等</li>
</ul>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/object-header.png">  </p>
<h2 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h2><p><img src="/2021/11/22/cloud-native-2-go-advanced/TCMalloc.png">  </p>
<ul>
<li><p>page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以page 为单位的  </p>
</li>
<li><p>span: 内存块，一个或多个连续的 page 组成一个 span  </p>
</li>
<li><p>sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何使用  </p>
</li>
<li><p>object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object ；假设 object 的大小是 16B ，span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去  </p>
</li>
<li><p>对象大小定义<br>小对象大小：0<del>256KB<br>中对象大小：256KB</del>1MB<br>大对象大小：&gt;1MB  </p>
</li>
<li><p>小对象的分配流程<br>ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分时候，ThreadCache 缓存都是足够的，不需要去访问CentralCache 和 HeapPage，无系统调用配合无锁分配，分配效率是非常高的  </p>
</li>
<li><p>中对象分配流程<br>直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存就是 1MB  </p>
</li>
<li><p>大对象分配流程<br>从 large span set 选择合适数量的页面组成 span，用来存储数据</p>
</li>
</ul>
<h2 id="Go-语言内存分配"><a href="#Go-语言内存分配" class="headerlink" title="Go 语言内存分配"></a>Go 语言内存分配</h2><p><img src="/2021/11/22/cloud-native-2-go-advanced/go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png">  </p>
<ul>
<li><p>mcache：小对象的内存分配直接走<br>size class 从 1 到 66，每个 class 两个 span<br>Span 大小是 8KB，按 span class 大小切分  </p>
</li>
<li><p>mcentral<br>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请1个span，mcache 拿到 span 后继续分配对象<br>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请span  </p>
</li>
<li><p>mheap<br>当 mheap 没有足够的内存时，mheap 会向 OS 申请内存<br>Mheap 把 Span 组织成了树结构，而不是链表<br>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<br>为了更高效的分配、回收和再利用内存</p>
</li>
</ul>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><h3 id="引用计数（Python，PHP，Swift）"><a href="#引用计数（Python，PHP，Swift）" class="headerlink" title="引用计数（Python，PHP，Swift）"></a>引用计数（Python，PHP，Swift）</h3><ul>
<li>对每一个对象维护一个引用计数，当引用该对象的对象被销毁的时候，引用计数减 1，当引用计数为 0 的时候，回收该对象  </li>
<li>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收  </li>
<li>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价</li>
</ul>
<h3 id="标记-清除（Golang）"><a href="#标记-清除（Golang）" class="headerlink" title="标记-清除（Golang）"></a>标记-清除（Golang）</h3><ul>
<li>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收  </li>
<li>优点：解决引用计数的缺点  </li>
<li>缺点：需要 STW（stop the word），即要暂停程序运行</li>
</ul>
<h3 id="分代收集（Java）"><a href="#分代收集（Java）" class="headerlink" title="分代收集（Java）"></a>分代收集（Java）</h3><ul>
<li>按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年代的频率</li>
</ul>
<h2 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h2><h3 id="allocBits"><a href="#allocBits" class="headerlink" title="allocBits"></a>allocBits</h3><p>记录了每块内存分配的情况  </p>
<h3 id="gcmarkBits"><a href="#gcmarkBits" class="headerlink" title="gcmarkBits"></a>gcmarkBits</h3><p>记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为1，没有的标记为 0  </p>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/gcmarkBits.png">  </p>
<p>这两个位图的数据结构是完全一致的，标记结束则进行内存回收，回收的时候，将 allocBits 指向 gcmarkBits，标记过的则存在，未进行标记的则进行回收  </p>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/gcmarkBits2.png">  </p>
<h2 id="GC-工作流程"><a href="#GC-工作流程" class="headerlink" title="GC 工作流程"></a>GC 工作流程</h2><p>Golang GC 的大部分处理是和用户代码并行的  </p>
<h3 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h3><ul>
<li>Mark Prepare: 初始化 GC 任务，包括开启写屏障 (write barrier) 和辅助 GC(mutator assist)，统计root对象的任务数量等。这个过程需要STW  </li>
<li>GC Drains: 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针（扫描对应 G 栈时需停止该 G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行</li>
</ul>
<h3 id="Mark-Termination"><a href="#Mark-Termination" class="headerlink" title="Mark Termination"></a>Mark Termination</h3><p>完成标记工作，重新扫描(re-scan)全局指针和栈。因为 Mark 和用户程序是并行的，所以在 Mark 过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这个过程也是会 STW 的  </p>
<h3 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h3><p>按照标记结果回收所有的白色对象，该过程后台并行执行  </p>
<h3 id="Sweep-Termination"><a href="#Sweep-Termination" class="headerlink" title="Sweep Termination"></a>Sweep Termination</h3><p>对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC  </p>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/gc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">  </p>
<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><ul>
<li>GC 开始时，认为所有 object 都是 白色，即垃圾。  </li>
<li>从 root 区开始遍历，被触达的 object 置成 灰色。  </li>
<li>遍历所有灰色 object，将他们内部的引用变量置成 灰色，自身置成 黑色  </li>
<li>循环第 3 步，直到没有灰色 object 了，只剩下了黑白两种，白色的都是垃圾。  </li>
<li>对于黑色 object，如果在标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为 灰色。  </li>
<li>标记过程中，mallocgc 新分配的 object，会先被标记成 黑色 再返回。</li>
</ul>
<p><img src="/2021/11/22/cloud-native-2-go-advanced/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png">  </p>
<h2 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h2><h3 id="内存分配量达到阀值触发-GC"><a href="#内存分配量达到阀值触发-GC" class="headerlink" title="内存分配量达到阀值触发 GC"></a>内存分配量达到阀值触发 GC</h3><p>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC。  </p>
<p>阀值 &#x3D; 上次 GC 内存分配量 * 内存增长率<br>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。  </p>
<h3 id="定期触发-GC"><a href="#定期触发-GC" class="headerlink" title="定期触发 GC"></a>定期触发 GC</h3><p>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src&#x2F;runtime&#x2F;proc.go:forcegcperiod 变量中被声明  </p>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>程序代码中也可以使用 runtime.GC()来手动触发 GC。这主要用于 GC 性能测试和统计。  </p>
<h1 id="包引用与依赖管理"><a href="#包引用与依赖管理" class="headerlink" title="包引用与依赖管理"></a>包引用与依赖管理</h1><h2 id="Go-语言依赖管理的演进"><a href="#Go-语言依赖管理的演进" class="headerlink" title="Go 语言依赖管理的演进"></a>Go 语言依赖管理的演进</h2><h3 id="回顾-GOPATH"><a href="#回顾-GOPATH" class="headerlink" title="回顾 GOPATH"></a>回顾 GOPATH</h3><ul>
<li>通过环境变量设置系统级的 Go 语言类库目录  </li>
<li>GOPATH 的问题？<br>不同项目可能依赖不同版本<br>代码被 clone 以后需要设置 GOPATH 才能编译</li>
</ul>
<h3 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h3><ul>
<li>自 1.6 版本，支持 vendor 目录，在每个 Go 语言项目中，创建一个名叫 vendor 的目录，并将依赖拷贝至该目录。  </li>
<li>Go 语言项目会自动将 vendor 目录作为自身的项目依赖路径  </li>
<li>好处？<br>每个项目的 vendor目录是独立的，可以灵活的选择版本<br>Vendor 目录与源代码一起 check in 到 github，其他人 checkout 以后可直接编译<br>无需在编译期间下载依赖包，所有依赖都已经与源代码保存在一起</li>
</ul>
<h2 id="vendor-管理工具"><a href="#vendor-管理工具" class="headerlink" title="vendor 管理工具"></a>vendor 管理工具</h2><p>通过声明式配置，实现 vendor 管理的自动化  </p>
<ul>
<li>在早期，Go 语言无自带依赖管理工具，社区方案鱼龙混杂比较出名的包括<code>Godeps, Glide</code>  </li>
<li>Go 语言随后发布了自带的依赖管理工具 Gopkg  </li>
<li>很快用新的工具 gomod 替换掉了 gopkg<br>切换 mod 开启模式：<code>export GO111MODULE=on/off/auto</code><br>Go mod 相比之前的工具更灵活易用，以基本统一了 Go 语言依赖管理</li>
</ul>
<p>思考：用依赖管理工具的目的？  </p>
<ul>
<li>版本管理  </li>
<li>防篡改</li>
</ul>
<h2 id="Go-mod-使用"><a href="#Go-mod-使用" class="headerlink" title="Go mod 使用"></a>Go mod 使用</h2><ul>
<li><p>创建项目  </p>
</li>
<li><p>初始化 Go 模块 <code>go mod init</code>  </p>
</li>
<li><p>下载依赖包<br>go mod download（下载的依赖包在$GOPATH&#x2F;pkg，如果没有设置 GOPATH，则下载在项目根目录&#x2F;pkg）<br>在源代码中使用某个依赖包，如 github.com&#x2F;emicklei&#x2F;go-restful  </p>
</li>
<li><p>添加缺少的依赖并为依赖包瘦身 <code>go mod tidy</code>  </p>
</li>
<li><p>把 Go 依赖模块添加到 vendor 目录 <code>go mod vendor</code></p>
</li>
</ul>
<p>配置细节会被保存在项目根目录的 go.mod 中，可在 require 或者 replacement 中指定版本  </p>
<h2 id="GOPROXY-和-GOPRIVATE"><a href="#GOPROXY-和-GOPRIVATE" class="headerlink" title="GOPROXY 和 GOPRIVATE"></a>GOPROXY 和 GOPRIVATE</h2><ul>
<li><p>GOPROXY<br>为拉取 Go 依赖设置代理<code>export GOPROXY=https://goproxy.cn</code>  </p>
</li>
<li><p>在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做checksum 校验  </p>
</li>
<li><p>某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com</span><br><span class="line">GOPROXY=proxy.example.com</span><br><span class="line">GONOPROXY=myrepo.corp.example.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>Go 语言项目多采用 Makefile 组织项目编译  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root:</span><br><span class="line">    <span class="built_in">export</span> ROOT=github.com/cncamp/golang;</span><br><span class="line">.PHONY: root</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;building httpserver binary&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p bin/amd64</span><br><span class="line">    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/amd64 .</span><br><span class="line">.PHONY: release</span><br></pre></td></tr></table></figure>

<h1 id="课后作业：动手编写一个-HTTP-Server"><a href="#课后作业：动手编写一个-HTTP-Server" class="headerlink" title="课后作业：动手编写一个 HTTP Server"></a>课后作业：动手编写一个 HTTP Server</h1><h2 id="课后练习-2-2"><a href="#课后练习-2-2" class="headerlink" title="课后练习 2.2"></a>课后练习 2.2</h2><ul>
<li>编写一个 HTTP 服务器<br>接收客户端请求并将请求的 Header 打印出来返回给客户端</li>
</ul>
<p><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson2/httpsvr">作业2.2</a>  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>锁</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营_第3课_Docker核心技术</title>
    <url>/2021/11/29/cloud-native-3-docker-core-technology/</url>
    <content><![CDATA[<h1 id="从系统架构谈起"><a href="#从系统架构谈起" class="headerlink" title="从系统架构谈起"></a>从系统架构谈起</h1><h2 id="传统分层架构-vs-微服务"><a href="#传统分层架构-vs-微服务" class="headerlink" title="传统分层架构 vs 微服务"></a>传统分层架构 vs 微服务</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E4%BC%A0%E7%BB%9Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png">  </p>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E4%BC%A0%E7%BB%9Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%842.png">  </p>
<h2 id="微服务改造"><a href="#微服务改造" class="headerlink" title="微服务改造"></a>微服务改造</h2><p>分离微服务的方法建议：  </p>
<ul>
<li>审视并发现可以分离的业务逻辑业务逻辑  </li>
<li>寻找天生隔离的代码模块，可以借助于静态代码分析工具  </li>
<li>不同并发规模，不同内存需求的模块都可以分离出不同的微服务，此方法可提高资源利用率，节省成本</li>
</ul>
<p>一些常用的可微服务化的组件：  </p>
<ul>
<li>用户和账户管理  </li>
<li>授权和会话管理  </li>
<li>系统配置  </li>
<li>通知和通讯服务  </li>
<li>照片，多媒体，元数据等</li>
</ul>
<p><strong>分解原则：基于 size, scope and capabilities</strong>  </p>
<h2 id="微服务间通讯"><a href="#微服务间通讯" class="headerlink" title="微服务间通讯"></a>微服务间通讯</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><ul>
<li>多用于系统内部多组件之间通讯；  </li>
<li>有大量的重复模块如认证授权；  </li>
<li>缺少统一规范，如监控，审计等功能；  </li>
<li>后期维护成本高，服务和服务的依赖关系错综复杂难以管理。</li>
</ul>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><ul>
<li>基于一个轻量级的 message gateway  </li>
<li>新 API 通过注册至 Gateway 实现  </li>
<li>整合实现 Common function</li>
</ul>
<h1 id="理解-Docker"><a href="#理解-Docker" class="headerlink" title="理解 Docker"></a>理解 Docker</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。  </li>
<li>最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。  </li>
<li>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。</li>
</ul>
<h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><ul>
<li>更高效地利用系统资源  </li>
<li>更快速的启动时间  </li>
<li>一致的运行环境  </li>
<li>持续交付和部署  </li>
<li>更轻松地迁移  </li>
<li>更轻松地维护和扩展</li>
</ul>
<h2 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E8%99%9A%E6%8B%9F%E6%9C%BAvs%E5%AE%B9%E5%99%A8.png">  </p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>在 ubuntu 上安装 Docker 运行时，参考 <a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a>  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">apt-transport-https \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">gnupg-agent \</span><br><span class="line">software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line"><span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string"><span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">stable&quot;</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul>
<li>启动：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run</span><br><span class="line">-it 交互</span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 磁盘挂载</span><br></pre></td></tr></table></figure>

<ul>
<li>启动已终止容器：<code>docker start</code>  </li>
<li>停止容器：<code>docker stop</code>  </li>
<li>查看容器进程：<code>docker ps</code>  </li>
<li>查看容器细节：<code>docker inspect &lt;containerid&gt;</code>  </li>
<li>进入容器：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker attach：</span><br><span class="line">通过 nsenter</span><br><span class="line">PID=$(docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot;&lt;container&gt;)</span><br><span class="line">$ nsenter --target $PID --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝文件至容器内：<code>docker cp file1 &lt;containerid&gt;:/file-to-path</code></li>
</ul>
<h2 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h2><ul>
<li>cat Dockerfile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV MY_SERVICE_PORT=80</span><br><span class="line">ADD bin/amd64/httpserver /httpserver</span><br><span class="line">ENTRYPOINT /httpserver</span><br></pre></td></tr></table></figure>

<ul>
<li>将 Dockerfile 打包成镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t cncamp/httpserver:$&#123;tag&#125; .</span><br><span class="line">docker push cncamp/httpserver:v1.0</span><br></pre></td></tr></table></figure>

<ul>
<li>运行容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d cncamp/httpserver:v1.0</span><br></pre></td></tr></table></figure>

<h2 id="容器标准"><a href="#容器标准" class="headerlink" title="容器标准"></a>容器标准</h2><ul>
<li><p>Open Container Initiative（OCI）<br>轻量级开放式管理组织（项目）  </p>
</li>
<li><p>OCI 主要定义两个规范<br>Runtime Specification：文件系统包如何解压至硬盘，共运行时运行。<br>Image Specification：如何通过构建系统打包，生成镜像清单（Manifest）、文件系统序列化文件、镜像配置。</p>
</li>
</ul>
<h2 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h2><ul>
<li>安全性  </li>
<li>隔离性  </li>
<li>便携性  </li>
<li>可配额</li>
</ul>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：  </p>
<ul>
<li>系统可以为进程分配不同的 Namespace；  </li>
<li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰 。</li>
</ul>
<h2 id="Linux-内核代码中-Namespace-的实现"><a href="#Linux-内核代码中-Namespace-的实现" class="headerlink" title="Linux 内核代码中 Namespace 的实现"></a>Linux 内核代码中 Namespace 的实现</h2><ul>
<li>进程数据结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*namespaces*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Namespace 数据结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux-对-Namespace-操作方法"><a href="#Linux-对-Namespace-操作方法" class="headerlink" title="Linux 对 Namespace 操作方法"></a>Linux 对 Namespace 操作方法</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CLONE_NEWCGROUP / CLONE_NEWIPC / CLONE_NEWNET / CLONE_NEWNS / CLONE_NEWPID / CLONE_NEWUSER / CLONE_NEWUTS</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>

<h3 id="setns"><a href="#setns" class="headerlink" title="setns"></a>setns</h3><p>该系统调用可以让调用进程加入某个已经存在的 Namespace 中：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Int <span class="title function_">setns</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> nstype)</span></span><br></pre></td></tr></table></figure>

<h3 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h3><p>该系统调用可以将调用进程移动到新的 Namespace 下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unshare</span><span class="params">(<span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<h2 id="隔离性-–-Linux-Namespace"><a href="#隔离性-–-Linux-Namespace" class="headerlink" title="隔离性 – Linux Namespace"></a>隔离性 – Linux Namespace</h2><p>Namespace 类型 隔离资源 Kernel 版本<br>IPC System V IPC 和 POSIX 消息队列 2.6.19<br>Network 网络设备、网络协议栈、网络端口等 2.6.29<br>PID 进程 2.6.14<br>Mount 挂载点 2.4.19<br>UTS 主机名和域名 2.6.19<br>USR 用户和用户组 3.8</p>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E9%9A%94%E7%A6%BB%E6%80%A7-Linux-Namespace.png">  </p>
<h3 id="Pid-namespace"><a href="#Pid-namespace" class="headerlink" title="Pid namespace"></a>Pid namespace</h3><ul>
<li>不同用户的进程就是通过 Pid namespace 隔离开的，且不同 namespace 中可以有相同 Pid。  </li>
<li>有了 Pid namespace, 每个 namespace 中的 Pid 能够相互隔离。</li>
</ul>
<h3 id="net-namespace"><a href="#net-namespace" class="headerlink" title="net namespace"></a>net namespace</h3><ul>
<li>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, &#x2F;proc&#x2F;net 目录。  </li>
<li>Docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge: docker0 连接在一起。</li>
</ul>
<h3 id="ipc-namespace"><a href="#ipc-namespace" class="headerlink" title="ipc namespace"></a>ipc namespace</h3><ul>
<li>Container 中进程交互还是采用 linux 常见的进程间交互方法 （interprocess communication – IPC）, 包括常见的信号量、消息队列和共享内存。  </li>
<li>container 的进程间交互实际上还是 host上 具有相同 Pid namespace 中的进程间交互，因此需要在 IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID。</li>
</ul>
<h3 id="mnt-namespace"><a href="#mnt-namespace" class="headerlink" title="mnt namespace"></a>mnt namespace</h3><ul>
<li>mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。</li>
</ul>
<h3 id="uts-namespace"><a href="#uts-namespace" class="headerlink" title="uts namespace"></a>uts namespace</h3><ul>
<li>UTS(“UNIX Time-sharing System”) namespace允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</li>
</ul>
<h3 id="user-namespace"><a href="#user-namespace" class="headerlink" title="user namespace"></a>user namespace</h3><ul>
<li>每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。</li>
</ul>
<h2 id="关于-namespace-的常用操作"><a href="#关于-namespace-的常用操作" class="headerlink" title="关于 namespace 的常用操作"></a>关于 namespace 的常用操作</h2><ul>
<li>查看当前系统的 namespace：<code>lsns –t &lt;type&gt;</code>  </li>
<li>查看某进程的 namespace：<code>ls -la /proc/&lt;pid&gt;/ns/</code>  </li>
<li>进入某 namespace 运行命令：<code>nsenter -t &lt;pid&gt; -n ip addr</code></li>
</ul>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><ul>
<li>Cgroups （Control Groups）是 Linux 下用于对一个或一组进程进行资源控制和监控的机制；  </li>
<li>可以对诸如 CPU 使用时间、内存、磁盘 I&#x2F;O 等进程所需的资源进行限制；  </li>
<li>不同资源的具体管理工作由相应的 Cgroup 子系统（Subsystem）来实现 ；  </li>
<li>针对不同类型的资源限制，只要将限制策略在不同的的子系统上进行关联即可 ；  </li>
<li>Cgroups 在不同的系统资源管理子系统中以层级树（Hierarchy）的方式来组织管理：每个 Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使用的资源除了受本 Cgroup 配置的资源参数限制，还受到父Cgroup 设置的资源限制。</li>
</ul>
<h2 id="Linux-内核代码中-Cgroups-的实现"><a href="#Linux-内核代码中-Cgroups-的实现" class="headerlink" title="Linux 内核代码中 Cgroups 的实现"></a>Linux 内核代码中 Cgroups 的实现</h2><ul>
<li><p>进程数据结构  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">css_set__rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>css_set 是 cgroup_subsys_state 对象的集合数据结构  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set of subsystem states, one for each subsystem. This array is</span></span><br><span class="line"><span class="comment"> * immutable after creation apart from the init_css_set during</span></span><br><span class="line"><span class="comment"> * subsystem registration (at boot time).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="可配额-x2F-可度量-Control-Groups-cgroups"><a href="#可配额-x2F-可度量-Control-Groups-cgroups" class="headerlink" title="可配额&#x2F;可度量 - Control Groups (cgroups)"></a>可配额&#x2F;可度量 - Control Groups (cgroups)</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E5%8F%AF%E9%85%8D%E9%A2%9D%E5%BA%A6%E9%87%8FControlGroups.png">  </p>
<p>cgroups 实现了对资源的配额和度量  </p>
<ul>
<li>blkio：这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及 USB 等等。  </li>
<li>CPU：这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问。  </li>
<li>cpuacct：产生 cgroup 任务的 CPU 资源报告。  </li>
<li>cpuset：如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU 和内存。  </li>
<li>devices：允许或拒绝 cgroup 任务对设备的访问。  </li>
<li>freezer：暂停和恢复 cgroup 任务。  </li>
<li>memory：设置每个 cgroup 的内存限制以及产生内存资源报告。  </li>
<li>net_cls：标记每个网络包以供 cgroup 方便使用。  </li>
<li>ns：名称空间子系统。  </li>
<li>pid:进程标识子系统。</li>
</ul>
<h2 id="CPU-子系统"><a href="#CPU-子系统" class="headerlink" title="CPU 子系统"></a>CPU 子系统</h2><ul>
<li><p>cpu.shares：可出让的能获得 CPU 使用时间的相对值。<br><img src="/2021/11/29/cloud-native-3-docker-core-technology/shares%E6%AF%94%E4%BE%8B%E6%8E%A7%E5%88%B6.png">  </p>
</li>
<li><p>cpu.cfs_period_us：cfs_period_us 用来配置时间周期长度，单位为 us（微秒）。  </p>
</li>
<li><p>cpu.cfs_quota_us：cfs_quota_us 用来配置当前 Cgroup 在 cfs_period_us 时间内最多能使用的 CPU 时间数，单位为 us（微秒）。<br><img src="/2021/11/29/cloud-native-3-docker-core-technology/period-quota%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png">  </p>
</li>
<li><p>cpu.stat：Cgroup 内的进程使用的 CPU 时间统计。  </p>
</li>
<li><p>nr_periods：经过 cpu.cfs_period_us 的时间周期数量。  </p>
</li>
<li><p>nr_throttled：在经过的周期内，有多少次因为进程在指定的时间周期内用光了配额时间而受到限制。  </p>
</li>
<li><p>throttled_time：Cgroup 中的进程被限制使用 CPU 的总用时，单位是 ns（纳秒）。</p>
</li>
</ul>
<h2 id="Linux-调度器"><a href="#Linux-调度器" class="headerlink" title="Linux 调度器"></a>Linux 调度器</h2><p>内核默认提供了5个调度器，Linux 内核使用 struct sched_class 来对调度器进行抽象：  </p>
<ul>
<li>Stop 调度器，stop_sched_class：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；  </li>
<li>Deadline 调度器，dl_sched_class：使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；  </li>
<li>RT 调度器， rt_sched_class：实时调度器，为每个优先级维护一个队列；  </li>
<li>CFS 调度器， cfs_sched_class：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念；  </li>
<li>IDLE-Task 调度器， idle_sched_class：空闲调度器，每个 CPU 都会有一个 idle 线程，当没有其他进程可以调度时，调度运行 idle 线程。</li>
</ul>
<h3 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h3><ul>
<li>CFS 是 Completely Fair Scheduler 简称，即完全公平调度器。  </li>
<li>CFS 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器。  </li>
<li>分给某个任务的时间失去平衡时，应给失去平衡的任务分配时间，让其执行。  </li>
<li>CFS 通过虚拟运行时间（vruntime）来实现平衡，维护提供给某个任务的时间量。vruntime &#x3D; 实际运行时间*1024 &#x2F; 进程权重。  </li>
<li>进程按照各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</li>
</ul>
<h2 id="vruntime-红黑树"><a href="#vruntime-红黑树" class="headerlink" title="vruntime 红黑树"></a>vruntime 红黑树</h2><p>CFS 调度器没有将进程维护在运行队列中，而是维护了一个以虚拟运行时间为顺序的红黑树。 红黑树的主要特点有：  </p>
<ol>
<li>自平衡，树上没有一条路径会比其他路径长出俩倍。  </li>
<li>O(log n) 时间复杂度，能够在树上进行快速高效地插入或删除进程。</li>
</ol>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/vruntime%E7%BA%A2%E9%BB%91%E6%A0%91.png">  </p>
<h2 id="CFS进程调度"><a href="#CFS进程调度" class="headerlink" title="CFS进程调度"></a>CFS进程调度</h2><ul>
<li>在时钟周期开始时，调度器调用 __schedule() 函数来开始调度的运行。  </li>
<li>__schedule() 函数调用 pick_next_task() 让进程调度器从就绪队列中选择一个最合适的进程 next，即红黑树最左边的节点。  </li>
<li>通过 context_switch() 切换到新的地址空间，从而保证 next 进程运行。  </li>
<li>在时钟周期结束时，调度器调用 entity_tick() 函数来更新进程负载、进程状态以及 vruntime（当前vruntime + 该时钟周期内运行的时间）。  </li>
<li>最后，将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，如果小于坐左边的时间，则不用触发调度，继续调度当前调度实体。</li>
</ul>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/CFS%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png">  </p>
<h2 id="cpuacct-子系统"><a href="#cpuacct-子系统" class="headerlink" title="cpuacct 子系统"></a>cpuacct 子系统</h2><p>用于统计 Cgroup 及其子 Cgroup 下进程的 CPU 的使用情况。  </p>
<ul>
<li>cpuacct.usage：包含该 Cgroup 及其子 Cgroup 下进程使用 CPU 的时间，单位是 ns（纳秒）。  </li>
<li>cpuacct.stat：包含该 Cgroup 及其子 Cgroup 下进程使用的 CPU 时间，以及用户态和内核态的时间。</li>
</ul>
<h2 id="Memory-子系统"><a href="#Memory-子系统" class="headerlink" title="Memory 子系统"></a>Memory 子系统</h2><ul>
<li>memory.usage_in_bytes：cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存  </li>
<li>memory.max_usage_in_bytes：cgroup 下进程使用内存的最大值，包含子 cgroup 的内存使用量。  </li>
<li>memory.limit_in_bytes：设置 Cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制。  </li>
<li>memory.soft_limit_in_bytes：这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。  </li>
<li>memory.oom_control：设置是否在 Cgroup 中使用 OOM（Out of Memory）Killer，默认为使用。当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理。</li>
</ul>
<h2 id="Cgroup-driver"><a href="#Cgroup-driver" class="headerlink" title="Cgroup driver"></a>Cgroup driver</h2><p>systemd:  </p>
<ul>
<li>当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup管理器。  </li>
<li>systemd 与 cgroup 紧密结合，并且为每个 systemd unit 分配 cgroup。</li>
</ul>
<p>cgroupfs:  </p>
<ul>
<li>docker 默认用 cgroupfs 作为 cgroup 驱动。</li>
</ul>
<p>存在问题：  </p>
<ul>
<li>在 systemd 作为 init system 的系统中，默认并存着两套 groupdriver。  </li>
<li>这会使得系统中 Docker 和 kubelet 管理的进程被 cgroupfs 驱动管，而 systemd 拉起的服务由systemd 驱动管，让 cgroup 管理混乱且容易在资源紧张时引发问题。  </li>
<li>因此 kubelet 会默认–cgroup-driver&#x3D;systemd，若运行时 cgroup 不一致时，kubelet 会报错。</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Union FS  </p>
<ul>
<li>将不同目录挂载到同一个虚拟文件系统下 （unite several directories into a single virtual filesystem）的文件系统  </li>
<li>支持为每一个成员目录（类似Git Branch）设定 readonly、readwrite 和 whiteout-able 权限  </li>
<li>文件系统分层, 对 readonly 权限的 branch 可以逻辑上进行修改(增量地, 不影响 readonly 部分的)。  </li>
<li>通常 Union FS 有两个用途, 一方面可以将多个 disk 挂到同一个目录下, 另一个更常用的就是将一个readonly 的 branch 和一个 writeable 的 branch 联合在一起。</li>
</ul>
<h2 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F.png">  </p>
<h2 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h2><p>典型的 Linux 文件系统组成：  </p>
<h3 id="Bootfs（boot-file-system）"><a href="#Bootfs（boot-file-system）" class="headerlink" title="Bootfs（boot file system）"></a>Bootfs（boot file system）</h3><ul>
<li>Bootloader - 引导加载 kernel  </li>
<li>Kernel - 当 kernel 被加载到内存中后 umount bootfs 。</li>
</ul>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/bootfs.png">  </p>
<h3 id="rootfs-（root-file-system）"><a href="#rootfs-（root-file-system）" class="headerlink" title="rootfs （root file system）"></a>rootfs （root file system）</h3><ul>
<li>&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。  </li>
<li>对于不同的 linux 发行版, bootfs 基本是一致的，但 rootfs 会有差别。</li>
</ul>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/rootfs.png">  </p>
<h2 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h2><p>Linux  </p>
<ul>
<li>在启动后，首先将 rootfs 设置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite”供用户使用。</li>
</ul>
<p>Docker 启动  </p>
<ul>
<li>初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个readwrite 文件系统挂载在 readonly 的 rootfs 之上；  </li>
<li>并且允许再次将下层的 FS（file system） 设定为 readonly 并且向上叠加。  </li>
<li>这样一组 readonly 和一个 writeable 的结构构成一个 container 的运行时态, 每一个 FS 被称作一个 FS层。</li>
</ul>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/Docker%E5%90%AF%E5%8A%A8.png">  </p>
<h2 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/Docker%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png">  </p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="Null-–net-x3D-None"><a href="#Null-–net-x3D-None" class="headerlink" title="Null(–net&#x3D;None)"></a>Null(–net&#x3D;None)</h3><ul>
<li>把容器放入独立的网络空间但不做任何网络配置；  </li>
<li>用户需要通过运行 docker network 命令来完成网络配置。</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><ul>
<li>使用主机网络名空间，复用主机网络。</li>
</ul>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li>重用其他容器的网络。</li>
</ul>
<h3 id="Bridge-–net-x3D-bridge"><a href="#Bridge-–net-x3D-bridge" class="headerlink" title="Bridge(–net&#x3D;bridge)"></a>Bridge(–net&#x3D;bridge)</h3><ul>
<li>使用 Linux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。</li>
</ul>
<h3 id="Overlay-libnetwork-libkv"><a href="#Overlay-libnetwork-libkv" class="headerlink" title="Overlay(libnetwork, libkv)"></a>Overlay(libnetwork, libkv)</h3><ul>
<li>通过网络封包实现。</li>
</ul>
<h3 id="Remote-work-with-remote-drivers"><a href="#Remote-work-with-remote-drivers" class="headerlink" title="Remote(work with remote drivers)"></a>Remote(work with remote drivers)</h3><ul>
<li>Underlay：使用现有底层网络，为每一个容器配置可路由的网络 IP。  </li>
<li>Overlay：通过网络封包实现。</li>
</ul>
<h2 id="Null-模式"><a href="#Null-模式" class="headerlink" title="Null 模式"></a>Null 模式</h2><ul>
<li>Null 模式是一个空实现；  </li>
<li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/run/netns</span><br><span class="line">find -L /var/run/netns -type l -delete</span><br><span class="line">ln -s /proc/$pid/ns/net /var/run/netns/$pid</span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line">brctl addif br0 A</span><br><span class="line">ip link set A up</span><br><span class="line">ip link set B netns $pid</span><br><span class="line">ip netns exec $pid ip link set dev B name eth0</span><br><span class="line">ip netns exec $pid ip link set eth0 up</span><br><span class="line">ip netns exec $pid ip addr add</span><br><span class="line">$SETIP/$SETMASK dev eth0</span><br><span class="line">ip netns exec $pid ip route add default via</span><br><span class="line">$GATEWAY</span><br></pre></td></tr></table></figure>

<h2 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/VXLAN.png">  </p>
<h2 id="Overlay-network-sample-–-Flannel"><a href="#Overlay-network-sample-–-Flannel" class="headerlink" title="Overlay network sample – Flannel"></a>Overlay network sample – Flannel</h2><ul>
<li>同一主机内的 Pod 可以使用网桥进行通信。  </li>
<li>不同主机上的 Pod 将通过flanneld 将其流量封装在 UDP数据包中</li>
</ul>
<p><img src="/2021/11/29/cloud-native-3-docker-core-technology/Overlay-network.png">  </p>
<h2 id="Flannel-packet-sample"><a href="#Flannel-packet-sample" class="headerlink" title="Flannel packet sample"></a>Flannel packet sample</h2><p><img src="/2021/11/29/cloud-native-3-docker-core-technology/Flannel-packet-sample.png">  </p>
<h2 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h2><p>1,定义 dockerfile  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"># so apt-get doesn&#x27;t complain</span><br><span class="line">ENV DEBIAN_FRONTEND=noninteractive</span><br><span class="line">RUN sed -i &#x27;s/^exit 101/exit 0/&#x27; /usr/sbin/policy-rc.d</span><br><span class="line"></span><br><span class="line">RUN \</span><br><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">apt-get install -y ca-certificates &amp;&amp; \</span><br><span class="line">apt-get install -y curl &amp;&amp; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ADD ./bin/eic eic</span><br><span class="line">ENTRYPOINT [&quot;/eic&quot;]</span><br></pre></td></tr></table></figure>

<p>2,docker build  </p>
<h1 id="Dockerfile-的最佳实践"><a href="#Dockerfile-的最佳实践" class="headerlink" title="Dockerfile 的最佳实践"></a>Dockerfile 的最佳实践</h1><h2 id="理解构建上下文（Build-Context）"><a href="#理解构建上下文（Build-Context）" class="headerlink" title="理解构建上下文（Build Context）"></a>理解构建上下文（Build Context）</h2><ul>
<li>当运行 docker build 命令时，当前工作目录被称为构建上下文。  </li>
<li>docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 –f 指定 Dockerfile。<code>docker build –f ./Dockerfile</code>  </li>
<li>当 docker build 运行时，首先会把构建上下文传输给 docker daemon，把没用的文件包含在构建上下文时，会导致传输时间长，构建需要的资源多，构建出的镜像大等问题。</li>
</ul>
<p>试着到一个包含文件很多的目录运行下面的命令，会感受到差异；<br>docker build -f $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp&#x2F;golang&#x2F;httpserver&#x2F;Dockerfile ；<br>docker build $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp&#x2F;golang&#x2F;httpserver&#x2F;；<br>可以通过.dockerignore文件从编译上下文排除某些文件。  </p>
<ul>
<li>因此需要确保构建上下文清晰，比如创建一个专门的目录放置 Dockerfile，并在目录中运行 docker build。</li>
</ul>
<h2 id="镜像构建日志"><a href="#镜像构建日志" class="headerlink" title="镜像构建日志"></a>镜像构建日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build $GOPATH/src/github.com/cncamp/golang/httpserver/</span><br><span class="line">Sending build context to Docker daemon 14.57MB</span><br><span class="line">Step 1/4 : FROM ubuntu</span><br><span class="line">---&gt; cf0f3ca922e0</span><br><span class="line">Step 2/4 : ENV MY_SERVICE_PORT=80</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; a7d824f74410</span><br><span class="line">Step 3/4 : ADD bin/amd64/httpserver /httpserver</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; 00bb47fce704</span><br><span class="line">Step 4/4 : ENTRYPOINT /httpserver</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; f77ee3366d08</span><br><span class="line">Successfully built f77ee3366d08</span><br></pre></td></tr></table></figure>

<h2 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h2><p>构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令。<br>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。  </p>
<ul>
<li>通常 Docker 简单判断 Dockerfile 中的指令与镜像。  </li>
<li>针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum。  </li>
<li>其他指令，比如 RUN apt-get -y update，Docker 简单比较与现存镜像中的指令字串是否一致。  </li>
<li>当某一层 cache 失效以后，所有所有层级的 cache 均一并失效，后续指令都重新构建镜像。</li>
</ul>
<h2 id="多段构建（Multi-stage-build）"><a href="#多段构建（Multi-stage-build）" class="headerlink" title="多段构建（Multi-stage build）"></a>多段构建（Multi-stage build）</h2><p>有效减少镜像层级的方式  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM golang:1.16-alpine AS build</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN go get github.com/golang/dep/cmd/dep</span><br><span class="line"></span><br><span class="line">COPY Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="line">WORKDIR /go/src/project/</span><br><span class="line">RUN dep ensure -vendor-only</span><br><span class="line"></span><br><span class="line">COPY . /go/src/project/</span><br><span class="line">RUN go build -o /bin/project（只有这个二进制文件是产线需要的，其他都是waste）</span><br><span class="line"></span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=build /bin/project /bin/project</span><br><span class="line">ENTRYPOINT [&quot;/bin/project&quot;]</span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h2><ul>
<li><p>FROM：选择基础镜像，推荐 alpine<br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code>  </p>
</li>
<li><p>LABELS：按标签组织项目<br><code>LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3”</code></p>
</li>
</ul>
<p>配合 label filter 可过滤镜像查询结果<br><code>docker images -f label=multi.label1=&quot;value1&quot;</code>  </p>
<ul>
<li><p>RUN：执行命令<br>最常见的用法是 RUN apt-get update &amp;&amp; apt-get install，这两条命令应该永远用&amp;&amp;连接，如果分开执行，RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装  </p>
</li>
<li><p>CMD：容器镜像中包含应用的运行命令，需要带参数<br><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;…]</code>  </p>
</li>
<li><p>EXPOSE：发布端口<br><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p>
</li>
</ul>
<p>是镜像创建者和使用者的约定<br>在 docker run –P 时，docker 会自动映射 expose 的端口到主机大端口，如0.0.0.0:32768-&gt;80&#x2F;tcp  </p>
<ul>
<li><p>ENV 设置环境变量<br><code>ENV &lt;key&gt;=&lt;value&gt; ...</code>  </p>
</li>
<li><p>ADD：从源地址（文件，目录或者 URL）复制文件到目标路径<br><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code><br><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [“&lt;src&gt;”,... “&lt;dest&gt;”] （路径中有空格时使用）</code>  </p>
</li>
<li><p>ADD 支持 Go 风格的通配符，如 ADD check* &#x2F;testdir&#x2F;  </p>
</li>
<li><p>src 如果是文件，则必须包含在编译上下文中，ADD 指令无法添加编译上下文之外的文件  </p>
</li>
<li><p>src 如果是 URL，如果 dest 结尾没有&#x2F;，那么 dest 是目标文件名，如果 dest 结尾有&#x2F;，那么 dest 是目标目录名  </p>
</li>
<li><p>如果 src 是一个目录，则所有文件都会被复制至 dest  </p>
</li>
<li><p>如果 src 是一个本地压缩文件，则在 ADD 的同时完整解压操作  </p>
</li>
<li><p>如果 dest 不存在，则 ADD 指令会创建目标目录  </p>
</li>
<li><p>应尽量减少通过 ADD URL 添加 remote 文件，建议使用 curl 或者 wget &amp;&amp; untar  </p>
</li>
<li><p>COPY：从源地址（文件，目录或者URL）复制文件到目标路径<br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] // 路径中有空格时使用</code>  </p>
</li>
<li><p>COPY 的使用与 ADD 类似，但有如下区别  </p>
</li>
<li><p>COPY 只支持本地文件的复制，不支持 URL  </p>
</li>
<li><p>COPY 不解压文件  </p>
</li>
<li><p>COPY 可以用于多阶段编译场景，可以用前一个临时镜像中拷贝文件<br><code>COPY --from=build /bin/project /bin/project</code>  </p>
</li>
<li><p>ENTRYPOINT：定义可以执行的容器镜像入口命令<br><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] // docker run参数追加模式</code><br><code>ENTRYPOINT command param1 param2 // docker run 参数替换模式</code>  </p>
</li>
<li><p>docker run –entrypoint 可替换 Dockerfile 中定义的 ENTRYPOINT  </p>
</li>
<li><p>ENTRYPOINT 的最佳实践是用 ENTRYPOINT 定义镜像主命令，并通过 CMD 定义主要参数，如下所示<br>ENTRYPOINT [“s3cmd”]<br>CMD [“–help”]  </p>
</li>
<li><p>VOLUME： 将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效<br>VOLUME [“&#x2F;data”]等价于 docker run –v &#x2F;data，可通过 docker inspect 查看主机的 mount point，&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;<containerid>&#x2F;_data  </containerid></p>
</li>
<li><p>USER：切换运行镜像的用户和用户组，因安全性要求，越来越多的场景要求容器应用要以 non-root 身份运行<br><code>USER &lt;user&gt;[:&lt;group&gt;]</code>  </p>
</li>
<li><p>WORKDIR：等价于 cd，切换工作目录<br><code>WORKDIR /path/to/workdir</code></p>
</li>
</ul>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson3">Namespace 练习</a><br><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson3">CPU 子系统练习</a><br><a href>课后练习3.1</a><br><a href>OverlayFS 文件系统练习</a><br><a href>思考并讨论容器的劣势</a><br><a href="https://github.com/OctopusLian/CloudNativeCampHomework/tree/main/lesson3">课后练习 3.2</a>  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/XiaoliBoy/p/10410686.html">https://www.cnblogs.com/XiaoliBoy/p/10410686.html</a><br><a href="http://www.wowotech.net/process_management/451.html">http://www.wowotech.net/process_management/451.html</a>  </p>
]]></content>
      <categories>
        <category>Learn-CloudNative</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营_第4课_Kubernetes架构原则和对象设计</title>
    <url>/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/</url>
    <content><![CDATA[<h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><h2 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E4%BA%91%E4%B8%9A%E5%8A%A1%E4%BA%91%E5%B9%B3%E5%8F%B0.png">  </p>
<h2 id="云计算平台的分类"><a href="#云计算平台的分类" class="headerlink" title="云计算平台的分类"></a>云计算平台的分类</h2><p>以 Openstack 为典型的虚拟化平台：  </p>
<ul>
<li>虚拟机构建和业务代码部署分离。  </li>
<li>可变的基础架构使后续维护风险变大。</li>
</ul>
<p>以谷歌 borg 为典型的基于进程的作业调度平台：  </p>
<ul>
<li>技术的迭代引发 borg 的换代需求。  </li>
<li>早期的隔离依靠 chroot jail 实现，一些不合理的设计需要在新产品中改进。<br>对象之间的强依赖 job 和 task 是强包含关系，不利于重组。<br>所有容器共享 IP，会导致端口冲突，隔离困难等问题。<br>为超级用户添加复杂逻辑导致系统过于复杂。</li>
</ul>
<h1 id="Kubernetes-架构基础"><a href="#Kubernetes-架构基础" class="headerlink" title="Kubernetes 架构基础"></a>Kubernetes 架构基础</h1><h2 id="Borg"><a href="#Borg" class="headerlink" title="Borg"></a>Borg</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Borg.png">  </p>
<h2 id="Google-Borg-简介"><a href="#Google-Borg-简介" class="headerlink" title="Google Borg 简介"></a>Google Borg 简介</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>物理资源利用率高。  </li>
<li>服务器共享，在进程级别做隔离。  </li>
<li>应用高可用，故障恢复时间短。  </li>
<li>调度策略灵活。  </li>
<li>应用接入和使用方便，提供了完备的 Job 描述语言，服务发现，实时状态监控和诊断工具。</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>对外隐藏底层资源管理和调度、故障处理等。  </li>
<li>实现应用的高可靠和高可用。  </li>
<li>足够弹性，支持应用跑在成千上万的机器上。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Workload"><a href="#Workload" class="headerlink" title="Workload"></a>Workload</h3><ul>
<li>prod：在线任务，长期运行、对延时敏感、面向终端用户等，比如<code>Gmail, Google Docs,Web Search</code>服务等。  </li>
<li>non-prod：离线任务，也称为批处理任务(Batch)，比如一些分布式计算服务等。</li>
</ul>
<h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><ul>
<li>一个Cell上跑一个集群管理服务系统<code>Brog</code>。  </li>
<li>通过定义Cell可以让</li>
</ul>
<h3 id="Job-和-Task"><a href="#Job-和-Task" class="headerlink" title="Job 和 Task"></a>Job 和 Task</h3><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><h2 id="Borg-架构"><a href="#Borg-架构" class="headerlink" title="Borg 架构"></a>Borg 架构</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Borg%E6%9E%B6%E6%9E%84.png">  </p>
<p>Borgmaster 主进程：  </p>
<ul>
<li>处理客户端 RPC 请求，比如创建 Job，查询 Job 等。  </li>
<li>维护系统组件和服务的状态，比如服务器、Task 等。  </li>
<li>负责与 Borglet 通信。</li>
</ul>
<p>Scheduler 进程：  </p>
<ul>
<li>调度策略：Worst Fit、Best Fit、Hybrid  </li>
<li>调度优化：<br>Score caching: 当服务器或者任务的状态未发生变更或者变更很少时，直接采用缓存数据，避免重复计算。<br>Equivalence classes: 调度同一 Job 下多个相同的 Task 只需计算一次。<br>Relaxed randomization: 引入一些随机性，即每次随机选择一些机器，只要符合需求的服务器数量达到一定值时，就可以停止计算，无需每次对 Cell 中所有服务器进行 feasibility   checking。</li>
</ul>
<p>Borglet：Borglet 是部署在所有服务器上的 Agent，负责接收 Borgmaster 进程的指令。  </p>
<h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><ul>
<li>被抢占的 non-prod 任务放回 pending queue，等待重新调度。  </li>
<li>多副本应用跨故障域部署。所谓故障域有大有小，比如相同机器、相同机架或相同电源插座等，一挂全挂。  </li>
<li>对于类似服务器或操作系统升级的维护操作，避免大量服务器同时进行。  </li>
<li>支持幂等性，支持客户端重复操作。  </li>
<li>当服务器状态变为不可用时，要控制重新调度任务的速率。因为 Borg 无法区分是节点故障还是出现了短暂的网络分区，如果是后者，静静地等待网络恢复更利于保障服务可用性。  </li>
<li>当某种“任务 @ 服务器”的组合出现故障时，下次重新调度时需避免这种组合再次出现，因为极大可能会再次出现相同故障。  </li>
<li>记录详细的内部信息，便于故障排查和分析。  </li>
<li>保障应用高可用的关键性设计原则：无论何种原因，即使 Borgmaster 或者 Borglet 挂掉、失联，都不能杀掉正在运行的服务（Task）。</li>
</ul>
<h2 id="Borg-系统自身高可用"><a href="#Borg-系统自身高可用" class="headerlink" title="Borg 系统自身高可用"></a>Borg 系统自身高可用</h2><ul>
<li>Borgmaster 组件多副本设计。  </li>
<li>采用一些简单的和底层（low-level）的工具来部署 Borg 系统实例，避免引入过多的外部依赖。  </li>
<li>每个 Cell 的 Borg 均独立部署，避免不同 Borg 系统相互影响。</li>
</ul>
<h2 id="资源利用率"><a href="#资源利用率" class="headerlink" title="资源利用率"></a>资源利用率</h2><ul>
<li>通过将在线任务（prod）和离线任务（non-prod，Batch）混合部署，空闲时，离线任务可以充分利用计算资源；繁忙时，在线任务通过抢占的方式保证优先得到执行，合理地利用资源。  </li>
<li>98% 的服务器实现了混部。  </li>
<li>90% 的服务器中跑了超过 25 个 Task 和 4500 个线程。  </li>
<li>在一个中等规模的 Cell 里，在线任务和离线任务独立部署比混合部署所需的服务器数量多出约 20%-30%。可以简单算一笔账，Google 的服务器数量在千万级别，按 20% 算也是百万级别，大概能省下的服务器采购费用就是百亿级别了，这还不包括省下的机房等基础设施和电费等费用。</li>
</ul>
<h2 id="Brog-调度原理"><a href="#Brog-调度原理" class="headerlink" title="Brog 调度原理"></a>Brog 调度原理</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Brog%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.png">  </p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>安全性隔离：  </p>
<ul>
<li>早期采用 Chroot jail，后期版本基于 Namespace。</li>
</ul>
<p>性能隔离：  </p>
<ul>
<li>采用基于 Cgroup 的容器技术实现。  </li>
<li>在线任务（prod）是延时敏感（latency-sensitive）型的，优先级高，而离线任务（non-prod，Batch）优先级低。  </li>
<li>Borg 通过不同优先级之间的抢占式调度来优先保障在线任务的性能，牺牲离线任务。  </li>
<li>Borg 将资源类型分成两类：<br>可压榨的（compressible），CPU 是可压榨资源，资源耗尽不会终止进程；<br>不可压榨的（non-compressible），内存是不可压榨资源，资源耗尽进程会被终止。</li>
</ul>
<h2 id="什么是-Kubernetes（K8s）"><a href="#什么是-Kubernetes（K8s）" class="headerlink" title="什么是 Kubernetes（K8s）"></a>什么是 Kubernetes（K8s）</h2><p>Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：  </p>
<ul>
<li>基于容器的应用部署、维护和滚动升级；  </li>
<li>负载均衡和服务发现；  </li>
<li>跨机器和跨地区的集群调度；  </li>
<li>自动伸缩；  </li>
<li>无状态服务和有状态服务；  </li>
<li>插件机制保证扩展性。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/kubelet.png">  </p>
<h2 id="命令式（-Imperative）vs-声明式（-Declarative）"><a href="#命令式（-Imperative）vs-声明式（-Declarative）" class="headerlink" title="命令式（ Imperative）vs 声明式（ Declarative）"></a>命令式（ Imperative）vs 声明式（ Declarative）</h2><p>命令式系统关注 “如何做”：在软件工程领域，命令式系统是写出解决某个问题、完成某个任务或者达到某个目标的明确步骤。此方法明确写出系统应该执行某指令，并且期待系统返回期望结果。  </p>
<p>声明式系统关注“做什么”：在软件工程领域，声明式系统指程序代码描述系统应该做什么而不是怎么做。仅限于描述要达到什么目的，如何达到目的交给系统。  </p>
<h2 id="声明式（Declaritive）系统规范"><a href="#声明式（Declaritive）系统规范" class="headerlink" title="声明式（Declaritive）系统规范"></a>声明式（Declaritive）系统规范</h2><p>命令式：<br>我要你做什么，怎么做，请严格按照我说的做。  </p>
<p>声明式：<br>我需要你帮我做点事，但是我只告诉你我需要你做什么，不是你应该怎么做。<br>直接声明：我直接告诉你我需要什么。<br>间接声明：我不直接告诉你我的需求，我会把我的需求放在特定的地方，请在方便的时候拿出来处理。  </p>
<p>幂等性：<br>状态固定，每次我要你做事，请给我返回相同结果。  </p>
<p>面向对象的：<br>把一切抽象成对象。  </p>
<h2 id="Kubernetes：声明式系统"><a href="#Kubernetes：声明式系统" class="headerlink" title="Kubernetes：声明式系统"></a>Kubernetes：声明式系统</h2><p>Kubernetes 的所有管理能力构建在对象抽象的基础上，核心对象包括：  </p>
<ul>
<li>Node：计算节点的抽象，用来描述计算节点的资源抽象、健康状态等。  </li>
<li>Namespace：资源隔离的基本单位，可以简单理解为文件系统中的目录结构。  </li>
<li>Pod：用来描述应用实例，包括镜像地址、资源需求等。 Kubernetes 中最核心的对象，也是打通应用和基础架构的秘密武器。  </li>
<li>Service：服务如何将应用发布成服务，本质上是负载均衡和域名服务的声明。</li>
</ul>
<h2 id="Kubernetes-采用与-Borg-类似的架构"><a href="#Kubernetes-采用与-Borg-类似的架构" class="headerlink" title="Kubernetes 采用与 Borg 类似的架构"></a>Kubernetes 采用与 Borg 类似的架构</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/k8s%E6%9E%B6%E6%9E%84.png">  </p>
<p>主要组件：  </p>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/k8s%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6.png">  </p>
<h2 id="Kubernetes-的主节点（Master-Node）"><a href="#Kubernetes-的主节点（Master-Node）" class="headerlink" title="Kubernetes 的主节点（Master Node）"></a>Kubernetes 的主节点（Master Node）</h2><h3 id="API服务器（API-Server）"><a href="#API服务器（API-Server）" class="headerlink" title="API服务器（API Server）"></a>API服务器（API Server）</h3><p>这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件（manifest files）。  </p>
<h3 id="群的数据存储（Cluster-Data-Store）"><a href="#群的数据存储（Cluster-Data-Store）" class="headerlink" title="群的数据存储（Cluster Data Store）"></a>群的数据存储（Cluster Data Store）</h3><p>Kubernetes使用<code>etcd</code>。这是一个强大的、稳定的、高可用的键值存储，被Kubernetes用于长久储存所有的<code>API</code>对象。  </p>
<h3 id="控制管理器（Controller-Manager）"><a href="#控制管理器（Controller-Manager）" class="headerlink" title="控制管理器（Controller Manager）"></a>控制管理器（Controller Manager）</h3><p>被称为<code>kube-controller manager</code>，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点（endpoint）控制器以及服务账户等。  </p>
<h3 id="调度器（Scheduler）"><a href="#调度器（Scheduler）" class="headerlink" title="调度器（Scheduler）"></a>调度器（Scheduler）</h3><p>调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。  </p>
<h2 id="Kubernetes-的工作节点（Worker-Node）"><a href="#Kubernetes-的工作节点（Worker-Node）" class="headerlink" title="Kubernetes 的工作节点（Worker Node）"></a>Kubernetes 的工作节点（Worker Node）</h2><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它还会定期执行被请求的容器的健康探测程序。  </p>
<h3 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h3><p>它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 pods 进行负载平衡。  </p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。  </p>
<ul>
<li>基本的 key-value 存储；  </li>
<li>监听机制；  </li>
<li>key 的过期及续约机制，用于监控和服务发现；  </li>
<li>原子 CAS 和 CAD，用于分布式锁和 leader 选举。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/etcd.png">  </p>
<h2 id="直接访问-etcd-的数据"><a href="#直接访问-etcd-的数据" class="headerlink" title="直接访问 etcd 的数据"></a>直接访问 etcd 的数据</h2><ul>
<li><p>通过 etcd 进程查看启动参数  </p>
</li>
<li><p>进入容器  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep etcd</span><br><span class="line">sh: ps: command not found</span><br></pre></td></tr></table></figure></li>
<li><p>怎么办？到主机 Namespace 查看 cert 信息  </p>
</li>
<li><p>进入容器查询数据  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line">etcdctl --endpoints https://localhost:2379 --cert /etc/kubernetes/pki/etcd/server.crt --key</span><br><span class="line">/etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt get --keys-only --prefix /</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听对象变化  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints https://localhost:2379 --cert /etc/kubernetes/pki/etcd/server.crt --key</span><br><span class="line">/etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt watch --prefix</span><br><span class="line">/registry/services/specs/default/mynginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="APIServer"><a href="#APIServer" class="headerlink" title="APIServer"></a>APIServer</h2><p>Kube-APIServer 是 Kubernetes 最重要的核心组件之一，主要提供以下功能：  </p>
<ul>
<li>提供集群管理的 REST API 接口，包括:认证 Authentication；授权 Authorization；准入 Admission（Mutating &amp; Valiating）。  </li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 APIServer 查询或修改数据，只有 APIServer 才直接操作 etcd）。  </li>
<li>APIServer 提供 etcd 数据缓存以减少集群对 etcd 的访问。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/APIServer.png">  </p>
<p>APIServer 展开  </p>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/APIServer%E5%B1%95%E5%BC%80.png">  </p>
<h2 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h2><ul>
<li>Controller Manager 是集群的大脑，是确保整个集群动起来的关键；  </li>
<li>作用是确保 Kubernetes 遵循声明式系统规范，确保系统的真实状态（Actual State）与用户定义的期望状态（Desired State）一致；  </li>
<li>Controller Manager 是多个控制器的组合，每个 Controller 事实上都是一个control loop，负责侦听其管控的对象，当对象发生变更时完成配置；  </li>
<li>Controller 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机制下确保最终一致性（ Eventual Consistency）。</li>
</ul>
<h2 id="控制器的工作流程"><a href="#控制器的工作流程" class="headerlink" title="控制器的工作流程"></a>控制器的工作流程</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">  </p>
<h2 id="Informer-的内部机制"><a href="#Informer-的内部机制" class="headerlink" title="Informer 的内部机制"></a>Informer 的内部机制</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Informer%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.png">  </p>
<h2 id="控制器的协同工作原理"><a href="#控制器的协同工作原理" class="headerlink" title="控制器的协同工作原理"></a>控制器的协同工作原理</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">  </p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>特殊的 Controller，工作原理与其他控制器无差别。<br>Scheduler 的特殊职责在于监控当前集群所有未调度的 Pod，并且获取当前集群所有节点的健康状况和资源使用情况，为待调度 Pod 选择最佳计算节点，完成调度。  </p>
<p>调度阶段分为：  </p>
<ul>
<li>Predict：过滤不能满足业务需求的节点，如资源不足、端口冲突等。  </li>
<li>Priority：按既定要素将满足调度需求的节点评分，选择最佳节点。  </li>
<li>Bind：将计算节点与 Pod 绑定，完成调度。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Scheduler.png">  </p>
<h2 id="Kubelet-1"><a href="#Kubelet-1" class="headerlink" title="Kubelet"></a>Kubelet</h2><p>Kubernetes 的初始化系统（init system）  </p>
<ul>
<li><p>从不同源获取 Pod 清单，并按需求启停 Pod 的核心组件：<br>Pod 清单可从本地文件目录，给定的 HTTPServer 或 Kube-APIServer 等源头获取；<br>Kubelet 将运行时，网络和存储抽象成了 CRI，CNI，CSI。  </p>
</li>
<li><p>负责汇报当前节点的资源信息和健康状态；  </p>
</li>
<li><p>负责 Pod 的健康检查和状态汇报。</p>
</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/kubelet2.png">  </p>
<h2 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h2><ul>
<li>监控集群中用户发布的服务，并完成负载均衡配置。  </li>
<li>每个节点的 Kube-Proxy 都会配置相同的负载均衡策略，使得整个集群的服务发现建立在分布式负载均衡器之上，服务调用无需经过额外的网络跳转（Network Hop）。  </li>
<li>负载均衡配置基于不同插件实现：<br>userspace。<br>操作系统网络协议栈不同的 Hooks 点和插件：iptables；ipvs。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Kube-Proxy.png">  </p>
<h2 id="推荐的-Add-ons"><a href="#推荐的-Add-ons" class="headerlink" title="推荐的 Add-ons"></a>推荐的 Add-ons</h2><ul>
<li>kube-dns：负责为整个集群提供 DNS 服务；  </li>
<li>Ingress Controller：为服务提供外网入口；  </li>
<li>MetricsServer：提供资源监控；  </li>
<li>Dashboard：提供 GUI；  </li>
<li>Fluentd-Elasticsearch：提供集群日志采集、存储与查询。</li>
</ul>
<h1 id="了解-kubectl"><a href="#了解-kubectl" class="headerlink" title="了解 kubectl"></a>了解 kubectl</h1><h2 id="Kubectl-命令和-kubeconfig"><a href="#Kubectl-命令和-kubeconfig" class="headerlink" title="Kubectl 命令和 kubeconfig"></a>Kubectl 命令和 kubeconfig</h2><ul>
<li>kubectl 是一个 Kubernetes 的命令行工具，它允许Kubernetes 用户以命令行的方式与 Kubernetes 交互，其默认读取配置文件 ~&#x2F;.kube&#x2F;config。  </li>
<li>kubectl 会将接收到的用户请求转化为 rest 调用以rest client 的形式与 apiserver 通讯。  </li>
<li>apiserver 的地址，用户信息等配置在 kubeconfig。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">certificate-authority-data: REDACTED</span><br><span class="line">server: https://127.0.0.1:54729</span><br><span class="line">name: kind-kind</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">cluster: kind-kind</span><br><span class="line">user: kind-kind</span><br><span class="line">name: kind-kind</span><br><span class="line">current-context: kind-kind</span><br><span class="line">kind: Config</span><br><span class="line">users:</span><br><span class="line">- name: kind-kind</span><br><span class="line">user:</span><br><span class="line">client-certificate-data: REDACTED</span><br><span class="line">client-key-data: REDACTED</span><br></pre></td></tr></table></figure>

<h2 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h2><p><code>kubectl get po –oyaml -w</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl 可查看对象。</span><br><span class="line">-oyaml 输出详细信息为 yaml 格式。</span><br><span class="line">-w watch 该对象的后续变化。</span><br><span class="line">-owide 以详细列表的格式查看对象。</span><br></pre></td></tr></table></figure>

<h2 id="Kubectl-describe"><a href="#Kubectl-describe" class="headerlink" title="Kubectl describe"></a>Kubectl describe</h2><p>kubectl describe 展示资源的详细信息和相关 Event。  </p>
<h2 id="kubectl-exec"><a href="#kubectl-exec" class="headerlink" title="kubectl exec"></a>kubectl exec</h2><p>kubectl exec 提供进入运行容器的通道，可以进入容器进行 debug 操作。  </p>
<h2 id="kubectl-logs"><a href="#kubectl-logs" class="headerlink" title="kubectl logs"></a>kubectl logs</h2><p>Kubectl logs 可查看 pod 的标准输入（stdout, stderr），与 tail 用法类似。  </p>
<h1 id="深入理解-Kubernetes"><a href="#深入理解-Kubernetes" class="headerlink" title="深入理解 Kubernetes"></a>深入理解 Kubernetes</h1><h2 id="云计算的传统分类"><a href="#云计算的传统分类" class="headerlink" title="云计算的传统分类"></a>云计算的传统分类</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%88%86%E7%B1%BB.png">  </p>
<h2 id="Kubernetes-生态系统"><a href="#Kubernetes-生态系统" class="headerlink" title="Kubernetes 生态系统"></a>Kubernetes 生态系统</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Kubernetes%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F.png">  </p>
<h2 id="Kubernetes-设计理念"><a href="#Kubernetes-设计理念" class="headerlink" title="Kubernetes 设计理念"></a>Kubernetes 设计理念</h2><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><ul>
<li>基于CRD的扩展  </li>
<li>插件化的生态系统</li>
</ul>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><ul>
<li>基于 replicaset，statefulset 的应用高可用  </li>
<li>Kubernetes 组件本身高可用</li>
</ul>
<h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul>
<li>多种 host Os 选择  </li>
<li>多种基础架构的选择  </li>
<li>多云和混合云</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>基于 TLS 提供服务  </li>
<li>Serviceaccount 和 user  </li>
<li>基于 Namespace 的隔离  </li>
<li>secret  </li>
<li>Taints，psp， networkpolicy</li>
</ul>
<h2 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/KM.png">  </p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul>
<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境。  </li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）。  </li>
<li>管理层：系统度量（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态 Provision 等）、策略管理（RBAC、Quota、PSP、NetworkPolicy 等）。  </li>
<li>接口层：Kubectl 命令行工具、客户端 SDK 以及集群联邦。  </li>
<li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴：<br>Kubernetes 外 部 ： 日 志 、 监 控 、 配 置 管 理 、 CI 、 CD 、 Workflow 、 FaaS 、 OTS 应 用 、ChatOps 等；<br>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等。</li>
</ul>
<h2 id="API-设计原则"><a href="#API-设计原则" class="headerlink" title="API 设计原则"></a>API 设计原则</h2><h3 id="所有-API-都应是声明式的"><a href="#所有-API-都应是声明式的" class="headerlink" title="所有 API 都应是声明式的"></a>所有 API 都应是声明式的</h3><ul>
<li>相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。  </li>
<li>声明式操作更易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性。  </li>
<li>此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标对象。</li>
</ul>
<h3 id="API-对象是彼此互补而且可组合的"><a href="#API-对象是彼此互补而且可组合的" class="headerlink" title="API 对象是彼此互补而且可组合的"></a>API 对象是彼此互补而且可组合的</h3><ul>
<li>这实际上鼓励 API 对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</li>
</ul>
<h3 id="高层-API-以操作意图为基础设计"><a href="#高层-API-以操作意图为基础设计" class="headerlink" title="高层 API 以操作意图为基础设计"></a>高层 API 以操作意图为基础设计</h3><ul>
<li>如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。  </li>
<li>因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。</li>
</ul>
<h3 id="低层-API-根据高层-API-的控制需要设计"><a href="#低层-API-根据高层-API-的控制需要设计" class="headerlink" title="低层 API 根据高层 API 的控制需要设计"></a>低层 API 根据高层 API 的控制需要设计</h3><ul>
<li>设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提高重用性的目的，低层 API的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。</li>
</ul>
<h3 id="尽量避免简单封装，不要有在外部-API-无法显式知道的内部隐藏的机制"><a href="#尽量避免简单封装，不要有在外部-API-无法显式知道的内部隐藏的机制" class="headerlink" title="尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制"></a>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制</h3><ul>
<li>简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性。  </li>
<li>例如 StatefulSet 和 ReplicaSet，本来就是两种 Pod 集合，那么 Kubernetes 就用不同 API 对象来定义它们，而不会说只用同一个 ReplicaSet，内部通过特殊的算法再来区分这个 ReplicaSet 是有状态的还是无状态。</li>
</ul>
<h3 id="API-操作复杂度与对象数量成正比"><a href="#API-操作复杂度与对象数量成正比" class="headerlink" title="API 操作复杂度与对象数量成正比"></a>API 操作复杂度与对象数量成正比</h3><ul>
<li>API 的操作复杂度不能超过 O(N)，否则系统就不具备水平伸缩性了。</li>
</ul>
<h3 id="API-对象状态不能依赖于网络连接状态"><a href="#API-对象状态不能依赖于网络连接状态" class="headerlink" title="API 对象状态不能依赖于网络连接状态"></a>API 对象状态不能依赖于网络连接状态</h3><ul>
<li>由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。</li>
</ul>
<h3 id="尽量避免让操作机制依赖于全局状态"><a href="#尽量避免让操作机制依赖于全局状态" class="headerlink" title="尽量避免让操作机制依赖于全局状态"></a>尽量避免让操作机制依赖于全局状态</h3><ul>
<li>因为在分布式系统中要保证全局状态的同步是非常困难的。</li>
</ul>
<h2 id="Kubernetes-如何通过对象的组合完成业务描述"><a href="#Kubernetes-如何通过对象的组合完成业务描述" class="headerlink" title="Kubernetes 如何通过对象的组合完成业务描述"></a>Kubernetes 如何通过对象的组合完成业务描述</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E4%B8%9A%E5%8A%A1%E6%8F%8F%E8%BF%B0.png">  </p>
<h2 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h2><ul>
<li>只有 APIServer 可以直接访问 etcd 存储，其他服务必须通过 Kubernetes API 来访问集群状态；  </li>
<li>单节点故障不应该影响集群的状态；  </li>
<li>在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求（比如网络分区或服务重启等）；  </li>
<li>所有组件都应该在内存中保持所需要的状态，APIServer 将状态写入 etcd 存储，而其他组件则通过 APIServer 更新并监听所有的变化；  </li>
<li>优先使用事件监听而不是轮询。</li>
</ul>
<h2 id="引导（Bootstrapping）原则"><a href="#引导（Bootstrapping）原则" class="headerlink" title="引导（Bootstrapping）原则"></a>引导（Bootstrapping）原则</h2><ul>
<li>Self-hosting 是目标。  </li>
<li>减少依赖，特别是稳态运行的依赖。  </li>
<li>通过分层的原则管理依赖。  </li>
<li>循环依赖问题的原则：<br>同时还接受其他方式的数据输入（比如本地文件等），这样在其他服务不可用时还可以手动配置引导服务；<br>状态应该是可恢复或可重新发现的；<br>支持简单的启动临时实例来创建稳态运行所需要的状态，使用分布式锁或文件锁等来协调不同状态的切换（通常称为 pivoting 技术）；<br>自动重启异常退出的服务，比如副本或者进程管理器等。</li>
</ul>
<h1 id="核心对象概览"><a href="#核心对象概览" class="headerlink" title="核心对象概览"></a>核心对象概览</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ul>
<li>Node 是 Pod 真正运行的主机，可以物理机，也可以是虚拟机。  </li>
<li>为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 Docker 或者 Rkt）、Kubelet 和 Kube-proxy 服务。</li>
</ul>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><strong>Namespace 是对一组资源和对象的抽象集合</strong>，比如可以用来将系统内部的对象划分为不同的项目组或用户组。  </p>
<p>常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 Namespace 的（默认是 default），而 Node, persistentVolumes等则不属于任何 Namespace。  </p>
<h2 id="什么是-Pod"><a href="#什么是-Pod" class="headerlink" title="什么是 Pod"></a>什么是 Pod</h2><ul>
<li>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes调度的基本单位。  </li>
<li>Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。  </li>
<li>同一个 Pod 中的不同容器可共享资源：共享网络 Namespace；可通过挂载存储卷共享存储；共享 Security Context。</li>
</ul>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E4%BB%80%E4%B9%88%E4%BA%8BPod.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">name: hello</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">- image: nginx:1.15</span><br><span class="line">name: nginx</span><br></pre></td></tr></table></figure>

<h2 id="如何通过-Pod-对象定义支撑应用运行"><a href="#如何通过-Pod-对象定义支撑应用运行" class="headerlink" title="如何通过 Pod 对象定义支撑应用运行"></a>如何通过 Pod 对象定义支撑应用运行</h2><p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/%E9%80%9A%E8%BF%87Pod%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E6%94%AF%E6%92%91%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C.png">  </p>
<h2 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h2><ul>
<li>通过存储卷可以将外挂存储挂载到 Pod 内部使用。  </li>
<li>存储卷定义包括两个部分: Volume 和 VolumeMounts。<br>Volume：定义 Pod 可以使用的存储卷来源；<br>VolumeMounts：定义存储卷如何 Mount 到容器内部。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">name: hello-volume</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">- image: nginx:1.15</span><br><span class="line">name: nginx</span><br><span class="line">volumeMounts:</span><br><span class="line">- name: data</span><br><span class="line">mountPath: /data</span><br><span class="line">volumes:</span><br><span class="line">- name: data</span><br><span class="line">emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pod-网络"><a href="#Pod-网络" class="headerlink" title="Pod 网络"></a>Pod 网络</h2><p>Pod的多个容器是共享网络 Namespace 的，这意味着：  </p>
<ul>
<li><p>同一个 Pod 中的不同容器可以彼此通过 Loopback 地址访问：<br>在第一个容器中起了一个服务 <a href="http://127.0.0.1/">http://127.0.0.1</a> 。<br>在第二个容器内，是可以通过 httpGet <a href="http://172.0.0.1/">http://172.0.0.1</a> 访问到该地址的。  </p>
</li>
<li><p>这种方法常用于不同容器的互相协作。</p>
</li>
</ul>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>Kubernetes 通过 Cgroups 提供容器资源管理的功能，可以限制每个容器的CPU 和内存使用，比如对于刚才创建的 deployment，可以通过下面的命令限制nginx 容器最多只用 50% 的 CPU 和 128MB 的内存：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl set resources deployment nginx-app -c=nginx --</span><br><span class="line">limits=cpu=500m,memory=128Mi</span><br><span class="line">deployment &quot;nginx&quot; resource requirements updated</span><br></pre></td></tr></table></figure>

<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>Kubernetes 作为一个面向应用的集群管理工具，需要确保容器在部署后确实处在正常的运行状态。  </p>
<ol>
<li>探针类型：</li>
</ol>
<ul>
<li>LivenessProbe：探测应用是否处于健康状态，如果不健康则删除并重新创建容器。  </li>
<li>ReadinessProbe：探测应用是否就绪并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量。  </li>
<li>StartupProbe：探测应用是否启动完成，如果在 failureThreshold*periodSeconds 周期内未就绪，则会应用进程会被重启。</li>
</ul>
<ol start="2">
<li>探活方式：</li>
</ol>
<ul>
<li>Exec  </li>
<li>TCP socket  </li>
<li>HTTP</li>
</ul>
<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><ul>
<li>ConfigMap 用来将非机密性的数据保存到键值对中。  </li>
<li>使用时， Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。  </li>
<li>ConfigMap 将环境配置信息和 容器镜像解耦，便于应用配置的修改。</li>
</ul>
<h2 id="密钥对象（Secret）"><a href="#密钥对象（Secret）" class="headerlink" title="密钥对象（Secret）"></a>密钥对象（Secret）</h2><ul>
<li>Secret 是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。  </li>
<li>使用 Secret 的好处是可以避免把敏感信息明文写在配置文件里。  </li>
<li>Kubernetes 集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问 AWS 存储的用户名密码。  </li>
<li>为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个 Secret 对象，而在配置文件中通过 Secret 对象引用这些敏感信息。  </li>
<li>这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</li>
</ul>
<h2 id="用户（User-Account）-amp-服务帐户（Service-Account）"><a href="#用户（User-Account）-amp-服务帐户（Service-Account）" class="headerlink" title="用户（User Account）&amp; 服务帐户（Service Account）"></a>用户（User Account）&amp; 服务帐户（Service Account）</h2><ul>
<li>用户帐户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 Pod 提供账户标识。  </li>
<li>用户帐户和服务帐户的一个区别是作用范围：<br>用户帐户对应的是人的身份，人的身份与服务的 Namespace 无关，所以用户账户是跨Namespace 的；<br>而服务帐户对应的是一个运行中程序的身份，与特定 Namespace 是相关的。</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 endpoints，由 Kube-proxy 负责将服务IP 负载均衡到这些 endpoints 上。  </p>
<p>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。  </p>
<p><img src="/2021/12/08/cloud-native-4-kubernetes-architectural-principles-and-object-design/Service.png">  </p>
<h2 id="副本集（Replica-Set）"><a href="#副本集（Replica-Set）" class="headerlink" title="副本集（Replica Set）"></a>副本集（Replica Set）</h2><ul>
<li>Pod 只是单个应用实例的抽象，要构建高可用应用，通常需要构建多个同样的副本，提供同一个服务。  </li>
<li>Kubernetes 为此抽象出副本集 ReplicaSet，其允许用户定义 Pod 的副本数，每一个 Pod 都会被当作一个无状态的成员进行管理，Kubernetes 保证总是有用户期望的数量的 Pod 正常运行。  </li>
<li>当某个副本宕机以后，控制器将会创建一个新的副本。  </li>
<li>当因业务负载发生变更而需要调整扩缩容时，可以方便地调整副本数量。</li>
</ul>
<h2 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h2><ul>
<li>部署表示用户对 Kubernetes 集群的一次更新操作。  </li>
<li>部署是一个比 RS 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。  </li>
<li>滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作。  </li>
<li>这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。  </li>
<li>以 Kubernetes 的发展方向，未来对所有长期伺服型的的业务的管理，都会通过 Deployment 来管理。</li>
</ul>
<h2 id="有状态服务集（StatefulSet）"><a href="#有状态服务集（StatefulSet）" class="headerlink" title="有状态服务集（StatefulSet）"></a>有状态服务集（StatefulSet）</h2><ul>
<li>对于 StatefulSet 中的 Pod，每个 Pod 挂载自己独立的存储，如果一个 Pod 出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来 Pod 的存储继续以它的状态提供服务。  </li>
<li>适合于 StatefulSet 的业务包括数据库服务 MySQL 和 PostgreSQL，集群化管理服务 ZooKeeper、etcd 等有状态服务。  </li>
<li>使用 StatefulSet，Pod 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet 做的只是将确定的 Pod 与确定的存储关联起来保证状态的连续性。</li>
</ul>
<h2 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h2><ul>
<li>Job 是 Kubernetes 用来控制批处理型任务的 API 对象。  </li>
<li>Job 管理的 Pod 根据用户的设置把任务成功完成后就自动退出。  </li>
<li>成功完成的标志根据不同的 spec.completions 策略而不同：<br>单 Pod 型任务有一个 Pod 成功就标志完成；<br>定数成功型任务保证有 N 个任务全部成功；<br>工作队列型任务根据应用确认的全局成功而标志成功。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>公司年会收获</title>
    <url>/2019/01/27/company-annual-meeting-harvest/</url>
    <content><![CDATA[<p>2019年1月23日，我参加了公司的年会彩排+表演。  </p>
<p>此次年会收获如下：  </p>
<ul>
<li>成功站在舞池中央，C位出道！  </li>
<li>步伐放慢一点，脚印踩实一些。  </li>
<li>有激情，才能带动一批人。  </li>
<li>再多坚持一会儿。</li>
</ul>
<p><img src="/2019/01/27/company-annual-meeting-harvest/center.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>收获</tag>
        <tag>年会</tag>
      </tags>
  </entry>
  <entry>
    <title>炒菜心得小结</title>
    <url>/2019/07/06/cooking-feeling/</url>
    <content><![CDATA[<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>女友工作了，于是开始商议在家自己做饭，顺便把第二天中午的也做好，带到公司去吃。<br>本文记录这段时间做饭炒菜的收获。<br>炒菜心得</p>
<p>炒菜前需要把菜洗干净，然后把菜和肉切薄。<br>接着进入炒菜步骤：</p>
<pre><code>首先，热锅冷油：先把锅烧热，再倒入冷油。
如果是肉，先倒肉，接着赶紧翻炒，防止粘锅。
肉翻的差不多后，倒入切好的蒜，可以入味和杀菌。
倒入料酒，去腥味。
倒入老抽酱油（凉菜用生抽）。
其次倒入不容易煮熟的菜，例如青椒，进行翻炒。
再倒入容易熟的菜进行翻炒。
洒盐。
快熟的时候关火，洒鸡精，然后用余温翻炒。
</code></pre>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>如果闻到糊味，就倒一些凉水。  </li>
<li>炒肉前可以加入料酒和酱油搅拌均匀放置。  </li>
<li>炒肉时可以放入适量的豆瓣酱。</li>
</ul>
<h2 id="小试牛刀-自制冒菜"><a href="#小试牛刀-自制冒菜" class="headerlink" title="小试牛刀_自制冒菜"></a>小试牛刀_自制冒菜</h2><pre><code>1，买一个冒菜底料（和火锅底料类似）
2，准备食材
</code></pre>
<p>素菜：鱼豆腐，娃娃菜，金针菇，海带，土豆片，土豆粉，火腿肠<br>荤菜：鸡胸肉，牛肉丸子，蟹棒，虾饺，毛肚，千层肚，午餐肉</p>
<pre><code>3，洗菜
4，切菜，切肉
5，烧水，煮沸
6，先倒入荤菜
7，再倒入素菜
8，煮熟，关火，试吃
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>认真做好一件事，真的很开心！</p>
]]></content>
      <categories>
        <category>Learn-cooking</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>炒菜</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂算法复杂度分析</title>
    <url>/2022/05/05/complexity-analysis/</url>
    <content><![CDATA[<h1 id="为什么要懂复杂度分析"><a href="#为什么要懂复杂度分析" class="headerlink" title="为什么要懂复杂度分析"></a>为什么要懂复杂度分析</h1><p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？  </p>
<p>你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？  </p>
<p>首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫<strong>事后统计法</strong>。但是，这种统计方法有非常大的局限性。  </p>
<ul>
<li><ol>
<li>测试结果非常依赖测试环境</li>
</ol>
</li>
<li><ol start="2">
<li>测试结果受数据规模的影响很大</li>
</ol>
</li>
</ul>
<p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。  </p>
<h1 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h1><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？  </p>
<p>这里有段非常简单的代码，求 1,2,3…n 的累加和  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据</strong>-<strong>运算</strong>-<strong>写数据</strong>。  </p>
<p>尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？  </p>
<p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。  </p>
<p>按照这个分析思路，我们再来看这段代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum = sum +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？  </p>
<p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n2遍，所以需要 2n2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) &#x3D; (2n2+2n+3)*unit_time。  </p>
<p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比</strong>。  </p>
<p>我们可以把这个规律总结成一个公式：  </p>
<p><img src="/2022/05/05/complexity-analysis/tn.png">  </p>
<p>其中，T(n)表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。  </p>
<p>所以，第一个例子中的 T(n) &#x3D; O(2n+2)，第二个例子中的 T(n) &#x3D; O(2n2+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。  </p>
<p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) &#x3D; O(n)； T(n) &#x3D; O(n2)。  </p>
<h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><h2 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h2><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。  </p>
<p>例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">0</span>;  <span class="comment">//常量级的执行时间</span></span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//常量级的执行时间</span></span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;  <span class="comment">//这两行代码被执行了 n 次</span></span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">   <span class="comment">//因此总的时间复杂度就是 O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;  <span class="comment">//这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关</span></span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;  <span class="comment">//这段代码循环了n次</span></span><br><span class="line">     sum_2 = sum_2 + q;  <span class="comment">//所以时间复杂度是O(n)</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;  <span class="comment">//这段代码循环了n*n次</span></span><br><span class="line">       sum_3 = sum_3 +  i * j; <span class="comment">//所以时间复杂度是O(n^2)</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//整段代码的时间复杂度就为 O(n^2) </span></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：<strong>总的时间复杂度*<em>**就**</em>*等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：<br>如果 T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么 T(n)&#x3D;T1(n)+T2(n)&#x3D;max(O(f(n)), O(g(n))) &#x3D;O(max(f(n), g(n))).  </p>
<h2 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h2><p>如果 T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么 T(n)&#x3D;T1(n)*T2(n)&#x3D;O(f(n))*O(g(n))&#x3D;O(f(n)*g(n)).<br>也就是说，假设 T1(n) &#x3D; O(n)，T2(n) &#x3D; O(n2)，则 T1(n) * T2(n) &#x3D; O(n3)。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;  <span class="comment">//这段代码循环了n次</span></span><br><span class="line">     ret = ret + f(i);  <span class="comment">//时间复杂度为T1(n) = O(n)</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)。</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;  <span class="comment">//时间复杂度为T2(n) = O(n)</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><p><img src="/2022/05/05/complexity-analysis/com-order.jpg">  </p>
<p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2n) 和 O(n!)。  </p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。  </p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。我们主要来看几种常见的<strong>多项式时间复杂度</strong>。  </p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p>注：O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> sum = i + j;</span><br></pre></td></tr></table></figure>

<p>因此，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，*<em>一般*</em>**情况下****，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。  </p>
<h3 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束，因此变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：  </p>
<p><img src="/2022/05/05/complexity-analysis/deng-cha.jpg">  </p>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x&#x3D;n 求解，x&#x3D;log2n，所以，这段代码的时间复杂度就是 O(log2n)。  </p>
<p>稍微改下代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的时间复杂度为 O(log3n)。  </p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。  </p>
<p>为什么？  </p>
<p>对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) &#x3D; O(C * log2n)，其中 C&#x3D;log32 是一个常量。基于我们前面的一个理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) &#x3D; O(f(n))**。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。  </p>
<p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。  </p>
<h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。  </p>
<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) &#x3D; O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) &#x3D; O(f(m) * f(n))。  </p>
<h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这段代码的作用：在一个无序的数组（array）中，查找变量 x 出现的位置，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] <span class="built_in">array</span>, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的复杂度是 O(n)，其中，n 代表数组的长度。  </p>
<p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] <span class="built_in">array</span>, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>貌似解决了，然而，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。  </p>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。  </p>
<ul>
<li><strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。  </li>
<li><strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</li>
</ul>
<h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度。  </p>
<p>以上述代码举例，要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中</strong>和<strong>不在数组中</strong>。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：  </p>
<p><img src="/2022/05/05/complexity-analysis/pj1.jpg">  </p>
<p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。  </p>
<h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现了一个往数组中插入数据的功能</span></span><br><span class="line"><span class="comment">// 当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</span></span><br><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">array</span> = new <span class="type">int</span>[n];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">          sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">       count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">array</span>[count] = val;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。  </p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1&#x2F;(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：  </p>
<p><img src="/2022/05/05/complexity-analysis/pj3.jpg">  </p>
<p>然而，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()<strong>第一个</strong>区别于 find() 的地方；对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。  </p>
<p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong>。  </p>
<p>每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。  </p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以可以忽略</span></span><br><span class="line">  <span class="type">int</span>[] a = new <span class="type">int</span>[n];  <span class="comment">//申请了一个大小为 n 的 int 类型数组</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//整段代码的空间复杂度就是 O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。  </p>
<p><img src="/2022/05/05/complexity-analysis/xian.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>Cooking_新疆大盘鸡</title>
    <url>/2020/07/19/cooking-xin-jiang-da-pan-ji/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>一个土豆  </li>
<li>一个红椒  </li>
<li>半只鸡  </li>
<li>4个蒜  </li>
<li>盐、鸡精、冰糖、胡椒粉、八角</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/1.jpg">  </p>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ul>
<li>热油放冰糖<br>上色</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/2.jpg">  </p>
<ul>
<li>油烧焦红色时倒入鸡肉翻炒</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/3.jpg">  </p>
<ul>
<li><p>翻炒直到鸡肉有颜色（3-5分钟）  </p>
</li>
<li><p>倒入蒜，料酒，酱油，味极鲜翻炒片刻后加八角  </p>
</li>
<li><p>加热水，盖上锅煮20分钟<br>途中加点盐，花椒粉</p>
</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/4.jpg">  </p>
<ul>
<li>加入土豆块，青椒，红椒，洋葱片烧10分钟左右</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/5.jpg">  </p>
<ul>
<li>加入鸡精翻炒一下，出锅</li>
</ul>
<p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/6.jpg">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>只要勤加练习，也能做出家乡的美味，感谢女友在旁的指导，哈哈哈。  </p>
]]></content>
      <categories>
        <category>Learn-cooking</category>
      </categories>
      <tags>
        <tag>厨艺</tag>
        <tag>大盘鸡</tag>
        <tag>新疆</tag>
      </tags>
  </entry>
  <entry>
    <title>Cooking_新疆手抓饭</title>
    <url>/2020/10/19/cooking-xin-jiang-shou-zhua-fan/</url>
    <content><![CDATA[<p>国庆期间去了一家新疆人开的新疆饭馆吃抓饭，一点也不正宗，尽是米饭，还是自己动手丰衣足食。  </p>
<h2 id="准备食材"><a href="#准备食材" class="headerlink" title="准备食材"></a>准备食材</h2><p>红萝卜两根，（皮牙子）洋葱一个，鸡翅根７-８个，盛一碗米饭泡着。  </p>
<p>红萝卜切成条，洋葱切成片，鸡肉切成块。</p>
<h2 id="开炒"><a href="#开炒" class="headerlink" title="开炒"></a>开炒</h2><p>倒入油，倒多一些，放入鸡肉翻炒，加盐一勺，加花椒粉一勺，加孜然粉一勺，肉炒3-5分钟后加入洋葱和胡萝卜，加盐两勺，翻炒至7-8分熟关火，将炒好的菜倒入电饭煲中。  </p>
<p><img src="/2020/10/19/cooking-xin-jiang-shou-zhua-fan/1.jpg">  </p>
<h2 id="蒸饭"><a href="#蒸饭" class="headerlink" title="蒸饭"></a>蒸饭</h2><p>倒入米粉，加水，合上电饭锅，开始蒸，等结束后开锅加入鸡精再翻一下。  </p>
<p><img src="/2020/10/19/cooking-xin-jiang-shou-zhua-fan/2.jpg">  </p>
<h2 id="出锅"><a href="#出锅" class="headerlink" title="出锅"></a>出锅</h2><p><img src="/2020/10/19/cooking-xin-jiang-shou-zhua-fan/3.jpg">  </p>
<h2 id="2020-10-25更新"><a href="#2020-10-25更新" class="headerlink" title="2020-10-25更新"></a>2020-10-25更新</h2><ul>
<li>一定要在蒸饭前多加盐，不然吃起来真的没味道。  </li>
<li>水放适中即可，不要放太多，不然出锅就容易粘，可以出锅前先焖一会。</li>
</ul>
]]></content>
      <categories>
        <category>Learn-cooking</category>
      </categories>
      <tags>
        <tag>厨艺</tag>
        <tag>大盘鸡</tag>
        <tag>新疆</tag>
      </tags>
  </entry>
  <entry>
    <title>Course MIT.6092 Introduction to Programming in Java</title>
    <url>/2024/06/21/course-mit-6092-introduction-to-programming-in-java/</url>
    <content><![CDATA[<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><ul>
<li>所属大学：MIT</li>
<li>先修要求：无</li>
<li>编程语言：Java</li>
<li>课程语言：英语</li>
<li>课程难度：🌟</li>
<li>预计学时：20小时  </li>
<li>Github: <a href="https://github.com/OctopusLian/mit-6092-introduction-to-programming-in-java">MIT.6092 Introduction to Programming in Java</a></li>
</ul>
<p>MIT出的Java入门课程，总共7节课程，每节课大概一个小时。<br>课程包括入门<code>Java</code>所需的基础知识概念，<code>Java</code>代码风格，以及如何<code>Debug</code>。<br>第五节和第六节会将结合所学知识做一个简单的绘图软件，很有趣。  </p>
<h1 id="作业展示"><a href="#作业展示" class="headerlink" title="作业展示"></a>作业展示</h1><p><img src="/2024/06/21/course-mit-6092-introduction-to-programming-in-java/hw-book.png">  </p>
<p><img src="/2024/06/21/course-mit-6092-introduction-to-programming-in-java/hw-graphics.png">    </p>
]]></content>
      <categories>
        <category>CSelfLearning</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基础-技术选型</title>
    <url>/2023/05/19/crawler-basic-technology-selection/</url>
    <content><![CDATA[<h1 id="Scrapy-VS-requests-beautifulsoup"><a href="#Scrapy-VS-requests-beautifulsoup" class="headerlink" title="Scrapy VS requests+beautifulsoup"></a>Scrapy VS requests+beautifulsoup</h1><ul>
<li>1.<code>requests</code>和<code>beautifulsoup</code>都是库，<code>scrapy</code>是框架  </li>
<li>2.<code>scrapy</code>框架中可以加入<code>requests</code>和<code>beautifulsoup</code>  </li>
<li>3.<code>scrapy</code>基于<code>twisted</code>，性能是最大的优势  </li>
<li>4.<code>scrapy</code>方便拓展，提供了很多内置的功能  </li>
<li>5.<code>scrapy</code>内置的<code>css</code>和<code>xpath selector</code>非常方便，<code>beautifulsoup</code>最大的缺点就是慢</li>
</ul>
<h1 id="爬虫能做什么"><a href="#爬虫能做什么" class="headerlink" title="爬虫能做什么"></a>爬虫能做什么</h1><ul>
<li>1.搜索引擎：百度、Google  </li>
<li>2.推荐引擎：今日头条  </li>
<li>3.机器学习的数据样本  </li>
<li>4.数据分析、舆情分析等</li>
</ul>
]]></content>
      <categories>
        <category>LearnCrawler</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
        <tag>requests</tag>
        <tag>beautifulsoup</tag>
      </tags>
  </entry>
  <entry>
    <title>CS50 Lab 1_Population Growth</title>
    <url>/2023/12/20/cs50-lab-1-population-growth/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>获取<code>startSize</code>和<code>endSize</code>  </li>
<li>使用<code>do while</code>做好范围限制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    n = get_int(<span class="string">&quot;Positive Integer: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>if</code>语句判断<code>startSize</code>和<code>endSize</code>是否相等  </li>
<li>如果相等，输出<code>Years</code>为0  </li>
<li>如果不相等，根据出生人数➗3，死亡人数➗4，每计算一次<code>Years</code>加1</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cs50.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Prompt for start size</span></span><br><span class="line">    <span class="type">int</span> startSize;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        startSize = get_int(<span class="string">&quot;Start size: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (startSize &lt; <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Prompt for end size</span></span><br><span class="line">    <span class="type">int</span> endSize;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        endSize = get_int(<span class="string">&quot;End size: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (endSize &lt; startSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Calculate number of years until we reach threshold</span></span><br><span class="line">    <span class="type">int</span> years = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (startSize != endSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;years: %i\n&quot;,years);</span></span><br><span class="line">            <span class="type">int</span> birth = startSize / <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;birth: %i\n&quot;,birth);</span></span><br><span class="line">            <span class="type">int</span> death = startSize / <span class="number">4</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;death: %i\n&quot;,death);</span></span><br><span class="line">            startSize = startSize + birth - death;</span><br><span class="line">            <span class="comment">//printf(&quot;startSize: %i\n&quot;,startSize);</span></span><br><span class="line">            years++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (startSize &lt; endSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Print number of years</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Years: %i&quot;</span>,years);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cs-self-learning</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CS50</tag>
      </tags>
  </entry>
  <entry>
    <title>Course UCI Programming with Google Go</title>
    <url>/2024/06/17/course-uci-programming-with-google-go/</url>
    <content><![CDATA[<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><ul>
<li>所属大学：UC Irvine</li>
<li>先修要求：无</li>
<li>编程语言：Go  </li>
<li>课程语言：英语</li>
<li>课程难度：🌟🌟</li>
<li>预计学时：50小时  </li>
<li>Github: <a href="https://github.com/OctopusLian/uci-programming-with-google-go-specialization">UCI Programming with Google Go</a></li>
</ul>
<p>UC Irvine在Coursera上出的Go语言入门课程，分成了三门课程来讲授Go语言的基础语法，特性和并发。<br>一门课程分四周，每周都会有测验，作业和学生互评。文档齐全，适合自学。  </p>
<h1 id="学完感受"><a href="#学完感受" class="headerlink" title="学完感受"></a>学完感受</h1><p>起因是受到一位大佬<a href="https://github.com/PKUFlyingPig">PKUFlyingPig</a>的影响，他说  </p>
<blockquote>
<p>试想如果有人能把艰深的知识点嚼碎嚼烂，用生动直白的方式呈现给你，还有那么多听起来就很 fancy，种类繁多的 project 来巩固你的理论知识，<br>你会觉得他们真的是在倾尽全力想方设法地让你完全掌握这门课，你会觉得不学好它简直是对这些课程建设者的侮辱。  </p>
</blockquote>
<p>我一直很想找到这门课，却一直缺乏行动，而现在，我也将成为这场行动的一份子。  </p>
<p>我不能说国外的课程是最好的，但目前来看它确实是适合我的，在这里，我找到了学习的乐趣。  </p>
<p>接下来我将按照计划，重新构建自己的计算机知识体系。最后引用一句话作为本文结尾：    </p>
<blockquote>
<p>如果你可以在三年不到的时间里就能建立起整座 CS 的基础大厦，能有相对扎实的数学功底和代码能力，<br>经历过数十个千行代码量的 Project 的洗礼， 掌握至少 C&#x2F;C++&#x2F;Java&#x2F;JS&#x2F;Python&#x2F;Go&#x2F;Rust 等主流语言，<br>对算法、电路、体系、网络、操统、编译、人工智能、机器学习、计算机视觉、自然语言处理、<br>强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、<br>Web开发、云服务、超算等等方面均有涉猎。</p>
<p>我想，你将有足够的底气和自信选择自己感兴趣的方向，无论是就业还是科研，你都将有相当的竞争力。<br>因为我坚信，既然你能坚持听我 BB 到这里，你一定不缺学好 CS 的能力，<br>你只是没有一个好的老师，给你讲一门好的课程。  </p>
</blockquote>
]]></content>
      <categories>
        <category>CSelfLearning</category>
      </categories>
      <tags>
        <tag>coursera</tag>
        <tag>go</tag>
        <tag>UCI</tag>
      </tags>
  </entry>
  <entry>
    <title>安装部署一个kubernetes集群</title>
    <url>/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/</url>
    <content><![CDATA[<h1 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h1><p><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/k8s%E6%9E%B6%E6%9E%84.png">  </p>
<ul>
<li>Master：负责集群的管理  </li>
<li>Node：计算节点，负责跑任务  </li>
<li>kubelet：相当于master的agent  </li>
<li>kube-proxy：网络  </li>
<li>Docker Engine：运行管理容器  </li>
<li>Etcd Cluster：存储k8s的数据</li>
</ul>
<p><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/k8s%E6%9E%B6%E6%9E%84%E5%9B%BEmn.png">  </p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：  </p>
<ul>
<li>一台或多台机器，操作系统是Linux&#x2F;CentOS  </li>
<li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多  </li>
<li>集群中所有机器之间网络互通  </li>
<li>可以访问外网，需要拉取镜像  </li>
<li>禁止swap分区<br>临时关闭swap  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># swapoff -a</span><br></pre></td></tr></table></figure></li>
</ul>
<p>永久关闭swap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/fstab</span><br><span class="line"></span><br><span class="line">注释调swap那一行后重启即可</span><br></pre></td></tr></table></figure>
<ul>
<li><p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># systemctl stop firewalld</span><br><span class="line"># systemctl disable firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭selinux  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"># setenforce 0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>添加主机名与IP对应关系（记得设置主机名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/hosts</span><br><span class="line">192.168.31.140 k8s-master  // 如果是部署单节点集群，配置一个即可</span><br><span class="line">192.168.32.141 k8s-node01</span><br><span class="line">192.168.32.142 k8s-node02</span><br></pre></td></tr></table></figure>


<p>将桥接的IPv4流量传递到iptables的链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># sysctl --system</span><br></pre></td></tr></table></figure>


<h1 id="所有节点安装Docker-x2F-kubeadm-x2F-kubelet"><a href="#所有节点安装Docker-x2F-kubeadm-x2F-kubelet" class="headerlink" title="所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet"></a>所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet</h1><p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。  </p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>下载最新版本的Docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># apt install docker.io</span><br><span class="line"></span><br><span class="line"># docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:           20.10.12</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.16.2</span><br><span class="line"> Git commit:        20.10.12-0ubuntu2~20.04.1</span><br><span class="line"> Built:             Wed Apr  6 02:14:38 2022</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.12</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.16.2</span><br><span class="line">  Git commit:       20.10.12-0ubuntu2~20.04.1</span><br><span class="line">  Built:            Thu Feb 10 15:03:35 2022</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.2.6-0ubuntu1~16.04.6+esm1</span><br><span class="line">  GitCommit:        </span><br><span class="line"> runc:</span><br><span class="line">  Version:          spec: 1.0.1-dev</span><br><span class="line">  GitCommit:        </span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        </span><br></pre></td></tr></table></figure>

<h2 id="添加访问公钥"><a href="#添加访问公钥" class="headerlink" title="添加访问公钥"></a>添加访问公钥</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br></pre></td></tr></table></figure>

<h2 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h2><p>因为考虑不能翻墙，所以选择阿里云源。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>更新缓存索引  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>

<h2 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定为 1.16.15版本</span><br><span class="line">apt install  kubectl=1.16.15-00 kubelet=1.16.15-00 kubeadm=1.16.15-00 -y</span><br></pre></td></tr></table></figure>

<p>开机自启kubelet  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<p>验证  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;16&quot;, GitVersion:&quot;v1.16.15&quot;, GitCommit:&quot;2adc8d7091e89b6e3ca8d048140618ec89b39369&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-09-02T11:40:00Z&quot;, GoVersion:&quot;go1.13.15&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line"></span><br><span class="line"># kubeadm version</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;16&quot;, GitVersion:&quot;v1.16.15&quot;, GitCommit:&quot;2adc8d7091e89b6e3ca8d048140618ec89b39369&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-09-02T11:37:34Z&quot;, GoVersion:&quot;go1.13.15&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># kubelet --version</span><br><span class="line">Kubernetes v1.16.15</span><br></pre></td></tr></table></figure>

<h1 id="部署Kubernetes-Master"><a href="#部署Kubernetes-Master" class="headerlink" title="部署Kubernetes Master"></a>部署Kubernetes Master</h1><p>在192.168.31.140（Master）执行。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.31.140 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.16.15 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--ignore-preflight-errors=all</span><br></pre></td></tr></table></figure>

<ul>
<li>apiserver-advertise-address：内网的IP地址  </li>
<li>image-repository：指定镜像仓库  </li>
<li>kubernetes-version：和下载的<code>kubelet</code>版本一致</li>
<li>service-cidr：kube-proxy的IP  </li>
<li>pod-network-cidr：每个容器的IP</li>
</ul>
<p>注：由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。  </p>
<p>使用kubectl工具：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line"># cat .kube/config </span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    一堆字符串，省略...</span><br><span class="line">    server: https://192.168.33.104:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    一堆字符串，省略...</span><br><span class="line">    client-key-data:</span><br><span class="line">    一堆字符串，省略...</span><br></pre></td></tr></table></figure>

<h1 id="部署Pod网络插件（CNI）"><a href="#部署Pod网络插件（CNI）" class="headerlink" title="部署Pod网络插件（CNI）"></a>部署Pod网络插件（CNI）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>查看是否启动成功  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -n kube-system</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6d8c4cb4d-7j6bz          1/1     Running   0          27m</span><br><span class="line">coredns-6d8c4cb4d-kmdk5          1/1     Running   0          27m</span><br><span class="line">etcd-ubuntu                      1/1     Running   0          27m</span><br><span class="line">kube-apiserver-ubuntu            1/1     Running   0          27m</span><br><span class="line">kube-controller-manager-ubuntu   1/1     Running   0          27m</span><br><span class="line">kube-flannel-ds-d275s            1/1     Running   0          2m15s</span><br><span class="line">kube-proxy-n94jd                 1/1     Running   0          27m</span><br><span class="line">kube-scheduler-ubuntu            1/1     Running   0          27m</span><br></pre></td></tr></table></figure>

<h1 id="加入Kubernetes-Node"><a href="#加入Kubernetes-Node" class="headerlink" title="加入Kubernetes Node"></a>加入Kubernetes Node</h1><p>在192.168.33.141（Node1）执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubeadm join 192.168.33.141:6443 --token 5vo1hz.0snnkh9fltyta36u --discovery-token-ca-cert-hash sha256:&quot;&lt;kubernetes master token&gt;&quot;</span><br></pre></td></tr></table></figure>

<p><code>discovery-token-ca-cert-hash</code>是在<code>kubeadm init</code>后的时候生成的，如果找不到这个token，可以使用命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.33.104:6443 --token 5vo1hz.0snnkh9fltyta36u --discovery-token-ca-cert-hash sha256:&quot;&lt;kubernetes master token&gt;&quot;</span><br></pre></td></tr></table></figure>
<h1 id="设置Master单节点集群"><a href="#设置Master单节点集群" class="headerlink" title="设置Master单节点集群"></a>设置Master单节点集群</h1><p>在<code>Master</code>节点输入  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<p>该命令含义是：移除所有以<code>node-role.kubernetes.io/master</code>为键的<code>Taint</code>  </p>
<h1 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h1><p>在<code>master</code>上运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /root/k8s-ha-install/dashboard/</span><br><span class="line"># kubectl create -f .</span><br></pre></td></tr></table></figure>

<p>更改dashboard的svc为NodePort：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/dashboard1.png">  </p>
<p>因为<strong>ClusterIP只对集群内部可见，NodePort对外部可见</strong>。  </p>
<p>然后查看端口号  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get svc kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/dashboard2.png">  </p>
<p>访问 ip:30036，即可访问k8s的仪表盘。  </p>
<p>查看token值：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>在仪表盘中输入<code>Token</code>即可。<br><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/dashboard3.png">  </p>
<p><img src="/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/dashboard4.png">  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/architectforest/p/12982886.html">linux(centos8): 临时关闭&#x2F;永久关闭交换分区swap？</a>  </p>
<p><a href="https://github.com/dotbalo/k8s-ha-install">超全面、超详细的Kubernetes视频教程，基于最新K8s进行讲解</a>  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>单例设计模式</title>
    <url>/2021/12/16/design-pattern-singleton/</url>
    <content><![CDATA[<h1 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h1><h2 id="单例的定义"><a href="#单例的定义" class="headerlink" title="单例的定义"></a>单例的定义</h2><p>一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。  </p>
<h2 id="单例的用处"><a href="#单例的用处" class="headerlink" title="单例的用处"></a>单例的用处</h2><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。  </p>
<h1 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h1><p>要实现一个单例，我们需要关注的点无外乎下面几个：  </p>
<ul>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；  </li>
<li>考虑对象创建时的线程安全问题；  </li>
<li>考虑是否支持延迟加载；  </li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。  </p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。  </p>
<h2 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h2><p>既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。  </p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。  </p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。  </p>
<h1 id="单例存在哪些问题"><a href="#单例存在哪些问题" class="headerlink" title="单例存在哪些问题?"></a>单例存在哪些问题?</h1><h2 id="单例对-OOP-特性的支持不友好"><a href="#单例对-OOP-特性的支持不友好" class="headerlink" title="单例对 OOP 特性的支持不友好"></a>单例对 OOP 特性的支持不友好</h2><h2 id="单例会隐藏类之间的依赖关系"><a href="#单例会隐藏类之间的依赖关系" class="headerlink" title="单例会隐藏类之间的依赖关系"></a>单例会隐藏类之间的依赖关系</h2><h2 id="单例对代码的扩展性不友好"><a href="#单例对代码的扩展性不友好" class="headerlink" title="单例对代码的扩展性不友好"></a>单例对代码的扩展性不友好</h2><h2 id="单例对代码的可测试性不友好"><a href="#单例对代码的可测试性不友好" class="headerlink" title="单例对代码的可测试性不友好"></a>单例对代码的可测试性不友好</h2><h2 id="单例不支持有参数的构造函数"><a href="#单例不支持有参数的构造函数" class="headerlink" title="单例不支持有参数的构造函数"></a>单例不支持有参数的构造函数</h2><h1 id="有何替代解决方案？"><a href="#有何替代解决方案？" class="headerlink" title="有何替代解决方案？"></a>有何替代解决方案？</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h2 id="将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量）"><a href="#将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量）" class="headerlink" title="将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量）"></a>将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量）</h2><h1 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h1><p>单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。  </p>
<h1 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h1><p>通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象  </p>
<h1 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h1><ul>
<li>“进程唯一”指的是进程内唯一、进程间不唯一。</li>
</ul>
<h1 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h1><p>“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。  </p>
<p>通过一个Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。  </p>
]]></content>
      <categories>
        <category>Learn-DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则四：接口隔离</title>
    <url>/2021/12/18/design-principle-interface-segregation/</url>
    <content><![CDATA[<h1 id="如何理解“接口隔离原则”？"><a href="#如何理解“接口隔离原则”？" class="headerlink" title="如何理解“接口隔离原则”？"></a>如何理解“接口隔离原则”？</h1><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP。<br>Robert Martin 在 SOLID 原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。  </p>
<p>理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：  </p>
<ul>
<li>一组 API 接口集合  </li>
<li>单个 API 接口或函数  </li>
<li>OOP 中的接口概念</li>
</ul>
<h1 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 API 接口集合</h1><p>例如，微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？  </p>
<ul>
<li>常规做法：只需要在 UserService中新添加一个 deleteUserByCellphone() 或 deleteUserById() 接口就可以了。</li>
</ul>
<p>这个方法可以解决问题，但是也隐藏了一些安全隐患。<br>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 UserService 中，那所有使用到 UserService的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。  </p>
<p>最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。  </p>
<p>如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。  </p>
<p>参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体代码实现如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RestrictedUserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, RestrictedUserService &#123;</span><br><span class="line">    <span class="comment">// ... 省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。  </p>
<h1 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 API 接口或函数</h1><p>函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long max;</span><br><span class="line">    <span class="keyword">private</span> Long min;</span><br><span class="line">    <span class="keyword">private</span> Long average;</span><br><span class="line">    <span class="keyword">private</span> Long sum;</span><br><span class="line">    <span class="keyword">private</span> Long percentile99;</span><br><span class="line">    <span class="keyword">private</span> Long percentile999;</span><br><span class="line">    <span class="comment">//... 省略 constructor/getter/setter 等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123;</span><br><span class="line">    <span class="type">tatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">    <span class="comment">//... 省略计算逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，count() 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。<br>按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Long <span class="title function_">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ... 省略其他统计函数...</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别：  </p>
<ul>
<li>单一职责原则针对的是模块、类、接口的设计。  </li>
<li>而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</li>
</ul>
<h1 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h1><p>假设我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig，具体的代码实现如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">// 配置中心（比如 zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="comment">// 省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfig</span><span class="params">(ConfigSource configSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从 configSource 加载配置到 address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> &#123; <span class="comment">//... 省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//... 省略... &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。但是，因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。  </p>
<p>为了实现这样一个功能需求，我们设计实现了一个 ScheduledUpdater 类，以固定时间频率（periodInSeconds）来调用 RedisConfig、KafkaConfig 的 update() 方法更新配置信息。具体的代码实现如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> implemets Updater &#123;</span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> implemets Updater &#123;</span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//... 省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledUpdater</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThread</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduleUpdater</span><span class="params">(Updater updater, <span class="type">long</span> initialDelayInSeconds, <span class="type">long</span> periodInSeconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updater = updater;</span><br><span class="line">        <span class="built_in">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="built_in">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.initialDelayInSeconds, <span class="built_in">this</span>.periodInSeconds, TimeUnit.SECONDS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>(<span class="comment">/* 省略参数 */</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlConfig</span>(configSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>)</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line"></span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>)</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚的热更新的需求我们已经搞定了。  </p>
<p>现在，我们又有了一个新的监控功能需求。通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的。<br>所以，我们希望能有一种更加方便的配置信息查看方式。  </p>
<p>我们可以在项目中开发一个内嵌的 SimpleHttpServer，输出项目的配置信息到一个固定的HTTP 地址，比如：<code>http://127.0.0.1:2389/config</code>。<br>我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 MySQL 和 Redis的配置信息，不想暴露 Kafka 的配置信息。  </p>
<p>为了实现这样一个功能，我们还需要对上面的代码做进一步改造。改造之后的代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">    String <span class="title function_">outputInPlainText</span><span class="params">()</span>;</span><br><span class="line">    Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> implemets Updater, Viewer &#123;</span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> <span class="keyword">implements</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHttpServer</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">            viewers.put(urlDirectory, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Viewer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlConfig</span>(configSource)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleHttpServer</span> <span class="variable">simpleHttpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpServer</span>(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2</span>)</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，热更新和监控的需求我们就都实现了。  </p>
<h2 id="回顾这个例子的设计思想"><a href="#回顾这个例子的设计思想" class="headerlink" title="回顾这个例子的设计思想"></a>回顾这个例子的设计思想</h2><p>我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则。  </p>
]]></content>
      <categories>
        <category>Learn-DesignPattern</category>
      </categories>
      <tags>
        <tag>接口隔离</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则三：里式替换</title>
    <url>/2021/12/18/design-principle-liskov-substitution/</url>
    <content><![CDATA[<h1 id="如何理解“里式替换原则”？"><a href="#如何理解“里式替换原则”？" class="headerlink" title="如何理解“里式替换原则”？"></a>如何理解“里式替换原则”？</h1><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。<br>这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的：  </p>
<blockquote>
<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。  </p>
</blockquote>
<p>在 1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则，英文原话是这样的：  </p>
<blockquote>
<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。  </p>
</blockquote>
<p>因此，中文描述即为：<strong>子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</strong>  </p>
<p>例如，如下代码中，父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> String appToken;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(httpClient);</span><br><span class="line">        <span class="built_in">this</span>.appId = appId;</span><br><span class="line">        <span class="built_in">this</span>.appToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(Transporter transporter)</span> &#123;</span><br><span class="line">        <span class="type">Reuqest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">        <span class="comment">//... 省略设置 request 中数据值的代码...</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> transporter.sendRequest(request);</span><br><span class="line">        <span class="comment">//... 省略其他逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> <span class="title class_">SecurityTransporter</span>(<span class="comment">/* 省略参数 */</span>););</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。  </p>
<p>疑问：刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？  </p>
<p>我们还是通过刚才这个例子来解释一下：对 SecurityTransporter 类中sendRequest() 函数稍加改造一下。改造前，如果 appId 或者 appToken 没有设置，我们就不做校验；改造后，如果 appId 或者 appToken 没有设置，则直接抛出NoAuthorizationRuntimeException 未授权异常。  </p>
<p>改造前后的代码对比如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="comment">//... 省略其他代码..</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="comment">//... 省略其他代码..</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoAuthorizationRuntimeException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在改造之后的代码中，如果传递进 demoFunction() 函数的是父类 Transporter 对象，那demoFunction() 函数并不会有异常抛出，但如果传递给 demoFunction() 函数的是子类<br>SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出。<br>尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进 demoFunction 函数之后，整个程序的逻辑行为有了改变。  </p>
<p>虽然改造之后的代码仍然可以通过 Java 的多态语法，动态地用子类 SecurityTransporter来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。<br>里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。  </p>
<h1 id="哪些代码明显违背了-LSP？"><a href="#哪些代码明显违背了-LSP？" class="headerlink" title="哪些代码明显违背了 LSP？"></a>哪些代码明显违背了 LSP？</h1><p>里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。  </p>
<h2 id="进一步解读"><a href="#进一步解读" class="headerlink" title="进一步解读"></a>进一步解读</h2><p>子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。  </p>
<p>为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。  </p>
<h2 id="子类违背父类声明要实现的功能"><a href="#子类违背父类声明要实现的功能" class="headerlink" title="子类违背父类声明要实现的功能"></a>子类违背父类声明要实现的功能</h2><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。  </p>
<h2 id="子类违背父类对输入、输出、异常的约定"><a href="#子类违背父类对输入、输出、异常的约定" class="headerlink" title="子类违背父类对输入、输出、异常的约定"></a>子类违背父类对输入、输出、异常的约定</h2><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。  </p>
<p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。  </p>
<p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。  </p>
<h2 id="子类违背父类注释中所罗列的任何特殊说明"><a href="#子类违背父类注释中所罗列的任何特殊说明" class="headerlink" title="子类违背父类注释中所罗列的任何特殊说明"></a>子类违背父类注释中所罗列的任何特殊说明</h2><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。  </p>
<h2 id="判断子类的设计实现是否违背里式替换原则的小窍门"><a href="#判断子类的设计实现是否违背里式替换原则的小窍门" class="headerlink" title="判断子类的设计实现是否违背里式替换原则的小窍门"></a>判断子类的设计实现是否违背里式替换原则的小窍门</h2><p>拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。  </p>
]]></content>
      <categories>
        <category>Learn-DesignPattern</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>里式替换原则</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则二：开闭</title>
    <url>/2021/12/18/design-principle-open-close/</url>
    <content><![CDATA[<h1 id="如何理解“对扩展开放、修改关闭”？"><a href="#如何理解“对扩展开放、修改关闭”？" class="headerlink" title="如何理解“对扩展开放、修改关闭”？"></a>如何理解“对扩展开放、修改关闭”？</h1><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。<br>它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension ,but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。  </p>
<p>详细描述：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。  </p>
<p>例如：这是一段 API 接口监控告警的代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule rule;  <span class="comment">//存储告警规则，可以自由设置。</span></span><br><span class="line">    <span class="keyword">private</span> Notification notification;  <span class="comment">//告警通知类，支持邮件、短信、微信、手机等多种通知渠道。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rule = rule;</span><br><span class="line">        <span class="built_in">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> durati)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">        <span class="comment">//NotificationEmergencyLevel 表示通知的紧急程度，包括 SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。</span></span><br><span class="line">        notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">        notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的业务逻辑，主要集中在check() 函数中。<br>当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。  </p>
<p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：<br>第一处是修改 check() 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数；<br>第二处是在 check() 函数中添加新的告警逻辑。  </p>
<p>具体的代码改动如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略 AlertRule/Notification 属性和构造函数...</span></span><br><span class="line">    <span class="comment">// 改动一：添加参数 timeoutCount</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">        <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeoutTps</span> <span class="operator">=</span> timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">        notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改。  </p>
<p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？  </p>
<p>我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：  </p>
<ul>
<li>第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类；  </li>
<li>第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。</li>
</ul>
<p>具体的代码实现如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">            handler.check(apiStatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">// 省略 constructor/getter/setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String api;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">    <span class="keyword">protected</span> Notification notification;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;<span class="number">26</span> <span class="built_in">this</span>.rule = rule;</span><br><span class="line">        <span class="built_in">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(rule, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(tps &gt; rule.getMatchedRule(apiStatInfo.getApi()</span>).getMaxTps()) &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(rule, notification);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi())</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 的使用：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line">    <span class="keyword">private</span> Alert alert;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">        alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*. 省略参数.*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*. 省略参数.*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Alert <span class="title function_">getAlert</span><span class="params">()</span> &#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationContext</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        instance.initializeBeans();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">        <span class="comment">// ... 省略设置 apiStatInfo 数据值的代码</span></span><br><span class="line">        ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和notification 的依赖注入）、初始化（添加 handlers）工作。  </p>
<p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有 下面四处：  </p>
<ul>
<li>第一处改动是：在 ApiStatInfo 类中添加新的属性 timeoutCount。  </li>
<li>第二处改动是：添加新的 TimeoutAlertHander 类。  </li>
<li>第三处改动是：在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler。  </li>
<li>第四处改动是：在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。</li>
</ul>
<p>改动之后的代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">// 省略 constructor/getter/setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String api;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">// 代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">// 代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的 handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">// 省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line">    <span class="keyword">private</span> Alert alert;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">        alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*. 省略参数.*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*. 省略参数.*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">        <span class="comment">// 改动三：注册 handler</span></span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TimeoutAlertHandler</span>(alertRule, notification));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Alert <span class="title function_">getAlert</span><span class="params">()</span> &#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationContext</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        instance.initializeBeans();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">        <span class="comment">// ... 省略设置 apiStatInfo 数据值的代码</span></span><br><span class="line">        apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置 tiemoutCount 值</span></span><br><span class="line">        ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。  </p>
<h1 id="修改代码就意味着违背开闭原则吗？"><a href="#修改代码就意味着违背开闭原则吗？" class="headerlink" title="修改代码就意味着违背开闭原则吗？"></a>修改代码就意味着违背开闭原则吗？</h1><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>在添加新的告警逻辑的时候，尽管改动二（添加新的 handler 类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？  </p>
<h2 id="分析改动一：往-ApiStatInfo-类中添加新的属性-timeoutCount。"><a href="#分析改动一：往-ApiStatInfo-类中添加新的属性-timeoutCount。" class="headerlink" title="分析改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。"></a>分析改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。</h2><p>实际上，我们不仅往 ApiStatInfo 类中添加了属性，还添加了对应的 getter&#x2F;setter 方法。那这个问题就转化为：<strong>给类中添加新的属性和方法，算作“修改”还是“扩展”？</strong>  </p>
<p>开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。  </p>
<p>从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。  </p>
<p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：<strong>只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</strong>  </p>
<h2 id="分析改动三和改动四：在-ApplicationContext-类的-initializeBeans-方法中，往-alert-对象中注册新的-timeoutAlertHandler；在使用-Alert-类的时候，需要给check-函数的入参-apiStatInfo-对象设置-timeoutCount-的值。"><a href="#分析改动三和改动四：在-ApplicationContext-类的-initializeBeans-方法中，往-alert-对象中注册新的-timeoutAlertHandler；在使用-Alert-类的时候，需要给check-函数的入参-apiStatInfo-对象设置-timeoutCount-的值。" class="headerlink" title="分析改动三和改动四：在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler；在使用 Alert 类的时候，需要给check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。"></a>分析改动三和改动四：在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler；在使用 Alert 类的时候，需要给check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。</h2><p>这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。因为：在重构之后的 Alert 代码中，我们的核心逻辑集中在 Alert 类及其各个 handler 中，当我们在添加新的告警逻辑的时候，Alert 类完全不需要修改，而只需要扩展一个新 handler 类。如果我们把 Alert 类及各个 handler 类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。  </p>
<p>而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。<br>类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。<br>我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。  </p>
<h1 id="如何做到“对扩展开放、修改关闭”？"><a href="#如何做到“对扩展开放、修改关闭”？" class="headerlink" title="如何做到“对扩展开放、修改关闭”？"></a>如何做到“对扩展开放、修改关闭”？</h1><p>开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。<br>如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。<br>所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。（后面再详细说）  </p>
<h2 id="偏向顶层的指导思想"><a href="#偏向顶层的指导思想" class="headerlink" title="偏向顶层的指导思想"></a>偏向顶层的指导思想</h2><p>为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。  </p>
<ul>
<li>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。  </li>
<li>在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</li>
</ul>
<h1 id="如何在项目中灵活应用开闭原则？"><a href="#如何在项目中灵活应用开闭原则？" class="headerlink" title="如何在项目中灵活应用开闭原则？"></a>如何在项目中灵活应用开闭原则？</h1><p>写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？  </p>
<ul>
<li>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。  </li>
<li>对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</li>
</ul>
<p>不过，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突，所以需要慎重使用。  </p>
]]></content>
      <categories>
        <category>Learn-DesignPattern</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>开闭原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的MTV架构</title>
    <url>/2021/06/24/django-mtv/</url>
    <content><![CDATA[<h2 id="MTV架构"><a href="#MTV架构" class="headerlink" title="MTV架构"></a>MTV架构</h2><p><img src="/2021/06/24/django-mtv/1.png">  </p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul>
<li>不重复造轮子</li>
<li>MVT  </li>
<li>快速开发  </li>
<li>灵活易于扩展  </li>
<li>松耦合  </li>
<li>显式优于隐式</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>Python实现，代码干净整洁  </li>
<li>提供管理后台，能快速开发  </li>
<li>复用度高  </li>
<li>易于扩展  </li>
<li>内置的安全框架  </li>
<li>丰富的第三方类库</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>单体应用，不易并行开发  </li>
<li>不适合非常小的几行代码的项目  </li>
<li>不适合高并发面向C端的互联网项目</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>MTV</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建私有镜像仓库-registry</title>
    <url>/2022/10/04/docker-deploy-private-image-repository-registry/</url>
    <content><![CDATA[<p>本文将介绍如何搭建最简单的私有镜像仓库——<code>Docker Registry</code>。  </p>
<p>首先，你需要使用 docker pull 命令拉取镜像：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker pull registry</span><br></pre></td></tr></table></figure>

<p>然后，我们需要做一个端口映射，对外暴露端口，这样 Docker Registry 才能提供服务。它的容器内端口是 5000，简单起见，我们在外面也使用同样的 5000 端口，所以运行命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<p>启动 Docker Registry 之后，你可以使用 docker ps 查看它的运行状态，可以看到它确实把本机的 5000 端口映射到了容器内的 5000 端口。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                  CREATED              STATUS             PORTS                                                                                                                                  NAMES</span><br><span class="line">77936b6bce8e   registry                 &quot;/entrypoint.sh /etc…&quot;   About a minute ago   Up 59 seconds      0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp                                                                                              stoic_hoover</span><br></pre></td></tr></table></figure>
<p>接下来，我们就要使用 docker tag 命令给镜像打标签再上传了。因为上传的目标不是默认的 Docker Hub，而是本地的私有仓库，所以镜像的名字前面还必须再加上仓库的地址（域名或者 IP 地址都行），形式上和 HTTP 的 URL 非常像。  </p>
<p>比如在这里，我就把“nginx:alpine”改成了“127.0.0.1:5000&#x2F;nginx:alpine”：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker tag nginx:alpine 127.0.0.1:5000/nginx:alpine</span><br></pre></td></tr></table></figure>

<p>现在，这个镜像有了一个附加仓库地址的完整名字，就可以用 docker push 推上去了：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/nginx:alpine</span><br><span class="line">The push refers to repository [127.0.0.1:5000/nginx]</span><br><span class="line">bf4e176a4d9b: Pushed </span><br><span class="line">a1d571e4e83d: Pushed </span><br><span class="line">6d97b4d00719: Pushed </span><br><span class="line">2a7647ca3937: Pushed </span><br><span class="line">549c42eea4a6: Pushed </span><br><span class="line">994393dc58e7: Pushed </span><br><span class="line">alpine: digest: sha256:2959a35e1b1e61e2419c01e0e457f75497e02d039360a658b66ff2d4caab19c4 size: 1568</span><br></pre></td></tr></table></figure>

<p>为了验证是否已经成功推送，我们可以把刚才打标签的镜像删掉，再重新下载：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker rmi  127.0.0.1:5000/nginx:alpine</span><br><span class="line">Untagged: 127.0.0.1:5000/nginx:alpine</span><br><span class="line">Untagged: 127.0.0.1:5000/nginx@sha256:2959a35e1b1e61e2419c01e0e457f75497e02d039360a658b66ff2d4caab19c4</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/nginx:alpine</span><br><span class="line">alpine: Pulling from nginx</span><br><span class="line">Digest: sha256:2959a35e1b1e61e2419c01e0e457f75497e02d039360a658b66ff2d4caab19c4</span><br><span class="line">Status: Downloaded newer image for 127.0.0.1:5000/nginx:alpine</span><br><span class="line">127.0.0.1:5000/nginx:alpine</span><br></pre></td></tr></table></figure>

<p>Docker Registry 虽然没有图形界面，但提供了 RESTful API，也可以发送 HTTP 请求来查看仓库里的镜像：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl 127.1:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;nginx&quot;]&#125;</span><br><span class="line"></span><br><span class="line">$ curl 127.1:5000/v2/nginx/tags/list</span><br><span class="line">&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;tags&quot;:[&quot;alpine&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，因为应用被封装到了镜像里，所以我们只用简单的一两条命令就完成了私有仓库的搭建工作，完全不需要复杂的软件安装、环境设置、调试测试等繁琐的操作，提升了效率。  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://registry.hub.docker.com/_/registry/">registry官网</a>  </li>
<li><a href="https://docs.docker.com/registry/spec/api/">Docker Registry HTTP API V2</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnDocker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建 WordPress 网站</title>
    <url>/2022/10/04/docker-deploy-wordpress/</url>
    <content><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/2022/10/04/docker-deploy-wordpress/1.png"><br>MariaDB 作为后面的关系型数据库，端口号是 3306；WordPress 是中间的应用服务器，使用 MariaDB 来存储数据，它的端口是 80；Nginx 是前面的反向代理，它对外暴露 80 端口，然后把请求转发给 WordPress。  </p>
<h1 id="使用-docker-pull-拉取镜像"><a href="#使用-docker-pull-拉取镜像" class="headerlink" title="使用 docker pull 拉取镜像"></a>使用 docker pull 拉取镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull wordpress:5</span><br><span class="line">docker pull mariadb:10</span><br><span class="line">docker pull nginx:alpine</span><br></pre></td></tr></table></figure>

<h1 id="启动-MariaDB"><a href="#启动-MariaDB" class="headerlink" title="启动 MariaDB"></a>启动 MariaDB</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --rm \</span><br><span class="line">    --env MARIADB_DATABASE=db \</span><br><span class="line">    --env MARIADB_USER=wp \</span><br><span class="line">    --env MARIADB_PASSWORD=123 \</span><br><span class="line">    --env MARIADB_ROOT_PASSWORD=123 \</span><br><span class="line">    mariadb:10</span><br><span class="line">44a276483f97035da17cf0d00bd0ff69d5f2f7f2a1f077e23be62dff8dfb008e</span><br></pre></td></tr></table></figure>

<p>因为 Docker 的 bridge 网络模式的默认网段是“172.17.0.0&#x2F;16”，宿主机固定是“172.17.0.1”，而且 IP 地址是顺序分配的，可以通过 docker inspect 命令来查看IP地址：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker inspect 44a |grep IPAddress</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br></pre></td></tr></table></figure>



<h1 id="启动-WordPress"><a href="#启动-WordPress" class="headerlink" title="启动 WordPress"></a>启动 WordPress</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --rm \</span><br><span class="line">    --env WORDPRESS_DB_HOST=172.17.0.2 \</span><br><span class="line">    --env WORDPRESS_DB_USER=wp \</span><br><span class="line">    --env WORDPRESS_DB_PASSWORD=123 \</span><br><span class="line">    --env WORDPRESS_DB_NAME=db \</span><br><span class="line">    wordpress:5</span><br><span class="line">03b25fef47dc1032b31994a018a2eda16f080abc4bca8e34e5d3c281673bc93d</span><br></pre></td></tr></table></figure>

<p>WordPress 容器在启动的时候并没有使用 -p 参数映射端口号，所以外界是不能直接访问的，我们需要在前面配一个 Nginx 反向代理，把请求转发给 WordPress 的 80 端口。  </p>
<p>配置 Nginx 反向代理必须要知道 WordPress 的 IP 地址，同样可以用 docker inspect 命令查看：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker inspect 03b |grep IPAddress</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br></pre></td></tr></table></figure>

<h1 id="启动Nginx反向代理"><a href="#启动Nginx反向代理" class="headerlink" title="启动Nginx反向代理"></a>启动Nginx反向代理</h1><p>新建一个配置文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  default_type text/html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">      proxy_http_version 1.1;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_pass http://172.17.0.3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个配置文件，最关键的一步就来了，我们需要用 -p 参数把本机的端口映射到 Nginx 容器内部的 80 端口，再用 -v 参数把配置文件挂载到 Nginx 的“conf.d”目录下。这样，Nginx 就会使用刚才编写好的配置文件，在 80 端口上监听 HTTP 请求，再转发到 WordPress 应用：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d --rm -p 80:80 -v `pwd`/wp.conf:/etc/nginx/conf.d/default.conf nginx:alpine</span><br><span class="line">3dcbe51c07db920e6cd90be901f54c1402ec3cd1f73981ce77dd45c11736e1dc</span><br></pre></td></tr></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>检查三个容器的运行情况：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker ps</span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                  CREATED              STATUS              PORTS                                                                                                                                  NAMES</span><br><span class="line">fbbfccd67370   nginx:alpine             &quot;/docker-entrypoint.…&quot;   3 seconds ago        Up 1 second         0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp                                                                                                      compassionate_herschel</span><br><span class="line">e78d0bafc7d8   wordpress:5              &quot;docker-entrypoint.s…&quot;   About a minute ago   Up About a minute   80/tcp                                                                                                                                 nervous_neumann</span><br><span class="line">844a80ff2f90   mariadb:10               &quot;docker-entrypoint.s…&quot;   2 minutes ago        Up 2 minutes        3306/tcp                                                                                                                               optimistic_elbakyan</span><br></pre></td></tr></table></figure>

<p>本地访问<a href="http://127.0.0.1/">http://127.0.0.1</a><br><img src="/2022/10/04/docker-deploy-wordpress/wp.png">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>容器技术是后端应用领域的一项重大创新，它彻底变革了应用的开发、交付与部署方式，是“云原生”的根本。  </p>
<p>容器基于 Linux 底层的 namespace、cgroup、chroot 等功能，虽然它们很早就出现了，但直到 Docker“横空出世”，把它们整合在一起，容器才真正走近了大众的视野，逐渐为广大开发者所熟知。  </p>
<p>容器技术中有三个核心概念：容器（Container）、镜像（Image），以及镜像仓库（Registry）：<br><img src="/2022/10/04/docker-deploy-wordpress/%E5%AE%B9%E5%99%A8%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5.png">  </p>
<p>从本质上来说，容器属于虚拟化技术的一种，和虚拟机（Virtual Machine）很类似，都能够分拆系统资源，隔离应用进程，但容器更加轻量级，运行效率更高，比虚拟机更适合云计算的需求。  </p>
<p>镜像是容器的静态形式，它把应用程序连同依赖的操作系统、配置文件、环境变量等等都打包到了一起，因而能够在任何系统上运行，免除了很多部署运维和平台迁移的麻烦。  </p>
<p>镜像内部由多个层（Layer）组成，每一层都是一组文件，多个层会使用<code>Union FS</code>技术合并成一个文件系统供容器使用。这种细粒度结构的好处是相同的层可以共享、复用，节约磁盘存储和网络传输的成本，也让构建镜像的工作变得更加容易。  </p>
<p>为了方便管理镜像，就出现了镜像仓库，它集中存放各种容器化的应用，用户可以任意上传下载，是分发镜像的最佳方式。  </p>
<p>容器技术有很多具体的实现，Docker 是最初也是最流行的容器技术，它的主要形态是运行在 Linux 上的“Docker Engine”。我们日常使用的 docker 命令其实只是一个前端工具，它必须与后台服务“Docker daemon”通信才能实现各种功能。  </p>
<p>操作容器的常用命令有 docker ps、docker run、docker exec、docker stop 等；操作镜像的常用命令有 docker images、docker rmi、docker build、docker tag 等；操作镜像仓库的常用命令有 docker pull、docker push 等。  </p>
<p>容器技术思维导图：<br><img src="/2022/10/04/docker-deploy-wordpress/map.png">  </p>
]]></content>
      <categories>
        <category>LearnDocker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>CS50 Lab 2_Scrabble</title>
    <url>/2023/12/23/cs50-lab-2-scrabble/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cs50.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Points assigned to each letter of the alphabet</span></span><br><span class="line"><span class="type">int</span> POINTS[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compute_score</span><span class="params">(<span class="built_in">string</span> word)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> small_letters[] = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>,<span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> capital_letters[] = &#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp_Points [] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get input words from both players</span></span><br><span class="line">    <span class="built_in">string</span> word1 = get_string(<span class="string">&quot;Player 1: &quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> word2 = get_string(<span class="string">&quot;Player 2: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Score both words</span></span><br><span class="line">    <span class="type">int</span> score1 = compute_score(word1);</span><br><span class="line">    <span class="type">int</span> score2 = compute_score(word2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Print the winner</span></span><br><span class="line">    <span class="keyword">if</span> (score1 &gt; score2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Player 1 wins!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score1 == score2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tie!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Player 2 wins!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compute_score</span><span class="params">(<span class="built_in">string</span> word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Compute and return score for string</span></span><br><span class="line">    <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(word); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(word[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> f = <span class="number">0</span>; f &lt; <span class="keyword">sizeof</span>(capital_letters); f++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word[i] == capital_letters[f])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp_Points[i] = POINTS[f];</span><br><span class="line">                    score += temp_Points[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(word[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> f = <span class="number">0</span>; f &lt; <span class="keyword">sizeof</span>(small_letters); f++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word[i] == small_letters[f])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp_Points[i] = POINTS[f];</span><br><span class="line">                    score += temp_Points[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cs-self-learning</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CS50</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习和命令的使用</title>
    <url>/2020/03/18/docker-study-and-use/</url>
    <content><![CDATA[<h2 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><p>在做软件服务时，有些程序对环境要求极其苛刻，比如必须把<code>C++</code>的库都安装好，且放到指定位置才行，这样就会对测试和运维人员造成极大的工作负担，因此我们利用<code>Docker</code>的<strong>一键编译，到处运行</strong>的特点，给自己的服务创建一个镜像，然后开启一个容器，将端口号和路径映射出来。  </p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="查询本机存在的镜像"><a href="#查询本机存在的镜像" class="headerlink" title="查询本机存在的镜像"></a>查询本机存在的镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="查询本机中所有创建的容器"><a href="#查询本机中所有创建的容器" class="headerlink" title="查询本机中所有创建的容器"></a>查询本机中所有创建的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h3 id="查询正在运行的容器"><a href="#查询正在运行的容器" class="headerlink" title="查询正在运行的容器"></a>查询正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<h3 id="创建一个容器并进入这个容器"><a href="#创建一个容器并进入这个容器" class="headerlink" title="创建一个容器并进入这个容器"></a>创建一个容器并进入这个容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -p 20002:20002 -v /data/:/data/ 47aae5c9b731  /usr/start.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>run: 创建一个容器，并让它跑起来  </li>
<li>-it: 进入这个容器  </li>
<li>-d: 后台运行这个容器  </li>
<li>-p: 映射端口号  </li>
<li>-v: 映射路径  </li>
<li>&#x2F;usr&#x2F;start.sh: 运行容器后默认执行的脚本文件</li>
</ul>
<h3 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure>

<h3 id="进入一个正在运行的容器"><a href="#进入一个正在运行的容器" class="headerlink" title="进入一个正在运行的容器"></a>进入一个正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>

<h3 id="停止正在运行的容器"><a href="#停止正在运行的容器" class="headerlink" title="停止正在运行的容器"></a>停止正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.dockerinfo.net/document">Docker中文文档</a>  </li>
<li><a href="https://docs.docker.com/">Docker Documentation</a>  </li>
<li><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程_Docker 教程</a>  </li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰_Docker 入门教程</a></li>
</ul>
<p>(待更新)  </p>
]]></content>
      <categories>
        <category>Learn-docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>端午安康以及我的高考</title>
    <url>/2019/06/08/duan-wu-and-my-gao-kao/</url>
    <content><![CDATA[<p>昨天是中国的传统节日端午节，也是2019年高考的第一天。  </p>
<p>她在端午节前一天下午来到了成都，我们相遇了，是的，相隔三千公里远外长达十个月的异地恋，终于宣告结束了。  </p>
<p>端午节这一天，我们把房子整体收拾了一下，该扔的扔，该买的买，中午吃的冒菜，晚上买了鸭肉，虾尾，酸奶和啤酒庆祝。  </p>
<p>今天是高考第一天，想起2014年我参加高考时，第一场语文作文后半段写的有些急，字都飞了起来；第二场数学填空选择做的很好，后面大题做的糟糕；第三场英语作文写的还可以；第四场理综一般般。后来回学校估分觉得应该能上个一本。  </p>
<p>后来高考成绩公布，与我估分的偏差有些大，但还是能上个二本，然而我不甘心，思考着是复读还是去上大学。后来决定还是去上大学，因为我厌恶了高考那压抑的生活。  </p>
<p>上了大学，遇见了各种各样的人，以及琳琅满目的社团和学生会。在每一次把酒言欢的夜晚，我独自坐在桌前，思考着我未来要走的路。当时的我很长一段时间都在自责与后悔中度过，放佛人生已成定数。  </p>
<p>直到大二下学期，开始尝试打开窗户看外面的世界，开阔新视野的同时让我对自己的遭遇和学校看淡了些。大学毕业后，从事研发，专注于提升实力，前几天还意外被Go语言中文站长拉入了一个Go语言实践和布道者的群，里面的人大部分都是公司内的专家了，我有些激动，因为我从没有想过，我会离大佬们如此接近。未来的路，我想我会更坚定的走下去，因为这是一次他们对我的认可。  </p>
<p>回忆了这么多，其实我想告诉正在准备高考的你，也是告诉那个曾经对未来惶恐不安的自己。人生就像一个长跑，也像一条正弦曲线，刚开始为0，然后你的事业会经历高峰和低谷，到高峰不要骄傲，到低谷不要气馁。  </p>
<p>高考只是一道小山坡，未来的变数还有很多。  </p>
<p>面带微笑，温暖前行。</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>端午</tag>
        <tag>高考</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则一：单一职责</title>
    <url>/2021/12/18/design-principle-single-responsibility/</url>
    <content><![CDATA[<h1 id="如何理解单一职责原则（SRP）？"><a href="#如何理解单一职责原则（SRP）？" class="headerlink" title="如何理解单一职责原则（SRP）？"></a>如何理解单一职责原则（SRP）？</h1><p>单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。<br>这个原则的英文描述是这样的：A class or module should have a single reponsibility。如果我们把它翻译成中文，那就是：<strong>一个类或者模块只负责完成一个职责（或者功能）。</strong>  </p>
<p>简单理解，就是<strong>不要设计大而全的类，要设计粒度小、功能单一的类。</strong><br>换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。  </p>
<p>例如：一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。  </p>
<h1 id="如何判断类的职责是否足够单一？"><a href="#如何判断类的职责是否足够单一？" class="headerlink" title="如何判断类的职责是否足够单一？"></a>如何判断类的职责是否足够单一？</h1><p>在一个社交产品中，我们用下面的 UserInfo 类来记录用户的信息。判断UserInfo 类的设计是否满足单一职责原则呢？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line"> <span class="keyword">private</span> String username;</span><br><span class="line"> <span class="keyword">private</span> String email;</span><br><span class="line"> <span class="keyword">private</span> String telephone;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> lastLoginTime;</span><br><span class="line"> <span class="keyword">private</span> String avatarUrl;</span><br><span class="line"> <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line"> <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line"> <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区</span></span><br><span class="line"> <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line"> <span class="comment">// ... 省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>观点1：UserInfo 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则。  </li>
<li>观点2：地址信息在 UserInfo 类中，所占的比重比较高，可以继续拆分成独立的 UserAddress类，UserInfo 只保留除 Address 之外的其他信息，拆分之后的两个类的职责更加单一。</li>
</ul>
<p>综上所述：如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。  </p>
<p>继续延伸：如果做这个社交产品的公司发展得越来越好，公司内部又开发出了跟多其他产品（可以理解为其他 App）。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录。这个时候，我们就需要继续对 UserInfo 进行拆分，将跟身份认证相关的信息（比如，email、telephone 等）抽取成独立的类。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类（重构）。  </p>
<h2 id="判断原则"><a href="#判断原则" class="headerlink" title="判断原则"></a>判断原则</h2><ul>
<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；  </li>
<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；  </li>
<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；  </li>
<li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；  </li>
<li>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>
</ul>
<h1 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h1><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？<br>答案是否定的。  </p>
<p>例如，Serialization 类实现了一个简单协议的序列化和反序列功能，具体代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Protocol format: identifier-string;&#123;gson string&#125;</span></span><br><span class="line"><span class="comment"> * For example: UEUEUE;&#123;&quot;a&quot;:&quot;A&quot;,&quot;b&quot;:&quot;B&quot;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span> &#123;<span class="number">10</span></span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让类的职责更加单一，我们对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span> &#123;<span class="number">10</span></span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Deserializer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。  </p>
<p>因此，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。  </p>
]]></content>
      <categories>
        <category>Learn-DesignPattern</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>单一职责</tag>
      </tags>
  </entry>
  <entry>
    <title>EdgeX 工作原理</title>
    <url>/2023/09/18/edgex-works/</url>
    <content><![CDATA[<h1 id="什么是EdgeX"><a href="#什么是EdgeX" class="headerlink" title="什么是EdgeX"></a>什么是EdgeX</h1><p>边缘中间件，服务于物理传感和执行“事物”和我们的信息技术(IT)系统之间。</p>
<h1 id="EdgeX架构"><a href="#EdgeX架构" class="headerlink" title="EdgeX架构"></a>EdgeX架构</h1><p><img src="/2023/09/18/edgex-works/EdgeX_architecture.png">  </p>
<h2 id="设备服务"><a href="#设备服务" class="headerlink" title="设备服务"></a>设备服务</h2><p>与传感器&#x2F;设备或IoT对象交互的边缘连接器，包括机器、无人机、HMAC设备、相机等。<br>利用可用连接器来控制设备或从EdgeX获取边缘数据。<br>可以使用设备服务SDK提供创建自己的EdgeX设备服务。  </p>
<h2 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h2><p>这是关于哪些“事物”相互连接、哪些数据流经以及如何在给定部署中配置EdgeX的开放边缘软件平台等大部分知识的地方。  </p>
<ul>
<li>核心数据：用于设备和传感器收集的边缘数据读数的集中数据库。</li>
<li>核心命令&#x2F;控制：代表其他微服务、应用程序和外部系统对设备执行命令&#x2F;操作</li>
<li>核心元数据：由其他服务用于获取有关设备以及如何与其通信的知识</li>
<li>配置和注册表：集中并简化服务配置数据。它使用开源项目Consul，该项目提供键值存储，客户端可以通过 RESTAPI访问EdgeXFoundry。</li>
</ul>
<h2 id="支撑服务"><a href="#支撑服务" class="headerlink" title="支撑服务"></a>支撑服务</h2><p>包括边缘数据分析 (也称为本地分析)等微服务和日志记录、调度和数据清理等典型边缘软件应用程序职责。</p>
<ul>
<li>警报和通知：将警报&#x2F;通知传递给系统或人员，以通知另一个微服务在节点上发现的某些内容。</li>
<li>计划服务：按照配置的时间间隔或计划在任何EdgeX服务中执行操作。</li>
<li>规则引擎(Kuiper)：EMQXKuiper是EdgeX<br>Foundry 参考规则引擎，允许用户在边缘实现快速数据处理并使用 SQL 编写规则。</li>
</ul>
<h2 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h2><p>应用服务是从EdgeXFoundry 提取、处理&#x2F;转换感知的边缘数据并将其发送到您选择的端点或应用程序的方法。这可以是边缘数据分析包、企业或本地应用程序，也可以是 Azure loT中心、AWSloT或 GoogleloTCore 等云系统。  </p>
<h2 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h2><ul>
<li>安全API网关：所有EdgeX REST流量的单点入口。  </li>
<li>秘密存储：EdgeX微服务的中央存储库。</li>
</ul>
<h2 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h2><p>为外部管理服务提供了中心联系点，用于启动&#x2F;停止&#x2F;重新启动EdgeX服务、获取服务的配置、服务的状态&#x2F;运行状况。  </p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>以<code>Modbus</code>设备为例：</p>
<ul>
<li><p>0：Modbus 设备服务将在 Modbus 中进行通信，以从 Modbus 泵获取压力读数。设备服务将传感器数据转换为 EdgeX 事件对象。  </p>
</li>
<li><p>1.1：事件对象通过消息总线发送到核心数据或应用程序服务<br><img src="/2023/09/18/edgex-works/EdgeX_step1-1.png">  </p>
</li>
<li><p>1.2：事件对象通过 REST 通信将事件对象发送到核心数据服务<br><img src="/2023/09/18/edgex-works/EdgeX_step1-2.png">  </p>
</li>
<li><p>2：当核心数据通过 REST 从设备服务接收事件对象时，它会将传感器数据事件放在发往应用程序服务的消息主题上。<br><img src="/2023/09/18/edgex-works/EdgeX_step2.png">  </p>
</li>
<li><p>3：应用程序服务根据需要转换、过滤、丰富、压缩、加密等操作数据后，并将数据推送到端点。<br><img src="/2023/09/18/edgex-works/EdgeX_step3.png">  </p>
</li>
<li><p>4：应用程序服务可以处理 EdgeX 事件（及其包含的传感器数据）并将其获取到任何分析包。<br><img src="/2023/09/18/edgex-works/EdgeX_step4.png">  </p>
</li>
<li><p>5：分析包可以探索传感器事件数据并做出触发设备驱动的决定（例如，它可以检查发动机的压力读数是否大于 60 PSI。当确定这样的规则为真时，分析包会调用核心命令服务来触发某些操作，例如在某些可控设备上“打开阀门”）。<br><img src="/2023/09/18/edgex-works/EdgeX_step5.png">  </p>
</li>
<li><p>6：核心命令服务获取动作请求，并根据请求确定需要动作于哪个设备；然后调用所属设备服务来执行驱动。<br><img src="/2023/09/18/edgex-works/EdgeX_step6.png">  </p>
</li>
<li><p>7：设备服务接收启动请求，将其转换为特定于协议的请求，并将请求转发到所需的设备。<br><img src="/2023/09/18/edgex-works/EdgeX_step7.png"></p>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://www.edgexfoundry.org/software/platform/">EdgeX Foundry平台</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnEdgeX</category>
      </categories>
      <tags>
        <tag>edgex</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Kafka</title>
    <url>/2024/01/17/docker-install-kafka/</url>
    <content><![CDATA[<h1 id="Docker安装Kafka服务"><a href="#Docker安装Kafka服务" class="headerlink" title="Docker安装Kafka服务"></a>Docker安装Kafka服务</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">docker run -d --name zookeeper -p 2181:2181 -e TZ=&quot;Asia/Shanghai&quot; --restart always wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">docker pull wurstmeister/kafka</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=&lt;这里换成你的zookeeper地址和端口&gt; -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://&lt;这里换成你的kafka地址和端口&gt; -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> wurstmeister/kafka</span></span><br><span class="line">docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=127.0.0.1:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -e TZ=&quot;Asia/Shanghai&quot; wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=172.17.0.3:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>-e KAFKA_ZOOKEEPER_CONNECT&#x3D;127.0.0.1:2181：指定 Zookeeper 的地址和端口，这里使用本地地址 127.0.0.1 和默认端口 2181。</li>
<li>-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;127.0.0.1:9092：将 Kafka 服务器的地址和端口设置为 127.0.0.1:9092。</li>
<li>-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092：指定 Kafka 监听的地址和端口为 0.0.0.0:9092，允许外部访问。</li>
<li>-p 9092:9092：将容器内部的 9092 端口映射到主机的 9092 端口，允许通过主机的 127.0.0.1:9092 访问 Kafka 服务器。</li>
</ul>
<h1 id="安装Kafka客户端"><a href="#安装Kafka客户端" class="headerlink" title="安装Kafka客户端"></a>安装Kafka客户端</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nickzurich/efak:latest</span><br><span class="line"></span><br><span class="line">docker run -d --name kafka-eagle -p 8048:8048 -e EFAK_CLUSTER_ZK_LIST=&quot;172.17.0.3:2181&quot; nickzurich/efak:latest</span><br></pre></td></tr></table></figure>


<h1 id="Docker-Compose部署"><a href="#Docker-Compose部署" class="headerlink" title="Docker Compose部署"></a>Docker Compose部署</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;bitnami/zookeeper:3.8.0&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ALLOW_ANONYMOUS_LOGIN:</span> <span class="string">&quot;yes&quot;</span></span><br><span class="line">      <span class="attr">ZOO_SERVER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_PORT_NUMBER:</span> <span class="number">2181</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;bitnami/kafka:3.2.0&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># 更多变量 查看文档 https://github.com/bitnami/bitnami-docker-kafka/blob/master/README.md</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 监听端口</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9092</span></span><br><span class="line">      <span class="comment"># 实际访问ip 本地用 127 内网用 192 外网用 外网ip</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://127.0.0.1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2181</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="string">&quot;yes&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/neozhang/dockercp/kafka/data:/bitnami/kafka/data</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka-manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sheepkiller/kafka-manager:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-manager</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;19092:19092&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZK_HOSTS:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2181</span></span><br><span class="line">      <span class="attr">APPLICATION_SECRET:</span> <span class="string">letmein</span></span><br><span class="line">      <span class="attr">KAFKA_MANAGER_USERNAME:</span> <span class="string">neo</span></span><br><span class="line">      <span class="attr">KAFKA_MANAGER_PASSWORD:</span> <span class="string">neo123</span></span><br><span class="line">      <span class="attr">KM_ARGS:</span> <span class="string">-Dhttp.port=19092</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">  <span class="attr">kafka-ui:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-ui</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">provectuslabs/kafka-ui:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DYNAMIC_CONFIG_ENABLED:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/kui/config.yml:/etc/kafkaui/dynamic_config.yaml</span></span><br></pre></td></tr></table></figure>


<h1 id="安装knowstreaming"><a href="#安装knowstreaming" class="headerlink" title="安装knowstreaming"></a>安装knowstreaming</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># *不要调整knowstreaming-manager服务名称，ui中会用到</span></span><br><span class="line">  <span class="attr">knowstreaming-manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">knowstreaming/knowstreaming-manager:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">knowstreaming-manager</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch-single</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/ks-start.sh</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># mysql服务地址</span></span><br><span class="line">      <span class="attr">SERVER_MYSQL_ADDRESS:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:3306</span></span><br><span class="line">      <span class="comment"># mysql数据库名</span></span><br><span class="line">      <span class="attr">SERVER_MYSQL_DB:</span> <span class="string">know_streaming</span></span><br><span class="line">      <span class="comment"># mysql用户名</span></span><br><span class="line">      <span class="attr">SERVER_MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># mysql用户密码</span></span><br><span class="line">      <span class="attr">SERVER_MYSQL_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment"># es服务地址</span></span><br><span class="line">      <span class="attr">SERVER_ES_ADDRESS:</span> <span class="string">elasticsearch-single:9200</span></span><br><span class="line">      <span class="comment"># 服务JVM参数</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">-Xmx1g</span> <span class="string">-Xms1g</span></span><br><span class="line">      <span class="comment"># 对于kafka中ADVERTISED_LISTENERS填写的hostname可以通过该方式完成</span></span><br><span class="line"><span class="comment">#    extra_hosts:</span></span><br><span class="line"><span class="comment">#      - &quot;hostname:x.x.x.x&quot;</span></span><br><span class="line">      <span class="comment"># 服务日志路径</span></span><br><span class="line"><span class="comment">#    volumes:</span></span><br><span class="line"><span class="comment">#      - /ks/manage/log:/logs</span></span><br><span class="line">  <span class="attr">knowstreaming-ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">knowstreaming/knowstreaming-ui:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">knowstreaming-ui</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">knowstreaming-manager</span></span><br><span class="line"><span class="comment">#    extra_hosts:</span></span><br><span class="line"><span class="comment">#      - &quot;hostname:x.x.x.x&quot;</span></span><br><span class="line">  <span class="attr">elasticsearch-single:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/library/elasticsearch:7.6.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch-single</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - &#x27;9200:9200&#x27;</span></span><br><span class="line"><span class="comment">#      - &#x27;9300:9300&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># es的JVM参数</span></span><br><span class="line">      <span class="attr">ES_JAVA_OPTS:</span> <span class="string">-Xms512m</span> <span class="string">-Xmx512m</span></span><br><span class="line">      <span class="comment"># 单节点配置，多节点集群参考 https://www.elastic.co/guide/en/elasticsearch/reference/7.6/docker.html#docker-compose-file</span></span><br><span class="line">      <span class="attr">discovery.type:</span> <span class="string">single-node</span></span><br><span class="line">      <span class="comment"># 数据持久化路径</span></span><br><span class="line"><span class="comment">#    volumes:</span></span><br><span class="line"><span class="comment">#      - /ks/es/data:/usr/share/elasticsearch/data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># es初始化服务，与manager使用同一镜像</span></span><br><span class="line">  <span class="comment"># 首次启动es需初始化模版和索引,后续会自动创建</span></span><br><span class="line">  <span class="attr">knowstreaming-init:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">knowstreaming/knowstreaming-manager:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">knowstreaming-init</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch-single</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/bash</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/es_template_create.sh</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># es服务地址</span></span><br><span class="line">      <span class="attr">SERVER_ES_ADDRESS:</span> <span class="string">elasticsearch-single:9200</span></span><br></pre></td></tr></table></figure>

<h1 id="Kafka快速入门"><a href="#Kafka快速入门" class="headerlink" title="Kafka快速入门"></a>Kafka快速入门</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-topics.sh --create --zookeeper 172.17.0.3:2181 --topic test --partitions 1 --replication-factor 1</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --describe --zookeeper 172.17.0.3:2181 --topic test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">消费消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>


<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://blog.csdn.net/wenqi1992/article/details/125447022">Docker 安装 kafka（M1 芯片版）</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnKafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>使用FFmpeg对视频增加转场特技功能</title>
    <url>/2020/11/17/ffmpeg-add-opengl/</url>
    <content><![CDATA[<p>先来看网上存在的一个<code>ffmpeg</code>脚本  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Example of concatenating 3 mp4s together with 1-second transitions between them.</span></span><br><span class="line"></span><br><span class="line">tpath=<span class="string">&quot;/ffmpeg/transitions/&quot;</span></span><br><span class="line">x264=<span class="string">&quot;-look_ahead 0 -ac 2 -c:v h264_qsv -profile:v high -level 3.1 -preset:v veryfast&quot;</span></span><br><span class="line">ki=<span class="string">&quot;-keyint_min 72 -g 72 -sc_threshold 0&quot;</span></span><br><span class="line">br=<span class="string">&quot;-b:v 3000k -minrate 3000k -maxrate 6000k -bufsize 6000k -b:a 128k&quot;</span></span><br><span class="line"></span><br><span class="line">ffmpeg -hide_banner \</span><br><span class="line">  -i 1.mp4 \</span><br><span class="line">  -i 2.mp4 \</span><br><span class="line">  -i 3.mp4 \</span><br><span class="line">  -filter_complex <span class="string">&quot; \</span></span><br><span class="line"><span class="string">    [0:a]   atrim=0:5  [a0]; \</span></span><br><span class="line"><span class="string">    [1:a]   atrim=0:5  [a1]; \</span></span><br><span class="line"><span class="string">    [2:a]   atrim=0:6  [a2]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [0:v]   split  [v000] [v010]; \</span></span><br><span class="line"><span class="string">    [1:v]   split  [v100] [v110]; \</span></span><br><span class="line"><span class="string">    [2:v]   split  [v200] [v210]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v000]  trim=0:5                [v001];  \</span></span><br><span class="line"><span class="string">    [v010]  trim=5:6                [v011t]; \</span></span><br><span class="line"><span class="string">    [v011t] setpts=PTS-STARTPTS     [v011];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v100]   trim=0:5               [v101];  \</span></span><br><span class="line"><span class="string">    [v110]   trim=5:6               [v111t]; \</span></span><br><span class="line"><span class="string">    [v111t]  setpts=PTS-STARTPTS    [v111];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v200]     trim=0:5             [v201];  \</span></span><br><span class="line"><span class="string">    [v210]     trim=5:6             [v211t]; \</span></span><br><span class="line"><span class="string">    [v211t]    setpts=PTS-STARTPTS  [v211];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v011] [v101] gltransition=duration=1:source=<span class="variable">$&#123;tpath&#125;</span>WaterDrop.glsl  [vt0]; \</span></span><br><span class="line"><span class="string">    [v111] [v201] gltransition=duration=1:source=<span class="variable">$&#123;tpath&#125;</span>crosswarp.glsl  [vt1]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v001] [vt0] [vt1] [v211]  concat=n=4          [outv]; \</span></span><br><span class="line"><span class="string">    [a0] [a1] [a2]             concat=n=3:v=0:a=1  [outa]&quot;</span> \</span><br><span class="line">  -map [outv] -map [outa] \</span><br><span class="line">  <span class="variable">$&#123;x264&#125;</span> <span class="variable">$&#123;ki&#125;</span> <span class="variable">$&#123;br&#125;</span> \</span><br><span class="line">  -y ffmpeg-gl-transition-concat.mp4</span><br></pre></td></tr></table></figure>


<h3 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h3><p><code>github</code>上的脚本如下  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Example of concatenating 3 mp4s together with 1-second transitions between them.</span></span><br><span class="line"></span><br><span class="line">./ffmpeg \</span><br><span class="line">  -i media/0.mp4 \</span><br><span class="line">  -i media/1.mp4 \</span><br><span class="line">  -i media/2.mp4 \</span><br><span class="line">  -filter_complex <span class="string">&quot; \</span></span><br><span class="line"><span class="string">    [0:v]split[v000][v010]; \</span></span><br><span class="line"><span class="string">    [1:v]split[v100][v110]; \</span></span><br><span class="line"><span class="string">    [2:v]split[v200][v210]; \</span></span><br><span class="line"><span class="string">    [v000]trim=0:3[v001]; \</span></span><br><span class="line"><span class="string">    [v010]trim=3:4[v011t]; \</span></span><br><span class="line"><span class="string">    [v011t]setpts=PTS-STARTPTS[v011]; \</span></span><br><span class="line"><span class="string">    [v100]trim=0:3[v101]; \</span></span><br><span class="line"><span class="string">    [v110]trim=3:4[v111t]; \</span></span><br><span class="line"><span class="string">    [v111t]setpts=PTS-STARTPTS[v111]; \</span></span><br><span class="line"><span class="string">    [v200]trim=0:3[v201]; \</span></span><br><span class="line"><span class="string">    [v210]trim=3:4[v211t]; \</span></span><br><span class="line"><span class="string">    [v211t]setpts=PTS-STARTPTS[v211]; \</span></span><br><span class="line"><span class="string">    [v011][v101]gltransition=duration=1:source=./crosswarp.glsl[vt0]; \</span></span><br><span class="line"><span class="string">    [v111][v201]gltransition=duration=1[vt1]; \</span></span><br><span class="line"><span class="string">    [v001][vt0][vt1][v211]concat=n=4[outv]&quot;</span> \</span><br><span class="line">  -map <span class="string">&quot;[outv]&quot;</span> \</span><br><span class="line">  -c:v libx264 -profile:v baseline -preset slow -movflags faststart -pix_fmt yuv420p \</span><br><span class="line">  -y out.mp4</span><br></pre></td></tr></table></figure>

<h3 id="相关过滤器功能"><a href="#相关过滤器功能" class="headerlink" title="相关过滤器功能"></a>相关过滤器功能</h3><ul>
<li>split，过滤器创建两个输入文件的拷贝并标记为[a],[b];  </li>
<li>trim，修剪视频;</li>
<li>setpts&#x3D;PTS-STARTPTS。重编码，算pts;</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2020/11/17/ffmpeg-add-opengl/p.png">  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="bbs.chinaffmpeg.com/forum.php?mod=viewthread&tid=391&extra=&page=3">Windows如何实现视频过渡滑入视频特效？</a></p>
<p><a href="https://www.cnblogs.com/nlsoft/p/10896543.html">ffmpeg 视频过度滤镜 gltransition</a>  </p>
]]></content>
      <categories>
        <category>Learn-FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>OpenGL</tag>
        <tag>视音频</tag>
      </tags>
  </entry>
  <entry>
    <title>国人皆如此，倭寇何敢</title>
    <url>/2020/08/21/every-chinese-like-this-how-dare-the-japanese-pirates/</url>
    <content><![CDATA[<p>今天我看完了《八佰》这部抗日电影，感触很深，在此记录我的一些心理感受。  </p>
<p>印象最深的是国军和日军打到白热化阶段时，日军的凿墙部队顶着钢板，扔手榴弹被弹开，中国军人不得不身体绑上炸弹，跳下去和日军同归于尽。这与《金陵十三钗》里中国军人以人数排成一列无限接近装甲车上让最后一个士兵在死前滚到装甲车的车轮子底下炸毁装甲车方法类似。  </p>
<p>我庆幸我活在一个和平的年代，没有战争，父母健在，按时上下班。然而，屈辱的历史不应该被遗忘。  </p>
<p>我记得我有个同事，去年去日本旅游，当地的日本人扔背地里叫他“支那人”，即使没有被叫成“支那猪”，但听着仍然叫人很不爽。区区的弹丸之国，还没有中国一个省大，为什么能如此嚣张？我想这部电影貌似已经告诉了我们答案。  </p>
<p>这部电影的另一个我喜欢的点就是真实，越长大越想看到真实。  </p>
<p>当如今被日本当做喜剧片的抗日神剧层出不穷，比如手撕鬼子，机枪打掉轰炸机，一箭射穿五个人，让我们这代是否产生了错觉，认为当年的日军是连滚带爬逃出中国的呢？事实并非如此，在对方装备先进，武士道精神（不知道是不是这个，反正就是类似天皇的意志在支配）的支配下，我军只能以人数去怼。我想这或许才是真实的战争。  </p>
<p>另外我不明白为什么有人总是带着有色眼睛来看这部电影，比如煽情，在我看来它真实表现了当时军队的想法。活着的怕死，伤的动弹不得的想给个痛快。这部电影节奏很快，尤其是打仗，哪里有缺口就需要赶紧补上，当补不上的时候，只有有命去补，但当你准备牺牲自己的生命时，你是否想到家里正在盼儿归来的父母，是否想到自己的妻子和孩子，然而你知道希望渺茫，只能对天嘶吼一声：“娘，俺走了，儿不孝！” 如果我在十楼往下跳，我想我会让时间过得慢一些，多说几句话。  </p>
<p>电影的最后，大家知道再对抗下去全都得死，于是往英租区跑，能活一个是一个，在这里也有鲜明的对比，比如刚开始四行仓库打仗，对面人就跟看热闹似的——哇哦，好大的舞台，那里竟然死了人。到最后，民族觉醒，送吃的，送喝的，实在不行打上两枪也行。连英国人都忍不住开始补抢——他妈的日本人，去死吧。  </p>
<p>当然，现在是和平年代，不打仗，都是经济战和人才战，但我们不应该忘记历史。我希望在我有生之年，可以看到我们中国人走出国门时，都是被人尊敬的，而不是听到“那里来了一个支那人”。  </p>
<p>国人皆如此，倭寇何敢。</p>
]]></content>
      <categories>
        <category>Review-film</category>
      </categories>
      <tags>
        <tag>八佰</tag>
      </tags>
  </entry>
  <entry>
    <title>感情这东西</title>
    <url>/2019/04/25/feelings/</url>
    <content><![CDATA[<p>今天是2019年4月25日，距离她毕业离校到来成都，还有一个月的时间。  </p>
<p>放佛是越到最后越按捺不住自己的情绪。感情这东西，真是有趣。  </p>
<p>最近情绪不怎么稳定，运维上出现了两个bug已经拖了四天还没有解决，五一回家，想和女友聚一波去耍，无奈新疆太大，从她出学校到见我，还有坐两个小时的班车和十三个小时的火车（速度比较快的）。真是很惆怅。  </p>
<p>我对她说，你要来，我肯定会给你把吃住安排好，带你去看美景，但是我也就在家呆六天，然后就要飞回成都工作。  </p>
<p>感情这东西，真是神奇，长年累月，让两个素不相识的人在一起，成为伴侣，这样的感觉很美妙，然而，当两个人分开时，却要承受分开时思念的痛苦。  </p>
<p>我希望这是我最后一次品尝，不管是不是最后一次，请不要再分开这么长的时间了。  </p>
<p>而我，也绝对绝对绝对不会再让我爱的人离开我，也不会让她再受到半点委屈。  </p>
<p>也许这就是爱情所赋予平凡人的力量吧。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg常用命令整理</title>
    <url>/2020/11/15/ffmpeg-command-finish/</url>
    <content><![CDATA[<h2 id="检测源流信息"><a href="#检测源流信息" class="headerlink" title="检测源流信息"></a>检测源流信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址</span><br></pre></td></tr></table></figure>

<h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口"><a href="#把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口" class="headerlink" title="把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口"></a>把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i A.mp4  -re -i B.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1  -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure>
<p>以此类推  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推一路流</span><br><span class="line">ffmpeg -re -i A.mp4 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1  -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">推三路流</span><br><span class="line">ffmpeg -re -i shenzhen.ts  -re -i guangdong.ts -re -i girl.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -program program_num=5:title=videoXXX:st=4:st=5 -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure>

<p>循环推一路流，不做编码  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure>

<h3 id="命令参数解释"><a href="#命令参数解释" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul>
<li>re:realtime 推的速度，按当前帧率推  </li>
<li>map 0:0  第一个流的视频  </li>
<li>map 0:1  第一个流的音频  </li>
<li>map 1:0  第二个流的视频  </li>
<li>map 1:1  第二个流的音频  </li>
<li>program_num&#x3D;1:title&#x3D;videoA:st&#x3D;0:st&#x3D;1            0,1合成一个视频videoA</li>
<li>program program_num&#x3D;3:title&#x3D;videoB:st&#x3D;2:st&#x3D;3    2,3合成一个视频videoB  </li>
<li>-stream_loop 循环推流  </li>
<li>-c copy 将视频中压缩的数据复制  </li>
<li>-c:v libh264 将视频流强制转换为h264编码</li>
</ul>
<h2 id="查看流中的program信息"><a href="#查看流中的program信息" class="headerlink" title="查看流中的program信息"></a>查看流中的program信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffprobe -show_programs -print_format json -timeout 5000000 -i udp://localhost:10003  </span><br></pre></td></tr></table></figure>

<ul>
<li>注意:这个命令有返回值，<code>0</code>表示执行成功，<code>1</code>表示失败。</li>
</ul>
<h2 id="将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件"><a href="#将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件" class="headerlink" title="将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件"></a>将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -timeout 5000000 -i udp://localhost:10003  -t 0:0:5  -map p:1 -c copy  1.mp4 -t 0:0:5 -map p:3 -c copy 3.mp4 </span><br></pre></td></tr></table></figure>
<ul>
<li>注意。此时推的是复合流。</li>
</ul>
<h2 id="对视频流抽帧"><a href="#对视频流抽帧" class="headerlink" title="对视频流抽帧"></a>对视频流抽帧</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址 -vframes 1 -vf scale=90:51 图片存放路径</span><br></pre></td></tr></table></figure>

<h2 id="重复推流"><a href="#重复推流" class="headerlink" title="重复推流"></a>重复推流</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">./ffmpeg -re  -i -stream_loop -1 startslient.mp3  -c:a aac -f flv rtmp://123.56.17.184/live/znn</span><br></pre></td></tr></table></figure>

<h2 id="将流保存成文件"><a href="#将流保存成文件" class="headerlink" title="将流保存成文件"></a>将流保存成文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 流地址 -c copy 文件名</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">ffmpeg -i udp://localhost:10003 -c copy test.ts</span><br></pre></td></tr></table></figure>

<h2 id="检测源流中是否有静音"><a href="#检测源流中是否有静音" class="headerlink" title="检测源流中是否有静音"></a>检测源流中是否有静音</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -</span><br><span class="line">(默认音频中如果有2秒是静音，就认为是有静音的)</span><br><span class="line"></span><br><span class="line">持续让ffmpeg检测音频5秒</span><br><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -t 0:0:5 -f null -</span><br></pre></td></tr></table></figure>

<h2 id="切分视频片段"><a href="#切分视频片段" class="headerlink" title="切分视频片段"></a>切分视频片段</h2><h3 id="切分纯视频片段"><a href="#切分纯视频片段" class="headerlink" title="切分纯视频片段"></a>切分纯视频片段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.flv -vsync 0 -filter_complex &quot;[0:v]select=&#x27;between(t-start_t,8.250,10.000)&#x27;[xv];[xv]setpts=&#x27;PTS-STARTPTS&#x27;[vout];[vout]scale=1920:1080,pad=1920:1080:0:0:black[vout2]&quot; -map &quot;[vout2]&quot; -c:v libx264 test.ts</span><br></pre></td></tr></table></figure>

<h3 id="切分纯音频片段"><a href="#切分纯音频片段" class="headerlink" title="切分纯音频片段"></a>切分纯音频片段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.mp3 -filter_complex &quot;[0:a]aselect=&#x27;between(t,0.000,26.250)&#x27;[xa];[xa]asetpts=&#x27;NB_CONSUMED_SAMPLES/SAMPLE_RATE*1/TB&#x27;[aout] &quot; -map &quot;[aout]&quot; out.mp3</span><br></pre></td></tr></table></figure>

<h3 id="切分带音频的视频片段"><a href="#切分带音频的视频片段" class="headerlink" title="切分带音频的视频片段"></a>切分带音频的视频片段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.flv -filter_complex &quot;[0:v]select=&#x27;between(t-start_t,5.250,10.000)&#x27;[xv];[xv]setpts=&#x27;PTS-STARTPTS&#x27;[vout];[vout]scale=[vout2]&quot; -r 25 -map &quot;[vout2]&quot; -c:v libx264 -x264-params sps-id=6 out.ts</span><br></pre></td></tr></table></figure>

<h3 id="命令参数解释-1"><a href="#命令参数解释-1" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul>
<li>-vsync 0：打印ffmpeg详细日志的开关  </li>
<li>black：添加黑边  </li>
<li>libx264：编码</li>
</ul>
<h2 id="合并视频片段"><a href="#合并视频片段" class="headerlink" title="合并视频片段"></a>合并视频片段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -f concat -safe 0 -i test.txt -c copy out.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li>test.txt：一个文件列表，里面存放着要合并的视频片段名  </li>
<li>-f concat -safe 0：打开文件时会用到</li>
</ul>
<h2 id="合并视频的同时添加图片和文字水印"><a href="#合并视频的同时添加图片和文字水印" class="headerlink" title="合并视频的同时添加图片和文字水印"></a>合并视频的同时添加图片和文字水印</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -f concat -safe 0 -i test.txt -t 27.040 -loop 1 -i 1080P%05d.png -filter_complex &quot;[0:v][1:v]overlay=x=0:y=885:enable=&#x27;between(t,0,30)&#x27;[out];[out]drawtext=fontfile=simhei.ttf:text=&#x27;name&#x27;:x=414:y=928:fontsize=60:fontcolor=white:enable=&#x27;between(t,0,30)&#x27;[out];[out]drawtext=fontfile=simhei.ttf:text=&#x27;title&#x27;:x=630:y=933:fontsize=52:fontcolor=white:enable=&#x27;between(t,0,30)&#x27;&quot; -y -c:v libx264 out.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li>-loop 1，让png序列循环</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://superuser.com/questions/1335639/how-can-i-overlay-png-image-sequence-but-start-at-particular-frame-using-ffmpeg">how-can-i-overlay-png-image-sequence-but-start-at-particular-frame-using-ffmpeg</a>  </p>
<p><a href="https://blog.csdn.net/m0_37684310/article/details/78257779">利用ffmpeg实现添加图片水印和文字水印，添加多个水印</a>  </p>
<p><a href="https://www.jianshu.com/p/c0e151775075">使用ffmpeg给视频添加图片及文字水印</a>  </p>
]]></content>
      <categories>
        <category>Learn-FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视音频</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下FFmpeg源码编译安装流程</title>
    <url>/2020/09/20/ffmpeg-install-process/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>自学视音频编解码，先从<code>FFmpeg</code>开始。本文记录下载、编译、安装<code>FFmpeg</code>的全过程。  </p>
<h2 id="下载编译安装"><a href="#下载编译安装" class="headerlink" title="下载编译安装"></a>下载编译安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure>

<h3 id="配置，编译FFmpeg"><a href="#配置，编译FFmpeg" class="headerlink" title="配置，编译FFmpeg"></a>配置，编译FFmpeg</h3><ul>
<li><p>1，安装yasm  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install yasm</span><br></pre></td></tr></table></figure>
</li>
<li><p>2，创建一个ffmpeg_install的目录，存放编译生成的文件  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir ffmpeg_install</span><br></pre></td></tr></table></figure>
</li>
<li><p>3，在ffmpge源码文件夹下运行命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=../ffmpeg-src/ffmpeg_install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>另外，可以根据<code>./configure --help</code>命令来查看关于FFMPEG的配置参数。  </p>
<ul>
<li>4，编译安装  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j16</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>接着我们就可以在<code>ffmpeg_install</code>这个文件夹下看到如下目录  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">├── share</span><br></pre></td></tr></table></figure>

<ul>
<li>5，生成可执行文件</li>
</ul>
<p>在<code>bin</code>目录下执行这条命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ffmpeg</span><br><span class="line"></span><br><span class="line">报错</span><br><span class="line">./ffmpeg: error while loading shared libraries: libavdevice.so.57: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>系统提示找不到动态库，我们用<code>ldd ffmpeg</code>命令看看运行当前可执行文件需要哪些动态库  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd ffmpeg</span><br><span class="line">	linux-vdso.so.1 (0x00007ffdf7584000)</span><br><span class="line">	libavdevice.so.58 =&gt; not found</span><br><span class="line">	libavfilter.so.7 =&gt; not found</span><br><span class="line">	libavformat.so.58 =&gt; not found</span><br><span class="line">	libavcodec.so.58 =&gt; not found</span><br><span class="line">	libswresample.so.3 =&gt; not found</span><br><span class="line">	libswscale.so.5 =&gt; not found</span><br><span class="line">	libavutil.so.56 =&gt; not found</span><br><span class="line">	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fc3e2f66000)</span><br><span class="line">	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fc3e2d47000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc3e2956000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fc3e3546000)</span><br></pre></td></tr></table></figure>

<ul>
<li>6，配置环境变量  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH=lib/</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在<code>./ffmpeg_install/bin</code>目录下运行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH=../lib/</span><br></pre></td></tr></table></figure>

<p>此时我们再运行<code>ldd ffmpeg</code>命令查看  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd ffmpeg</span><br><span class="line">	linux-vdso.so.1 (0x00007ffc701f7000)</span><br><span class="line">	libavdevice.so.58 =&gt; ../lib/libavdevice.so.58 (0x00007f0f70b9c000)</span><br><span class="line">	libavfilter.so.7 =&gt; ../lib/libavfilter.so.7 (0x00007f0f7068f000)</span><br><span class="line">	libavformat.so.58 =&gt; ../lib/libavformat.so.58 (0x00007f0f70233000)</span><br><span class="line">	libavcodec.so.58 =&gt; ../lib/libavcodec.so.58 (0x00007f0f6eb0b000)</span><br><span class="line">	libswresample.so.3 =&gt; ../lib/libswresample.so.3 (0x00007f0f6e8ee000)</span><br><span class="line">	libswscale.so.5 =&gt; ../lib/libswscale.so.5 (0x00007f0f6e663000)</span><br><span class="line">	libavutil.so.56 =&gt; ../lib/libavutil.so.56 (0x00007f0f6e23e000)</span><br><span class="line">	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f0f6dea0000)</span><br><span class="line">	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f0f6dc81000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0f6d890000)</span><br><span class="line">	libxcb.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libxcb.so.1 (0x00007f0f6d668000)</span><br><span class="line">	libxcb-shm.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libxcb-shm.so.0 (0x00007f0f6d465000)</span><br><span class="line">	libxcb-shape.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libxcb-shape.so.0 (0x00007f0f6d261000)</span><br><span class="line">	libxcb-xfixes.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libxcb-xfixes.so.0 (0x00007f0f6d059000)</span><br><span class="line">	libasound.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libasound.so.2 (0x00007f0f6cd52000)</span><br><span class="line">	libva.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libva.so.2 (0x00007f0f6cb31000)</span><br><span class="line">	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f0f6c914000)</span><br><span class="line">	libva-drm.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libva-drm.so.2 (0x00007f0f6c711000)</span><br><span class="line">	libvdpau.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libvdpau.so.1 (0x00007f0f6c50d000)</span><br><span class="line">	libX11.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libX11.so.6 (0x00007f0f6c1d5000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f0f70ff2000)</span><br><span class="line">	libXau.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libXau.so.6 (0x00007f0f6bfd1000)</span><br><span class="line">	libXdmcp.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 (0x00007f0f6bdcb000)</span><br><span class="line">	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0f6bbc7000)</span><br><span class="line">	librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f0f6b9bf000)</span><br><span class="line">	libdrm.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libdrm.so.2 (0x00007f0f6b7ae000)</span><br><span class="line">	libXext.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libXext.so.6 (0x00007f0f6b59c000)</span><br><span class="line">	libbsd.so.0 =&gt; /lib/x86_64-linux-gnu/libbsd.so.0 (0x00007f0f6b387000)</span><br></pre></td></tr></table></figure>

<p>然后再去运行<code>bin</code>目录下的<code>ffmpeg</code>可执行文件  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./ffmpeg </span><br><span class="line">ffmpeg version N-95621-g53c21c2d6b Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">  built with gcc 7 (Ubuntu 7.4.0-1ubuntu1~18.04.1)</span><br><span class="line">  configuration: --prefix=/home/zoctopus/sofoware/ffmpeg-src/ffmpeg_install --enable-shared --disable-static --disable-doc</span><br><span class="line">  libavutil      56. 35.101 / 56. 35.101</span><br><span class="line">  libavcodec     58. 60.100 / 58. 60.100</span><br><span class="line">  libavformat    58. 33.100 / 58. 33.100</span><br><span class="line">  libavdevice    58.  9.100 / 58.  9.100</span><br><span class="line">  libavfilter     7. 66.100 /  7. 66.100</span><br><span class="line">  libswscale      5.  6.100 /  5.  6.100</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br></pre></td></tr></table></figure>



<p>默认文件位置：</p>
<p>默认安装在&#x2F;user&#x2F;local文件下，其中：</p>
<ol>
<li><p>头文件在&#x2F;usr&#x2F;local&#x2F;include目录下</p>
</li>
<li><p>编译好的libs放在&#x2F;usr&#x2F;local&#x2F;lib目录下</p>
</li>
<li><p>可执行文件放在&#x2F;usr&#x2F;local&#x2F;bin目录下(ffmpeg、ffprobe、ffserver)</p>
</li>
<li><p>文档放在&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1目录下</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/qq_31186123/article/details/81180918">ubuntu 编译安装ffmpeg</a></li>
</ul>
]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视音频编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>今年终于要开始忙了</title>
    <url>/2021/04/17/first-entrepreneurship/</url>
    <content><![CDATA[<p>昨天收到两条消息，我的副业&amp;创业终于要开始了。  </p>
<p>聊天1：  </p>
<p>和川大计算机硕士毕业的学长一起做一款程序，预计9月初上线。  </p>
<p>这位学长我是意外在工作中认识的，后来他毕业后，我俩有次在望江楼公园闲聊，他说他第一眼看到我就觉得我是个非常<code>nice</code>的人。我笑了笑说，一般对我没有攻击的我我都会真诚以待，不造谣，隐私除外。  </p>
<p>技术和市场都做完调研，但对我来说是一块全新的领域。  </p>
<p>聊天2：  </p>
<p>和清华在读博士的创业。  </p>
<p>2月底他找到我时，问我有没有兴趣做这个，他目前拿到第一笔融资，想等9月中旬项目第一版上线后再去谈下一笔融资。我不懂融资，但我信过他这个人，从本科时接触他写的<a href="http://www.demongan.com/">恶魔的世界</a>，到硕士出了一本黑客书籍，并创办了<a href="https://www.write-bug.com/">WRITR-BUG技术共享平台</a>，在他身上我看到了许多将不可能转换为可能的事情。  </p>
<p>2017年夏天我和他在北邮相遇，非常帅气的小伙子，带我逛了北邮，同时在他面前班门弄斧了一下汇编，哈哈  </p>
<p>2月底他打电话说如果我要做的话，就会给我发工资，我说你即使不给我发工资我也愿意做。我嘛，总觉得按部就班的会缺少一些什么，你给我的这次机会，我要好好把握，我觉得我的一生，总要去尝试一些没有做过的事情。  </p>
<p>半年时间，半年后，我会来这里还愿。  </p>
<p>GOOD LUCK~</p>
]]></content>
      <categories>
        <category>Try-to-Challenges</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>融资</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>第一款 iPad 和 Apple Pencil</title>
    <url>/2020/06/22/first-ipad-and-apple-pencil/</url>
    <content><![CDATA[<p>今天利用好友推荐的官网教育优惠，终于下单了<code>Apple Pencil 一代</code>！  </p>
<p><img src="/2020/06/22/first-ipad-and-apple-pencil/pencil-edu.png">  </p>
<p>虽然比我预想的还要贵一些（因为之前3月底的时候答应一学妹，ipad2018 128g + pencil 2600元搞定），但因为疫情原因，学校迟迟不开学，正好6月1号京东苹果官方旗舰店秒杀<code>ipad2019 128g</code>，于是下单了，无奈<code>pencil</code>一直到618都没有降价（天猫苏宁旗舰店必须要凑单满1000减100即可，买一些没用的，总共要八百多，放弃）。  </p>
<p>朋友说，虽然贵一些，但因为是官网，比较省心，今天终于体会到了。  </p>
<p>希望这两位可以作为我强有力的生产力工具，加油！  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>ipad</tag>
        <tag>pencil</tag>
        <tag>生产力</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个Kubernetes应用</title>
    <url>/2022/09/06/first-kubernetes-app/</url>
    <content><![CDATA[<p>本文将以创建一个<code>nginx</code>的<code>deployment</code>为例体验<code>Kubernetes</code>的基础使用  </p>
<p><code>Kubernetes</code>跟<code>Docker</code>等很多项目最大的不同是：<strong>它不推荐你使用命令行方式的方式直接运行容器，而是希望你用YAML文件的方式，即把容器的定义、参数、配置都记录在一个YAML文件中</strong>，然后用  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl create -f test.yml</span><br></pre></td></tr></table></figure>

<p>运行起来。  </p>
<p>这么做最直接的好处就是，会有一个文件记录下<code>Kubernetes</code>到底运行了什么。  </p>
<h1 id="编写YAML文件"><a href="#编写YAML文件" class="headerlink" title="编写YAML文件"></a>编写YAML文件</h1><p><code>nginx-deployment.yaml</code>文件内容：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 过滤规则的定义</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 定义Pod副本个数为2</span></span><br><span class="line"> <span class="attr">template:</span> </span><br><span class="line">   <span class="attr">metadata: labels:</span> <span class="comment"># 元数据</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># labels，一组键值对的标签</span></span><br><span class="line">   <span class="attr">spec:</span> </span><br><span class="line">     <span class="attr">containers:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx:1.7.9</span> </span><br><span class="line">       <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Deployment</code>是一个定义多副本应用（多个副本Pod）的对象，此外，<code>Deployment</code>还负责在<code>Pod</code>定义发生变化时对每个副本进行滚动更新；  </li>
<li><code>Pod</code>是<code>Kubernetes</code>世界里的”应用运行单元”，而一个应用运行单元可以由多个容器组成；  </li>
<li>使用一种API对象（Deployment）管理另一种API对象（Pod），在<code>Kubernetes</code>中叫作控制器模式（<code>controller pattern</code>）  </li>
<li><code>Labels</code>作用：可以通过它从<code>Kubernetes</code>中过滤出它所关心的被控制对象；  </li>
<li>另外，在<code>Metadata</code>中，还有一个与<code>Labels</code>格式、层级完全相同的字段，叫做<code>Annotations</code>。它专门用来携带键值对格式的内部信息。所谓内部信息，指的是对这些信息感兴趣的是<code>Kubernetes</code>组件，而不是用户。所以大多数<code>Annotations</code>是在<code>Kubernetes</code>运行过程中被自动加在这个<code>API</code>对象上；  </li>
<li>一个<code>Kubernetes</code>的<code>API</code>对象定义，大多可以分为<code>Metadata</code>和<code>Spec</code>两个部分，前者存放的是这个对象的元数据，而后者存放的是属于这个对象的定义，用来描述它所要表达的功能。</li>
</ul>
<h1 id="运行YAML文件"><a href="#运行YAML文件" class="headerlink" title="运行YAML文件"></a>运行YAML文件</h1><p>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx-default.yaml</span><br></pre></td></tr></table></figure>

<p>然后，通过<code>kubectl get</code>命令检查这个<code>YAML</code>运行起来的状态  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l app=nginx</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl1.png">  </p>
<p>此外，还可以使用<code>kubectl describe</code>命令查看一个API对象的细节，比如  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-67594d6bf6-4vkq9</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl2.png">  </p>
<ul>
<li>在<code>Kubernetes</code>执行的过程中，对API对象的所有重要操作都会被记录在这个对象的<code>Events</code>里，并且显示在<code>kubectl describe</code>指令返回的结果中。</li>
</ul>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>接下来，如果要升级这个<code>Nginx</code>服务，把它的镜像版本从1.7.9升级到1.8，只需要修改这个YAML文件即可：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 过滤规则的定义</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 定义Pod副本个数为2</span></span><br><span class="line"> <span class="attr">template:</span> </span><br><span class="line">   <span class="attr">metadata: labels:</span> <span class="comment"># 元数据</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># labels，一组键值对的标签</span></span><br><span class="line">   <span class="attr">spec:</span> </span><br><span class="line">     <span class="attr">containers:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx:1.8</span> <span class="comment"># 这里从1.7.9修改为1.8</span></span><br><span class="line">       <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>然后执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl3.png">  </p>
<h2 id="声明书API"><a href="#声明书API" class="headerlink" title="声明书API"></a>声明书API</h2><p><code>kubectl apply -f</code>的操作方法是&#96;&#96;Kubernetes<code>声明式API所推荐的用法。也就说，作为用户，你不必关心当前的操作是创建还是更新，你执行的命令始终是</code>kubectl apply<code>，这个YAML文件描述的就是你这个应用的期望状态，或者说最终状态。而当这个文件发生变化后，</code>Kubernetes&#96;会根据具体的变化内容自动进行处理，将整个系统的状态向你所定义的最终状态“逐步逼近”，最终重新“达成一致”。  </p>
<p>这个流程的好处是有助于开发人员和运维人员围绕可以版本化管理的YAML文件，而不是“行踪不定”的命令式进行写作，从而大大降低沟通成本。这种面向最终状态的分布式系统设计原则就被称为“声明式API”。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>所以，如果通过容器镜像能够保证应用本身在开发环境与部署环境中的一致性的话，那么现在<code>Kubernetes</code>项目通过YAML文件就保证了应用的“部署配置”在开发环境与部署环境中的一致性。而当应用本身发生变化时，开发人员和运维人员可以依靠容器镜像来进行同步，当应用部署参数发生变化时，这些YAML文件就是他们相互沟通和信任的媒介。  </p>
<h1 id="在Deployment中声明Volume"><a href="#在Deployment中声明Volume" class="headerlink" title="在Deployment中声明Volume"></a>在Deployment中声明Volume</h1><p>在<code>Kubernetes</code>中，<code>Volume</code>属于<code>Pod</code>对象的一部分，所以，我们需要修改这个YAML文件里的<code>template.spec</code>字段：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 过滤规则的定义</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 定义Pod副本个数为2</span></span><br><span class="line"> <span class="attr">template:</span> </span><br><span class="line">   <span class="attr">metadata: labels:</span> <span class="comment"># 元数据</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># labels，一组键值对的标签</span></span><br><span class="line">   <span class="attr">spec:</span> </span><br><span class="line">     <span class="attr">containers:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx:1.8</span></span><br><span class="line">       <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">       <span class="attr">volumeMounts:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">nginx-vol</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-vol</span> <span class="comment"># Volume的名称</span></span><br><span class="line">       <span class="attr">emptyDir:</span> &#123;&#125;    <span class="comment"># Volume的类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>emptyDir</code>类型等同于<code>Docker</code>的隐式<code>Volume</code>参数，即不显式声明宿主机目录的<code>Volume</code>。所以，<code>Kubernetes</code>也会在宿主机上创建一个临时目录，这个目录将会在被绑定挂载到容器所声明的<code>Volume</code>目录上。</li>
</ul>
<p>执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl4.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-54d8dff7d7-r6z8t</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl5.png">  </p>
<p>最后，还可以使用<code>kubectl exec</code>指令进入这个<code>Pod</code>中（容器的<code>Namespace</code>中）查看这个<code>Volume</code>目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it nginx-deployment-54d8dff7d7-r6z8t -- /bin/bash</span><br><span class="line"></span><br><span class="line">ls /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl6.png">  </p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>若要从<code>Kubernetes</code>集群中删除这个<code>Nginx Deployment</code>，直接执行以下命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/06/first-kubernetes-app/kubectl7.png">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一个完整<code>kubernetes</code>应用从创建，更新到删除的全过程，以及目录挂载的命令使用。</p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次做项目学到的技术之外的东西</title>
    <url>/2019/03/28/first-work-project-havest/</url>
    <content><![CDATA[<p>三月初转正后开始接手公司内的一个有关流媒体收录系统服务器方面的项目，和部门老哥，产品，测试，运维，前端交流，对需求，看bug，学习到了很多编程之外的技能，写篇文章记录下来。  </p>
<h2 id="接手新项目"><a href="#接手新项目" class="headerlink" title="接手新项目"></a>接手新项目</h2><ul>
<li>把完整的接口说明文档，配置文件拿到手，大致先过一遍  </li>
<li>学会打断点，代码不是文章，不能从头读到尾，除非是一个文件只有一个<code>main</code>函数从头跟到尾  </li>
<li>有不懂就赶紧问，时间不等人！  </li>
<li>大部分时间都是把逻辑理清楚，代码只是分分钟的事情。</li>
</ul>
<h2 id="与产品沟通"><a href="#与产品沟通" class="headerlink" title="与产品沟通"></a>与产品沟通</h2><ul>
<li>大部分产品是不写代码的，所以不要和他&#x2F;她扯到程序内部的实现上，否则他&#x2F;她会很懵逼  </li>
<li>遇到需求完成不了或觉得有问题，应尽早提出来</li>
</ul>
<h2 id="与其他部门的沟通"><a href="#与其他部门的沟通" class="headerlink" title="与其他部门的沟通"></a>与其他部门的沟通</h2><ul>
<li>其实在做编码设计的时候，我的时间不是整块的，有时候会被测试，运维临时打断去处理bug  </li>
<li>学会把时间整片化，例如25-30分钟做一件事情，如果中间被要求去解决<code>bug</code>，咨询他能否等10分钟  </li>
<li>每次解决完一个<code>bug</code>，把问题和解决过程描述清楚，记录在<code>wiki</code>上，方便自己和其他相关人员以后查看  </li>
<li>学会看日志，通过日志分析问题的所在</li>
</ul>
<h2 id="排查bug的基本流程"><a href="#排查bug的基本流程" class="headerlink" title="排查bug的基本流程"></a>排查bug的基本流程</h2><p>当运维、测试那里出现问题需要你来解决时，解决流程是这样的:  </p>
<ul>
<li>先看配置文件是否正确，也许是模式<code>model</code>选错，也许是路径没有配置正确;  </li>
<li>再看日志记录;(所以前提是自己要在关键模块打详细日志描述，方便排查问题)  </li>
<li>然后再看版本号是否正确;  </li>
<li>最后再将问题在本机复现，用<code>dlv</code>或<code>gdb</code>打断点调试找出问题;  </li>
<li>当问题解决后，一定记得在<code>wiki</code>里做好相应的记录，原因有二，帮助自己整理和回顾项目中的业务流程，当另外的运维或测试碰到类似的问题时，直接让它看<code>wiki</code>记录就可以，自己可以专心干其他的事情。</li>
</ul>
<p>加油！这将是我正式开发和维护的第一个<code>Golang</code>语言的项目！  </p>
<p><img src="/2019/03/28/first-work-project-havest/beautiful.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>工作</tag>
        <tag>学习</tag>
        <tag>沟通</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>写给高中的你</title>
    <url>/2011/11/26/for-you-in-high-school/</url>
    <content><![CDATA[<p>To:you——你  </p>
<p>嗨…恋恋，听说你考上了高级中学，而且还在重点班，我发自内心的为你而感到高兴、自豪。因为你实现了自己初中时的目标。  </p>
<p>上高中了，就要端正学习态度，不要再像初中学习时打打闹闹的样子了，也不要像初一时那么“疯”了，要和同学之间和睦相处，不要耍小脾气。（开玩笑例外）  </p>
<p>高一时，感觉一切都很新鲜——陌生的面孔，陌生的环境，这就在考验你的社会适应能力，我相信你一定能度过这一关的！上高中后首先能体验到的是课上的“快节奏”与课下的“重压力”，为此你也戴上了眼镜，并且高中生活打破了你初中生活零点之前睡觉的记录！这些——我可以理解，我理解你为高一期中考试付出了努力却收获甚微而懊恼不已…朋友，请听我说，其实——他们也一样，只是你比较粗心，犯的错误比别人多了些，不要放弃，因为这对于你来说只是一次“热身”，如果这时候你选择放弃，你将失去一切！请相信——阳光总在风雨后！<br>（Please believe that sunshine always comes after the rainstorm!）  </p>
<p>高二时，会进行文理分科。我觉得，根据你的性格和理想，你无论如何都会选择理科，因为你将要当的是领导而不是领导的助手！加油吧，成功只属于你！<br>（Come on,because success belongs to you!）</p>
<p>高二时，你也将16岁了，16岁——是一个花季年华。这时候，你可能会有自己仰慕已久的女生，可能会有属于自己的girl friend，虽然不是最漂亮的，但很可爱，而且很乖。记得：要好好的照顾她，付起责任来，不要让她不开心；不要让她失望；当她遇到困难或不高兴的时候，要好好的安慰她，关心她；当她遇到危险或被别人欺负时，你要挺身而出，不要让她受到伤害，人生最幸福的事——就是你和她一起在黎明前看日出；在黑色的星空上看流星划过，然后互相许一个相同的愿望；在旅途中听街边小草叶上的雨露，感受雨后刚“洗浴”完的和煦的阳光。加油吧，幸福来自于你和她的内心！<br>（Come on,happiness comes from your and her heart!）  </p>
<p>高二时，或许是因为繁重的学习压力；或许是因为自己已经长大了；或许是因为遇到一些不顺心的事；你会烦躁，会和父母顶嘴。但是，请你记住：父母永远是为你好，你的任性，还有你没有经过大脑思考而脱口而出的话语，会使父母心痛不已。所以，当你遇到这种情况时，要用耳朵去倾听，尽量不要与他们斗嘴。<br>（Please you don’t argue with your parents!）  </p>
<p>当心情压抑之时，请在一望无际的星空中感受微凉的清风缓缓拂过你的脸庞，欣赏周围的景色，再哼上几段小曲，在悠哉的环境中，那不快的心情也会一扫而光。  </p>
<p>高三时，是你高中学习中最重要的一个阶段。你不仅要冲刺高考，而且与同学相处的时间也愈来愈短。所以，一切都要珍惜，珍惜所有的一切！  </p>
<p>希望你在高考时能实现自己的目标，笑着走出来！加油吧，一切皆有可能发生，只要你肯努力拼搏！<br>（Come on,nothing is impossible,unless you don’t work hard!）  </p>
<p>我会在某个时间等着你的，朋友！<br>From:me——我  </p>
<p>(这篇文章是我进入高中后突然看到一篇书信文章有感而发写出来的，也因此从我心中开始幻化出另一个人-恋恋，念念与恋恋彼此沟通，彼此倾诉，彼此成长…想想我那时候还真是幼稚的可爱啊^_^)  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>高中</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转Docker-鸟瞰容器生态系统</title>
    <url>/2021/04/08/fun-with-docker-0-container-ecosystem/</url>
    <content><![CDATA[<p>这篇文章有一张思维导图足以  </p>
<p><img src="/2021/04/08/fun-with-docker-0-container-ecosystem/container.jpg">  </p>
<p>意外发现一本国人写的《玩转Docker容器技术》，好好学习一下Docker系列，就从开头为<code>fun with...</code>开始。  </p>
]]></content>
      <categories>
        <category>Learn-Docker</category>
      </categories>
  </entry>
  <entry>
    <title>玩转docker-核心知识概述</title>
    <url>/2021/04/08/fun-with-docker-1-core-knowledge/</url>
    <content><![CDATA[<h2 id="What——什么是容器"><a href="#What——什么是容器" class="headerlink" title="What——什么是容器"></a>What——什么是容器</h2><p>容器由两部分组成：（1）应用程序本身；（2）依赖：比如应用程序需要的库或其他软件容器在Host操作系统的用户空间中运行，与操作系统的其他进程隔离。这一点显著区别于的虚拟机。  </p>
<p>传统的虚拟化技术，比如VMWare、KVM、Xen，目标是创建完整的虚拟机。为了运行应用，除了部署应用本身及其依赖（通常几十MB），还得安装整个操作系统（几十GB）。  </p>
<h2 id="Why——为什么需要容器"><a href="#Why——为什么需要容器" class="headerlink" title="Why——为什么需要容器"></a>Why——为什么需要容器</h2><p>容器使软件具备了超强的可移植能力。  </p>
<p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。容器可以运行在几乎所有的操作系统上  </p>
<h3 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h3><p>对于开发人员：Build Once、Run Anywhere。  </p>
<p>对于运维人员：Configure Once、Run Anything。  </p>
<h2 id="How——容器是如何工作的"><a href="#How——容器是如何工作的" class="headerlink" title="How——容器是如何工作的"></a>How——容器是如何工作的</h2><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker的核心组件包括：<br>● Docker客户端：Client<br>● Docker服务器：Docker daemon<br>● Docker镜像：Image● Registry<br>● Docker容器：Container  </p>
<h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。  </p>
<h3 id="Docker服务器"><a href="#Docker服务器" class="headerlink" title="Docker服务器"></a>Docker服务器</h3><p>Docker daemon是服务器组件，以Linux后台服务的方式运行  </p>
]]></content>
      <categories>
        <category>Learn-Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现低配版 scanf 函数</title>
    <url>/2020/05/23/geekbang-column-DIY-scanf-function-by-yourself/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>仿照 scanf 函数，实现一个低配版的 my_scanf 函数。这个函数的功能，简单来说就是将一个字符串信息转换成整型数字，能够完成这个任务，你会更深刻的理解 scanf 函数，更深刻的理解参数设计。  </p>
<p>例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个基础功能</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">98</span>;</span><br><span class="line">my_scanf(<span class="string">&quot;12345&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n); <span class="comment">// 输出 12345，而不是 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个基础功能</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">98</span>, m = <span class="number">0</span>;</span><br><span class="line">my_scanf(<span class="string">&quot;123 45&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n = %d m = %d&quot;</span>, n, m); <span class="comment">// 输出 n = 123 m = 45</span></span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_scanf</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> *ret)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;  <span class="comment">//定义存放转换结果的 num 变量，用来标记正负数的flag 变量。0 代表正数，1 代表负数。</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) str += <span class="number">1</span>, flag = <span class="number">1</span>; <span class="comment">//判断字符串中的第一位是不是字符 ‘-’，如果是字符 ‘-’，就将 flag 标记为 1，并且把 str 字符指针所指的位置，向后跳动一位，因为 ‘-’ 后面就是要转换的第一个数字字符了。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//遍历字符串剩余的每一位，每次将当前字符所代表的数字，放到 num 数字的末尾。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) num = -num;  <span class="comment">//如果是负数，数字前需要加-</span></span><br><span class="line">    *ret = num;  <span class="comment">//把 num 中的值拷贝到 ret 所指向的存储区中，也就是主函数中的 n 变量的内存区中。</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];  <span class="comment">//定义字符数组 str</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">65</span>;  <span class="comment">//定义整型变量 n</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);  <span class="comment">//读入一个字符串，将其保存在字符数组中</span></span><br><span class="line">    my_scanf(str, &amp;n);  <span class="comment">//使用 my_scanf 函数将字符数组中的字符串信息，转换成为整型信息存储在 n 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);  <span class="comment">//使用 printf 函数输出 n 的值，加以确认</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>函数的作用，是做功能封装，以便在程序其他地方复用相关功能。  </li>
<li>函数的参数传递过程，就是“实参”给“形参”赋值的过程，“实参”与“形参”之间互相独立，互不影响。  </li>
<li>在函数参数设计中，一定要分清楚，传入参数和传出参数在功能上的差别。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>scanf</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理命令：让编译器帮你写代码</title>
    <url>/2020/05/23/geekbang-column-Pre-processing-cmd-let-the-compiler-write-the-code-for-you/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个打印“漂亮日志格式”的方法。  </p>
<p>首先我们先说“日志”的作用，程序中的“日志”，通常是指在程序运行过程中，输出的一些与程序当前状态或者数据相关的一些信息。这些信息，可以帮助程序开发人员做调试，帮助运营人员做数据分析，帮助管理人员分析日活等等。总而言之，一份合理的日志信息，是非常有价值的数据。而我们今天呢，接触一种最简单的日志形式，就是程序运行过程中的调试信息。  </p>
<p>请你实现一个参数形式和 printf 函数一样的 log 方法，用法如代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会看到上述代码中，有一个和 printf 名字不一样可用法完全一样的方法叫做 log，而这个 log 的输出结果，和 printf 可不一样。  </p>
<p>具体如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 123</span><br><span class="line">[main, 10] a = 123</span><br><span class="line">[func, 4] a = 123</span><br></pre></td></tr></table></figure>

<p>你会看到 log 的方法，虽然和 printf 函数的用法一致，可在输出内容中，log 方法的输出明显比 printf 函数的输出要多了一些信息。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>如何定义一个支持可变参数的log宏：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> log(frm, args...) <span class="comment">// 假装这里有内容，后续展开讲解</span></span></span><br></pre></td></tr></table></figure>

<p>所以可以将 log 方法的使用方式与 printf 类似了：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> log(frm, args...) printf(frm, args)</span></span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log(frm, args...) &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;[%s : %d] &quot;</span>,__func__,__LINE__); \</span></span><br><span class="line"><span class="meta">    printf(frm, ##args); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;##&quot;的作用是对token进行连接，这里的args就是token,如果token为空，那么不进行连接，所以允许省略可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//[main : 11] hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，没有-Bug-的-MAX-宏"><a href="#1，没有-Bug-的-MAX-宏" class="headerlink" title="1，没有 Bug 的 MAX 宏"></a>1，没有 Bug 的 MAX 宏</h3><blockquote>
<p>请你完善下面代码中的 MAX 宏，MAX 宏的作用，就是接受两个元素，选择出两个元素中的最大值。<br>完善以后的 MAX 宏，输出需要与如下给出的输出样例一致，注意，只能修改 MAX 宏的定义内容，不可以修改主函数中的内容。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P(item) printf(<span class="string">&quot;%s = %d\n&quot;</span>, #item, item);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) <span class="comment">// TODO</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(<span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>));</span><br><span class="line">    P(MAX(a++, <span class="number">5</span>));</span><br><span class="line">    P(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果参考：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MAX(2, 3) = 3</span></span><br><span class="line"><span class="comment">5 + MAX(2, 3) = 8</span></span><br><span class="line"><span class="comment">MAX(2, MAX(3, 4)) = 4</span></span><br><span class="line"><span class="comment">MAX(2, 3 &gt; 4 ? 3 : 4) = 4</span></span><br><span class="line"><span class="comment">MAX(a++, 5) = 6</span></span><br><span class="line"><span class="comment">a = 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>实现（思考过程是重点）  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line"><span class="meta">    __typeof(a) __a = (a), __b = (b); \</span></span><br><span class="line"><span class="meta">    __a &gt; __b ? __a : __b; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>C 语言的程序编译是一套过程，中间你必须搞懂的有：预处理阶段，编译阶段和链接阶段。  </li>
<li>程序最终的功能，是由“待编译源码”决定的，而“待编译源码”是由各种各样的预处理命令决定的。  </li>
<li>预处理命令之所以被称为“黑魔法”，是因为编译器会根据预处理命令改变你的源代码，这个过程，神秘而具有力量，功能强大。  </li>
<li>代码中反斜杠的后面，不能出现任何其他内容。  </li>
<li>宏定义只占用一行代码，为了增强宏定义的代码可读性，我们可以采用在行尾加反斜杠的技巧，来使得上下两行代码，变成编译器眼中的一行代码。  </li>
<li>宏的作用，就是替换，要想理解最终的代码行为，必须从宏替换以后的代码入手分析。  </li>
<li>条件编译相当于一种预处理阶段的代码剪裁技巧。  </li>
<li>编译器预设的宏，有标准的，也有非标准的，非标准的代码会影响其可移植性。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>预处理</tag>
        <tag>宏定义</tag>
      </tags>
  </entry>
  <entry>
    <title>数组：一秒钟，定义 1000 个变量</title>
    <url>/2020/05/23/geekbang-column-array-one-second-define-1000-variables/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>程序中读入一个整数 n，假设 n 不会大于 1000，请输出 1 到 n 的每一个数字二进制表示中的 1 的个数。  </p>
<p>当 n 等于 7 的时候，我们把 1 到 7 的每个数字的二进制表示罗列出来，会得到下表所示内容：  </p>
<p><img src="/2020/05/23/geekbang-column-array-one-second-define-1000-variables/array1.jpg" alt="到7的二进制表示">  </p>
<p>根据表中的内容，如果你的程序编写成功的话，程序应该分别输出 1、1、2、1、2、2、3，这些输出内容分别代表每个数字二进制表示中 1 的数量。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果我们用一个数组 f 记录相应数字二进制表示中 1 的数量，那么 f[i] 就代表 i 这个数字二进制表示中 1 的数量，从而我们可以推导得到 f[i] &#x3D; f[i &amp; (i - 1)] + 1，也就是说 i 比 i &amp; (i - 1) 这个数字的二进制表示中的 1 的数量要多一个，这样我们通过一步计算就得到 f[i] 的结果。  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);  <span class="comment">//读入一个整数n，代表要求解的范围</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">//循环n次</span></span><br><span class="line">        f[i] = f[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//每一次通过递推公式f[i] = f[i &amp; (i - 1)] + 1 计算得到 f[i] 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出 1 到 n 中每个数字二进制表示中 1 的个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 2 3 3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，去掉倍数"><a href="#1，去掉倍数" class="headerlink" title="1，去掉倍数"></a>1，去掉倍数</h3><blockquote>
<p>设计一个去掉倍数的程序，要求如下：<br>首先读入两个数字 n 和 m，n 的大小不会超过 10，m 的大小都不会超过 10000；<br>接下来读入 n 个各不相同的正整数，输出 1 到 m 中，有哪些数字无法被这 n 个正整数中任意的一个整除。  </p>
</blockquote>
<p>例子  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">3 12</span><br><span class="line">4 5 6</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 2 3 7 9 11</span><br></pre></td></tr></table></figure>

<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> check[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//使用一个 check 数组作为标记，check[i] 等于 0，代表 i 这个数字不是 n 个数字中的任何一个数字的倍数。check[i] 等于 1，代表 i 这个数字能够被 n 个数字中的某个数字整除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  <span class="comment">//首先读入 n 个数字中的某一个，存储在 num 变量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = num; j &lt;= m; j += num) &#123;</span><br><span class="line">            check[j] = <span class="number">1</span>;  <span class="comment">//循环 m 以内所有 num 的倍数，把每个数字的 check 值标记为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);  <span class="comment">//最后我们循环把 1 到 m 中没有被标记的数字输出，就是符合题目要求的所有数字。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>使用数组，可以很方便的定义出一组变量存储空间，数组下标从 0 开始。</li>
<li>数据的最基本存储单位是字节，每一个字节都有一个独一无二的地址。</li>
<li>一个变量占用若干个字节，第一个字节的地址，是这个变量的首地址，称为：变量地址。</li>
<li>字节是存储数据的最基本单位，比特是表示信息的最基本单位。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字节</tag>
        <tag>比特</tag>
      </tags>
  </entry>
  <entry>
    <title>English_Article 1：The Product-Minded Software Engineer</title>
    <url>/2020/06/14/geekbang-column-article-1-the-product-minded-software-engineer/</url>
    <content><![CDATA[<p><a href="https://blog.pragmaticengineer.com/the-product-minded-engineer/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website">The Product-Minded Software Engineer</a>  </p>
<h1 id="导读：背景知识对于理解文章究竟有多重要？"><a href="#导读：背景知识对于理解文章究竟有多重要？" class="headerlink" title="导读：背景知识对于理解文章究竟有多重要？"></a>导读：背景知识对于理解文章究竟有多重要？</h1><h2 id="背景知识的重要性"><a href="#背景知识的重要性" class="headerlink" title="背景知识的重要性"></a>背景知识的重要性</h2><p>这个标题“The Product-Minded Software Engineer”中有两个关键词，product-minded（产品思维）和 engineer（工程师）。这篇文章的主题是产品思维，那我们就要先去了解一些背景知识。  </p>
<h2 id="核心词汇：minded"><a href="#核心词汇：minded" class="headerlink" title="核心词汇：minded"></a>核心词汇：minded</h2><p>我们一般会在 minded 前面加一个形容词或名词，用连字符连接，通过连用构成复合形容词，表示“具有某种（前面形容词定义的）思维（或态度、性格）”。我们通过几个例句，来感受一下 minded 这个词的使用场景。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The United States is a sports-minded country, with millions of fans who follow football, baseball, basketball and hockey, among other sports.</span><br><span class="line">翻译：美国是一个体育意识很强的国家，有数以百万计的球迷关注足球、棒球、篮球和曲棍球等体育运动。</span><br><span class="line"></span><br><span class="line">例句：Two dozen states have asked the D.C. Circuit to block a new climate-change-minded federal law that they say will inflate electricity bills for families.</span><br><span class="line">翻译：二十多个州要求华盛顿特区巡回法院阻止一项新的关注气候变化的联邦法律，他们说这项法律将增加家庭的电费账单。</span><br><span class="line"></span><br><span class="line">例句：They are business-minded yet warm-hearted when it comes to those less fortunate, and prove that they can transform their theoretical academic knowledge into sustainable business practices through social projects.</span><br><span class="line">翻译：对于那些不幸的人，他们既有商业头脑，又有古道热肠。他们证明自己能够通过社会项目，将理论上的学术知识转化为可持续的商业实践。</span><br></pre></td></tr></table></figure>

<h1 id="什么时候适合用“词根词缀法”来背单词？"><a href="#什么时候适合用“词根词缀法”来背单词？" class="headerlink" title="什么时候适合用“词根词缀法”来背单词？"></a>什么时候适合用“词根词缀法”来背单词？</h1><p>先来精读文章第一段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Proactive with product ideas/opinions</span><br><span class="line">Product-minded engineers don’t settle for getting a specification and jumping to implement it. They think about other ideas and approach the product manager with these. They often challenge existing specifications, suggesting alternative product approaches, that might work better.  </span><br><span class="line"></span><br><span class="line">1. 积极主动地对待产品理念或观点</span><br><span class="line">具有产品思维的工程师不会满足于拿到设计说明后就匆匆忙忙地立即执行。他们会思考其他的创意，并找产品经理提出这些想法。他们经常挑战现有的设计规范，建议可能更优的替代性方法。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="proactive"><a href="#proactive" class="headerlink" title="proactive"></a>proactive</h3><p>它的意思是“积极、主动的”，它的反义词是 reactive，“消极、被动的”。  </p>
<p>我们先来看一个例句，通过这个例句我们来学习这两个词的含义。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The difference between proactive people and reactive people is that proactive people take initiative, and they come up with ideas to get things done despite the conditions they are in. Reactive people, on the other hand, usually are the ones to react to a situation rather than take initiative to create a situation.  </span><br><span class="line"></span><br><span class="line">翻译：积极主动的人和消极被动的人之间的区别在于，积极主动的人会采取主动，无论他们所处的环境如何，都会想出办法来完成任务；而消极被动型的人通常只会对形势做出被动的反应，而不会主动采取行动去创造形势。</span><br></pre></td></tr></table></figure>

<p>讲到 reactive， 想到了 reactive programming（响应式编程）。  </p>
<p>同样道理，Pro- 和 Re- 这一对反义前缀，能够帮助我们更好地理解和记忆其他单词。例如 progress（前进、进化）和 regress（后退、退化）。它们的英语解释如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Progress is to move, go, or proceed forward; to advance.</span><br><span class="line"></span><br><span class="line">Regress is to move backwards to an earlier stage; to devolve.</span><br></pre></td></tr></table></figure>

<h3 id="settle-for-x2F-settle"><a href="#settle-for-x2F-settle" class="headerlink" title="settle for &#x2F; settle"></a>settle for &#x2F; settle</h3><p>英文解释：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">settle for (something):</span><br><span class="line"></span><br><span class="line">to accept something less ideal or worse than what one really wanted;</span><br><span class="line">to agree to accept something (even though something else would be better);</span><br><span class="line">accept or be satisfied with as a compromise.</span><br></pre></td></tr></table></figure>

<p>简单来说，settle for 就是“勉强同意接受，将就或者凑合”的意思。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：He demanded a bigger raise but decided to settle for what they offered.</span><br><span class="line">翻译：他原本要求更高的涨薪，但最后决定人家给多少拿多少，凑合一下算了。</span><br><span class="line"></span><br><span class="line">例句：I could never settle for such a quiet life; I want excitement.</span><br><span class="line">翻译：我不能将就如此单调的生活。我需要刺激。</span><br></pre></td></tr></table></figure>

<p>同样，settle 这个动词有“停留、安顿”的含义，也可以衍生出“将就、凑合、妥协”的意思。苹果公司创始人乔布斯在他著名的斯坦福大学毕业典礼演讲中就有这么一段，你可以感受一下：  </p>
<blockquote>
<p>And that is as true for your work as it is for your lovers. Your work is going to fill a large &gt;part of your life, and the only way to be truly satisfied is to do what you believe is great &gt;work. And the only way to do great work is to love what you do. If you haven’t found it yet, &gt;keep looking. <strong>Don’t settle</strong>. As with all matters of the heart, you’ll know when you find it. &gt;And, like any great relationship, it just gets better and better as the years roll on.  So &gt;keep looking until you find it. <strong>Don’t settle</strong>.</p>
</blockquote>
<p>在这段话里，乔帮主两次提到“Don’t settle”，就是让我们跟随自己的内心，去寻找我们倾心的工作或爱情，找到了，你的心会告诉你，往后的日子历久弥新会越来越好；还没找到的话，千万不要放弃，不要妥协，不可以将就和凑合。  </p>
<h3 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h3><p>在工程中，指的是“设计说明书、设计规范”的意思：a detailed description of the design and materials used to make something.  </p>
<h3 id="jump-to"><a href="#jump-to" class="headerlink" title="jump to"></a>jump to</h3><p>顾名思义是“匆匆忙忙、很快，甚至有些草率”的意思。  </p>
<h4 id="第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information"><a href="#第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information" class="headerlink" title="第一种用法：jump to conclusions: to guess the facts about a situation without having enough information."></a>第一种用法：jump to conclusions: to guess the facts about a situation without having enough information.</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Don’t jump to conclusions! Perhaps it was his daughter he was dancing with.</span><br><span class="line">翻译：别匆忙下结论，和他跳舞的没准是他女儿呢。</span><br></pre></td></tr></table></figure>

<h4 id="第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly"><a href="#第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly" class="headerlink" title="第二种用法：jump to it (informal): used to tell someone to do something quickly."></a>第二种用法：jump to it (informal): used to tell someone to do something quickly.</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I told you to tidy this room - now jump to it!</span><br><span class="line">翻译：（俚语）早就让你打扫房间，怎么还这样乱！快去！</span><br></pre></td></tr></table></figure>

<h4 id="第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone"><a href="#第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone" class="headerlink" title="第三种用法：jump to sb’s defence: to quickly defend someone."></a>第三种用法：jump to sb’s defence: to quickly defend someone.</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Whenever anyone criticizes her husband, she immediately jumps to his defence.</span><br><span class="line">翻译：每当有人批评她的丈夫时，她会立即为他辩护。</span><br></pre></td></tr></table></figure>

<h3 id="approach"><a href="#approach" class="headerlink" title="approach"></a>approach</h3><p>这一段出现了两次 approach，分别有不同的意思。第一处是动词，意思是“找（某人）谈话、与（某人）打交道”，第二处是名词，意思是“（处理）方法”。这些都是最早从 to go or come near in place or in time 或者 come near in quality or character, resemble, become similar 等含义中衍生出来的意思。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The workers approached the manager with a request for shorter working hours.</span><br><span class="line">翻译：工人们找经理要求减少工作时间。</span><br><span class="line"></span><br><span class="line">例句：Those officials were approached with bribes.</span><br><span class="line">翻译：这些官员是被贿赂买通的。在特定语境中，approach a government officer 本身就有企图贿赂政府官员的意思。</span><br><span class="line"></span><br><span class="line">例句：His sober approach to the crisis averted a catastrophe.</span><br><span class="line">翻译：他对危机的冷静处理避免了一场大灾难。</span><br></pre></td></tr></table></figure>

<h1 id="到底要不要学语法？什么时候学比较好？"><a href="#到底要不要学语法？什么时候学比较好？" class="headerlink" title="到底要不要学语法？什么时候学比较好？"></a>到底要不要学语法？什么时候学比较好？</h1><p>精读文章的第二段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. Interest in the business, user behavior and data on this</span><br><span class="line">When coming with ideas, product-minded engineers don&#x27;t just get these from thin air. They take the time to understand how the business works, how the product fits in, and what its goals are. They are also empathetic about how the product makes users feel and how those users benefit from using this product. They often dive straight to data about business and user metrics, getting their hands on this data however they can. They might access it directly - if this is possible - or approach the product manager or data scientists to get this kind of information. They do this because of their curious nature. This is the next trait I&#x27;ve observed.</span><br><span class="line"></span><br><span class="line">2. 工程师对业务、用户行为和数据的兴趣</span><br><span class="line">具有产品思维的工程师们的想法和创意都不是凭空得来的。他们会花时间去了解企业是如何商业运作的，产品又是如何配合商业运作，以及最终要达到什么样的商业目标。此外，他们也会去换位思考，试图理解产品将给用户带来什么感受，以及用户如何从使用产品中受益。他们通常会直接去深入研究商业数据和用户测量指标，并尽其所能获取这些数据。如果可能的话，他们会直接访问相关数据，或者找产品经理、数据专家去要这些信息。工程师们这样做，往往是出于他们好奇的天性。这也是我观察到的下一个特征。</span><br></pre></td></tr></table></figure>

<p>所有的英语句子，无论长短多少、变态与否，都可以归入三类：简单句、并列句和复合句。  </p>
<h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="状语（分词短语做时间状语）"><a href="#状语（分词短语做时间状语）" class="headerlink" title="状语（分词短语做时间状语）"></a>状语（分词短语做时间状语）</h3><blockquote>
<p>When coming with ideas, product-minded engineers don’t just get these from thin air.  </p>
</blockquote>
<p>这段话的第一句就是分词短语做时间状语。<strong>所谓状语，顾名思义，就是对动作的状态进行描述的句子成分，可以是单词（副词）、短语（分词短语）或句子（状语从句）。状语可以用来说明地点、时间、原因、目的、结果、条件、方向、程度、频率、方式、伴随等等。</strong>  </p>
<p>看几个分词短语做时间状语的超级简单的例句，一般都带有引导时间状语的关系连词，例如 before、after、when 等，分词短语紧随其后。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：She normally boils the water before drinking it.</span><br><span class="line">翻译：她喝水之前通常会把水烧开。</span><br><span class="line"></span><br><span class="line">例句：After talking to you I always feel better.</span><br><span class="line">翻译：每次和你聊完之后，我都感觉心里舒服多了。</span><br><span class="line"></span><br><span class="line">例句：When opened, keep in refrigerator.</span><br><span class="line">翻译：开罐之后，需要冷藏。</span><br></pre></td></tr></table></figure>

<h3 id="thin-air"><a href="#thin-air" class="headerlink" title="thin air"></a>thin air</h3><p>英文解释：nowhere to be found in a giant void；nihility; nothingness; nullity; void; the state of nonexistence。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：You need to work hard—opportunities don’t just come out of thin air.</span><br><span class="line">翻译：你得努力啦，机会不会凭空产生 / 天上不会掉馅饼。</span><br><span class="line"></span><br><span class="line">例句：The magician pulled a bouquet of flowers out of thin air.</span><br><span class="line">翻译：魔术师妙手空空变出一捧花来。</span><br><span class="line"></span><br><span class="line">例句：With her children almost grown up, she found herself having to conjure a career from thin air.</span><br><span class="line">翻译：孩子们都快长大了，她发现自己需要凭空变出个工作来。</span><br></pre></td></tr></table></figure>

<p>和 thin air 搭配的介词，通常是 out of 或者 from。  </p>
<h3 id="动词宾语从句"><a href="#动词宾语从句" class="headerlink" title="动词宾语从句"></a>动词宾语从句</h3><blockquote>
<p>They take the time to understand how the business works, how the product fits in, and what its goals are.  </p>
</blockquote>
<p>这句话首先是用不定式 to do 做状语，表示目的。程序员花时间干什么？to understand，是一个及物动词，去了解，了解什么？后面跟的就是宾语从句，而且是三个并列的宾语从句。  </p>
<h3 id="take-time"><a href="#take-time" class="headerlink" title="take (time)"></a>take (time)</h3><p>take the time 是非常地道的搭配，如果非要说 spend the time，当然别人也能理解，但一听就是不地道的英语。另外，take 还可以和具体的时间搭配在一起，你可以把 the time 换成具体的事情，表示“做什么事情需要花多少时间”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I took three hours to get home last night.</span><br><span class="line">翻译：昨天晚上回家花了我三个小时。</span><br><span class="line"></span><br><span class="line">例句：The journey home last night took me three hours.</span><br><span class="line"></span><br><span class="line">例句：It took me three hours to get home last night.</span><br></pre></td></tr></table></figure>

<h3 id="fit-in"><a href="#fit-in" class="headerlink" title="fit in"></a>fit in</h3><p>fit in 的第一个意思是“融入”，英文解释是：To become assimilated into and accepted by a group。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I just don’t fit in with any of the kids at my new school.</span><br><span class="line">翻译：我和新学校的小孩们都合不来。</span><br></pre></td></tr></table></figure>

<p>fit in 的第二个意思是“适合”，英文解释是：To blend or work harmoniously with something。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Working in a research lab really fits in with my shy personality.</span><br><span class="line">翻译：在科研实验室工作非常适合我腼腆的性格。</span><br></pre></td></tr></table></figure>

<h3 id="介词宾语从句"><a href="#介词宾语从句" class="headerlink" title="介词宾语从句"></a>介词宾语从句</h3><blockquote>
<p>They are also empathetic about how the product makes users feel and how those users benefit &gt;from using this product. They often dive straight to data about business and user metrics, &gt;getting their hands on this data however they can.  </p>
</blockquote>
<p>这句话说，他们会共情，会去换位思考。思考什么？about 这个介词后面跟了两个并列的宾语从句。第一，思考产品将给用户带来什么感受；第二，思考用户如何从使用产品中受益。  </p>
<p>最后半句是分词短语做状语，这个街角我们已经走过好几次了。这里的状语表示伴随状态，程序员们会直接去研究商业数据和用户指标，getting hands on，表示“同时动手获取这些数据”。  </p>
<h3 id="empathy-和-sympathy"><a href="#empathy-和-sympathy" class="headerlink" title="empathy 和 sympathy"></a>empathy 和 sympathy</h3><p>empathy 和 sympathy 这两个单词的拼写很相像，含义似乎相似，但其实完全不一样。  </p>
<p>empathy 表示“感同身受”，它的英文解释是：an individual’s ability to understand what another person is going through, by perceiving himself in the same situation，指一个人通过把自己放到相同的情境中感知自己，来理解另一个人正在经历的事情的能力。而有时候我们说“共情”，是强调“理解、共鸣”的意思。你可以通过下面这个例句再感受一下。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：He is empathetic with the jobless youth, as he was also struggling for a job in his early years.</span><br><span class="line">翻译：他对失业的年轻人感同身受，因为他自己早年也为找工作挣扎过。</span><br></pre></td></tr></table></figure>

<p>而 Sympathy 表示“同情”，它的英文解释是：the feeling of sorrow for the hardships, problems and pain caused to another person，指“对另一个人造成的困难、问题和痛苦感到悲伤或怜悯”，更强调“同情、悲悯”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：All Tony’s friends joined in sending their sympathies to his widow Jean.</span><br><span class="line">翻译：托尼的所有朋友都向他的遗孀琼表示了同情。</span><br></pre></td></tr></table></figure>

<h3 id="dive"><a href="#dive" class="headerlink" title="dive"></a>dive</h3><p>dive 的本意是“跳水”，就是头和两臂先入水的那种，plunge head first into water。它也可以指“鱼类、潜水艇或人类，借助呼吸设备潜水到更深的水下，(of a fish, a submarine, or a vessel used for underwater exploration) go to a deeper level in water (using breathing equipment)。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The fish dive down to about 1,400 feet and then swim southwest.</span><br><span class="line">翻译：那条鱼潜到大约 1400 英尺的深度，然后向西南方向游去。</span><br></pre></td></tr></table></figure>

<p>除此之外，dive 还可以指“飞机或鸟类在空中俯冲”，(of an aircraft or bird) plunge steeply downward through the air。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The aircraft dove for the ground to avoid the attack.</span><br><span class="line">翻译：飞机向地面俯冲以躲避攻击。</span><br></pre></td></tr></table></figure>

<p>在此基础上，我们可以通过“一头扎进去”这个意思，进一步引申出“立即开始采取行动、深入分析研究”等含义。例如本段话里的 dive to，就有程序员“立刻开始深入挖掘数据”的意思。比较常见的搭配还有 deep dive。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Although this article does not provide a deep dive into the programming language, some Objective-C fundamentals are provided below.</span><br><span class="line">翻译：尽管本文没有深入介绍编程语言，但是下面提供了一些 Objective-C 的基础知识。</span><br><span class="line"></span><br><span class="line">例句：Each article will dive deep into these concepts, with lots of detail and source code.</span><br><span class="line">翻译：每篇文章都将深入探讨这些概念，包括大量细节和源代码。</span><br></pre></td></tr></table></figure>

<h3 id="user-metrics"><a href="#user-metrics" class="headerlink" title="(user) metrics"></a>(user) metrics</h3><p>software metrics 即“软件测量 &#x2F; 度量”，有时候也叫 software measurements。  </p>
<p>要想真正跳脱出软件开发的暗箱，除了定性评估以外，还需要一系列基于数值的度量指标来进行测评。同样道理，对于一个产品的用户体验，也有相应的用户测量指标。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Software metrics are numerical ratings to measure the complexity and reliability of source code, the length and quality of the development process and the performance of the application when completed.</span><br><span class="line">翻译：软件度量使用数值评级来衡量源代码的复杂性和可靠性、开发过程的长度和质量以及应用程序完成后的性能。</span><br><span class="line"></span><br><span class="line">例句：Social media technologies have given companies access to an unprecedented flood of new analytics, metrics and user data.</span><br><span class="line">翻译：有了社交网络之后，企业获取了空前大量的新分析方法、度量指标和用户数据。</span><br></pre></td></tr></table></figure>

<h3 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a>插入语</h3><blockquote>
<p>They might access it directly - if this is possible - or approach the product manager or data &gt;scientists to get this kind of information. They do this because of their curious nature. This &gt;is the next trait I’ve observed.  </p>
</blockquote>
<p>在这句话里，if this is possible 是插入语。在阅读的过程中，如果感觉句子偏长或者偏复杂，我们完全可以先忽略插入语。插入语通常夹在两个破折号或者两个逗号之间。  </p>
<h1 id="从那些不规范的表达中，我们可以学到什么？"><a href="#从那些不规范的表达中，我们可以学到什么？" class="headerlink" title="从那些不规范的表达中，我们可以学到什么？"></a>从那些不规范的表达中，我们可以学到什么？</h1><p>文章的第三段和第四段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. Curiosity and a keen interest in &quot;why?&quot;</span><br><span class="line">Product-minded engineers like to understand the &quot;why?&quot; behind all things. Why build this feature for the product, why not the other one? Why ship this first milestone, instead of choosing another one, that&#x27;s a lot simpler to build? How will things be measured - why don&#x27;t we choose a more thorough way to measure things?</span><br><span class="line">They are autonomous in finding answers they can, by themselves. They turn to the product manager and other people in the business for other, product-related questions. Even though they ask many questions, doing this frequently, they manage not to annoy people, as they&#x27;ve built up strong relationships with them.</span><br><span class="line">4. Strong communicators and great relationships with non-engineers</span><br><span class="line">Product-minded engineers like talking with people outside engineering, learning about what and why they do. They are smooth communicators, making it clear they&#x27;re interested in learning more about how other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with non-engineers.</span><br><span class="line"></span><br><span class="line">软件工程师的好奇心和对“为什么”的浓厚兴趣。具有产品意识的工程师喜欢去理解所有事物背后的那个“为什么? ”。为什么产品要开发这个功能、而不开发另一个功能呢？为什么要首先发布这一里程碑，而不是选择另一个更简单的里程碑呢？如何进行测量——为什么我们不选择一种更全面彻底的度量方式来测量呢？</span><br><span class="line">他们能够自主地找到他们能够找到的答案。他们也会向产品经理和其他业务人员寻求帮助，找寻其他与产品相关问题的答案。尽管他们经常会问很多问题，但是他们都会设法不让其他人觉得不爽，因为他们已经与那些同事建立起了牢固的关系。</span><br><span class="line"></span><br><span class="line">强大的沟通能力，建立与非工程师同事良好的关系。具有产品意识的工程师喜欢与软件工程领域外的同事们交谈，了解他们在做什么、为什么做。他们善于沟通，充分显示他们对于学习其他学科工作方式的浓厚兴趣。我经常看到他们和其他专业的同事们一起喝咖啡、吃午饭或者在走廊上聊天。</span><br></pre></td></tr></table></figure>

<p>这几段话的意思比较直白，但存在几处写作不规范的地方，可以作为反面教材，供我们分析。  </p>
<p><strong>首先，口语交流和书面写作对于语言精确和严谨程度的预期要求是不同的。</strong>如果只是作为口语交流，只要不影响意思的表达，出现一些语法错误或者不规范之处，并无大碍；但对于那些需要正式发表的书面稿件，例如学术论文、合约、新闻稿等，写作过程中的语言就要力求规范。  </p>
<p><strong>其次，我们不要迷信那些英语是母语的外国人，觉得他们说的或写的每句话都一定是正确的。</strong>有时候因为各种原因，英语母语国家的人在口头和书面表达中都会出现或多或少的错误用法，其随意性甚至超过外语学习者。  </p>
<h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="curiosity-x2F-keen-interest"><a href="#curiosity-x2F-keen-interest" class="headerlink" title="curiosity&#x2F;keen interest"></a>curiosity&#x2F;keen interest</h3><ul>
<li><p>curiosity killed the cat，“好奇害死猫”，说的就是好奇心容易惹祸上身，即便猫有九条命都不够死，告诫别人不要多管闲事，不要到处打听和自己无关的事情。<br>Inquisitiveness can lead one into dangerous situations.  </p>
</li>
<li><p>Keen interest，意思是“浓厚的兴趣”。有一个常用的英语成语也可以表示同样的意思，但是非常形象生动，(as) keen as mustard，“像芥末一样浓烈”，表示 very excited and interested；very enthusiastic。mustard 是黄芥末，由芥菜种子碾磨而成，在西方国家比较常见，一般和热狗搭配。日本料理使用的是绿芥末，wasabi，其实是山葵酱。</p>
</li>
</ul>
<p>类似 as X as Y 这样的英语成语还有不少，例如 as hard as nail，as hot as hell 等，第一个 as 在口语或非正式表达中可以省略。很多成语是约定俗成的传统表达方式，其中有些比喻涉及特定的文化背景。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I gave him the job because he was willing to learn and seemed as keen as mustard.</span><br><span class="line">翻译：我给他这份工作，是因为他学习愿望强烈，兴趣（如同芥末一样）浓厚。</span><br></pre></td></tr></table></figure>

<h3 id="why-not-do-结构"><a href="#why-not-do-结构" class="headerlink" title="why (not) do 结构"></a>why (not) do 结构</h3><blockquote>
<p>Product-minded engineers like to understand the “why?” behind all things. Why build this &gt;feature for the product, why not the other one? Why ship this first milestone, instead of &gt;choosing another one, that’s a lot simpler to build? How will things be measured - why don’t ?&gt;we choose a more thorough way to measure things?  </p>
</blockquote>
<p>第一句话“具有产品意识的工程师喜欢去理解所有事物背后的那个为什么”的后面，跟了三组并列的问句，来举例说明具有产品思维的工程师通常会问的问题。  </p>
<p>注意 why+do 和 why not+do 的结构和用法。why+do 通常表示“该动作没有必要、无意义”。why not+do 通常表示“建议采取该动作”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Why build this feature for the product? = Why do we build this feature for the product?</span><br><span class="line"></span><br><span class="line">why not the other one? = Why not build the other one? = Why don’t we build the other one?</span><br><span class="line"></span><br><span class="line">例句：Why argue with him？He will never change his mind. （注意不能说 why arguing with him?）</span><br><span class="line">翻译：干嘛和他争？他永远不会改主意的。</span><br><span class="line"></span><br><span class="line">例句：Sandy’s in bad mood. Why not give her some flowers?</span><br><span class="line">翻译：桑迪心情不好，何不送她一些花呢？</span><br><span class="line"></span><br><span class="line">例句：Why don’t you give her some flowers?</span><br><span class="line">翻译：你为什么不给她送些花呢？</span><br></pre></td></tr></table></figure>

<h3 id="ship-the-milestone"><a href="#ship-the-milestone" class="headerlink" title="ship the milestone"></a>ship the milestone</h3><p>“发布某一阶段的成果”或者“上市某一版产品”的意思。  </p>
<p>ship 做动词的时候，基本含义是“船运”“运输”，在此基础上引申出“发货”“上市” “发布”等含义。milestone 由“里程碑”（a stone pillar that shows the distance in miles to or from a place）引申出了“重大事件”“阶段性成果”“重要时间节点”等含义。因此，除非你讲的是物流（例如航运行业）的事情，其他大部分语境下 ship 都是指“产品上市、发布或者发货”的意思。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Apple will unveil a 10-inch touchscreen tablet device in January, and ship the product in March.</span><br><span class="line">翻译：苹果将于一月份推出 10 英寸触屏平板电脑，并于三月份发货。</span><br><span class="line"></span><br><span class="line">例句：We define an iteration as a phase or a milestone.</span><br><span class="line">翻译：我们将一次迭代定义为一个阶段或一个里程碑。</span><br></pre></td></tr></table></figure>

<h3 id="不规范的定语从句"><a href="#不规范的定语从句" class="headerlink" title="不规范的定语从句"></a>不规范的定语从句</h3><blockquote>
<p>Why ship this first milestone, instead of choosing another one, that’s a lot simpler to build?  </p>
</blockquote>
<p>此句标黑处为限定性定语从句，修饰先行词 another one，所以这里应该去掉逗号。如果是非限定性定语从句，要保留逗号，但 that 必须改为 which。  </p>
<h3 id="autonomous"><a href="#autonomous" class="headerlink" title="autonomous"></a>autonomous</h3><blockquote>
<p>They are autonomous in finding answers they can, by themselves. They turn to the product manager and &gt;other people in the business for other product-related questions.  </p>
</blockquote>
<p>autonomous 一般指“地区或组织享有自治权”，英文意思是 governs or controls itself rather than being controlled by anyone else，或者指“个人独立自主、自发做一些事情（例如本句）”，英文意思是 able to do things and make decisions without help from anyone else。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A self-driving car, also known as an autonomous vehicle (AV), driverless car or robotic car, is a vehicle that can sense its environment and moving safely with little or no human input.</span><br><span class="line">自动驾驶汽车也被称为无人驾驶汽车或机器人汽车，是一种能够感知周围环境并在几乎没有人类干预的情况下安全行驶的交通工具。</span><br></pre></td></tr></table></figure>

<p>需要指出的是，互联网公司研发自动驾驶汽车比较喜欢用 driverless 这个词，突出无人驾驶，表示未来要取消驾驶员。而传统的汽车行业更坚持使用 autonomous 这个词，淡化“无人”的概念，并强调非由机器还是人类来驾驶汽车，这个决定最终要由人类做出，不能剥夺人类的驾驶乐趣。<strong>所以，一个简单的单词背后，代表的可能是不同行业对同一件事的不同态度。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oracle Autonomous Database is a cloud-based technology designed to automate many of the routine tasks required to manage Oracle databases, which Oracle says can free up DBAs to do higher-level and more strategic work.</span><br><span class="line">甲骨文自治数据库是一种基于云的技术，旨在自动化管理甲骨文数据库所需的许多日常任务。甲骨文公司表示，这可以让数据库管理员们腾出时间来做更高层次、更具战略性的工作。</span><br></pre></td></tr></table></figure>

<h3 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h3><blockquote>
<p>They are autonomous in finding answers <strong>they can</strong>, by themselves.  </p>
</blockquote>
<p>此句标黑处为定语从句，修饰 answers，完整形式为 that they can find，也可省略 that（that 或 which 做从句谓语动词的宾语时，可省略）和 find （和前文主句中的动词 find 重合）。  </p>
<p>此句中的定语从句和 by themselves 插入语均为冗余信息，autonomous 的含义已经非常清楚，作者一而再、再而三重复相同的意思，这就属于不规范写作。  </p>
<h3 id="turn-to-somebody"><a href="#turn-to-somebody" class="headerlink" title="turn to (somebody)"></a>turn to (somebody)</h3><p>turn to 本身就含有“寻求帮助”的意思，我们在使用的时候可以不用再说 turn to someone for help&#x2F;advise。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Sometimes young lads just need to turn to a mother figure for a bit of a chat and reassurance.</span><br><span class="line">翻译：有时候年轻小伙子只是需要找一个母亲式的人物聊一聊，从中获得安慰。</span><br><span class="line"></span><br><span class="line">例句：Her husband was unsympathetic and she felt she had no one to turn to.</span><br><span class="line">翻译：她的丈夫不懂得体恤人，她觉得无人可以依靠。</span><br></pre></td></tr></table></figure>

<h3 id="分词短语做插入语（语法关系不规范）"><a href="#分词短语做插入语（语法关系不规范）" class="headerlink" title="分词短语做插入语（语法关系不规范）"></a>分词短语做插入语（语法关系不规范）</h3><blockquote>
<p>Even though they ask many questions, doing this frequently, they manage not to annoy people, as &gt;they’ve built up strong relationships with them.  </p>
</blockquote>
<p>如果是口语表达，此句没有任何问题，意思也是明确的。但严格来讲，比较规范、符合语法的说法是 Even though they ask many questions frequently.  </p>
<h3 id="manage-not-to"><a href="#manage-not-to" class="headerlink" title="manage (not) to"></a>manage (not) to</h3><blockquote>
<p>If you manage to do something, especially something difficult, you succeed in doing it.  </p>
</blockquote>
<p>需要提醒特别注意的是，manage to 并不是指“试图去做”一件事情，而是强调“<strong>成功做到一件比较困难的事情</strong>”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Somehow, he’d managed to persuade Kay to buy one for him.</span><br><span class="line">翻译：不知用了什么方法，他成功说服凯给他买了一个。</span><br><span class="line"></span><br><span class="line">例句：How do you manage not to tell your boss to f*** off to his face?</span><br><span class="line">翻译：你是怎么做到不当着你老板的面让他滚蛋的？</span><br></pre></td></tr></table></figure>

<h3 id="communicator"><a href="#communicator" class="headerlink" title="communicator"></a>communicator</h3><blockquote>
<p>Strong communicators and great relationships with non-engineers  </p>
</blockquote>
<p>英文解释是：( rather formal ) a person who is able to describe their ideas and feelings clearly to others。在本文中指“（善于）交际者、交流者”，也可以泛指“通信器材”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。</span><br></pre></td></tr></table></figure>

<h3 id="分词短语做状语（不规范用法）"><a href="#分词短语做状语（不规范用法）" class="headerlink" title="分词短语做状语（不规范用法）"></a>分词短语做状语（不规范用法）</h3><blockquote>
<p>Product-minded engineers like talking with people outside engineering, learning about what and why &gt;they do. They are smooth communicators, <strong>making it clear they’re interested in</strong> learning more about how &gt;other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with &gt;non-engineers.  </p>
</blockquote>
<p>此句的加黑部分是上一讲我们讲过的分词短语做状语，但它的主句 They are smooth communicators 是描写状态的系表结构，只有系动词 are，没有具体的动作，因此这种情况下用分词短语做状语在此处是不恰当的。  </p>
<p>我们可以把这句话改写成：They communicate smoothly and show their interest in learning more about how other disciplines work。这样的话，这句话就符合语法规范了。  </p>
<p>最后一句话，就是任正非说的，要善于用一杯咖啡去吸收宇宙的能量。  </p>
<h1 id="tradeoff-还是-trade-off？用连字符到底对不对？"><a href="#tradeoff-还是-trade-off？用连字符到底对不对？" class="headerlink" title="tradeoff 还是 trade-off？用连字符到底对不对？"></a>tradeoff 还是 trade-off？用连字符到底对不对？</h1><p>文章的第五段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. Offering product/engineering tradeoffs upfront</span><br><span class="line">Because they have a strong understanding of the product &quot;why,&quot; as well as the engineering side of things, they can bring suggestions that few other people can. For example, when scoping the effort to build the product, the engineering effort to build a key feature might be significant. Many engineers would start to look for ways to reduce the effort and try to figure out what the impact of the reduced effort would mean for the feature itself.</span><br><span class="line">Product-minded engineers attack this problem from both angles: both looking for engineering tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the engineering impact. They often go back to the product manager, suggesting a completely different feature to be built, given the product impact would be similar, but the engineering effort vastly smaller.</span><br><span class="line">Juggling both the product and engineering tradeoffs and the impact of each is a unique strength product-minded engineers have. They can quickly go back-and-forth between the two sides of the same coin: product features and engineering effort and tradeoffs. Because they do it all in their head, using their engineering and product insights, they get to valuable conclusions remarkably quickly.</span><br><span class="line"></span><br><span class="line">5. 提前在产品和工程两方面做出权衡</span><br><span class="line">因为具有产品思维的工程师们对产品的原理以及软件工程都有深刻的理解，他们可以提出非常独到的建议，而很少有别人可以做到。例如，在确定产品构建的工作范围时，打造产品某项关键功能的编程工作量可能非常巨大。许多工程师会开始寻找减少工作量的方法，并试图明确减少工作量对该项关键功能可能会产生的影响。</span><br><span class="line">具有产品意识的工程师会从两个角度来解决这个问题：一方面在工程方面进行取舍，明确可能对产品产生的影响；同时在另一方面，他们还会开始对产品功能进行取舍，评估对工程工作量的影响。他们经常会去找产品经理，在保持产品体验相似的前提下，建议构建一个完全不同的功能，从而使得编程的工作量大幅降低。</span><br><span class="line">兼顾产品和工程、平衡两者的影响，是具有产品意识的工程师们拥有的独特优势。他们可以快速地在同一枚硬币的两面之间来回切换：产品特性、工程工作量和两者的平衡。由于他们利用其工程和产品两方面的洞察力，在头脑中快速完成上述权衡，所以他们能够很快得出有价值的结论。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-3"><a href="#知识讲解-3" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="tradeoff"><a href="#tradeoff" class="headerlink" title="tradeoff"></a>tradeoff</h3><p>这是一个复合名词，由动词和介词 &#x2F; 副词小品词直接相连构成，你也可以写成 trade-off。同时，这是一个可数名词，可以加 s 变成复数形式 tradeoffs。无疑，这个词在文章中反复出现，所以肯定是整段的关键词，也是中心思想。  </p>
<p>所谓 tradeoff，顾名思义，首先是“交易”的意思。有交易就有讨价还价，就有妥协，就有得有失，就有鱼和熊掌不可兼得。所以这个词指的是一种取舍、一种权衡，最后达成折中平衡。英文解释：A trade-off is a situation where you make a compromise between two things, or where you exchange all or part of one thing for another.  </p>
<p>平时我们有各种利弊要取舍，不能西瓜也要，芝麻也要。一个手机，续航也要，但是不能太厚；屏幕要最好的，但不能太贵；要安全性，但不能太麻烦；要黑科技，但系统不能不稳定、不可靠。这条英文解释进一步诠释了 tradeoff 这一层的意思：A trade-off is a balance between two opposing things, that you are willing to accept in order to achieve something.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Life is full of trade-offs. You cannot have your cake and eat it too.</span><br><span class="line">翻译：生活充满了取舍。鱼和熊掌不可兼得。</span><br></pre></td></tr></table></figure>

<p>补充：“You cannot have your cake and eat it (too)”或者“You can’t eat your cake and [then still] have it (too)”是很常用的英语谚语，类似于“you can’t have the best of both worlds”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Depending on your system resources, there will always be some trade-offs between CPU, memory, and I/O in your tuning decisions.</span><br><span class="line">翻译：根据你的系统资源进行调优决策时，CPU、内存和 I/O 之间总是需要进行权衡。</span><br></pre></td></tr></table></figure>

<h3 id="复合名词"><a href="#复合名词" class="headerlink" title="复合名词"></a>复合名词</h3><p>复合名词构成的方法比较多，它可以由动词和介词 &#x2F; 副词小品词组成，这在英语中很是常见。这种方式构成的复合名词与相关联的短语动词之间，意义基本相近。我们以短语动词 break out 为例来看下。  </p>
<p>动词短语 break out 指“（战争、瘟疫）爆发、越狱”，由此我们可以引申出“摆脱局限的状态、突破”等含义。如果把 break 和 out 之间的空格去掉，这个动词短语就变成了复合名词 breakout。下面是三个例句。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Bubble economy usually starts with false prosperity and ends in a breakout of financial crises.</span><br><span class="line">翻译：泡沫经济通常以虚假繁荣开始，以金融危机爆发告终。</span><br><span class="line"></span><br><span class="line">例句：Point Break was a breakout film for Kathryn Bigelow in 1991.</span><br><span class="line">翻译：凯瑟琳·毕格罗于 1991 年拍摄了《惊爆点》，该片突破了她之前的风格。</span><br><span class="line"></span><br><span class="line">例句：Breakout session is a relatively short meeting where a small group of attendees, drawn from a large conference or convention, discusses specific subjects or aspects of the broad theme of the main gathering.</span><br><span class="line">翻译：分组会议是大会中一个相对较短的小会，由部分与会者讨论大会主题下的某个具体议题。</span><br></pre></td></tr></table></figure>

<p>注意，颠倒两个单词的次序之后，还可以构成另外一个复合名词 outbreak，但这个词更多地特指“（战争、瘟疫）突然爆发、蔓延”。同时，outbreak 偶尔也可用作动词。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Fears are growing of avian influenza outbreak following the appearance of several cases in the city.</span><br><span class="line">翻译：随着该市出现若干病例，人们对禽流感大爆发的担忧日益加剧。</span><br></pre></td></tr></table></figure>

<h3 id="a-few-x2F-a-little"><a href="#a-few-x2F-a-little" class="headerlink" title="(a) few&#x2F;(a) little"></a>(a) few&#x2F;(a) little</h3><blockquote>
<p>Because they have a strong understanding of the product “why,” as well as the engineering side of &gt;things, they can bring suggestions that few other people can.  </p>
</blockquote>
<p>作为限定词，little 用于修饰不可数名词，few 用于修饰可数名词的复数。  </p>
<p>需要特别注意的是，little 和 few 在不带 a 的情况下，表达的是否定的意思，表示“几乎没有”或者“很少”。比如 We have little time，表示“我们没时间了”。如果带 a，则表示肯定，“虽然不多，但有一些”。比如 We have a little time，表示“我们还有一些时间”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Few people can say they always tell the truth.</span><br><span class="line">翻译：几乎没有人敢说自己从不撒谎。</span><br><span class="line"></span><br><span class="line">例句：We don’t need to go shopping today. We’ve got a few potatoes and some steak.</span><br><span class="line">翻译：我们今天不需要去购物。 我们还有一些土豆和牛排。</span><br><span class="line"></span><br><span class="line">例句：I have little knowledge of computer and business, can I still learn Navisio？</span><br><span class="line">翻译：我对计算机和商业知之甚少，我还能学习 Navision 系统吗？</span><br><span class="line"></span><br><span class="line">例句：Just because she painted her room by herself, now she thinks she can do the entire house—inside and out! A little knowledge is a dangerous thing.</span><br><span class="line">翻译：仅仅因为她自己粉刷了自己的房间，现在她认为可以把整个房子里里外外都粉刷一遍！ 一知半解害死人。</span><br></pre></td></tr></table></figure>

<p>这一句中，“A little knowledge is a dangerous thing”是一句英语谚语，按照字面的意思来说就是，“危险的不是一个人没有知识，而是有了一点点知识之后的过度自信和膨胀”。  </p>
<h3 id="figure-out"><a href="#figure-out" class="headerlink" title="figure out"></a>figure out</h3><blockquote>
<p>Many engineers would start to look for ways to reduce the effort and try to figure out what the impact &gt;of the reduced effort would mean for the feature itself.  </p>
</blockquote>
<p>这是个很常用的动词短语，意思是 find the solution to (a problem or question) or understand the meaning of…，“找到问题的解决办法、搞清楚、弄明白”。这个很简单，我就不多说了，我们直接通过例句来感受使用场景。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：By 2020, scientists will figure out how to control robots via brain-machine interfaces.</span><br><span class="line">翻译：到 2020 年，科学家们将解决如何通过脑机接口来控制机器人的问题。</span><br></pre></td></tr></table></figure>

<h3 id="打破语言形式看实质含义"><a href="#打破语言形式看实质含义" class="headerlink" title="打破语言形式看实质含义"></a>打破语言形式看实质含义</h3><blockquote>
<p>Product-minded engineers attack this problem from both angles: <strong>both looking for engineering &gt;tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the &gt;engineering impact.</strong>  </p>
</blockquote>
<p>第一句话。作者明确说了，具有产品思维的工程师们会从两个角度来解决问题，而且后面加了冒号，那我们必然预期，冒号后面会解释这两个角度分别是什么。  </p>
<p>接下来，冒号后面又出现了第二个 both，我们的预期就更加明确了。both…and…这个平衡的结构你肯定知道。那前面提到过的两个角度肯定会工整地在 both 后面放一个，and 后面再放一个，就像下面这几个例句：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">She is both pretty  and clever. （形容词）</span><br><span class="line">I talked to both the Director and his secretary. （名词）</span><br><span class="line">You can both borrow the flat and use our car. （动词）</span><br></pre></td></tr></table></figure>

<p>在 both 后面跟了一个现在分词短语，做主句中 from 的介词宾语，意思是在工程方面进行取舍。但是，and 后面却跟了一个从句，单纯从语法角度看这是 from 这个介词的宾语从句，显然形式不对等。形式不对等没关系，只要内容或者逻辑对等并列也行，我们可以解释主句讲的两个角度。但是，and 后面说的“对产品产生的影响”，是之前工程方面取舍的结果，逻辑上看并没有并列关系。  </p>
<p>句子在这里就结束了，仿佛话说了半句，我们掉进了作者挖的坑里。从坑里爬出来，我们接着往下读，你会突然发现，原来作者另起炉灶讲的下一句话，才是前文讲的第二个角度 They also start making product tradeoffs, evaluating the engineering impact.，要在产品功能方面进行取舍，并评估对工程工作量的影响。  </p>
<p>即便是非常严谨的学术著作，写作都有可能存在不严密的地方，更何况是这种相对随意一些的博客专栏。<strong>虽然语法上有些小瑕疵，但这种文章可以训练我们突破语言的形式外壳，去分析句子之间的逻辑关系，领会作者想要表达的实质含义。</strong>  </p>
<h3 id="独立主格结构"><a href="#独立主格结构" class="headerlink" title="独立主格结构"></a>独立主格结构</h3><blockquote>
<p>They often go back to the product manager, suggesting a completely different feature to be built, &gt;given the product impact would be similar, <strong>but the engineering effort vastly smaller.</strong>  </p>
</blockquote>
<p>工程师们经常去找产品经理，去干什么呢？后面是我们已经非常熟悉的现在分词做状语，来表示目的，去找他们提建议，建议改产品的功能，而且还是完全不同的功能。产品经理刚要急，工程师马上就接上说，当然前提条件（given 后面跟的是从句）是产品的用户体验相似，然后话锋一转，但是工程师的工作量会大幅度下降。  </p>
<p>这里我们需要讲解一下 but 后面的<strong>独立主格结构</strong>，英文叫作 Absolute Construction。所谓独立主格，首先它是一个“格”，属于短语性质的成分，而不是一个“句子”或“从句”，因为英语中任何一个句子都要有主谓结构。例如，我们将本段最后一句话改成 but the engineering effort would be vastly smaller 的话，这就变成了一个单独的句子。</p>
<p>而独立主格结构没有真正的主语和谓语动词，它由名词或代词作逻辑主语，再加上分词、形容词、副词、动词不定式或介词短语作逻辑谓语来构成的，前后两部分具有逻辑主谓关系。  </p>
<p>独立主格结构形式上与主句没有关系，但功能上相当于一个带有独立逻辑主语的状语从句。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The wind failing, we lowered the sail. 风力减弱，我们放下了船帆。</span><br><span class="line">比较：When the wind failed, we lowered the sail. 意思相同，但属于状语从句。</span><br></pre></td></tr></table></figure>

<p>The wind failing 带有自己的主语 wind，从语法结构上和主句的主语 we 不发生关系。但是，所谓的“独立”并非真正独立，它从逻辑或者意思上看，还是一种从属结构，在句中通常起状语的作用，常用来表示时间、原因、条件、行为方式或伴随情况等。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Weather permitting, we will have a barbecue tomorrow.</span><br><span class="line">翻译：如果天气好的话，明天我们一起烤肉。（表示条件）</span><br><span class="line"></span><br><span class="line">例句：The night dark and frosty, he wrapped her up with great care.</span><br><span class="line">翻译：夜又黑又冷，所以他把她裹得严严实实的。（表示原因）</span><br><span class="line"></span><br><span class="line">例句：Evenings he read aloud, his wife sewing by his side.</span><br><span class="line">翻译：晚上他朗声读书，妻子在他身边缝衣服。（表示伴随情况）</span><br><span class="line"></span><br><span class="line">例句：Almost all metals are good conductors, silver being the best of all.</span><br><span class="line">翻译：几乎所有的金属都是良导体，而银则是最好的导体。（表示补充说明）</span><br></pre></td></tr></table></figure>

<p>最著名（也最臭名昭著）的“独立主格结构”应该就是美国宪法修正案第二条了，它授予了美国公民合法持枪的权利。  </p>
<blockquote>
<p>A well-regulated militia, being necessary to the security of a free State, the right of the people to &gt;keep and bear Arms, shall not be infringed.纪律优良之民众武装乃自由邦国安全所必需，故，人民持有并携带武器之权不受侵&gt;犯。  </p>
</blockquote>
<h3 id="juggle"><a href="#juggle" class="headerlink" title="juggle"></a>juggle</h3><blockquote>
<p>Juggling both the product and engineering tradeoffs and the impact of each is a unique strength &gt;product-minded engineers have.  </p>
</blockquote>
<p>juggle 这个词的原意是“玩杂耍的时候接连抛接几个物体”，英文解释是 to throw a set of three or more objects such as balls into the air and catch and throw them again quickly, one at a time，同时它也可以引申出“同时应付几件事情，一心多用、兼顾”等含义。我们还是通过几个例句来感受使用场景。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I was juggling books, shopping bags and the baby.</span><br><span class="line">翻译：我手里又是书，又是购物袋，还抱着孩子，跟演杂技一样。</span><br><span class="line"></span><br><span class="line">例句：The management team meets several times a week to juggle budgets and resources.</span><br><span class="line">翻译：管理团队一周碰头几次，来兼顾预算和资源。</span><br></pre></td></tr></table></figure>

<p>juggle 还有一个近义词 multitask，也是指“同时做几件事情、多任务处理”。但是，和 juggle 不同的是，multitask 是不及物动词，后面不跟宾语。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：According to a study published by the American Psychological Association, you spend between 20 and 40 percent more time when you multitask.</span><br><span class="line">翻译：根据美国心理协会发表的一项研究，当你一心多用同时处理多项工作时，你所花费的时间会多 20% 到 40%。</span><br></pre></td></tr></table></figure>

<h3 id="back-and-forth"><a href="#back-and-forth" class="headerlink" title="back-and-forth"></a>back-and-forth</h3><blockquote>
<p>They can quickly go back-and-forth between the two sides of the same coin: product features and &gt;engineering effort and tradeoffs.  </p>
</blockquote>
<p>back-and-forth 的意思是“来来回回”，英文解释是：moving first in one direction and then in the opposite one。但是，backward and forward 不能表示同样的意思。back 强调的是目的地、回到什么地方，比如 back home（回家）；而 backward 只是一个方向，表示“倒退”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I will drive back to Shanghai this weekend.</span><br><span class="line">翻译：这周末我开车回上海。</span><br></pre></td></tr></table></figure>

<p>至于你的车是正着开还是倒着开，这句话并不关心，只是强调要“回去”，表示目的地而不是方向。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：This lessens the back-and-forth remote traffic and can reduce deployment times.</span><br><span class="line">翻译：这样可以减少来回的远程传输，并缩短部署时间。</span><br></pre></td></tr></table></figure>

<h3 id="two-sides-of-the-coin"><a href="#two-sides-of-the-coin" class="headerlink" title="two sides of the coin"></a>two sides of the coin</h3><p>“一个硬币的两面”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If two things are two sides of the same coin or opposite sides of the same coin, they are closely related to each other and cannot be separated, even though they seem to be completely different.</span><br><span class="line"></span><br><span class="line">I’ve always felt that tragedy and comedy are two sides of the same coin. Love and hate are the opposite sides of the same coin. 祸福相依、爱恨交织。/ 塞翁失马焉知非福。</span><br><span class="line"></span><br><span class="line">例句：WCF and WF are really two sides of the same coin: WCF is the interface and hosting environment for the service, while WF implements its processing logic.</span><br><span class="line">翻译：WCF 和 WF 实际上是同一枚硬币的两面：WCF 是服务的接口和托管环境，而 WF 实现其处理逻辑。</span><br></pre></td></tr></table></figure>

<h3 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h3><blockquote>
<p>Because they do it all in their head, using their engineering and product insights, they get to &gt;valuable conclusions remarkably quickly.  </p>
</blockquote>
<p>insight 有个现成的译法叫“洞察”。“洞”字非常准确生动，有“透彻、清楚”的意思，和英文中对 insight 的解释非常吻合：If you gain insight or an insight into a complex situation or problem, you gain an accurate and deep understanding of it.  </p>
<p>所谓洞察，简单讲就是透过现象看到本质。  </p>
<h1 id="小心那些平淡无奇、人畜无害的简单小词！"><a href="#小心那些平淡无奇、人畜无害的简单小词！" class="headerlink" title="小心那些平淡无奇、人畜无害的简单小词！"></a>小心那些平淡无奇、人畜无害的简单小词！</h1><p>文章的第六段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. Pragmatic handling of edge cases</span><br><span class="line">Edge cases are a funny thing. On one extreme, engineers often forget about many of these, having to come back to addressing them, after getting feedback from people testing the product or end users. On the other hand, handling all possible edge cases in a new product or feature can take a lot of time.  </span><br><span class="line">Product-minded engineers quickly map out edge cases and think of ways to reduce work on them: often bringing solutions that require no engineering work. They are focused on the &quot;minimum lovable product concept&quot; and evaluate the impact of an edge case and the effort of handling it. They come with good middle-ground suggestions: mapping out most things that can go wrong and bring suggestions on what edge cases need to be addressed, before shipping even an early version.  </span><br><span class="line">For example, if one in a thousand users might be hit by an error, they will consider the effort to fix it and think about what happens if they don&#x27;t do anything. Can customer support help the person in this case, during validation? Can the user just retry and succeed the next time? Can the product be slightly modified, so this edge case won&#x27;t occur?</span><br><span class="line"></span><br><span class="line">6. 以务实的方式处理边缘案例</span><br><span class="line">边缘案例是一件很有意思的事情。有的工程师经常会忘记边缘案例的存在，最后从产品测试人员或最终用户那里得到反馈之后，才不得不回过头来解决这些问题。这是一个极端，而另一方面，如果在一个新产品或功能中试图处理所有可能的边缘情况，则可能会耗费大量的时间。</span><br><span class="line">具有产品意识的工程师会很快制定出关于边缘案例的计划，并思考如何减少工作量，并经常会找到不需要额外工作量的解决方案。他们专注于“最小可爱产品”的概念，评估边缘案例的影响和处理所需的工作量。他们会提供很好的折衷建议: 在发布早期版本之前，列出大多数可能出错的地方，并提出需要解决哪些边缘案例的建议。</span><br><span class="line">例如，对于一个千分之一的用户可能会遇到的错误，他们会考虑修复这一错误涉及的工作量，以及如果什么都不做会发生的后果。在产品验证过程中，客服专员是否可以在这个案例中帮助用户？用户下一次再遇到同样问题可以自己尝试成功解决吗？对产品进行略微调整，是否就可以避免边缘案例？</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-4"><a href="#知识讲解-4" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="edge-case"><a href="#edge-case" class="headerlink" title="edge case"></a>edge case</h3><p>维基百科对这个词的定义是：Edge case occurs at an extreme (maximum or minimum) operating parameter.  </p>
<p>edge case 较为常见的译法为“边缘案例”，指“一个运行参数或条件为极值（最大值或最小值）的情况”。类似的，我们来看下 corner case 这个词。  </p>
<p><strong>Corner case</strong> occurs outside of normal operating parameters, specifically when multiple environmental variables or conditions are simultaneously at extreme levels, even though each parameter is within the specified range for that parameter.</p>
<p>“边角案例”一词应该来自边缘案例，两个边缘的交叉点构成角，所以边角案例就是多个参数或条件均为极值的情形。如果音量调到最大，声音失真，这属于边缘案例；如果问题在音量最大、周边环境高湿、且同时一万人以上同时在线时才会出现，这属于边角案例。边角案例一般在复杂系统的测试或除错过程中才会出现。  </p>
<p>Boundary case occurs when one of inputs is at or just beyond maximum or minimum limits.  </p>
<p>还有一个词 boundary case，我们也叫“边界案例”或者“边界条件”，也是指系统输入刚好在上下限或是恰好超过上下限一点点的状态。  </p>
<h3 id="pragmatic"><a href="#pragmatic" class="headerlink" title="pragmatic"></a>pragmatic</h3><p>它既可以强调“一种务实的态度”（A pragmatic way of dealing with something is based on practical considerations, rather than theoretical ones.），也可以用来说“一个人非常务实”（A pragmatic person deals with things in a practical way.）。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Incorporating both risk-based and customer-based analysis into your solution will yield a more pragmatic test plan.</span><br><span class="line">翻译：将基于风险和基于客户的分析整合到您的解决方案中，将会产生一个更加务实的测试计划。</span><br></pre></td></tr></table></figure>

<h3 id="funny"><a href="#funny" class="headerlink" title="funny"></a>funny</h3><blockquote>
<p>Edge cases are a funny thing.  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：</span><br><span class="line">A: Sorry I’m late. My car broke down half way here.</span><br><span class="line">B: Oh, very funny. Tell me another!</span><br><span class="line">翻译：</span><br><span class="line">A：抱歉我迟到了，我的车半路抛锚了。</span><br><span class="line">B：你得了吧，接着编。（有点类似于“呵呵”的口气）</span><br><span class="line"></span><br><span class="line">例句：It’s not funny! Someone could have been hurt.</span><br><span class="line">翻译：这不好玩（这太危险了）！没人受伤算是运气好。</span><br><span class="line"></span><br><span class="line">例句：If there has been any funny business, we’ll soon find out.</span><br><span class="line">翻译：如果这里面有任何猫腻（非法勾当），我们很快会发现的。</span><br><span class="line"></span><br><span class="line">例句：My computer keeps going funny.</span><br><span class="line">翻译：我的计算机老出故障。</span><br></pre></td></tr></table></figure>

<p>另外，还有一些可以用来夸人的词汇，也比较常用。这些词不含负面意思，在交流的时候，你可以放心使用。这些词有：hilarious、humorous、amusing、entertaining 等。  </p>
<p>除了 funny 外，还有很多类似的词，使用的时候也要特别小心。例如 interesting，其实它也是“呵呵”的意思。以下是一些工作和生活中非常常见的表达：  </p>
<ul>
<li>Could we consider some other options？能否考虑其他方案？（你的方案是狗屎）  </li>
<li>It was a bit disappointing that…我感到有些失望……（你们 XXX 干的叫什么事！！！）  </li>
<li>Oh, by the way…顺便提一句……（下面要说的可能是谈话里最重要的一件事……）  </li>
<li>It is quite good. 还行吧。（不咋地。）</li>
<li>It is not bad. 不坏。（真心不错，但不要骄傲。）  </li>
<li>With all due&#x2F;the greatest respect…恕我冒昧，恕我直言……（后面跟的话就是要骂人了。）  </li>
<li>I hear what you say…你的意见我听到了……（你给我闭嘴吧！）  </li>
<li>It is a very brave proposal. 这真是个勇敢的提议。（我看这个愣头青大概是疯了吧！）  </li>
<li>I almost agree…我基本同意？（同意个鬼，基本不同意。）</li>
</ul>
<h3 id="现在分词短语（做状语和主语）"><a href="#现在分词短语（做状语和主语）" class="headerlink" title="现在分词短语（做状语和主语）"></a>现在分词短语（做状语和主语）</h3><blockquote>
<p>On one extreme, engineers often forget about many of these, <strong>having to come back to addressing them, &gt;after getting feedback from people testing the product or end users.</strong> On the other hand, <strong>handling all &gt;possible edge cases in a new product or feature</strong> can take a lot of time.</p>
</blockquote>
<p>们用这两句话来复习一下现在分词短语做状语和做主语的情况。  </p>
<p>这两句话讲了两个极端，一个是程序员完全忘了边缘案例这回事（一定是新手干的），还有一个就是在这个事情上花太多的时间和精力。  </p>
<ul>
<li><p>第一个极端，有的工程师经常健忘。结果怎么样呢？having to come back to addressing them，现在分词做状语，表示结果，结果不得不回过头来解决这些问题。什么时候发生的事情呢？after getting feedback from people testing the product or end users， 还是现在分词做状语，表示时间，从产品测试人员或最终用户那里得到反馈之后。  </p>
</li>
<li><p>另外一个极端，handling all possible edge cases in a new product or feature can take a lot of time。从 handling 这个现在分词开始一直到 feature，这整个短语都是句子的主语，表示在一个新产品或功能中试图处理所有可能的边缘情况，can take 情态动词加上实义动词做谓语，可能会耗费大量的时间。</p>
</li>
</ul>
<h3 id="map-out"><a href="#map-out" class="headerlink" title="map out"></a>map out</h3><blockquote>
<p>Product-minded engineers quickly <strong>map out</strong> edge cases and think of ways to reduce work on them: &gt;often &gt;bringing solutions that require no engineering work.  </p>
</blockquote>
<p>map out 是“计划、规划、提前安排”的意思。例如，map out the future 的意思是“筹划未来”。它的英文解释是：If you map out something that you are intending to do, you work out in detail how you will do it.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：With the whole IT picture in hand, we can map out how the information flows from start to finish.</span><br><span class="line">翻译：掌握了整个 IT 蓝图之后，我们就可以规划信息从头到尾的流动方式。</span><br><span class="line"></span><br><span class="line">例句：It is important to map out the big picture first so that we can systematically identify user requirements.</span><br><span class="line">翻译：为了系统地识别用户的需求，我们首先需要制定一个全局规划。</span><br></pre></td></tr></table></figure>

<h3 id="focus-和-focused"><a href="#focus-和-focused" class="headerlink" title="focus 和 focused"></a>focus 和 focused</h3><blockquote>
<p>They are focused on the “<strong>minimum lovable product</strong> concept” and evaluate the impact of an edge case and &gt;the effort of handling it.  </p>
</blockquote>
<p>focus 是动词，表示“（某人）集中精力于某件事情上”。focused 是过去分词，可作形容词，表示“（注意力、眼神、焦点、光线等）集中的，（论文、计划等）目标明确的”  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I am exhausted, and just can’t focus on the work anymore.</span><br><span class="line">翻译：我筋疲力尽了，实在难以集中注意力工作了。</span><br><span class="line"></span><br><span class="line">例句：I think it is time you woke up and focused your thoughts on more worldly matters.</span><br><span class="line">翻译：我认为该是你清醒过来把思想集中到更为现实的问题上的时候了。</span><br><span class="line"></span><br><span class="line">例句：Every eye at the conference was focused on the rostrum.</span><br><span class="line">翻译：代表们的眼光都集中在大会主席台上。</span><br><span class="line"></span><br><span class="line">例句：Focused light rays can set something afire.</span><br><span class="line">翻译：聚焦光线可以点燃东西。</span><br><span class="line"></span><br><span class="line">例句：I spent the next year just wandering. I wasn’t focused.</span><br><span class="line">翻译：接下来的一年我一直在闲逛。没有什么明确的目标。</span><br></pre></td></tr></table></figure>

<p>由上面这些例句我们可以看出，本段中的 They are focused on the “minimum lovable product concept”，改为 They focus on the “minimum lovable product concept”，其实会更好一点，直接用 focus 做 They 这个主语即程序员们的谓语动词。当然，如果非要说 They are focused on（focused 做形容词）意思也勉强说得通，不能算错。  </p>
<h3 id="minimum-lovable-product"><a href="#minimum-lovable-product" class="headerlink" title="minimum lovable product"></a>minimum lovable product</h3><p>MVP 指的是 Minimum Viable Product，按照字面含义可以直译为“最小可行产品”。这种产品只包含最简单的基本核心功能。  </p>
<p>MLP 指的是 Minimum Lovable Product，可以直译为“最小可爱产品”。  </p>
<p>两者之间的本质区别究竟在哪里？  </p>
<ul>
<li><p>MVP is the version of a new product that brings back the maximum amount of validated learning about your customers with the least effort. （强调以最小的努力换回最大数量的经过验证的客户反馈数据；目标在于了解用户体验。）  </p>
</li>
<li><p>MLP is the version of a new product that brings back the maximum amount of love from your early tribe members with the least effort. （强调以最小的努力换回最大数量的首批部落成员的爱；目标在于直接开始圈粉。）</p>
</li>
</ul>
<h3 id="middle-ground"><a href="#middle-ground" class="headerlink" title="middle ground"></a>middle ground</h3><blockquote>
<p>They come with good middle-ground suggestions: mapping out most things that can go wrong and bring bringing suggestions on what edge cases need to be addressed, before shipping even an early version.  </p>
</blockquote>
<p>middle ground 的意思是“中间地带”，表示“折中、妥协之后的立场、观点、决定、协议”等等。字典里的解释是：a set of opinions, decisions, etc. that two or more groups who oppose each other can agree on; a position that is not extreme.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：More and more in this age of social media, it seems like people of differing views are unwilling to attempt to find a middle ground.</span><br><span class="line">翻译：在这个社交媒体时代，越来越多持不同观点的人似乎不愿意尝试找到一个中间立场。</span><br></pre></td></tr></table></figure>

<p>注意：最后一句话的 bring 应该改成 bringing。  </p>
<h1 id="为什么虚拟语气一看就懂、一用就忘？"><a href="#为什么虚拟语气一看就懂、一用就忘？" class="headerlink" title="为什么虚拟语气一看就懂、一用就忘？"></a>为什么虚拟语气一看就懂、一用就忘？</h1><p>文章的第七、八段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. Quick product validation cycles</span><br><span class="line">Even before the feature they are working on is production-ready, product-minded engineers find creative ways to get early feedback. This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, organizing a team bug bash on the beta build, and many other, creative ways. They are continuously thinking:&quot;how can we validate that people will use this feature, the way we think they will?&quot;</span><br><span class="line"></span><br><span class="line">7. 快速的产品验证周期</span><br><span class="line">甚至在开发的产品功能可以上线之前，具有产品思维的工程师们早就已经找到创造性的方法来获取早期的反馈意见。他们可以和同事一起进行走廊测试，可以向产品经理演示尚在开发中的功能，也可以在 Beta 版本发布前组织整个团队来一场“漏洞大扫荡”，当然还有许多其他创造性的方法。他们会一直思考这个问题：“我们怎样才能验证用户们会像我们预期的那样来使用这个功能？”</span><br></pre></td></tr></table></figure>

<p>首先，我们从整体看一下这段话。这段话中有两个从句，第一句的前半部分 Even before the feature they are working on is production-ready，是时间状语从句，表示“在功能上线之前”。其中，even 表示“高于预期，甚至”。主语 the feature 后面跟了一个定语从句，强调是“工程师们正在开发的”。在功能上线之前，工程师们就已经找到了创造性的方法来获取早期的反馈意见。  </p>
<p>最后一句的标黑处 people will use this feature, the way we think they will?，这是比较随意的说法，相对规范一点的说法为：people will use this feature in the way we think they will. 当然原文并不影响意思的表达和理解，无伤大雅。但是一般我看到不太规范的地方，总是忍不住要去修改，或许这也是一种“语言洁癖”的症状吧……  </p>
<h2 id="知识讲解-5"><a href="#知识讲解-5" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="work-in-progress"><a href="#work-in-progress" class="headerlink" title="work-in-progress"></a>work-in-progress</h3><blockquote>
<p>This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, &gt;organizing a team bug bash on the beta build, and many other, creative ways.  </p>
</blockquote>
<p>work-in-progress 是一个不可数名词，指“半成品、在制品、在建项目”，有时会缩写为 WIP。在文章中指“尚在开发过程中的应用软件”。这里是名词作形容词来修饰 feature，即“在开发中的软件的某项功能”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：You are strongly encouraged to save your document frequently, back-up regularly, and print your work-in-progress periodically.</span><br><span class="line">翻译：强烈建议你们经常保存和备份，并且定期把写作过程中的文稿打印出来。</span><br></pre></td></tr></table></figure>

<h3 id="bug-bash"><a href="#bug-bash" class="headerlink" title="bug bash"></a>bug bash</h3><p>这里的 bash，原意是“猛烈击打”。我们先来看维基百科给出的 bug bash 的定义。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In software development, a bug bash is a procedure where all the developers, testers, program managers, usability researchers, designers, documentation folks, and even sometimes marketing people, put aside their regular day-to-day duties and “pound on the product”—that is, each exercises the product in every way they can think of. Because each person will use the product in slightly different (or very different) ways, and the product is getting a great deal of use in a short amount of time, this approach may reveal bugs relatively quickly.</span><br><span class="line"></span><br><span class="line">在软件开发过程中，所有开发人员、测试人员、项目经理，还有负责可研、设计、文档管理甚至营销的同事，把他们的日常工作放在一边，一起来开“捉虫大会”。换言之，每个人都用他们能想到的方式来操作产品。因为每个人使用产品的方式略有不同（或非常不同），从而使得产品在很短的时间内得到了大量的使用，有助于团队相对较快地发现产品缺陷。</span><br></pre></td></tr></table></figure>

<p>文章第八大段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. End-to-end product feature ownership</span><br><span class="line">Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly. Product-minded engineers often go a step beyond this.</span><br><span class="line">They consider their work done only after getting results on user behavior and business metrics. After rollout, they still actively engage with product managers, data scientists, and customer support channels, to learn how the feature is being used in the real world. It can take weeks to get enough reliable data to draw conclusions. Even though they might be working on a new project, they make checking on the results one of their top priorities. It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?</span><br><span class="line">When a feature performs worse than expected, they are curious to understand where the mismatch was. They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase. They’ll often spend a good amount of time debating hypothesizes and learnings with the product manager and data scientists.</span><br><span class="line"></span><br><span class="line">8.对产品功能从头至尾负责到底</span><br><span class="line">经验丰富的工程师们都会对他们的工作从头至尾负责到底：从拿到产品规范到部署实施，再到发布产品并最终验证产品能否正常工作。除了上述这些工作以外，具有产品意识的工程师通常会举一反三、再进一步。</span><br><span class="line">他们坚信，只有在获得用户行为和商业指标的结果之后，他们的工作才算全部完成。产品上线后，他们仍然会积极与产品经理、数据专家和客户支持渠道保持密切沟通，以便了解产品功能在现实世界中的使用情况。要获得足够得出结论的可靠数据通常需要几周时间。即使他们可能已经接手下一个新项目，他们仍然会把检查上一项目的成果作为首要任务之一。这并不是一项特别耗时的活动，但是特别需要一种锲而不舍的精神，推动那些想要知道自己的辛勤劳动究竟效果如何的工程师们，去坚持探寻答案。</span><br><span class="line">当开发的某项功能表现得不如预期时，他们会特别好奇问题出在哪里？他们对于找到产品计划和现实世界结果之间存在差距的根本原因怀有浓厚的兴趣，程度不亚于他们在代码库中找到难以复现的缺陷并成功除错。他们经常会花费大量的时间，就某些假设和心得与产品经理和数据专家展开辩论。</span><br></pre></td></tr></table></figure>

<h3 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h3><p>它由 owner（物主、所有权人）加上 ship（表示地位、状态、关系的后缀，例如 leadership&#x2F;friendship&#x2F;dictatorship&#x2F;partnership 等等）组成，本意是“物主身份、产权关系”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：On January 23rd, America decided to relax its rules on the foreign ownership of its airlines.</span><br><span class="line">翻译：1 月 23 日，美国决定放宽对外国持有美国航空公司所有权的管制规定。</span><br><span class="line"></span><br><span class="line">例句：Major breakthroughs have been made in the reform of China’s ownership structure.</span><br><span class="line">翻译：中国所有制结构改革也取得了重大突破。</span><br></pre></td></tr></table></figure>

<p>这里的 ownership 指的是“产权体制”。  </p>
<h4 id="普及两类特别容易混淆的企业概念"><a href="#普及两类特别容易混淆的企业概念" class="headerlink" title="普及两类特别容易混淆的企业概念"></a>普及两类特别容易混淆的企业概念</h4><ul>
<li>在国内，论及所有制（即 ownership）的时候，我们会区分国有企业、集体企业和非公有制企业（包括私营企业）等。而西方国家在对市场中的企业类型进行划分时，更常用的是 private company 和 public company 这两个相对的概念。初学者看到这组词的时候，容易望文生义，认为 private company 是“私营企业或者民营企业”，那么 public company 一定是“公有体制下的国有企业”。如果这么理解的话，那就大错特错啦。国有企业现在约定俗成的说法叫 state-owned-enterprise，缩写是 SOE。</li>
</ul>
<p>那private company 和 public company 到底是什么意思呢？  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Privately held companies are—no surprise here—privately held. This means that, in most cases, the company is owned by its founders, management, or a group of private investors. A public company, on the other hand, is a company that has sold all or a portion of itself to the public via an initial public offering (IPO), meaning shareholders have a claim to part of the company’s assets and profits.</span><br></pre></td></tr></table></figure>

<p>根据这段解释，我们可以看出，private company 或者 privately held company 指的是“私人控股或持股公司”，一般由创始人、管理层或一群私人投资者拥有产权。  </p>
<p>而 public company 其实指的是“公众持股公司”，大多数时候我们也可以称为“上市公司（listed company）”，指通过股权首次公开发行（或简称 IPO）向公众出售公司全部或部分资产的公司，当然持有股票的公众股东理论上可分享上市公司一定比例的资产和利润。  </p>
<p>所以，在西方，区分公众公司和私人公司的标准并非对应中国的所有制形式，也不取决于规模大小（很多世界级的大型企业，例如美国的科氏工业集团、玛氏集团、彭博有限合伙企业等，都是不上市的私人企业），而是取决于公司的股份是否面向公众公开发行、是否可以自由转让。  </p>
<p>最重要的是，一旦一个私人公司成为公众公司（英文可以叫 goes public），就不能再享有闭门经营、少数几个经营者说了算的自由，公众公司必须接受证券交易监督管理委员会的监管，满足定期向股东和公众进行信息披露的要求。公众公司也可以进行“私有化”（privatization，如果是一家上市公司，就是“退市”），私有化和公募上市是一个反向的过程。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One of the biggest differences between the two types of companies is how they deal with public disclosure. If it’s a public U.S. company, which means it is trading on a U.S. stock exchange, it is typically required to file quarterly earnings reports (among other things) with the Securities and Exchange Commission (SEC). This information is made available to shareholders and the public. Private companies, however, are not required to disclose their financial information to anyone, since they do not trade stock on a stock exchange.</span><br></pre></td></tr></table></figure>

<p>由财产权引申出来，我们经常会听到 Kate owns this project 这样的话，表面意思是“凯特拥有这个项目”，指的是“这个项目的负责人是凯特”。  </p>
<p>文章中 ownership 的意思其实也是负责某个项目或某项工作的状态。字面上看，就是把公司的事情真正当作自己的，做事一跟到底，对结果负责。这一段小标题里面的 end-to-end（端到端），也是进一步强调了 ownership 这个意思。所以，ownership 其实也用来表示一个人有责任心，有主人翁精神，是一种可贵的、自发投入的工作状态。很多企业都会在自己的公司文化中倡导员工的 ownership 意识，和公司同心同德。  </p>
<h3 id="from…through…-all-the-way-to…"><a href="#from…through…-all-the-way-to…" class="headerlink" title="from…through… (all the way) to…"></a>from…through… (all the way) to…</h3><blockquote>
<p>Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly.  </p>
</blockquote>
<p>这是一个从 A 经过 B 到 C 的句型。all the way 表示“一直、自始至终”。ABC 可以是“时间、地点、一连串先后发生的事件”。此外，all the way through 也是一个惯用成语。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I slept all the way through the film.</span><br><span class="line">翻译：整部电影我都在睡觉。</span><br></pre></td></tr></table></figure>

<h3 id="beyond"><a href="#beyond" class="headerlink" title="beyond"></a>beyond</h3><blockquote>
<p>Product-minded engineers often go a step beyond this.  </p>
</blockquote>
<p>介词 beyond 在英语日常表达中很常用，是充分体现英语语言效率的高能小词。它最核心的含义就是“超出范围”。在时间、空间、能力范围以外，基本都可以用这个词。  </p>
<p>前几年北京雾霾比较严重的日子，AQI（Air Quality Index，空气质量指数）超过 500，我们会说“爆表了”，英文表述就是 beyond index（超出了正常的指数计量范围）。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The night session will go beyond midnight.</span><br><span class="line">翻译：夜间会议将持续到午夜以后。</span><br><span class="line"></span><br><span class="line">例句：Jenna always wondered what was beyond the horizon.</span><br><span class="line">翻译：洁娜总是纳闷地平线的那一边是什么。</span><br><span class="line"></span><br><span class="line">例句：What Jock had done was beyond my comprehension.</span><br><span class="line">翻译：我无法理解乔克的所作所为。</span><br></pre></td></tr></table></figure>

<h3 id="过去分词做宾语补足语"><a href="#过去分词做宾语补足语" class="headerlink" title="过去分词做宾语补足语"></a>过去分词做宾语补足语</h3><blockquote>
<p>They consider their work <strong>done</strong> only <strong>after getting results on user behavior and business metrics.</strong>  </p>
</blockquote>
<p>这句话的前半句是典型的过去分词做宾语补足语的句型，后半句则是我们已经很熟悉的状语从句，表示时间，“只有在拿到…之后，他们的工作才算完成”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：They keep the door locked for the whole day.（过去分词做宾语补足语）</span><br><span class="line">翻译：他们把门锁了一整天。</span><br><span class="line"></span><br><span class="line">例句：I find learning Japanese difficult.（形容词做宾语补足语）</span><br><span class="line">翻译：我发现学习日语很难。</span><br></pre></td></tr></table></figure>

<h3 id="even-if-x2F-though"><a href="#even-if-x2F-though" class="headerlink" title="even if&#x2F;though"></a>even if&#x2F;though</h3><blockquote>
<p>Even though they might be working on a new project, they make checking on the results one of their top priorities.  </p>
</blockquote>
<p>even if 和 even though 意思相近，都可用于引导表示让步的状语从句，但它们的用法存在微妙差别。  </p>
<p><strong>even if 引导的从句一般是假设性的，并不符合真实的状况，表示“即使、就算、哪怕”等含义</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I wouldn’t marry you even if you were the last man in the world.</span><br><span class="line">翻译：即使你是世界上最后一个男人，我也不会嫁给你。</span><br></pre></td></tr></table></figure>

<p><strong>even though 引导的从句，往往是在说真实发生的情况，表示“尽管、虽然”的意思。大部分情况下，我们可以直接用 though 或 although 代替，但是不可以说 even although。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Thomas is awarded the best teacher of the year even though he has the least experience.</span><br><span class="line">翻译：托马斯被授予年度最佳教师，尽管他的经验最少。</span><br></pre></td></tr></table></figure>

<p>当 even if 或 even though 引导让步状语从句时，后面可以是真实的条件句，也可以是虚拟语气。  </p>
<p>用一句话来说，虚拟语气用来<strong>表示虚假的、与事实相反或难以实现的情况，也可以用来表示某种不确定的情形，体现主观愿望或某种强烈情感。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：If it rains tomorrow, we will cancel the event.</span><br><span class="line">例句 2：If I were you I should go to see the doctor.</span><br><span class="line">例句 3：I wish it were Sundy today.</span><br><span class="line">例句 4：I should have called Emily this morning, but I forgot.</span><br></pre></td></tr></table></figure>

<h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><p>priority 源于形容词 prior，意思是“优先的、前面的、更重要的事项”。有时候为了表示强调，我们会在 priority 前面加上 top 或者 number one，表示“重中之重、第一优先事项”。  </p>
<p>它的词根 pri&#x2F;prim&#x2F;prin，表示“首先、第一、重要”等含义，我们所熟悉的 primary、prime minister&#x2F;premier、prince&#x2F;princess、principal、principle、primate 都带有这个前缀。  </p>
<h3 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h3><blockquote>
<p>It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?  </p>
</blockquote>
<p>persistence 源于形容词 persistent 和动词 persist。从词根的角度看，per&#x3D;through，是“从头至尾、贯穿始终”的意思（例如 permanent、perpetual 等）；sist&#x3D;to stand，是“站立”的意思。例如，consist（站在一起 &#x3D; 组成）、resist（站到反面 &#x3D; 抵抗）。所以，合在一起这个词就是“始终站立、坚持到底”的意思。  </p>
<p>动词 persist 一般和介词 in 搭配，意思要看上下文，较多情况下偏贬义，有“顽固坚持、执迷不悟”的意思。  </p>
<p>几条词典的解释：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to try to do or continue doing something in a determined but often unreasonable way. (Cambridge Advanced Learners’ Dictionary）</span><br><span class="line">if you persist in doing something, you continue to do it, even though it is difficult or other people are against it. (Collins Cobuild Essential English Dictionary)</span><br><span class="line">to go on resolutely or stubbornly in spite of opposition, importunity, or warning. (Merriam-Webster Online)</span><br></pre></td></tr></table></figure>

<p>通过上面来自不同词典的解释可以看到，persist 一词有褒义的含义，但更多的语境下是偏贬义的，因此需要我们根据上下文来辨别它的具体含义。你可以理解为“坚持不懈”，更多语境下它带有“不顾别人的反对、执迷不悟”的意思。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：We join, we persist, we win.</span><br><span class="line">翻译：我们参与了，我们坚持了，我们最终胜利了。</span><br><span class="line"></span><br><span class="line">例句：Why do you persist in blaming yourself for what happened?</span><br><span class="line">翻译：你何必为已发生的事没完没了地自责？</span><br><span class="line"></span><br><span class="line">例句：She had turned him down for a date before, but he persisted and asked her again.</span><br><span class="line">翻译：她以前拒绝过他的约会，但他坚持要再约她一次。</span><br></pre></td></tr></table></figure>

<p>同样，形容词 persistent 和名词 persistence 的含义也要看上下文，也有褒义也有贬义。褒义的时候形容坚持不懈。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Skill comes only with practice, patience and persistence.</span><br><span class="line">翻译：只有不断练习，有耐心，有毅力，才能学会一门技艺。</span><br></pre></td></tr></table></figure>

<p>不过，它的近义词 persevere、perseverant 和 perseverance 则永远是褒义的，表示“孜孜以求、锲而不舍”，不用管上下文。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：By perseverance the crippled boy learned how to swim.</span><br><span class="line">翻译：由于锲而不舍，那个腿部残疾的男孩学会了游泳。</span><br></pre></td></tr></table></figure>

<h3 id="as…as…"><a href="#as…as…" class="headerlink" title="as…as…"></a>as…as…</h3><blockquote>
<p>They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase.  </p>
</blockquote>
<p>as X as Y，比较活动 X 和 Y。  </p>
<p>活动 X（即 finding…）做 interested in 的介词宾语，活动 Y 跟在第二个 as 后面，是表示比较的状语从句。句子虽然长，但框架结构很明确，强调“工程师们对活动 X（找产品问题的根源）的兴趣和活动 Y（捉虫，即找技术问题的根源）一样大”。  </p>
<h1 id="带你一次性搞懂非限定性和限定性定语从句"><a href="#带你一次性搞懂非限定性和限定性定语从句" class="headerlink" title="带你一次性搞懂非限定性和限定性定语从句"></a>带你一次性搞懂非限定性和限定性定语从句</h1><p>文章的第九段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. Strong product instincts through repeated cycles of learning</span><br><span class="line">A typical project for a product-minded engineer usually goes like this:</span><br><span class="line">1.They ask a lot of questions to understand exactly why the product feature is being built.</span><br><span class="line">2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.</span><br><span class="line">3.They build the feature quickly, getting early feedback, as they do.</span><br><span class="line">4.After shipping the feature, they actively follow up to understand if the feature lives up to the expectation.</span><br><span class="line">5.When it does not, they dig deep, to understand why it did not and learn something new about product usage in the real world.</span><br><span class="line">After each project, their product understanding deepens, and they start to develop better and better product instincts. The next time, they’ll bring even more relevant suggestions to the table. Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off. They build a strong reputation outside the team, opening more doors for their continued career growth.</span><br><span class="line"></span><br><span class="line">9.通过反复循环的学习，形成强大的产品本能</span><br><span class="line">对于有产品意识的工程师来说，一个典型的项目通常是这样的：</span><br><span class="line">1. 他们会提出很多问题，来准确理解构建产品功能的原因；</span><br><span class="line">2. 他们会提供建议和取舍方案，其中某些建议会反映在修订后的产品设计规范中；</span><br><span class="line">3. 他们会很快开发出相关功能，以便尽早得到反馈意见；</span><br><span class="line">4. 在产品发布之后，他们会积极跟进了解相关产品功能是否符合预期；</span><br><span class="line">5. 如果没有达到预期，他们会深入挖掘原因，并学到产品在现实世界中使用的新知识。</span><br><span class="line">每完成一个项目，他们对产品的理解就会加深，他们开始培养起越来越好的产品直觉。等到下一个项目，他们会贡献更多有价值的建议。随着时间推移，他们会成为产品经理最愿意去讨教的大专家，在新的项目还未开始之前就会提前去征求他们的意见。他们将名声在外，为持续的职业发展打开更多的大门。</span><br></pre></td></tr></table></figure>

<h2 id="知识详解"><a href="#知识详解" class="headerlink" title="知识详解"></a>知识详解</h2><h3 id="instinct"><a href="#instinct" class="headerlink" title="instinct"></a>instinct</h3><p>英文解释：An inborn pattern of behavior that is characteristic of a species and is often a response to specific environmental stimuli，一种天生的行为模式，作为一个物种的群体特征，通常是对特定环境刺激的反应。  </p>
<p>这里涉及一个常见的词根，sting&#x2F;stinct&#x2F;stimul&#x3D;thorn&#x2F;to prick，即“刺 &#x2F; 刺激”的意思。in-stinct 就是“内在的刺激反应”，也就是“一种与生俱来的天性、天赋”，或者叫“本能、直觉”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Children do not know by instinct the difference between right and wrong.</span><br><span class="line">翻译：儿童并非生来就会分辨是非。</span><br><span class="line"></span><br><span class="line">例句：Even at school, he showed he had an instinct for business.</span><br><span class="line">翻译：他早在求学时期就表现出优秀的商业直觉（或经商天赋）。</span><br><span class="line"></span><br><span class="line">例句：Farmers are increasingly losing touch with their instinct for managing the land.</span><br><span class="line">翻译：农民正在逐渐失去经营土地的本领。</span><br></pre></td></tr></table></figure>

<h3 id="过去分词做前置定语"><a href="#过去分词做前置定语" class="headerlink" title="过去分词做前置定语"></a>过去分词做前置定语</h3><p>标题中的另一个词 repeated cycles，这是典型的过去分词做前置定语。需要注意的是，它有被动的含义，相当于 the cycles that are repeated。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：She says she’s got a broken heart. (=a heart that has been broken).</span><br><span class="line">翻译：她说她的心碎了。</span><br></pre></td></tr></table></figure>

<p>这里就是被动的含义，但是也有一些过去分词在做前置定语的时候，带有主动的含义，例如：  </p>
<ul>
<li>a fallen leaf&#x3D;a leaf that has fallen 一片落叶  </li>
<li>a retired general &#x3D;a general who has retired 一名退休的将军</li>
</ul>
<p>还有一些过去分词在做前置定语的时候，也带有主动的含义，但必须和副词一起使用才可以。例如下面这些：  </p>
<ul>
<li>a much-travelled man &#x3D; a man who travelled much 一个经常出远门的人（不可以说 a travelled man）  </li>
<li>recently-arrived immigrants &#x3D; immigrants who arrived recently 新来的移民（不可以说 arrived immigrants）</li>
</ul>
<p>下一段话中有一句 Bring well-backed product suggestions to the table。其中的 well-backed suggestions 也是同样的用法，表示工程师提的建议有充分的依据，但是直接说 backed suggestions 而不带副词 well，那就错啦。  </p>
<p>还有些过去分词，前置定语和后置定语的意思会发生变化，例如：  </p>
<ul>
<li>an adopted child&#x3D;a child who is brought up by people who are not his&#x2F;her biological parents 一个被收养的孩子  </li>
<li>the solution adopted&#x3D;the solution that is&#x2F;was chosen 所采取的解决方案</li>
</ul>
<h3 id="bring-something-to-the-table"><a href="#bring-something-to-the-table" class="headerlink" title="bring (something) to the table"></a>bring (something) to the table</h3><blockquote>
<p>2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.  </p>
</blockquote>
<p>这个词组的字面含义是“把…放到桌上”，一般可以引申出“提供（意见、建议等）、贡献（技能、经验等）”的意思，to provide or offer a useful skill or attribute，表示一般提供或贡献的是能拿得出手、上得了台面、有价值的东西。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：He brings years of leadership experience to the table.</span><br><span class="line">翻译：他贡献了多年的领导经验。</span><br><span class="line"></span><br><span class="line">例句：Tell us what you bring to the table, not just what you want.</span><br><span class="line">翻译：告诉我们你能给公司带来什么，而不仅仅是你想要什么。</span><br></pre></td></tr></table></figure>

<h3 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h3><blockquote>
<p>They bring suggestions and tradeoffs to the table, <strong>some of which are included in the revised spec.</strong>  </p>
</blockquote>
<p><strong>所谓限定性，就是从句要对前面修饰的内容进行限制，缩小范围。</strong>  </p>
<p>例如，在“What is the name of the tall man who&#x2F;that just came in? ”这句话中，说话的人问那个刚刚进来的高个男生叫什么名字？ “刚刚进来的”就是限定，不可以省略，否则就会变成问所有的高个男生叫什么名字了，影响前面整个句子意思的完整性。  </p>
<p><strong>而非限定性定语从句，则是对前面的内容进行补充，增加信息。</strong>  </p>
<p>刚才文中的那句话，逗号后面的 some of which…补充说明工程师提出了建议，而且有的还会加到新版的设计规范文件里面去。逗号后面这部分信息可有可无，即使省略，也不影响前面主句意思的完整性。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">She married a man that she met on a bus.</span><br><span class="line">She married a very nice young engineer from Chicago, whom she met on a bus.</span><br></pre></td></tr></table></figure>

<p>从形式上看，限定性定语从句的先行词可以用 that 引导，主句与从句不需要用逗号隔开，引导词有时可以省略；而非限定性定语从句的先行词不可以用 that 引导，主句与从句需要用逗号隔开，引导词不可以省略。  </p>
<p>我们看下面这两组句子。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一组：</span><br><span class="line">Have you got a book which/that is really easy to read? （可以用 that 引导，没有逗号）</span><br><span class="line">I lent him the Old Man and the Sea, which is really easy to read. （不可以用 that 代替 which，必须有逗号隔开）</span><br><span class="line"></span><br><span class="line">第二组：</span><br><span class="line">Did you like the wine we drank last night? （引导词可以省略）</span><br><span class="line">I poured him a glass of wine, which he drank at once. （引导词不可以省略）</span><br></pre></td></tr></table></figure>

<p>此外，限定性定语从句只能修饰先行词，遵循就近原则。非限定性定语从句既可以修饰先行词，也可以修饰整个句子或句子的一部分。你可以比较下面这两句话：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We had some ice-cream which was very unusual.</span><br><span class="line">We had some ice-cream, which was very unusual.</span><br></pre></td></tr></table></figure>

<p>第一句话是限定性定语从句，只能修饰先行词 ice-cream ，说明这个冰激凌不一般、很难得。<br>第二句非限定性定语从句，既可以修饰先行词，也可以修饰整个句子。所以这里就有可能产生歧义，一种理解和第一句一样，还有一种理解就是从句修饰 We had some ice-cream 这件事，强调我们不太吃冰激凌，所以吃冰激凌这件事情很少见、非同寻常。但是既然专门用了非限定性定语从句，一般作者的意图就是第二种解释，来强调吃冰激凌这件事。  </p>
<h3 id="live-up-to"><a href="#live-up-to" class="headerlink" title="live up to"></a>live up to</h3><blockquote>
<p>4.After shipping the feature, they actively follow up to understand if the feature <strong>lives up to</strong> the expectation.  </p>
</blockquote>
<p>live up to 是一个很常用也很地道的动词短语，表示 to be as good as or have the qualities that someone predicted, expected, or hoped for，即“遵守（诺言）、符合（预期）、不辜负（期望）”等。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：We’d heard so many good things about the new restaurant, but the food didn’t live up to our expectations at all.</span><br><span class="line">翻译：我们听说很多关于这家新餐馆的赞誉，但餐食却远远没有达到我们的期望。</span><br><span class="line"></span><br><span class="line">例句：I’ve delivered the cash as you instructed. Now you must live up to your end of the bargain!</span><br><span class="line">翻译：我已经按照你说的把钱送来了。现在该你履行承诺了！</span><br></pre></td></tr></table></figure>

<h3 id="动词后缀-en"><a href="#动词后缀-en" class="headerlink" title="动词后缀 -en"></a>动词后缀 -en</h3><blockquote>
<p>After each project, their product understanding deepens, and they start to develop better and better product instincts.  </p>
</blockquote>
<p>-en 是常用的动词后缀，形容词加上 -en 后缀，构成动词，表示“使得、变得”（make, become）。  </p>
<p>例如，本句中 their product understanding deepens，deep 是形容词，表示“深、深刻”，加上 -en 后缀之后，变成动词 deepen，表示“变深、加深、使深刻”等含义，也就是工程师们对产品的理解加深了。  </p>
<p>使用相同构词法构成的动词还有很多，例如 deaf（耳聋）加上 -en，就变成了 deafen（声音响得让人耳朵都要聋掉了）。这里列了一些类似的单词：  </p>
<ul>
<li>broaden v 加宽（broad 宽）  </li>
<li>darken 变黑（dark 黑）  </li>
<li>dampen 使潮湿；使沮丧（damp 潮湿）  </li>
<li>hasten 促进（haste 匆忙）  </li>
<li>hearten 鼓励（heart 心）  </li>
<li>sharpen 削尖（sharp 尖）  </li>
<li>shorten 缩短（short 短）</li>
</ul>
<p>deafening silence，”震耳欲聋的安静“。这是英语里常用的矛盾修饰法（oxymoron）。  </p>
<p>另外，-en 后缀还可以和名词一起组成形容词，例如名词 gold 加上 -en 变成 golden，成为形容词，表示“黄金的、金色的”。类似的词还有 wooden、woolen 等等。  </p>
<p>除了 -en 之外，常用的动词后缀还有 -ate&#x2F;-ify&#x2F;-ise&#x2F;-ize 等。  </p>
<h3 id="relevant-x2F-irrelevant"><a href="#relevant-x2F-irrelevant" class="headerlink" title="relevant&#x2F;irrelevant"></a>relevant&#x2F;irrelevant</h3><blockquote>
<p>The next time, they’ll bring even more relevant suggestions to the table.  </p>
</blockquote>
<p>这个词看似简单，只是表示“有意义的、密切相关的”（having significant and demonstrable bearing on the matter at hand），似乎没什么实质意义。类似，汉语里“有关部门”“相关问题”，听上去感觉含义很隐晦，所以很多中国同学经常会忽略这个词。但在英语中，relevant 这个词的含义一点都不隐晦哦，在很多场合，它的语气还很明确而强烈。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：These comments are not even relevant to this enquiry.</span><br><span class="line">翻译：这些意见简直文不对题，与这项调查没有关联。</span><br><span class="line"></span><br><span class="line">例句：I don’t see the relevance of your question. （名词形式）</span><br><span class="line">翻译：我不懂你提的这个问题有什么意义。（口气非常强烈甚至不礼貌）</span><br></pre></td></tr></table></figure>

<p>而反义词 irrelevant 的含义则更加直白，“不相关”的意思就是“无关紧要、有没有都一样”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Their old hard-won skills now become irrelevant.</span><br><span class="line">翻译：他们以往辛苦学会（来自不易）的技能现如今已经没什么用处了。</span><br></pre></td></tr></table></figure>

<h3 id="a-go-to-person"><a href="#a-go-to-person" class="headerlink" title="a go-to person"></a>a go-to person</h3><blockquote>
<p>Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off.  </p>
</blockquote>
<p>a go-to person 这个词比较口语化，意思是“一个组织里的多面手、大拿、牛人”。每个公司或多或少都有这样几个人，你遇到棘手的问题都会去咨询他或她，这些人就是 goto person。  </p>
<h3 id="kick-off"><a href="#kick-off" class="headerlink" title="kick off"></a>kick off</h3><p>kick off 这个动词短语，最初的意思是指“足球比赛中的开球”，(of a football game, soccer game, etc.) be started or resumed after a score by a player kicking the ball from a designated spot。现在用得更多的是它的引申义，表示“（会议）开始、（项目）启动”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：We’re going to kick off the new year with a huge party.</span><br><span class="line">翻译：我们将以一个盛大的晚会来开始新的一年。</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><p>要善于“用一杯咖啡吸收宇宙能量”，其实都是一样的意思。因此，我们学英语绝非学习语言本身，在兴趣和好奇心的驱使下，广泛涉猎五花八门的百科知识，然后通过相同话题的外语“平行文本（parallel text）”的阅读或视听，来进行语言学习，是事半功倍的好方法。  </p>
</li>
<li><p>培养好的态度和好的习惯。所谓好的态度，就是不要放过生活中碰到的任何一个疑问。<strong>心中苟有所开，即便札记。不则还塞之矣</strong>，意思就是说，你要是有了灵感，必须要马上记下来，不然很快就没了。  </p>
</li>
<li><p>语言学习有方法但无捷径，语法如此，词根词缀也是如此。每天坚持听和读，有机会的时候加上一些说和写，不论多少，贵在坚持，细水长流，金石可断。  </p>
</li>
<li><p>把学习外语想成你去一个陌生的地方旅行，别人的学习心得就是旅行攻略，而语法就是地图。无论你把地图研究得多么透彻，把街道名称倒背如流，都比不上真的踏上那片土地，亲自去挤一下当地的公交车，用脚丈量一下从酒店到山顶的几条步道，或者偶遇一家当地著名的苍蝇馆子，哪怕在街巷中迷失方向，都是非常好的体验。<strong>但请你一定不要急着想要把所有的语法规则记住背熟，现阶段跟我一起欣赏街景就好。</strong></p>
</li>
<li><p>在英语学习的过程中，我们除了要学习一个一个的单词以外，更加重要的是，要多学固定搭配和短语。就像我们学习汉语的时候，光识字是不够的，认识了单个的汉字之后，我们其实更多的在学习词语、词组或者成语。</p>
</li>
<li><p>学习语言的唯一目的就是交流，只要这个目的达到了，不管白猫黑猫，都是好猫。如果反过来，关起门来对自己很宽松，到人前又瞻前顾后、不敢开口，就很难学好外语。  </p>
</li>
<li><p><strong>Stay hungry, stay foolish.”</strong>意在告诉人们，在自己精进的时候，要如饥似渴，始终保持“入口”的开放，做个吃货；但一旦付诸行动去实现自己认准的人生理想时，要如同赤子一般天真大胆，不怕别人耻笑，敢于在别人误解的目光里孤独前行，做个“傻缺”。  </p>
</li>
<li><p>People don’t want to buy a quarter-inch drill. They want a quarter-inch hole（顾客不是想买一个 1&#x2F;4 英寸的电钻，他们想要的是 1&#x2F;4 英寸的洞！）。这句话想说的就是，顾客对产品本身不感兴趣，他们感兴趣的是产品能给他们带来什么好处。  </p>
</li>
<li><p><strong>语法永远是为意思服务的。</strong>数据本身是没有价值的，就如同语言文字千变万化，浩如烟海，慢慢地获得将数据转化为洞察力的本事，才能先行一步。正如《指环王》的作者托尔金在《汉姆的农夫吉尔斯》（Farmer Giles of Ham）里提到先知的牧师时说：He was a grammarian and could doubtless see further into the future than others.（他是一个语法学家，无疑他比其他人更能预见未来。）  </p>
</li>
<li><p>平时自己在阅读的时候可以慢慢养成的一些习惯——首先，阅读过程中碰到不认识的词，在不影响大意理解的前提下，我们要勇敢地无视生词，直接碾压过去。千万不要每一个词都去查，否则除了效率降低以外，阅读的乐趣也会大打折扣；其次，如果发现这个词绕不过去，影响核心内容的理解，那就一定要查了。但是也不要只查一个中文的意思就结束了，顺便做三件事情：第一，查阅英英字典，了解一下英文的解释；第二，比较全面地了解一下这个词的几个不同意思，想一想这几个意思之间的关联性；第三，多读几个例句，了解这个词活生生的用法；最后，要善于去发现一些你似乎认得，但并不真正了解的“小词”。  </p>
</li>
<li><p>在英语学习的过程，我们固然希望保持精益求精的态度，少犯低级的语法错误，但也不能因噎废食，因为害怕出错就畏惧开口。  </p>
</li>
<li><p><strong>词汇学习一定不能脱离上下文，背单词不如背例句，背例句不如自己模仿写例句。</strong>凡学英语，必学整句，不觉中将其句法音调整个吸入。每日选二三句，回环熟诵，此数句读音必正，出口必熟。如此半年，操英语能力必大进。</p>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://tech.qq.com/a/20111006/000132.htm">斯坦福大学演讲（英文）</a>  </li>
<li><a href="https://time.geekbang.org/column/article/237837">What are Similes?</a>  </li>
<li><a href="https://www.englishpractice.com/grammar/adverb-particles/?pdf=1004">What are Adverb Particles?</a>  </li>
<li><a href="https://www.grammar-monster.com/glossary/compound_nouns.htm">compound_nouns</a>  </li>
<li><a href="https://medium.com/the-happy-startup-school/beyond-mvp-10-steps-to-make-your-product-minimum-loveable-51800164ae0c">beyond-mvp-10-steps-to-make-your-product-minimum-loveable</a>  </li>
<li><a href="http://englishplus.com/grammar/00000031.htm">http://englishplus.com/grammar/00000031.htm</a>  </li>
<li><a href="https://www.grammar-monster.com/glossary/subjunctive_mood.htm">https://www.grammar-monster.com/glossary/subjunctive_mood.htm</a>  </li>
<li><a href="https://www.forbes.com/sites/jeffschmitt/2013/10/31/the-go-to-person-what-you-need-to-become-one/#b31f871522ee">The Go-To Person: What You Need To Become One</a>  </li>
<li><a href="https://learnenglish.britishcouncil.org/grammar/intermediate-to-upper-intermediate/relative-clauses-non-defining-relative-clauses">Relative clauses – non-defining relative clauses</a></li>
</ul>
]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>程序员</tag>
        <tag>产品</tag>
        <tag>语法</tag>
        <tag>词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>English_Article 2：Open Source Benefits to Innovation and Organizational Agility</title>
    <url>/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/</url>
    <content><![CDATA[<p><a href="https://www.infoq.com/news/2019/03/open-source-benefits/">Open Source Benefits to Innovation and Organizational Agility</a>  </p>
<p>这篇文章出自 InfoQ 英文站，主要探讨了开源给科技创新能力和组织敏捷性带来的好处。  </p>
<h1 id="导读：通过阅读序言段了解文章的背景知识"><a href="#导读：通过阅读序言段了解文章的背景知识" class="headerlink" title="导读：通过阅读序言段了解文章的背景知识"></a>导读：通过阅读序言段了解文章的背景知识</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>通过这篇文章的序言段，了解一下文章的总体背景。  </p>
<blockquote>
<p><strong>Capital One</strong> hosted their 3rd <strong>Agile Conference</strong> in December 2018 in Virginia. Among the <strong>guest speakers, Andrew Aitken</strong>, global open source strategy leader at <strong>Wipro</strong>, presented the state of open source and how it is becoming an industry-wide organizational <strong>keystone</strong> strategy in driving innovation and in retaining top talent.</p>
</blockquote>
<ul>
<li><p>Capital One，美国第一资本集团，做过互联网金融的小伙伴肯定都听说过这家企业。<br>Capital One 最开始只是美国弗吉尼亚州一家地区性小银行的信用卡中心。1995 年，它从集团独立出去并正式更名为 Capital One。作为后起的“小人物”，在短短二十多年的时间里，在一片市场已经高度饱和、几乎被老牌巨头们垄断、产品又相当同质化的“红海”之中，Capital One 利用多元化战略和信息技术创新，快速从一家名不见经传的小型地区银行崛起成为美国十大银行之一，同时也变成了美国排名前三的信用卡发卡机构和零售商。<br>Capital One 在后来也成为了中国新兴金融科技企业，特别是互联网金融、消费金融企业及信用卡中心学习和效仿的对象。行业内有一些企业，是那些从 Capital One 离职回国的创业者创立的，所以也有人将 Capital One 戏称为金融科技行业的“黄埔军校”。  </p>
</li>
<li><p>Wipro（维布络）。它是和 Infosys、塔塔咨询等齐名的信息技术服务公司，总部位于有印度硅谷之称的班加罗尔，客户和业务遍布全球各地。这篇文章的作者 Andrew Aitken，就是维布络全球开源技术战略的负责人。每年 Capital One 都会举办一次“敏捷技术大会”（Agile Conference）。而我们要讲的这篇文章就是他作为特邀嘉宾，发表的关于开源技术战略的演讲稿。</p>
</li>
</ul>
<h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="guest-speaker"><a href="#guest-speaker" class="headerlink" title="guest speaker"></a>guest speaker</h3><p>英文解释：A guest speaker is a person who is invited to speak at an event.  </p>
<p>敏捷技术大会是 Capital One 组织的年度商务技术会议，大会会邀请类似 Wipro 这样的合作伙伴参加，所以，负责全球开源技术战略的负责人 Wipro，是会议主办方邀请来的客人。他是作为行业意见领袖之一来发表演讲。这样的人我们称之为 guest speaker，中文一般称为“特邀嘉宾”或“特邀演讲人”。  </p>
<p>现在有很多软硬件厂商主办的研讨会，他们也经常会邀请一些重要客户的代表在会上现身说法，分享使用产品的经验，这些演讲者都属于 guest speaker。  </p>
<h3 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h3><p>keynote speaker，他们发表的演讲叫作 keynote speech 或者 keynote address。  </p>
<p>苹果公司的演示幻灯片软件就叫 Keynote，它的英文解释是 the fundamental or central fact, idea, or mood，“最基本或最核心的事实、思想或调性”，或者叫“要旨、主题、基调”等。  </p>
<p>所以，keynote speech 是一场活动中最重要的演讲，keynote speaker 一般称为“主旨演讲人、主题报告人”等，可以是主办方的领导，也可以是特邀的重量级嘉宾。  </p>
<p>既然提到 keynote，你肯定会联想到微软的 PowerPoint 或者 PPT。我们平时也会很习惯地说，“我在做 PPT“”或者“给大家演示一下我的 PPT”，但一打开软件用的其实是苹果公司的 Keynote 软件。  </p>
<p>建议：多使用 slide 这个词。因为这个词是中性的，只是表示一页一页的幻灯片，并不涉及某家公司的产品。“I can’t wait to show you guys the slides,”比“I can’t wait to show you guys my PPT.”要更合适一些。  </p>
<h3 id="agile"><a href="#agile" class="headerlink" title="agile"></a>agile</h3><p>英文解释：able to move quickly and easily；able to think quickly and in an intelligent way。前者指动作，“能够快速灵活地移动”；后者指思维，“能够敏锐机智地思考”。  </p>
<p>“敏捷软件开发”（agile software development）这个词，你应该很熟悉。Capital One 作为一家金融服务企业，用“敏捷”来命名自己的年度商务技术大会，应该和“敏捷开发”的理念以及公司战略有着千丝万缕的联系。  </p>
<p>在美国传统信用卡行业中，一般会根据美国个人消费信用评估公司的信用评分结果（FICO Score），把消费者分成两大类，分别是优质客户和次级客户。  </p>
<p>所谓的“优质客户”（prime），信誉良好、几乎不欠款。这些客户的信用风险非常低。而信用评分偏低的客户（一般低于 670），或多或少存在逾期拖欠、随意透支甚至申请破产等各种财务困境历史。这些人会被归入“次级客户”（subprime）里。给他们发放贷款信用风险较高，所以这个也被称为“次级贷款”（subprime mortgage）。我们所知道的 2008 年全球金融危机，就是由次级贷款引发的，所以也被称为“次贷危机”。  </p>
<p>前面我们提到过，在 Capital One 成立之初，信用卡市场已经相当成熟。传统意义上的“优质”信贷客户群体已经被运通、花旗等老牌金融机构瓜分殆尽，大的环境会逼迫后起的企业去开辟新的战场，打造新的竞争环境，建立全新的游戏规则。  </p>
<p>Capital One 在矮子里面拔高个儿，首先将目标客户群体锁定“次级客户”中风险相对较低的那一群，例如循环借贷客户。这些人逾期概率较高，但是过一段时间之后又通常能够还清欠账，最终的实际坏账率较低，这些人对公司的利润率贡献却很高。  </p>
<p>这一差异化竞争战略听上去非常靠谱，关键在于如何执行。俄国文学巨匠托尔斯泰在他的《安娜 卡列尼娜》(Anna Karenina）里这样开篇：幸福的家庭都是相似的，不幸的家庭各有各的不幸（All happy families resemble one another, each unhappy family is unhappy in its own way）。  </p>
<p>同样的道理，优质客户都是相似的，次级客户各有各的问题。如何真正把“高个儿”从矮子群里拔出来，也就是如何在长尾市场中筛选出符合要求的高价值客户，保证他们给公司带来高收益的同时、又能确保风险可控，毫无疑问，需要强大的信息技术和深度的数据分析能力来提供支撑。  </p>
<p>这一点在大数据家喻户晓的今天似乎很容易理解，但在互联网方兴未艾的上世纪九十年代，则需要独到的洞察力以及持续投入创新的决心。  </p>
<p>除了吸引“次级”客户以外，Capital One 还打破了美国信用卡市场长期不变的“20+19.8”的收费模式（20 美元的年费和 19.8% 的年化利率）。他们采用“诱惑利率”（teaser rate）和“信用卡余额代偿”（balance transfer）等具有开创性的营销手段，去吸引其他银行的信用卡客户转网。  </p>
<p>例如，Capital One 通过电话或邮件方式，用年化利率 8% 的贷款替客户还清其他银行的欠款，同时把该客户的贷款余额转移到 Capital One 的信用卡上。当然，诱惑客户转网的低息期结束之后，利率会调回到正常的市场水平。  </p>
<p>Capital One 因此很快获得了大量新客户，然而这并不是这一战略的关键。关键在于，到底应该如何留住下了血本拉过来的这些新客户，自然还是要靠持续不断具有吸引力的产品。  </p>
<p>我们前面介绍过，上世纪九十年代的美国信用卡市场的定价是统一僵化的，但每一个客户个体的利润率却千差万别。Capital One 成功地通过“边测试边学习”策略（Test-and-Learn），在数据分析的基础上实现有效的用户分层和差异化定价，设计出符合各类客户需求的产品，持续用低利率吸引并留住好客户，及时甄别和拒绝垃圾客户，最终使 Capital One 在激烈的市场竞争中脱颖而出。  </p>
<h3 id="敏捷开发和-DevOps-理念的重要性"><a href="#敏捷开发和-DevOps-理念的重要性" class="headerlink" title="敏捷开发和 DevOps 理念的重要性"></a>敏捷开发和 DevOps 理念的重要性</h3><p>对于敏捷开发和所谓“瀑布式开发”（agile vs. waterfall）的讨论，已经持续了很多年。如果你是程序员的话，应该比较熟悉。维基百科也讲了这两种方法论的差别，表述如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One of the differences between agile software development methods and waterfall is the approach to quality and testing. In the waterfall model, there is always a separate testing phase after a build phase; however, in agile software development testing is completed in the same iteration as programming.</span><br><span class="line">Another difference is that traditional “waterfall” software development moves a project through various Software Development Lifecycle (SDLC) phases. One phase is completed in its entirety before moving on to the next phase.</span><br></pre></td></tr></table></figure>

<p>总结来说，敏捷软件开发打破了“瀑布式”分开发阶段的生命周期循环，把测试环节融入到了编程迭代中完成，从原本的一站一停变成了小步快跑，将原本一块又一块的大石头敲成了小碎石。这种方法论的实质就是 Capital One 所说的“边测试边学习” 策略，和我们上面分析的商业战略是高度匹配的。  </p>
<p>无论是持续推出上千款不同产品，还是开发高效的个性化客服系统，以及先进的风险控制模型，Capital One 一旦有任何新的想法，立刻就会调集所掌握的客户数据，进行调整、测试然后以最快的速度推向市场，把传统的大里程碑转化成一个永无止境的产品优化过程。  </p>
<p>有人觉得敏捷开发会影响系统稳定性，其实不然。小步快跑可以更快地交付产品给用户，可以更快地得到用户的反馈、更快地发现问题、更快地进行响应。同时，小步快跑带来的变化是比较小的，即使出现问题也不会太严重，修复起来也相对容易。  </p>
<p>当然，所有这一切都需要长期的投入和持续的创新。<strong>任何的理想都需要实实在在的技术来支撑。</strong>  </p>
<p>DevOps 一词是将 Development 和 Operations 这两个词组合在一起构成的。顾名思义，就是试图把软件开发人员和运维人员之间的隔墙拆除，强调两者之间的沟通与协作。DevOps 十几年前就提出来了，但直到近些年才开始受到越来越多企业的重视，主要原因还是应为配套技术（enabling technology）的逐步成熟，例如云计算、容器技术、自动化运维工具、微服务架构等。  </p>
<p>综上，Capital One 的战略始终是信息技术在驱动，通过“边测试边学习”策略来高频测试和开发最适合客户需求的金融产品，并在数据分析和科学实验的基础之上进行决策。市场中不少企业也试图复制这一成功模式。但为什么他们没有成功呢？其实看懂人家的战略不难，产品形态也容易模仿，但是 Capital one 数十年以来在信息技术和创新能力方面的积累形成的竞争优势却是难以复制的。  </p>
<p>正如 Capital One 的董事会主席兼 CEO 瑞奇·菲尔班克（Rich Fairbank），在一次投资者会议上指出的那样：我们的思维应该更像那些高科技企业，而不是银行（We need to think more like technology companies and maybe a little less like banks）。  </p>
<h1 id="一切始于“主干”，万变不离其宗"><a href="#一切始于“主干”，万变不离其宗" class="headerlink" title="一切始于“主干”，万变不离其宗"></a>一切始于“主干”，万变不离其宗</h1><p>文章的前三段：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Based on numerous surveys and conversations conducted with experienced clients, analysts, subject matter experts and peers, Aitken identified five leading benefits from adopting company wide open source strategies.</span><br><span class="line">Most companies initiate their open source journey because of the perceived financial benefits, although this is almost never the reason why they keep using and scale open source. The main reason is what Aitken calls secondary innovation: once teams have ingested open source software, they naturally customize it to their needs and organizations by adding new features. These teams’ led customizations contribute to increasing the speed of new ideas and features to market.</span><br><span class="line">The second benefit is teams’ ability to safely experiment and fail fast. When buying proprietary enterprise software, management and teams are pressured to make these products work because of the upfront investment, even if they no longer fit the purpose. With open source, teams feel empowered to download and experiment with various solutions. If they realize that it’s not the right open source for their project, they can experiment with different open source solutions and even consider proprietary software. Open source enables organizations to empower teams and provides teams the ability to fail fast and cheaply.</span><br><span class="line"></span><br><span class="line">与经验丰富的客户、分析师、主题专家和同行进行了大量的调查和对话后，埃特金总结了全公司范围内推行开源策略的五大益处。</span><br><span class="line">大多数公司开始其开源之旅，往往是因为他们感觉可以省钱，但是，他们继续使用并推广开源战略的原因几乎都和财务方面的好处无关。最主要的原因是埃特金所说的二次创新是：一旦团队接受了开源软件，他们自然会定制新的功能，来满足他们和组织的个性化需求。这些由开发团队主导的个性化定制有助于加快新的想法和功能推向市场的速度。</span><br><span class="line">第二个好处是团队能够安全地进行实验并获得“快速失败”的能力。当公司购买企业级专有软件时，管理层和团队会因为前期投资而被迫使用这些产品，哪怕它们不再适合公司的商业目的。而通过开源，团队可以下载和试验各种解决方案。如果团队意识到这个开源软件不适合他们的项目，他们可以尝试不同的开源方案，甚至可以考虑转而购买专有软件。开源战略使组织能够赋能团队，为团队提供低成本快速失败的能力。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="复习句子结构和状语从句"><a href="#复习句子结构和状语从句" class="headerlink" title="复习句子结构和状语从句"></a>复习句子结构和状语从句</h3><blockquote>
<p><strong>Based on numerous surveys and conversations conducted with experienced clients, analysts, subject matter experts and peers,</strong> Aitken identified five leading benefits from adopting company wide open source strategies.  </p>
</blockquote>
<p>这一句话相对比较长，但我们应该很快就能找到主语 Aitken 和谓语动词 identified，后面跟着宾语 five leading benefits，这样整个句子的骨架就很清楚了，那就是“埃特金（即作者）发现了五大好处”。什么带来的好处呢？benefit from 是英语里的固定搭配，是 from 后面的原因带来的好处，即公司推行开源战略带来的好处。  </p>
<p>英语的句子都是一棵棵大树，我们可以先找到主干之后，再去添加枝叶。最常见的枝叶就是状语，用来描绘动作发生的状态，这个状态可以是时间、地点，也可以是目的、条件等。  </p>
<p>这句话里的加黑部分，就是过去分词短语 based on 做状语。那埃特金是怎么发现这些好处的呢？他是根据和一大批人做的调查和访谈得出的结论。  </p>
<h3 id="perceive"><a href="#perceive" class="headerlink" title="perceive"></a>perceive</h3><blockquote>
<p>Most companies initiate their open source journey because of the <strong>perceived</strong> financial benefits, although this is almost never the reason why they keep using and scale open source.</p>
</blockquote>
<p>英文解释，to come to an opinion about something, or have a belief about something，“形成某种意见或认识”，也就是“对某些事物的意识、感觉和认知”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：New technology was perceived to be a threat to employment.</span><br><span class="line">翻译：新技术被认为是对就业的一种威胁。</span><br><span class="line"></span><br><span class="line">例句：Stress is widely perceived as contributing to heart disease.</span><br><span class="line">翻译：压力被广泛认为是导致心脏病的诱因。</span><br></pre></td></tr></table></figure>

<p>从上面的例句中可以看出，perceive 强调的是一种主观的认识，也就是人的一种观点或看法，而不是强调客观事实。例如文章中说的 perceived financial benefits，强调的是大家感觉用开源软件能带来财务上的好处，也就是省钱。至于是不是真的省钱，作者其实没有说。  </p>
<p>在市场营销中有一个概念，叫 perceived value（过去分词做形容词），即“感知价值”，强调的是消费者自己认为的价值，而并非测算产品的成本以及利润得出的客观真实价值，也就说这不是 real value。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The fact that an e-book can’t be sold or given away after it’s read also reduces the perceived value of the product.</span><br><span class="line">翻译：电子书在读完后不能卖掉或送人，降低了这一产品在人们眼中的价值。</span><br></pre></td></tr></table></figure>

<p>教市场营销的老师经常会有两句话挂在嘴边：第一句话是 All values are perceived value（所有的价值其实都是感知价值）；第二句话是 Perception is reality（感知即现实）。这两句话表达的意思差不多，就是要强调在市场中，几乎没有消费者会关心某种产品或服务的真实价值，他们心理上感知到的价值在他们眼中就等同于真实价值，而市场营销的任务，就是去洞察消费者心里那个感知价值，并想办法提高感知价值。  </p>
<h3 id="though-x2F-although-和表示让步的状语从句"><a href="#though-x2F-although-和表示让步的状语从句" class="headerlink" title="though&#x2F;although 和表示让步的状语从句"></a>though&#x2F;although 和表示让步的状语从句</h3><blockquote>
<p>Most companies initiate their open source journey because of the perceived financial benefits, <strong>although this is almost never the reason why they keep using and scale open source.</strong>  </p>
</blockquote>
<p>文中加黑部分是由 although 或 though 引导表示让步的状语从句。所谓“让步”，就是退一步讲，是一种以退为进的说话方式，相当于汉语中的“虽然”“即便”“就算”等词。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Although I don’t like him, I agree he is a good manager.</span><br><span class="line">翻译：虽然我不喜欢他，但我承认他是一个出色的经理人。</span><br></pre></td></tr></table></figure>

<p>同样，文章中这句话在明确讲，大部分公司开始开源的原因主要为了省钱，然后踏上开源之路以后怎么样呢？作者话锋一转，退后一步，强调省钱从来不是公司继续使用开源并且扩大规模的原因，并由此引出采用开源战略给公司带来的比省钱更重要的好处，就是后面提到的二次创新。  </p>
<h4 id="though-和-although-的细微差别"><a href="#though-和-although-的细微差别" class="headerlink" title="though 和 although 的细微差别"></a>though 和 although 的细微差别</h4><p>首先，这两个词都是连词。一般情况下，although 比 though 更为正式。though 更多用于非正式表达。  </p>
<p>其次，大部分情况下，这两个词是可以互换的，但我们之前讲过 as though 的固定搭配，though 不可以替换成 although，不存在 as although 的说法。  </p>
<p>此外，though 可以做副词，但是 although 不行。例如，A 说：“Nice day！（天气不错。）”，然后 B 回应说：“Yes. Bit cold, though. （是不错，就是有点冷。）”此处的 though 用作副词，不能替换成 although。  </p>
<h3 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h3><blockquote>
<p>The main reason is <strong>what Aitken calls secondary innovation.</strong>  </p>
</blockquote>
<p>谓语动词如果是及物动词，之后跟着的结构就是宾语，表示动作的对象。例如，过海关的时候，工作人员让你出示护照，他会说“Show me your passport.”。show 是动词，passport 是直接宾语，出示这个动作的对象是什么呢，当然是护照，所以 me 是间接宾语。  </p>
<p>那什么是表语呢？如果谓语动词是系动词（顾名思义，系动词指联系前后两种句子成分的动词。它的英文可能更加清楚一些，叫 linking verb），系动词前面是主语，后面是表述主语状态或性质的结构就称为表语。  </p>
<p>例如，我们说 The weather is horrible，is 就是系动词，horrible 就是表语。翻译成中文“天气太糟糕了”之后，表语就不存在了，因为汉语里没有表语这个称谓。  </p>
<p>常用的系动词数量不多，我这里总结了几个，主要有：be (is&#x2F;am&#x2F;are)、sound、smell、feel、taste、become、seem、keep、stay 等。  </p>
<p>关于系动词的用法，只要注意我这两点即可：  </p>
<ul>
<li>第一，系动词后面跟形容词，而不是副词。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：Tom spoke intelligently. （副词修饰谓语动词，描述说话的状态，讲得很有智慧）</span><br><span class="line">例句 2：Tom seems intelligent. （形容词修饰主语，表示 Tom 这个人很智慧）</span><br></pre></td></tr></table></figure>

<ul>
<li>第二，将系动词替换成 be 之后，句子的意思一般不会发生改变。<br>如果我们将上面例句 2 的 seems 换成 is，基本意思没有变化。如果我们把上面表语位置上的单词换成句子，就是表语从句。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The question is whether he can pass the exam.</span><br><span class="line">翻译：问题是他能否通过考试。</span><br></pre></td></tr></table></figure>

<h3 id="once-和表示条件的状语从句"><a href="#once-和表示条件的状语从句" class="headerlink" title="once 和表示条件的状语从句"></a>once 和表示条件的状语从句</h3><blockquote>
<p>The main reason is what Aitken calls secondary innovation: <strong>once teams have ingested open source software,</strong> they naturally customize it to their needs and organizations by adding new features.</p>
</blockquote>
<p>once 引导状语从句，既可以表示时间（&#x3D;as soon as），也可以表示条件（&#x3D;if, as long as），两者其实没什么差别，都是“一旦”的意思，一般配合完成时态使用。  </p>
<h3 id="contribute-to-something"><a href="#contribute-to-something" class="headerlink" title="contribute to (something)"></a>contribute to (something)</h3><blockquote>
<p>These teams’ led customizations <strong>contribute to</strong> increasing the speed of new ideas and features to market.  </p>
</blockquote>
<p>这句话的主语是 customizations，之前有一个 led，是过去分词短语做前置定语，表示“由开发团队主导的个性化定制”。  </p>
<p>谓语动词 contribute to 是固定搭配。这里你需要特别注意，to 后面需要接名词或者现在分词。而 contribute to 除了“捐助”“做贡献”的含义外，更多地是表示“促成”“使得”“有助于”等含义。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I think you should keep Eric because he really contributes a lot to our team.</span><br><span class="line">翻译：我认为你应该留下埃里克，因为他对我们的团队贡献很大。</span><br><span class="line"></span><br><span class="line">例句：I’m sorry, I think sleep deprivation contributed to my outburst just then.</span><br><span class="line">翻译：抱歉，睡眠不足让我刚才情绪失控了。</span><br></pre></td></tr></table></figure>

<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail fast"></a>fail fast</h3><blockquote>
<p>The second benefit is teams’ ability to safely experiment and <strong>fail fast.</strong>  </p>
</blockquote>
<p>如果你是 Java 工程师，那你对 fail fast 的功能应该很熟悉。迭代器在集合遍历时发现，元素在不知情的情况下莫名其妙地被修改了，系统就会抛出异常。广义来讲，fail fast 是一种植入系统的保护机制，当有异常发生时就会立刻启动，中断执行。  </p>
<p>创新的过程当然要容许失败，但在整个创新的漏斗中，早失败要比晚失败要好，对于一个项目团队而言，最可怕的事情莫过于项目几乎快要完成的时候，突然发现致命的全局性错误，这会导致大量人、财、物、资源和时间的浪费。所以，“快速失败”要比未来出现不确定风险要好。  </p>
<p>开源战略允许团队进行安全的实验，赢得快速失败、不断低成本试错的能力，的确是最重要的益处之一。  </p>
<h3 id="状语从句和长句"><a href="#状语从句和长句" class="headerlink" title="状语从句和长句"></a>状语从句和长句</h3><blockquote>
<p><strong>When buying proprietary enterprise software</strong>, management and teams are pressured to make these products work because of the upfront investment, <strong>even if they no longer fit the purpose.</strong>  </p>
</blockquote>
<p>主语是 management and teams（管理层领导和开发团队），然后我们找到谓语动词 are pressured（有压力）。有什么压力呢？买了产品要用起来，因为已经花钱了。  </p>
<p>句子的主干有了，我们再看枝叶。  </p>
<p>前面半句是我们熟悉的现在分词短语做时间状语，“当你买了企业级专有软件之后”。后面半句也是状语从句，表示条件，“即使这些软件不合适、没法解决企业问题”。这样枝叶就和主干的意思就串在一起了：花钱买了付费软件，即使发现没啥用，但已经投资了，反正也得用，所以领导和团队都有压力。  </p>
<h3 id="empower"><a href="#empower" class="headerlink" title="empower"></a>empower</h3><blockquote>
<p><strong>With open source,</strong> teams feel <strong>empowered</strong> to download and experiment with various solutions.  </p>
</blockquote>
<p>empower 这个词最基本的意思是“授权”，to give official authority or legal power to。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I empowered my agent to close the deal.</span><br><span class="line">翻译：我授权我的经纪人完成这笔交易。</span><br></pre></td></tr></table></figure>

<p>最近这些年，empower 或 empowerment 一词在一系列思想解放运动和职场管理变革中广泛使用。在这种情况下，它的英文的解释是 to promote the self-actualization，即“推动相关群体的自我实现”。说白了就是让各类弱势群体获得更多的权利，让他们获得独立自主的力量。中文一般翻译成“赋权”。  </p>
<p>很多企业进行员工授权，因为各种考量，更喜欢把 empowerment 翻译成“赋能”，有些玩文字游戏的感觉。如果要说“赋能”，enablement 其实更恰当。无论是“赋权”还是“赋能”，其实都有点翻译腔。  </p>
<p>一个新词的翻译，往往前人想出来一个翻法，即使效果不太理想，用的人多了，也就约定俗成地沿用下来，“区块链”就是一例。区块链的英文是 blockchain，这里面的 block 指的是“数据块”，而不是传统意义上一个四方街区的地理区块，翻译成“数块链”更为准确。但前人已经种好了树，就算有点歪，大家也都看顺眼、用习惯了，也就无需再改。  </p>
<h3 id="状语从句里的宾语从句"><a href="#状语从句里的宾语从句" class="headerlink" title="状语从句里的宾语从句"></a>状语从句里的宾语从句</h3><blockquote>
<p>**If they realize that it’s not the right open source for their project,**they can experiment with different open source solutions and even consider proprietary software. Open source enables organizations to empower teams and provides teams the ability to fail fast and cheaply.  </p>
</blockquote>
<p>这里的加黑部分又是一个状语从句，表示条件，但状语从句里面又套了一个宾语从句 that it’s not the right open source for their project。这整个从句是 realize 的宾语，也就是“意识到”这个动词的对象，即“如果他们意识到这个开源软件不行，可以换其他开源方案或者回去买专有软件”。  </p>
<p>为什么这么灵活呢？最后一句话进行了总结，因为开源战略“赋能”组织，使组织可以“赋权”开发团队，使他们获得快速、低成本试错的能力。  </p>
<h1 id="并列句-x3D-简单句-并列连词-简单句"><a href="#并列句-x3D-简单句-并列连词-简单句" class="headerlink" title="并列句 &#x3D; 简单句 + 并列连词 + 简单句"></a>并列句 &#x3D; 简单句 + 并列连词 + 简单句</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The third benefit open source offers is a better way of building software. As organizations scale their teams and applications, they can create silos between product teams, which in turn can create equally as many development silos. When organizations strategically pair open source with inner-sourcing programs – creating internal networks of shared code, transparency, increased collective code ownership and collaboration – organizations and teams speed knowledge transfer, and produce greater quality code. This in turn leads to more reliable software.</span><br><span class="line">A bank headquartered on the west coast concluded after performing an analysis of their development that only 20 to 25 percent of their code was shared across the organization, and that 50 to 70 percent of their code was redundant, creating duplicate software. They selected six software development teams, created a shared code repository, and developed a process for exposing and sharing those code repositories to different groups within the </span><br><span class="line"></span><br><span class="line">开源的第三个好处是提高软件开发质量。随着一个组织的团队和应用不断拓展，产品团队之间会形成“孤岛”，进而形成同样多的开发孤岛。当组织战略性地将开源与内源项目（内源项目旨在创建一个组织内部网络，来共享代码、提高透明度、增加代码集体所有权和鼓励内部协作）结合起来之后，组织和团队就能加速知识转移，产生更高质量的代码，并最终发布更可靠的软件。</span><br><span class="line">一家总部设在美国西海岸的银行对其软件开发进行分析后得出结论，只有 20% 到 25% 的代码在整个组织内部共享，而 50% 到 70% 的代码是冗余的，结果产生重复的软件。他们选择了六个软件开发团队，创建了一个共享的代码库，并开发了一个将代码库公开分享给组织内不同团队的流程。立竿见影的结果是团队将开发和共享的代码量增加了一倍，直接减少了冗余代码的数量和成本。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="silo"><a href="#silo" class="headerlink" title="silo"></a>silo</h3><blockquote>
<p>As organizations scale their teams and applications, they can create silos between product teams, which in turn can create equally as many development silos.  </p>
</blockquote>
<p>它的原意是“农场里储存粮食或草料的筒仓”，看起来很像一个又一个挨得很近的水桶，但每个都高耸、密闭，各自独立，互不相连。后来，商业管理领域的学者就利用 silo 的这个形象，引申出新的一层意思，中文翻译叫“谷仓现象”，用来比喻企业内不同部门各自为政、不愿分享信息和资源的现象。有的翻译怕中国读者不了解谷仓的比喻含义，也会翻译成“孤岛现象”。  </p>
<h3 id="复习定语从句（包括非限定性定语从句）"><a href="#复习定语从句（包括非限定性定语从句）" class="headerlink" title="复习定语从句（包括非限定性定语从句）"></a>复习定语从句（包括非限定性定语从句）</h3><p>我们从第一句话开始看，首先来找主语和谓语动词。  </p>
<p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/dingcong.jpg">  </p>
<p>第一句话的主语里面藏了一个定语从句，而且省略了引导词 that 或者 which，写完整的话应该是 benefit that&#x2F;which open source offers，开源带来的好处，动词是 is，我们上次讲过 be 是系动词，不是实义动词，所以后面跟着的结构是表语，核心词是 way，所以是一个名词短语做表语，一种更好的编程方式。  </p>
<p>第二句话，我们同样先找主语和谓语动词。  </p>
<p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/dingcong2.jpg">  </p>
<p>一看到第一个词 As 开头，又是我们熟悉的时间状语从句，先放在一边。往下看到主语 they，他们是谁，一会儿回到从句里面去找；接下来我们看到情态动词 can，情态动词表示说话人的语气，这里的 can 表示一般的可能性，但情态动词不能单独做谓语，必须要和实义动词或者系动词连用构成谓语，所以这句话的谓语是 can create，表示非常有可能造成产品团队间的孤岛。  </p>
<p>句子的主干找到之后，我们再回过头去看一下前面的状语从句，看看主语 they 指的是什么。从句里面的主语是 organizations，指各类组织（这样说比较全面，企业也是某一种组织），后面的 they 应该也是指的各类组织；谓语动词是 scale，意思是“扩大、拓展”。我们把状语从句的意思和主干连在一起，就很清楚了：随着一个组织的团队和应用不断拓展，组织内的产品团队之间就很有可能会形成“孤岛”（或者“谷仓”）。  </p>
<p>从逗号和 which 我们可以判断出来，后面还跟着一个非限定性定语从句，。我们在前面讲座中说过，非限定性定语从句起到补充说明、增加信息的作用，从句既可以修饰先行词，也可以修饰整个事情。这里的从句就是修饰前面讲的“在组织内的产品团队之间就形成孤岛”整个事情，进而补充说明这个事情还能再进一步，在开发团队之间也形成同样多的孤岛。  </p>
<h3 id="inner-source-program"><a href="#inner-source-program" class="headerlink" title="inner source program"></a>inner source program</h3><blockquote>
<p>When organizations strategically pair open source with inner-sourcing programs – creating internal networks of shared code, transparency, increased collective code ownership and collaboration – organizations and teams speed knowledge transfer, and produce greater quality code.  </p>
</blockquote>
<p>inner source 的概念这几年提得越来越多，我们先来看一下维基百科的定义，了解下它的含义。除此之外呢，因为它是本世纪产生的新词，也有写成 innersource、InnerSource、inner-source 的，这几种写法都是可以的。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnerSource is the use of open source software development best practices and the establishment of an open source-like culture within organizations. The organization may still develop proprietary software, but internally opens up its development. The term was coined by Tim O’Reilly in 2000.</span><br></pre></td></tr></table></figure>

<p>简而言之，inner source 是用开源的开发方式来做一个组织内部的开发平台。说得更加直白一点，就是闭源代码平台在公司内部对内的“开源”。  </p>
<p>所以，inner source 翻译成“内部开源”平台应该是准确的。  </p>
<p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi1.jpg">  </p>
<p>第一个词就是 When，出现它一般就是时间状语从句，我们先放一边。然后是前后两个破折号（和两个逗号是一样的作用），一看就是插入语，也先放一边。我们先找到主语 organizations and teams，然后找谓语动词，speed 和 produce，这是两个并列动作。主干的意思非常清楚，组织和各团队加快了知识转移和改善了代码质量。  </p>
<p>又快又好的编程是怎么实现的呢？我们回去看状语从句，里面的谓语动词是 pair，把两样东西配一起，也就是开源结合内源平台，而破折号里面的插入语对内源平台的概念做了补充说明。这样把前后意思一串，就非常清楚了：开源加内源，编程的活干得又快又好。  </p>
<p>最后一个小短句就是结论，主语 this 指代前面一大堆，谓语动词 leads to，表示最后的成果，几乎是更为可靠的软件。  </p>
<h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/bingcong1.jpg">  </p>
<p>这句话的主语和谓语动词都非常明显，主语就是 bank，带一个后置定语，一家总部在美国西海岸的银行；谓语动词是 concluded，得出结论。根据什么得出结论呢？谓语动词后面紧跟了一个分词短语做时间状语，我们知道这家银行就他们的软件开发进行了分析之后，得出了结论。  </p>
<p>那么结论的内容是什么呢？也就是 concluded 的宾语，我们看到了 that 引导的两个并列的宾语从句，分别说明了分析研究的结论。第一个结论是共享代码只占 20% 到 25%，第二个结论是冗余代码高达 50% 到 70%。  </p>
<p>在此基础上，这个句子还没有完，逗号后面还跟了一个分词短语来做结果状语。结果怎么样呢？结果就是重复劳动，产生了重复的软件。  </p>
<h3 id="简单句和并列句"><a href="#简单句和并列句" class="headerlink" title="简单句和并列句"></a>简单句和并列句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi2.jpg">  </p>
<p>所谓简单句，就是只有一个结构的句子，谁（主语）做了什么（谓语）。  </p>
<p>虽然上面这句话看着也比较长，但它的结构其实很简单。主语就是 They，根据前面一句话，我们知道这里的 they，指的是美西那家银行里面的那些人。他们干了什么呢？后面可以找到并列的三个谓语动词，selected、created、developed，也就是美西银行的“他们”连续做了三个动作：选开发团队、建共享代码库、开发内源流程。  </p>
<p>从内容看，这就是一个简单句。但是，按照英语语法里一个简单句只能有一个谓语动词的大原则，虽然是同一个主语，但既然做了三个动作，从形式上讲也可以算并列句。争论这句话究竟是简单句还是并列句没什么意思，你明白背后的道理即可。  </p>
<p><strong>所谓并列句（compound sentence），是两个或多个简单句的并列，各简单句意义同等重要，相互之间是平行并列的关系，而没有从属关系。如果有从属关系，就有主句和从句，变成复杂句（complex sentence）。</strong>  </p>
<p>并列句由并列连词相连，基本结构就是：简单句 + 并列连词 + 简单句。并列连词只有下列七个，取每个并列连词的首字母拼成非常著名的“FANBOYS”。  </p>
<ul>
<li>For - Explains reason or purpose (just like “because”)I go to the park every Sunday, for I long to see his face.  </li>
<li>And - Adds one thing to anotherI like to read, and I write faithfully in my journal every night.  </li>
<li>Nor - Used to present an alternative negative idea to an already stated negative ideaI neither love nor hate to watch TV.  </li>
<li>But - Shows contrastTelevision is a wonderful escape, but it interferes with my writing.  </li>
<li>Or - Presents an alternative or a choiceWould you rather read a book or watch a good TV show?  </li>
<li>Yet - Introduces a contrasting idea that follows the preceding idea logically (similar to “but”)I always take a book to the beach, yet I never seem to turn a single page.  </li>
<li>So - Indicates effect, result or consequenceI like to read, so my grammar is always on-point.</li>
</ul>
<h3 id="expose-to-x2F-exposure"><a href="#expose-to-x2F-exposure" class="headerlink" title="expose to&#x2F;exposure"></a>expose to&#x2F;exposure</h3><p>expose to 是固定搭配的动词短语，常用的意思有两个，第一个意思是“透露或揭露原本保密的信息”，英文的解释是 to reveal private information to someone or something。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：She was arrested for exposing state secrets to a foreign agent.</span><br><span class="line">翻译：她因为向外国特工泄露国家机密而被捕。</span><br></pre></td></tr></table></figure>

<p>expose to 的第二层意思是“暴露、接触（而遭受危险或不快）”，例如接触病毒、胶卷曝光等，英文的解释是 to bring someone, something, or oneself into contact with someone or something, often with negative consequences。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Well, my mom is really sick, which means that we might have exposed the kids to the flu virus when we had her watch them last week.</span><br><span class="line">翻译：嗯，我妈妈病得很重，这意味着上周我们让她看孩子的时候，可能已经让他们接触了流感病毒。</span><br></pre></td></tr></table></figure>

<p>expose 的名词形式是 exposure。例如，an actor with much recent exposure in television，最近经常在电视上露面的演员。我们在投资领域经常会看到 risk exposure、FX exposure 等说法，指的是没有对冲保护的投资，因而存在风险，一般翻译成“风险敞口、外汇敞口”。  </p>
<h3 id="as-an-immediate-result"><a href="#as-an-immediate-result" class="headerlink" title="as an immediate result"></a>as an immediate result</h3><blockquote>
<p>As an immediate result, their teams doubled the amount of code that was developed and shared, <strong>which directly reduced the amount and cost of redundant code.</strong>  </p>
</blockquote>
<p>as a result 也是常用的固定搭配，表示结果，中间加上一个 immediate，强调是“立竿见影立刻产生的结果”。  </p>
<p>最后加黑部分又是一个非限定性定语从句，which 指代前面阐述的整件事情，即各团队开发和共享的代码数量翻番。只有非限定性定语从句的 which 才可以指代整个事情，强调正是这件事直接降低了重复代码的数量和成本。  </p>
<h1 id="谓语动词永远是英语句子的核心"><a href="#谓语动词永远是英语句子的核心" class="headerlink" title="谓语动词永远是英语句子的核心"></a>谓语动词永远是英语句子的核心</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">According to Aitken, the quality of the code increased dramatically because it was exposed to everyone inside the organization. This led to software developers taking more care in the software they were writing. Additionally, with new cross-functional teams contributing to the code base, there were some direct benefits from the product innovation perspective: teams developed new functionalities that they haven’t thought about previously.</span><br><span class="line">The next two benefits relate to talent retention and competency development. 80% of the organizations Aitken talked to shared that one of the key reasons why they got into open source is specifically to attract and retain the best software developer talent. Open source is evolving at a rapid pace, and developers learn new open source technologies every few years. In the competition for the best software development talent, companies now must advertise and show candidates that they are open source shops, and that they contribute to and open source their own software. Additionally, several studies showed that, through open source development and collaboration, developers become proficient faster, reducing the number of defects in their code base.</span><br><span class="line"></span><br><span class="line">按照埃特金的说法，由于代码对组织内每一个人开放，代码的质量得以大幅提升。这也使得软件开发人员在编写软件时更加用心。此外，随着新的跨职能团队持续不断丰富代码库，团队开发出了以前从未考虑过的新功能，这也是从产品创新的角度产生的直接成果。</span><br><span class="line">接下来的两个好处是保留人才和发展能力。在埃特金调研过的组织中，有 80% 认为他们采用开源的主要原因之一就是吸引和留住最优秀的软件开发人才。开源软件发展迅猛，开发人员每隔几年就要学习新的开源技术。在抢夺优秀程序员的竞争中，公司现在必须向应聘者宣传并展示自己的开源战略，公司自己开发软件并推广开源。此外，一些研究表明，通过开源发展和协作，开发人员的技能更为娴熟，其代码库中的缺陷数量也大为减少。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-3"><a href="#知识讲解-3" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="简单句、并列句、复合句、复杂句"><a href="#简单句、并列句、复合句、复杂句" class="headerlink" title="简单句、并列句、复合句、复杂句"></a>简单句、并列句、复合句、复杂句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi3.jpg">  </p>
<p>这句话的主语是 quality，谓语动词是 increase，所以句子的主干是 quality increased（质量提升）。然后我们再看一下枝叶，丰富一下主干。按照作者的说法，代码的质量大幅度提升，最后还有一个表示原因的状语从句来解释，为什么代码质量会大幅提升呢？因为代码对内部每一个人开放了。  </p>
<h4 id="英语句式结构的整体框架整体梳理"><a href="#英语句式结构的整体框架整体梳理" class="headerlink" title="英语句式结构的整体框架整体梳理"></a>英语句式结构的整体框架整体梳理</h4><ul>
<li><p>第一，无论句子有多长，主干永远是一个简单句，谓语动词永远是句子的核心。  </p>
</li>
<li><p>第二，大树主干以外都是枝叶，都是从属于主句的“挂件”，这样可以使得英语句子“主从分明”。  </p>
</li>
<li><p>第三，语法概念永远是为理解意思服务的，不要被概念和规则束缚住手脚。</p>
</li>
</ul>
<h3 id="复习独立主格结构"><a href="#复习独立主格结构" class="headerlink" title="复习独立主格结构"></a>复习独立主格结构</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi4.jpg">  </p>
<p>独立主格是一个“格” ，属于短语性质，而不是一个“句子”或“从句”。因为独立主格结构没有真正的主语和谓语动词，它由名词或代词作为逻辑主语，加上分词、形容词、副词、动词不定式或介词短语作为逻辑谓语构成，前后两部分具有逻辑主谓关系。  </p>
<p>从形式上看，独立主格结构与主句没有关系，但功能上相当于一个带有独立逻辑主语的状语从句。这句话里，加黑处就是独立主格结构。  </p>
<p>这是独立主格结构做介词宾语，句子的主语是 this，是指示代词，指代前面提到过的事情（代码质量提高），谓语动词 led to（通向、造成什么结果），结果是什么呢？是后面跟着的独立主格结构，逻辑主语是 software developers，和句子本身的主语没有关系；用现在分词 taking care 作为逻辑谓语，和逻辑主语“软件工程师”形成逻辑主谓关系，“软件工程师对他们写的软解更上心”成为 led to 的宾语。  </p>
<p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi5.jpg">  </p>
<p>这句话的主句是 there be 句型，属于主谓倒装。主语在后面，是 benefits，其实应该是 benefits were there，但已经约定俗成为 there be 的句型，表示有什么。所以主干就是有好处，从产品创新的角度看有好处。前面的独立主格结构用 with 引导（with 也可以省略），做状语，逻辑主语 new cross-functional teams 和逻辑谓语 contributing 构成逻辑主谓关系，“随着新的跨部门团队纷纷给代码库做贡献”作为伴随的状态。具体有什么好处呢，冒号后面进一步解释了：开发出以前想都没有想过的功能。  </p>
<h3 id="从句套从句的复杂句"><a href="#从句套从句的复杂句" class="headerlink" title="从句套从句的复杂句"></a>从句套从句的复杂句</h3><p>最后一段，讲开源的而最后两个好处：留住人才、发展能力。这句话不长，但出现了三个从句。  </p>
<p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi6.jpg">  </p>
<p>第一步还是找主干，主句的主语是 organizations，主语带了一个定语从句，如果加上省略的先行词应该是 organizations which Aitken talked to，即 80% 埃特金访谈过的那些组织；谓语动词是 shared，分享了什么内容呢？后面跟着一个宾语从句，而宾语从句的主语又套了一个定语从句，用表示原因的关系副词 why 引导，修饰从句的主语 key reasons，表示“最初开源的主要原因”；主要原因是什么呢？吸引和留住最优秀的软件开发人才。  </p>
<p>组合：主句是 80% 埃特金访谈过的那些组织（主语）分享认为（谓语动词）他们最初开源的主要原因（宾语从句的主语）是吸引和留住最优秀的软件开发人才（宾语从句）。意思已经很清楚了，还不满意的话可以再改写一下，让它更加符合汉语的习惯。  </p>
<h3 id="两个简单句组成的并列句"><a href="#两个简单句组成的并列句" class="headerlink" title="两个简单句组成的并列句"></a>两个简单句组成的并列句</h3><blockquote>
<p>Open source is evolving at a rapid pace, <strong>and</strong> developers learn new open source technologies every few years.  </p>
</blockquote>
<p>这句话就是我们前面讲的，两个简单句用并列连词 and 连接成并列句（也叫并列复合句）。讲了两件事情，第一件事情是开源软件发展快，第二件事情是开发人员要经常学习开源技术。这两件事情互相之间没有附属关系，A 和 B 地位同等重要，属于并列句。  </p>
<h3 id="两个并列的宾语从句"><a href="#两个并列的宾语从句" class="headerlink" title="两个并列的宾语从句"></a>两个并列的宾语从句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi7.jpg">  </p>
<p>首先我们还是先找句子的主干。一看到 in the competition for，就知道是介词短语做状语，表示“在抢人的时候……”。主语是 companies，公司的复数，表示大部分公司；谓语动词是 must advertise and show，must 是情态动词，是来帮忙的，它自己不能做谓语动词，必须和实义动词 advertise and show 一起成为谓语。谓语动词后面跟了双宾语，紧跟其后的 candidates 是间接宾语，是“广告”和“秀”的对象，直接宾语是“广告”和“秀”的内容，通过两个 that 引导的宾语从句来体现：第一个“广告”要讲公司是开源名厂，第二个要“秀”公司自己开源写软件。  </p>
<p>“在各大公司抢人的时候”，“公司都要大力宣传并且秀给应聘者看”，“此地是开源名厂”，而且“自己开源写软件”，潜台词就是，你们来对地方了，到本厂广阔天地、大有可为。  </p>
<blockquote>
<p>Additionally, several studies showed <strong>that, through</strong> open source development and collaboration, developers become proficient faster, <strong>reducing</strong> the number of defects in their code base.  </p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><p>中文的句式结构相对比较松散，多为“意合”。我们经常将其比喻成一列火车或一盘珍珠。说话的人根据自己想要表达的意思，可以连绵不断地说出一连串没有连接成分的句子，犹如一条小溪，潺潺流水向前推进，一波又一波似分似合，彼此相像又各不相同。例如宝玉对黛玉说：“你死了，我做和尚。”  </p>
</li>
<li><p>英文的句式结构则多为“形合”，更为强调外在逻辑，我们经常把英语的句子比喻为一棵大树或者一串葡萄——主干和枝叶（挂果）是非常分明的。我们分析句子时，通常可以先找到主干，再去添枝加叶。主干永远是主谓结构的简单句，找主干就是找到句子的主语（物质）和谓语动词（运动）。最常见的枝叶是我们已经非常熟悉的状语，来描绘动作发生的状态，可以是时间、地点，也可以是目的、条件等。所以，<strong>英语的句子，一切始于主干，万变不离其宗。领会这一点，英语的句法就会了大半。</strong></p>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://www.quickanddirtytips.com/business-career/public-speaking/how-to-be-a-great-guest-speaker">How to Be a Great Guest Speaker</a>  </li>
<li><a href="https://www.forbes.com/sites/peterhigh/2016/12/12/how-capital-one-became-a-leading-digital-bank/#3da32d7815ee">How Capital One Became A Leading Digital Bank</a>  </li>
<li><a href="https://grammar.yourdictionary.com/parts-of-speech/conjunctions/what-is-a-conjunction.html">https://grammar.yourdictionary.com/parts-of-speech/conjunctions/what-is-a-conjunction.html</a>  </li>
<li><a href="https://grammar.yourdictionary.com/parts-of-speech/conjunctions/conjunctions.html">https://grammar.yourdictionary.com/parts-of-speech/conjunctions/conjunctions.html</a>  </li>
<li><a href="https://www.mentalfloss.com/article/49238/7-sentences-sound-crazy-are-still-grammatical">7 Sentences That Sound Crazy But Are Still Grammatical</a>  </li>
<li><a href="https://grammar.yourdictionary.com/sentences/writing-complex-compound-sentences.html">Writing Compound-Complex Sentences</a></li>
</ul>
]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>并列句</tag>
        <tag>定语从句</tag>
        <tag>宾语从句</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找：提升程序的查找效率</title>
    <url>/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设你手上有 n 段长度不等的绳子，你现在想将这些绳子进行裁剪，裁剪出 k 条长度相等的绳子，注意，只能剪断绳子，不能拼接绳子。问题就是，你能得到的这 k 段绳子的最长长度是多长？  </p>
<p><img src="/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/shenzi.jpg">  </p>
<p>如图所示，如果你手中有 3 条绳子，分别是 4 米、6 米 和 5 米，想要切出等长的 4 段，你会发现，每段最长就是 3 米。  </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>采用枚举法，就是先尝试能不能切出至少 4 段的 1 米长绳子，如果可以的话，再去尝试每段长度 2 米是否可行，依次尝试下去，直到尝试不下去为止。最后一次尝试可行的长度，就是每段绳子的最长长度了。（效率太低，放弃。）  </p>
</li>
<li><p>采用二分法。</p>
</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="二分法示例代码"><a href="#二分法示例代码" class="headerlink" title="二分法示例代码"></a>二分法示例代码</h3><p>中心思想：<strong>不管如何调整区间，都要保证待查找数字，总是落在我们的由 L 和 R 标记的查找区间内部。</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">//入参：有序数组 arr，数组长度 n 和待查找数字 x</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;  <span class="comment">//查找区间不为空</span></span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//l 和 r 的值，计算得到一个中间位置的下标 mid 值     </span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;  <span class="comment">//比较 mid 位置的值与 x 的大小关系，从而确定区间调整策略。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; x) r = mid - <span class="number">1</span>;  <span class="comment">//如果 arr[mid] 大于 x，说明 x 值在区间的前半段，那么 mid 及 mid 位置以后的值，就不在下一次查找的范围之内了，我们就把区间的尾部位置 r 向前移动，移动到 mid - 1 位。</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">//arr[mid] 小于 x 时候的调整策略与之类似</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><ul>
<li>将每一段绳子的长度 x，与能切出来的绳子段数之间，看成一个映射关系，用函数 f(x) &#x3D; y 来表示，代表每一段长度为 x 的情况下，最多能切出来 y 段绳子。  </li>
<li>f 函数是一个单调函数，随着每一段长度的增加，能切出来的段数 y 是在减少的，而对于我们来说，就是要确定 y &#x3D; k 时的 x 的最大值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EPS 1e-7  <span class="comment">//EPS 是一个宏，就是我们要控制的精度，一般控制在 10^−7 范围，两个值相差不到 10−7 的时候，我们就认为这两个浮点值相等。</span></span></span><br><span class="line"><span class="type">double</span> l[<span class="number">100</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入每一段的长度 x，返回最多能切多少段</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">//变量 n 记录的是原始绳子的数量，l 数组记录的是每一段原始绳子的长度</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt += (<span class="type">int</span>)<span class="built_in">floor</span>(l[i] / x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">double</span> *l, <span class="type">double</span> *r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= EPS) <span class="keyword">return</span> r;  <span class="comment">//递归程序的边界条件，是当 r - l 小于等于一个极小值的时候，就终止递归</span></span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(mid) &lt; k) <span class="keyword">return</span> bs(l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> bs(mid, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>二分算法框架，是求解具有单调性问题的利器。  </li>
<li>二分算法，通常用来求解那些 f(x) &#x3D; y 问题中，给定 y，求解 x 的问题。  </li>
<li>数组和函数在思维层面，没有什么本质差别。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：大整数实战，提升 Shift-And 算法能力</title>
    <url>/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果给你一个文本串和模式串，让你查找文本串中是否包含模式串，你用程序怎么完成？  </p>
<h3 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h3><p>在一个大的字符串里面，查找是否包含另外一个较小的字符串。  </p>
<p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/stringpipei.jpg">  </p>
<h3 id="暴力法解决"><a href="#暴力法解决" class="headerlink" title="暴力法解决"></a>暴力法解决</h3><p>用模式串的首字母依次和文本串中的每一位对齐，每次对齐以后，看看所对应区域是否匹配，如果匹配就说明文本串包含模式串。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力匹配算法程序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bruce_force</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">const</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历文本串每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从文本串的第 i 位开始与模式串进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; p[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i + j] == p[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当代码到了这里，说明某一位不匹配</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(nm)，其中，n 是文本串的长度，m 是模式串的长度。<br>如果文本串长度是 10，模式串长度是 3，那么这个程序差不多要计算 30 次，外层循环 10 次，内层循环每次循环 3 次。  </p>
<p>效率比较差，放弃。  </p>
<h2 id="Shift-And-算法"><a href="#Shift-And-算法" class="headerlink" title="Shift-And 算法"></a>Shift-And 算法</h2><p>基本流程：首先做信息的转换，然后利用位运算，完成单模匹配问题。  </p>
<h3 id="Shift-And-中的信息转换"><a href="#Shift-And-中的信息转换" class="headerlink" title="Shift-And 中的信息转换"></a>Shift-And 中的信息转换</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/bianma.jpg">  </p>
<h3 id="利用位运算做匹配"><a href="#利用位运算做匹配" class="headerlink" title="利用位运算做匹配"></a>利用位运算做匹配</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/pipei.jpg">  </p>
<p>我们假设模式串的长度是 m ，code(str[i]) 代表了文本串第 i 位字符的编码，整个匹配过程，从前往后，依次处理文本串的每一位，处理到第 i 位的时候，就是用第 i 位字符的编码（code（str[i])），与 p 左移 1 位并或上 1 以后的值（p&lt;&lt; 1 | 1），做“按位与”运算，把得到的值赋给 p 变量。最终，当 p 的二进制表示的第 m 位为 1 时，说明匹配成功了。  </p>
<p>示例，当模式串为 cdd，文本串为 acdd 时候的匹配流程：  </p>
<p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/shili.jpg">  </p>
<h3 id="p-公式的理解与推导"><a href="#p-公式的理解与推导" class="headerlink" title="p 公式的理解与推导"></a>p 公式的理解与推导</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/p.jpg">  </p>
<p>其中 pm​ 代表  p 的二进制表示的第 m 位为 1，pm−1​ 表示  p 的二进制表示的第 m-1 位为 1。因为只有第 m-1 位为 1，才可能左移 1 位以后的结果第 m 位为 1。  </p>
<h3 id="实现Shift-And-算法"><a href="#实现Shift-And-算法" class="headerlink" title="实现Shift-And 算法"></a>实现Shift-And 算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shift_and</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *p_str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> code[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化每一个字符的编码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; p_str[i]; i++, m++) &#123;</span><br><span class="line">        code[p_str[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; code[str[i]];</span><br><span class="line">        <span class="comment">// 如果 p 所对应的模式串最高位为1，代表匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该算法只用了两次循环，一次循环是遍历模式串，生成编码 code 信息，第二次循环是遍历文本串 str，循环迭代得到 p 变量的值，直到 p 变量的第 m 位为 1 时，就代表匹配成功。  </li>
<li>时间复杂度就是 O(n + m) 。意味着，同样是文本串 10000 的长度，模式串 1000 长度，Shift-And 算法，是暴力匹配算法效率的 1000 倍！</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>等价信息表示对于解决问题很重要。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：突破基本类型的限制，存储更大的整数</title>
    <url>/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个程序，输出 2 的 1000 次方的结果是多少。  </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>C 语言中给我们提供的 int 类型，肯定是无法完成这个任务的，因为它表示不了这么大的数字。  </li>
<li>用 long long 类型来进行解决，但long long 是 64 位整型，也就是占 64 个 2 进制位，它顶多能表示 2 的 64 次方减 1 的结果，相对于 2 的 1000 次方来说，小太多了。  </li>
<li>用double类型进行解决，但存在一个严重的问题，就是 double 是有精度损失的。<br>（double 的表示精度，一般来说是有效数字 15 位，就是一个数字，由左向右，从第一个不为零的数字起，向后 15 位都是准确的。因此 double 类型实际上也没有办法，准确表示 2 的 1000 次方的计算结果。）</li>
</ul>
<p>那该怎么办呢？  </p>
<h2 id="编码解决"><a href="#编码解决" class="headerlink" title="编码解决"></a>编码解决</h2><h3 id="大整数表示法"><a href="#大整数表示法" class="headerlink" title="大整数表示法"></a>大整数表示法</h3><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshu.jpg">  </p>
<p>这种表示法中，使用数组的第 0 位存储数字的位数，因为 3526 有 4 位，所以数组的第 0 位就设置成了 4 这个值。接下来，数组从第 1 位到第 4 位记录的就是原数字 3526。  </p>
<p>注意：这个数字是好像是倒着放置的，数字的最高位，也放在数组的最高位中。  </p>
<h3 id="如何计算大整数加法"><a href="#如何计算大整数加法" class="headerlink" title="如何计算大整数加法"></a>如何计算大整数加法</h3><p>计算 445 + 9667：  </p>
<p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshujiafa.jpg">  </p>
<p>首先我们用大整数表示法，分别表示 445 和 9667 这两个数字；然后以位数最长的那个大整数，作为计算结果大整数的基础位数，445 和 9667 按位相加，得到一个 4 位的结果大整数，4 位分别是，9、10、10、12；最后我们再依次处理进位，就得到了底下那一行的结果：10112。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个交换两个变量值的宏 swap</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line"><span class="meta">    __typeof(a) _t = a; \</span></span><br><span class="line"><span class="meta">    a = b, b = _t; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 实现大整数加法 a + b 的结果，存放在 c 中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">plus_big_integer</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 让 a 指向位数较长的那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) swap(a, b);</span><br><span class="line">    <span class="comment">// 大整数 c 的位数以 a 的位数为基准</span></span><br><span class="line">    c[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 循环模拟按位做加法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= b[<span class="number">0</span>]) c[i] = a[i] + b[i];      </span><br><span class="line">        <span class="keyword">else</span> c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理每一位的进位过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断是不是最高位产生了进位</span></span><br><span class="line">        <span class="comment">// 如果是最高位产生进位，就进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (i == c[<span class="number">0</span>]) c[++c[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>要计算 2 的 1000 次方的结果，就是要计算 1000 次乘法，最终的结果由于数值太大，我们肯定要使用大整数表示法了，所以要想理解这个计算过程，我们还是得回到大整数表示法本身，所对应的数学模型理解上。  </p>
<p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi.jpg">  </p>
<p>如上图所示，我们把大整数表示法中，每一个数字所对应的位权写出来，那么数组中所存储 3、5、2、6 的大整数信息，其实等价于下面的那一行数学公式，即 3∗10^3+5∗10^2+2∗10^1+6∗10^0。  </p>
<p>我们对 3526 这个大整数乘以 2，其实等价于对下面那个数学式子乘以 2，就可以得到如下结果：  </p>
<p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi2.jpg">  </p>
<p>对某个大整数乘 2 的操作，其实，可以看成是对这个大整数的每一位分别乘以 2 的操作，然后再仿照大整数加法的过程，依次处理进位即可。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 num 数组初始化成大整数表示的 1</span></span><br><span class="line"><span class="comment">// 作用就是做累乘变量</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">400</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 100 次 2 的 10 次方相乘的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 对大整数的每一位乘以 2 的 10 次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) num[j] *= <span class="number">1024</span>;      </span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;          </span><br><span class="line">            <span class="keyword">if</span> (j == num[<span class="number">0</span>]) num[++num[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            num[j + <span class="number">1</span>] += num[j] / <span class="number">10</span>;</span><br><span class="line">            num[j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出大整数</span></span><br><span class="line">    <span class="comment">// 由于大整数是倒着存的，所以输出的时候倒着遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = num[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376/</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在大整数的表示法中，数字是从右到左，倒着存放在数组中的。  </li>
<li>大整数的表示法，体现的是数据结构对于程序设计的作用。  </li>
<li>大整数的加法和乘法过程，体现的则是算法对于程序设计的作用。  </li>
<li><strong>算法的底层是数学。</strong>  </li>
<li>如果是计算流程不合理，我们需要改进算法；如果是数据表示受限，我们需要求助于数据结构。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大整数表示法</tag>
        <tag>高精度表示法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：背包问题与动态规划算法优化</title>
    <url>/2020/06/13/geekbang-column-dp-backpack-problem-and-dp-algorithm-optimization/</url>
    <content><![CDATA[<h2 id="初识：0-x2F-1-背包问题"><a href="#初识：0-x2F-1-背包问题" class="headerlink" title="初识：0&#x2F;1 背包问题"></a>初识：0&#x2F;1 背包问题</h2><p>0&#x2F;1 背包问题可以说是所有背包问题的基础，它描述的场景是这样的：假设你有一个背包，载重上限是 W，你面前有 n 个物品，第 i 个物品的重量是 wi，价值是 vi，那么，在不超过背包重量上限的前提下，你能获得的最大物品价值总和是多少？  </p>
<p>按照动态规划问题的四步走，咱们来分析一下这个问题。  </p>
<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>关于状态定义，我们首先来分析 0&#x2F;1 背包问题中的自变量和因变量。  </p>
<p>因变量比较好确定，就是问题中所求的最大价值总和。自变量呢？经过分析你会发现，物品种类和背包承重上限就是自变量，因为它们都能够影响价值总和的最大值。这样我们就可以设置一个二维的状态，状态定义如下：  </p>
<p>0&#x2F;1 背包状态定义：dp[i][j] 代表使用前 i 个物品，背包最大载重为 j 的情况下的最大价值总和。  </p>
<h3 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h3><p>推导状态转移方程，也就是推导 dp[i][j] 的表达式。根据 dp[i][j] 的含义，我们可以将 dp[i][j] 可能达到最大值时的方案分成两类：一类是方案中不选择第 i 个物品的最大价值和，另一类是方案中选择了第 i 个物品的最大价值和。只需要在这两类方案的最大值中，选择一个价值和较大的方案，转移到 dp[i][j] 即可。下面，我们就分别表示一下这两种方案的公式。  </p>
<p>不选择第 i 个物品的最大价值和，就是 dp[i - 1][j]。也就是说，在背包最大载重为 j 的情况下，前 i 个物品中，不选择第 i 个物品的最大价值和，就等于在前 i - 1 个物品中选择的最大价值和。  </p>
<p>选择第 i 个物品的最大价值和就是 dp[i - 1][j - wi] + vi。关于这个公式的理解，可以参考我们前面讲的凑钱币问题，既然要求一定选择了第 i 个物品，那我们就可以先给第 i 个物品预留出来一个位置，然后给剩余的 i - 1 个物品留的载重空间就只剩下 j - wi 了，那么 i - 1 个物品选择的最大价值和是 dp[i - 1][j - wi]，再加上 vi 就是选择第 i 个物品时，我们能够获得最大价值和。  </p>
<p>最终，我们得到 dp[i][j] 的状态转移方程，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i])</span><br></pre></td></tr></table></figure>

<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>动规算法的正确性证明，还是需要依赖于数学归纳法，下面我们开始数学归纳法的三步走。  </p>
<p>首先，dp[0][j] &#x3D; 0，就是当没有物品的时候，无论背包限重是多少，能得到的最大价值和都是 0，这也就是已知 k0 正确。  </p>
<p>其次，假设我们已经正确计算得到了，在 i - 1 个物品的任意一种背包容量下的价值最大和值，也就是所有 dp[i - 1] 中的值。那么根据状态转移方程，我们也肯定可以正确的得到所有 dp[i] 中的值。  </p>
<p>最后两步联立，整个求解过程对于任意 dp[i][j]，均正确。  </p>
<p>(认真理解这个证明过程，因为接下来的程序处理过程，其实和这个证明过程是一致的。)  </p>
<h3 id="程序设计与实现"><a href="#程序设计与实现" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_V 10000</span></span><br><span class="line"><span class="type">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dp[MAX_N + <span class="number">5</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_dp</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> W)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 dp[0] 阶段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= W; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 假设 dp[i - 1] 成立，计算得到 dp[i]</span></span><br><span class="line">    <span class="comment">// 状态转移过程，i 代表物品，j 代表背包限重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="comment">// 不选择第 i 种物品时的最大值</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 与选择第 i 种物品的最大值作比较，并更新</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][j - w[i]] + v[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - w[i]] + v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get_dp 函数就是求解 0&#x2F;1 背包问题的过程，函数传入两个整形参数 n 和 W，分别代表了物品数量与背包最大限重。程序中有三个数组：v、w 与 dp，v[i] 代表第 i 个物品的价值，w[i]代表第 i 个物品的重量，dp[i][j] 代表背包问题相关的状态。  </p>
<p>这一段代码，采用了正向递推的程序实现。而且，如果你注意观察 get_dp 函数的实现过程，你会惊奇地发现，这就是数学归纳法的证明过程。  </p>
<p>首先，初始化 dp[0] 阶段的所有值，也就是保证了 k0 成立；然后从 dp[1] 开始迭代计算到 dp[n] 中所有值，每一次 dp[i]依赖的就是 dp[i - 1] 中的值，只有 dp[i - 1] 中所有值是正确的，才能保证 dp[i]中所有值是正确的，这就是数学归纳法的第二步。最后，两步联立，就证明了以 dp 数组的第一维作为阶段，进行状态转移，计算得到的所有 dp 值均是正确的。  </p>
<h2 id="进阶：多重背包问题"><a href="#进阶：多重背包问题" class="headerlink" title="进阶：多重背包问题"></a>进阶：多重背包问题</h2><p>其实这个问题，整体和 0&#x2F;1 背包问题类似，只不过从 n 个物品变成了 n 种物品，且每种物品都有不同的数量，我们可以设定第 i 种物品的数量是 ci。  </p>
<p>现在你有一个载重上限为 15kg 的背包，有如下 4 件物品：  </p>
<ul>
<li>镀金极客币，每个 4kg，每个价值 10 块钱，一共有 5 个；  </li>
<li>胡船长手办，每个 3kg ，每个价值 7 块钱，一共有 4 个；  </li>
<li>西瓜，每个 12kg ，每个价值 12 块钱，一共有 2 个；  </li>
<li>哈密瓜，每个 9kg ，每个价值 8 块钱，一共有 7 个。</li>
</ul>
<p>经过分析，在不超过背包载重上限的情况下，你可以选择 3 个镀金极客币和 1 个胡船长手办装到背包里面，这种选择方案能获得最大价值为：37 块钱。  </p>
<p>回到我们说的这个多重背包问题，你想如何求解呢？  </p>
<p>其实最简单的解决办法，就是把 n 种物品中的每一个，都看成是 0&#x2F;1 背包中的一个物品，然后按照 0&#x2F;1 背包问题的求解过程来做即可。这也就是说，如果一种物品有 12 件，就相当于 0&#x2F;1 背包中多了 12 件物品，我们就多做 12 轮运算，要是有 120 件呢，那就是多做 120 轮运算。  </p>
<p>这种做法虽然可行，可显然太浪费我们计算机的计算资源了。下面就让我们看看怎么做，才能更优化。  </p>
<h3 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a>二进制拆分法</h3><p>想象一个场景，假设你是一个卖白菜的老农，手上有 23 斤白菜和若干个筐，出于某种不知名的原因，你今天不能把称重器带到菜市场，只能提前把白菜称好装入不同的筐里贩卖给顾客。问题来了，白菜要如何分到这些筐里面，才能使得第一个顾客无论要多少斤白菜，你都能通过挑选其中的几筐白菜，从而满足顾客的需求呢？  </p>
<ul>
<li><p>一种最直接的装筐方法，就是每个筐里面装 1 斤白菜，共需要 23 个筐。这样，第一个顾客要多少斤白菜，你就给他多少筐就行。这种方法简单粗暴，可是用的筐太多了。  </p>
</li>
<li><p>转换一个思路去想这件事：当你准备挑几个筐满足第一个顾客需求的时候，对于每个筐来说，都有两种状态，选或者不选，这不就是二进制每位上的数字么？我们就可以把每个筐，看成是二进制相应的位权。</p>
</li>
</ul>
<p><img src="/2020/06/13/geekbang-column-dp-backpack-problem-and-dp-algorithm-optimization/erjinzhi.jpg">  </p>
<p>可以看到，从第一个筐开始，我们依次装上 1 斤、2 斤、4 斤、8 斤，第五个筐应该装 16 斤的，可剩下的白菜不够 16 斤，所以就一起放到最后一个筐里面。这样，我们只需要 5 个筐，就装了 23 斤白菜，并且可以保证无论第一个客人要几斤白菜，都能满足他的需求。  </p>
<h3 id="多重背包的拆分优化"><a href="#多重背包的拆分优化" class="headerlink" title="多重背包的拆分优化"></a>多重背包的拆分优化</h3><p>假设多重背包中，某一种物品有 23 件，转换到 0&#x2F;1 背包问题中，就是 23 个物品，就跟前面一斤白菜装一筐的做法是一样的。我们虽然不知道，在 0&#x2F;1 背包问题的最优方案中，这种物品被具体选择了多少件，可是只要我们通过一种合理的拆分方法，使得无论最优方案中选择了多少件这种商品，我们都可以组合出来。  </p>
<p>简单粗暴地拆分成 23 份，是一种拆分方法，而二进制拆分法也是一种拆分方法，并且二进制拆分法只需要拆成 5 份物品，作为 0&#x2F;1 背包问题中的 5 个单独的物品即可，这么做可以达到和拆分成 23 件物品等价的效果，并且节省了大量的计算资源。  </p>
<p>例如，前面多重背包问题的那个例子中，按照原本简单粗暴的方式，我们是把 5 个镀金极客币、4 个胡船长手办、2 个西瓜、7 个哈密瓜，当作 18 个物品的 0&#x2F;1 背包问题来求解的。但如果采用二进制拆分法，我们就会得到如下拆分方案：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1个镀金极客币，4kg每个，价值 10 块钱</span><br><span class="line">2个镀金极客币，8kg每个，价值 20 块钱</span><br><span class="line">2个镀金极客币，8kg每个，价值 20 块钱</span><br><span class="line"></span><br><span class="line">1个胡船长手办，3kg每个，价值 7 块钱</span><br><span class="line">2个胡船长手办，6kg每个，价值 14 块钱</span><br><span class="line">1个胡船长手办，3kg每个，价值 7 块钱</span><br><span class="line"></span><br><span class="line">1个西瓜，12kg每个，价值 12 块钱</span><br><span class="line">1个西瓜，12kg每个，价值 12 块钱</span><br><span class="line"></span><br><span class="line">1个哈密瓜，9kg每个，价值 8 块钱</span><br><span class="line">2个哈密瓜，18kg每个，价值 16 块钱</span><br><span class="line">4个哈密瓜，36kg每个，价值 32 </span><br></pre></td></tr></table></figure>

<p>这种拆分方案等价于求解 11 个物品的 0&#x2F;1 背包问题，比之前求解的 18 个物品的 0&#x2F;1 背包问题显然要优秀。  </p>
<p><strong>实际上，随着某个物品数量的增加，二进制拆分法的优势会愈加地明显。</strong>  </p>
<p>(想一想 32 个二进制位能表示的数字大小)  </p>
<h3 id="程序设计与实现-1"><a href="#程序设计与实现-1" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><p>待更新…  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>0&#x2F;1 背包问题中的自变量是物品的种类和背包限重，所以我们把这两维设计到了状态定义中。  </li>
<li>多重背包问题可以转换成 0&#x2F;1 背包进行求解，转换过程不同，效率也就不同。  </li>
<li>二进制拆分法，本质思想就是二进制的数字表示法，0&#x2F;1 表示两种状态，表示选或不选。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>背包</tag>
        <tag>动态规划</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>English_Article 3：Successful Remote Working</title>
    <url>/2020/06/14/geekbang-column-article-3-successful-remote-working/</url>
    <content><![CDATA[<p><a href="https://www.infoq.com/news/2020/03/successful-remote-working/">Successful Remote Working</a><br>这篇文章主要探讨如何成功地进行远程工作。</p>
<h1 id="导读：如何逐渐培养阅读习惯，快速抓住文章大意？"><a href="#导读：如何逐渐培养阅读习惯，快速抓住文章大意？" class="headerlink" title="导读：如何逐渐培养阅读习惯，快速抓住文章大意？"></a>导读：如何逐渐培养阅读习惯，快速抓住文章大意？</h1><h2 id="文章背景"><a href="#文章背景" class="headerlink" title="文章背景"></a>文章背景</h2><p>远程工作这个话题最近比较火。新冠肺炎的疫情爆发之后，为保持社交距离（social distancing），压制病毒传播，很多企业都会要求员工在家办公（work from home）。但是，远程办公其实并不是一个新话题。出于各种目的，例如政府为缓解城市交通压力，企业为减少员工通勤成本（交通费用在其次，更宝贵的是时间）、个人为躲避雾霾等严重污染的环境，远程办公被越来越多的企业所接受。  </p>
<p>在开始讲解这篇文章之前，我们来比较一下 work from home 和 work at home 这两个短语的区别。从某种意义上讲，这两个短语的区别其实就是远程工作和自由职业（self-employed）之间的区别。  </p>
<p>work from home 给人的感觉是，工作的中心仍然还是公司，但出于各种原因我在家完成工作，但最后还是汇聚到公司这个中心去的。而 work at home 表示，我平时常态的工作地点就是家里，我的家就是我工作的中心。大部分没有固定工作的自由职业者基本就是这种状态，比如，自媒体作家、网红主播、翻译等等。  </p>
<p>当然，work at home 也可以指，我有私人的一些事情，要在家干一些活。例如我打电话给朋友说：“Sorry dude, I cannot accompany you. I have work at home.”，指的就是“我没法陪你了，我在家有活要干”。这一语境下一般指临时性的一些 work，例如修水管、打扫卫生之类的。  </p>
<h2 id="全篇通读"><a href="#全篇通读" class="headerlink" title="全篇通读"></a>全篇通读</h2><p><strong>首先，我们可以借鉴检索阅读（inspectionalreading）中的略读法（pre-reading or skim，也可以叫粗读法），来了解这篇文章的梗概。</strong>  </p>
<blockquote>
<p>For both <strong>employees and employers</strong>, remote work requires <strong>intentional design</strong> and implementation to be effective. People find remote work challenging because the <strong>established mindset</strong> says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the <strong>advantages</strong> to employees and employer are sufficient to make it worthwhile.<br>无论对于<strong>雇员</strong>还是<strong>雇主</strong>，要想使远程工作有效，需要双方<strong>有心的设计</strong>和实施。人们感觉远程工作很有挑战性，是因为<strong>固有的思维模式</strong>都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的<strong>心理健康</strong>。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的<strong>好处</strong>都足以使其值得一试。  </p>
</blockquote>
<p>第一段往往是文章的总起段落，通常会概述整篇文章的核心思想。我理解的关键思想包括下面 5 点：  </p>
<ul>
<li>远程工作是老板和员工两方面的事情；  </li>
<li>需要专门的设计；  </li>
<li>要打破固有思维模式；  </li>
<li>要关注心理健康问题；  </li>
<li>利大于弊。</li>
</ul>
<p>接着来看下一段。  </p>
<blockquote>
<p>These were some of the key takeaways expressed by Charles Humble during his presentation at QCon London 2020, titled “Remote Working Approaches That Worked (and Some That Didn’t).” Humble’s opinions are based on his experience working at C4 Media, a remote-only company, and the parent organization of InfoQ and QCon.  </p>
</blockquote>
<p>看完这段我们可以知道，这篇文章是一个叫 Charles Humble 的人，在今年伦敦 QCon 软件开发大会上的一篇演讲，题目叫《远程工作好方法（和坏方法）》。接着，这段话还专门介绍了演讲者依据的是他在 C4 Media（InfoQ 和 QCon 的母公司）的工作经验提出的观点，而 C4 Media 又是一家全员远程工作的组织。  </p>
<p>继续看下一段。这段讲了现在疫情要保持社交距离，使得更多人在家工作。  </p>
<blockquote>
<p>Because many additional people are working from home due to social distancing, QCon has made the video recording of the presentation immediately available on InfoQ.  </p>
</blockquote>
<p>我们可以看到，以上两段都是实用信息，不是文章的观点和内容。  </p>
<blockquote>
<p><strong>The first starting point for remote employees is to have clear separation between home and work.</strong> This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.<br><strong>员工在家工作，第一要务就是把家和工作分开。</strong>  </p>
</blockquote>
<p>联系第一段里讲远程工作的挑战来自传统观念，即家不是工作的地方，所以远程工作者需要想办法把日常家庭生活和工作分开。后面的内容应该是这一问题的展开。  </p>
<blockquote>
<p><strong>Successful remote work is not just up to the employees.</strong> Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”<br><strong>远程工作要想成功，不仅仅靠员工。</strong>  </p>
</blockquote>
<p>不仅靠员工，那就还要靠老板、靠公司。这段应该讨论公司的管理层在这个问题上应该怎么做，要扮演什么角色。  </p>
<blockquote>
<p><strong>Establishing a high level of trust among remote managers and employees starts with having good meeting rituals.</strong> Meetings should be conducted on video if at all possible, and start with a “check in” for each team member. The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity. Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.<br><strong>经理和员工之间的高度信任，始于一套好的会议仪式。</strong>  </p>
</blockquote>
<p>这句话字面意思听着有点翻译腔，你可以猜一下这段的内容：首先要开会，尽管人在家不去公司了，但远程会议还是要开的；第二，开会要有仪式感，不能太随意。大方向应该逃不出这些内容。  </p>
<blockquote>
<p><strong>An established calendar of regular meetings also helps create structure for distributed teams.</strong> A daily huddle takes the place of a “standup.” Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.<br><strong>定期的会议日程安排有助于为分散的团队建立结构。</strong>  </p>
</blockquote>
<p>整个团队都在办公室，每天按部就班比较容易碰头和安排工作，很有组织感，但分散在各处自家办公，队伍容易散漫，日子也容易过糊涂，所以需要通过一些定期的安排来建立这种组织秩序。  </p>
<blockquote>
<p><strong>One-on-one meetings between employee and manager are extremely important, and must be treated as sacrosanct.</strong> These meetings are for the employee, with discussions about their career and other personal concerns. Humble had two absolute rules: The one-on-one is not a status meeting, and managers should never be allowed to cancel the meeting.<br><strong>员工和经理一对一的会议也很重要。</strong></p>
</blockquote>
<p>前面两段讲的开大会，这段应该讲经理和员工一对一开小会。有效沟通是管理的核心，私密的沟通机制当然也是其中的重要一环。  </p>
<blockquote>
<p><strong>Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, which is every four months for C4, and coincides with QCon scheduling.</strong> C4 has an annual “all hands” meeting that lasts for four days, which also involves flying everyone into one location. This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.<br>战略性的讨论很难远程进行，通常需要见面开会。  </p>
</blockquote>
<p>前面几段说的都是日常管理，但特别重大的会议用视频的方式就不够了，需要专门安排正式的会议。这是很自然的，即使是远程工作，也不会一年都不见一次面的。  </p>
<blockquote>
<p><strong>Humble shared a list of tools he and C4 have used.</strong> Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.<br><strong>Humble（演讲人）分享了一堆 C4 用的工具。</strong>  </p>
</blockquote>
<p>自然是远程工作的工具（Zoom 之类的），疫情之后，家喻户晓。据我所知，现在督促孙辈上网课的爷爷奶奶们都是“Zoom 专家”。  </p>
<p>接下来，最后一段通常是总结段，我们全部通读一遍。我也在英文原文和中文翻译中标黑了我认为的关键内容。总结起来讲就是，远程工作有得有失，所以成本不是问题，心理健康才是关键问题。怎么样才能健康呢？要工作团队信任开放，要家庭社交克服孤独，还要有健康的生活方式。  </p>
<blockquote>
<p>While remote work is very appealing to some employees, it does come with some trade-offs. Although the time and costs associated with commuting disappear, new costs may be incurred from premium high-speed internet, a good laptop, a nice desk, and especially a good office chair. A subject not often, or easily, discussed regarding remote work is mental health. Burnout is a real, serious issue, and is endemic in IT. Trust and openness is critically important, and allows team members to recognize when someone is struggling, and help them cope, including seeking professional help. Loneliness can also be a problem, and it takes active effort to make your family and your social life a real priority. Pets, exercise, and getting into nature can also help improve mental well-being.<br>虽然远程工作对某些员工非常有吸引力，但有得必有失。与上下班相关的时间和财务成本消失了，但是会产生新的成本去购置高速上网服务、好的笔记本电脑、漂亮的办公桌、特别是一张舒服的办公椅。远程工作的另一个不经常或不容易讨论的话题是心理健康。职业倦怠是一个现实而严重的问题，并且在 IT 行业普遍存在。信任和坦诚至关重要，只有这样团队成员才能够发现正在挣扎的同事，并及时帮助他们，包括寻求专业的帮助。孤独也是一个问题，让家庭和社交真正成为生活重心是需要你为之付出积极努力的。宠物、锻炼和亲近大自然也可以帮助改善心理健康。  </p>
</blockquote>
<h1 id="为什么介词如此“烦人”？"><a href="#为什么介词如此“烦人”？" class="headerlink" title="为什么介词如此“烦人”？"></a>为什么介词如此“烦人”？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For both employees and employers, remote work requires intentional design and implementation to be effective. People find remote work challenging because the established mindset says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.</span><br><span class="line">无论对于雇员还是雇主，要想使远程工作有效，需要双方有心地设计和实施。人们感觉远程工作很有挑战性，是因为固有的思维模式都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的心理健康。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的好处都足以使其值得一试。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="宾语补足语"><a href="#宾语补足语" class="headerlink" title="宾语补足语"></a>宾语补足语</h3><blockquote>
<p>For both employees and employers, remote work requires intentional design and implementation <strong>to be effective.</strong> People find remote work <strong>challenging because the established mindset says that being in an office is how work gets done.</strong>  </p>
</blockquote>
<p>所谓“宾语补足语”，就是谓语及物动词后面接了宾语，但意思仍然不完整，需要继续加一个补充说明，明确宾语的状态。这个补充说明的句子成分，就是宾语补足语。宾语和后面的补足语组成复合宾语。宾语一般是名词或代词。补足语可以是名词、形容词、副词、介词短语、现在分词、过去分词也可以是动词不定式或从句等。补足语英语叫 complement，to complete the meaning，使意思完整。  </p>
<p>第一句话，主语是本篇的主题词 remote work，谓语动词是 requires，远程工作需要，需要什么呢？后面接了宾语 intentional design and implementation，有意（或有心）的设计和执行，之后还加了一个不定式 to be effective，使其有效。远程工作需要有心的设计和执行才能有效。例句：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Does he understand the need to keep everything secret?</span><br><span class="line">翻译：他知道所有这一切都要保密吗？</span><br></pre></td></tr></table></figure>

<p>第二句话，主语 people，谓语动词 find，宾语 remote work，人们发现远程工作，怎么样呢？需要补充说明，后面跟了一个分词 challenging（词性为形容词，类似于 interesting、exciting 等），很有挑战，意思才完整。我们再来看一个类似的例句，例句中的现在分词更具有动词性：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Shelly spends all her time gardening.</span><br><span class="line">翻译：雪莉把她所有的时间都花在园艺上。</span><br></pre></td></tr></table></figure>

<p>最后我们再来看一下 because 引导的状语从句。  </p>
<p>首先，状语从句的主语是 established mindset，已经建立起来的思维，就是固有的思维或者传统的思维。谓语动词是 says，传统思维说，说什么呢？宾语是一个 that 引导的从句，宾语从句的主语是 being in an office，后面是系动词 is，一看就知道是系表结构。is 后面是最小的套娃，即表语从句，how work gets done，去办公室（去上班）才是工作的正确姿势。  </p>
<p>英文结构分析起来觉得好复杂，但把这整句话翻译成中文之后，我们会发现，其实一点也不复杂，就是“传统思维认为去办公室上班才算工作”。  </p>
<h3 id="介词-by"><a href="#介词-by" class="headerlink" title="介词 by"></a>介词 by</h3><blockquote>
<p>Remote workers also need to prioritize their mental health, by taking breaks, <strong>getting exercise, and having a social life.</strong>  </p>
</blockquote>
<p>这句话本身不复杂，主句的意思也很直白，“在家工作的人要把心理健康放在第一位”。但我们来看一下后面的介词短语by doing something，这里它来做主句的方式状语，这里好似强调实现心理健康的一些方式，例如劳逸结合、多做运动、社交生活等。  </p>
<p>介词，英文叫 preposition。pre- 是表示“在前”的前缀。position 是位置。顾名思义，我们可以把它理解为“前置词”，后面可以跟名词性质的宾语。所谓名词性质，指的是名词、代词或者其他具有名词性质的词类、短语或从句。而介词和介词宾语共同组成介词短语。  </p>
<p>介词非常重要，因为：  </p>
<ul>
<li><p>第一，介词是英语中的高频词，几乎无处不在。  </p>
</li>
<li><p>第二，介词在英语的句子里起到穿针引线的“桥梁”作用。介词的“介”，在汉语中第一个意思就是“在两者之间”，可以组成“媒介”“介绍”等词语，所以介词的本质在于表示对象间的关系。大多数英语介词的本源义都是用来描述空间关系，包括空间位置（例如 on、at、in 等，为静态）和空间运动（如 off、over、down 等，为动态）的关系。在空间关系的基础上，我们可以进一步引申出时间关系、抽象关系等。<br><img src="/2020/06/14/geekbang-column-article-3-successful-remote-working/jieci.png">  </p>
</li>
<li><p>第三，介词使用范围广泛，变化繁多。</p>
</li>
</ul>
<p>介词和名词、动词、形容词等进行的搭配大多是约定俗成的，例如 the reason for、arrive at、angry with 等。  </p>
<p>此外，介词和动词搭配后会产生丰富的含义。比如，out 可以和 600 多个动词搭配产生不同的含义。再比如，get、take、put、make、turn 等本身含义不是很明确的弱势动词，可以和十几个甚至数十个不同的介词搭配产生不同的短语。这些搭配产生的短语含义丰富，但大多数没有办法根据字面猜测其含义，必须理解并记忆整个短语。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I wanted to know if she could put me up for a few days.</span><br><span class="line">翻译：我想知道她能否收留我住几天。（put up 在这里是“提供食宿”的意思，按字面我们很难猜出其含义。）</span><br></pre></td></tr></table></figure>

<p>回头我们来看这句话中 by 这个介词。前面我们说过，大多数英语介词的本源义都是用来描述空间关系，<strong>by 在静态的空间位置上有“在旁边、靠近”的意思，</strong>类似于 next to&#x2F;near&#x2F;beside 等，但意思相近的介词之间也有微妙的差别。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Stanley lives by the sea.</span><br><span class="line">翻译：斯坦利住在海边。（可以看得见海的那种）</span><br><span class="line"></span><br><span class="line">例句：Stanley lives near the sea.</span><br><span class="line">翻译：斯坦利家离海边不远。（差不多住在几公里以外）</span><br></pre></td></tr></table></figure>

<p><strong>by 在动态的空间运动上有“通过、经过（through or through the medium）”的意思。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：They came in by the back door.</span><br><span class="line">翻译：他们是从后门进来的。</span><br></pre></td></tr></table></figure>

<p>然后，我们可以进一步<strong>将 by 引申出时间关系，表示“不晚于某一时间（no later than; at or before）”。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：The application needs to be in by the 31st to be accepted.</span><br><span class="line">翻译：申请必须在 31 日前提交，才能被接受。</span><br></pre></td></tr></table></figure>

<p>进而，我们还可以再引申出一些抽象关系，例如下面这几个含义：  </p>
<ul>
<li>凭借（某种交通工具 by air&#x2F;bus&#x2F;bike&#x2F;boat）  </li>
<li>通过（某种通讯手段 by telephone&#x2F;post&#x2F;email&#x2F;fax、支付手段 by credit card&#x2F;cheque）  </li>
<li>以…的方式（例如本文中 by doing something）”</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：My parents have never travelled by plane before.</span><br><span class="line">翻译：我父母以前从未坐过飞机。</span><br><span class="line"></span><br><span class="line">例句：Can I pay by credit card？ No. You must pay in cash.</span><br><span class="line">翻译：我可以用信用卡付款吗? 不行，你必须付现金。（注意，付现金常用 pay in cash 而不是 by cash。这是固定搭配，也是介词为什么烦人的原因之一。）</span><br><span class="line"></span><br><span class="line">例句：I killed the cockroach by hitting it.</span><br><span class="line">翻译：我拍死了那只蟑螂。（强调的是用什么动作达到了结果）</span><br><span class="line"></span><br><span class="line">例句：I killed the cockroach with my shoe.</span><br><span class="line">翻译：我用鞋拍死了那只蟑螂。（强调的是用什么工具达到了结果）</span><br><span class="line"></span><br><span class="line">例句：I got where I am by hard work. No you didn’t. You got there with your wife’s money.</span><br><span class="line">翻译：我是靠努力工作才有今天的成就的。 才不是，你靠的是你老婆的钱。</span><br></pre></td></tr></table></figure>

<h3 id="介词-despite"><a href="#介词-despite" class="headerlink" title="介词 despite"></a>介词 despite</h3><blockquote>
<p><strong>Despite</strong> the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.  </p>
</blockquote>
<p>介词 despite 是“即使、尽管”的意思，和我们前面讲过的 although、though 类似。但 despite 后面跟名词性的词或者短语，是介词；although 或 though 引导让步状语从句，属连词。  </p>
<p>有一个常用短语 in spite of 和 despite 的意思基本一样，也在句子里发挥介词的作用，例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：We understood him in spite of his accent. (=…although he had a strong accent.)</span><br><span class="line">翻译: 尽管他有口音，我们还是听得懂他的话。</span><br></pre></td></tr></table></figure>

<p>从意思上来看，despite、in spite of 和 because 的意思是相反的。你可以比较下列两句话：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：He passed his exams in spite of his teacher. （尽管他老师很烂，但他还是通过了考试。）</span><br><span class="line">例句 2：He passed his exams because of his teacher. （幸亏有他老师，他才通过了考试。）</span><br></pre></td></tr></table></figure>

<h3 id="介词-to"><a href="#介词-to" class="headerlink" title="介词 to"></a>介词 to</h3><blockquote>
<p>Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient <strong>to</strong> make it worthwhile.</p>
</blockquote>
<p>介词用来将一个名词与其他概念联系在一起，所以介词 to 后面一定是跟名词性的词或短语。而不定式 to do 是一个动词形式的整体， to 和后面紧跟的动词原形这两者是不可分的。例如，I would like to have some tea 这句话，to have 是一个整体，你可以把 to have 整个去掉，变成 I would like some tea. 也可以，但不可以说 I would like to some tea.。  </p>
<p>基于这一区别，我们很容易分辨句子中的 to 到底是介词还是动词不定式，关键其实就是看 to 后面的词性。比如上面这句话里，to 后面跟的是 employees and employer，都是名词，显然 to 在这里是做介词用，整体做 advantages 的后置定语，对谁的好处？to 后面说了，对员工和雇主的好处。  </p>
<p>介词 to 更多地是描述一种从空间某点向 A 点运动的动态空间概念，有明确的方向性或指向性。简单说就是，目的地 A 点就是 to 后面跟的具有名词属性的词组。比方说，我们学英语就是从 I go to school everyday 开始的。  </p>
<p>从空间关系延伸到时间关系，我们会说 ten to ten，九点五十分，回到表盘上其实还是空间的概念，分针向着整点（十点）的方向再走十个刻度。  </p>
<p>时空关系的基础之上，我们就可以引申出更加抽象的含义，但仍然逃不出最本源的空间关系指向性。例如我们经常讲 I look forward to meeting you soon（我期待着和您会面）。这里的 to 后面就是那个“目的地”，我们见面这个事情，具有名词属性，因此必须是 -doing 这样的动名词。我们现在是分离的状态，一段时间之后就可以变成团聚的状态，隔在两者之间的就是时空，就是这个介词 to。或许，连接一切被时空隔断的彼岸，才是中文“介”的本意。  </p>
<h3 id="表语补足语"><a href="#表语补足语" class="headerlink" title="表语补足语"></a>表语补足语</h3><blockquote>
<p>Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient <strong>to make it worthwhile.</strong>  </p>
</blockquote>
<p>这句话的主句是系表结构。主语 advantages 后面是系动词 are，sufficient 是表语。表语的本质其实也是一种补足语，来说明主语的性质、特征和状态等。这句话里 sufficient 说明（远程工作）给员工和雇主带来的好处足够，但意思似乎还不是很完整，所以后面又用不定式 to do 来补充说明，强调“好处足够多，值得一试”，在形式上我们称之为表语补足语。  </p>
<h1 id="同位语的两个重要作用"><a href="#同位语的两个重要作用" class="headerlink" title="同位语的两个重要作用"></a>同位语的两个重要作用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The first starting point for remote employees is to have clear separation between home and work. This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.</span><br><span class="line">员工在家远程工作，首先要把家和工作分开。要实现这一点，可以通过物理隔断，在家专设办公区或者干脆去共享工作空间（例如雷格斯或者 WeWork 等共创空间）。有时也可以人为设定一个取代通勤的转换点，作为从在家状态到工作状态的切换标志。有人发现，带狗出去散步，或者只是从前门出后门回，就足以使他们在心理上实现这种切换，并开始专注工作。</span><br><span class="line"></span><br><span class="line">Successful remote work is not just up to the employees. Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”</span><br><span class="line">远程工作的成功不仅仅取决于员工。公司和管理者们必须做出额外的努力来展示透明度和建立信任，因为不在同一屋檐下共事，就无法享受轻松面谈和肢体语言的便利。远程工作需要心理安全感，这意味着经理们必须做好准备展现自己的脆弱一面。如果管理者乐于分享自己的难处，那么员工也就会乐于敞开心扉。亨堡说：“你必须完全信任他人，因为你看不到他们在做什么，必须由他们告诉你才行。”</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="介词-for、between、through、by、at"><a href="#介词-for、between、through、by、at" class="headerlink" title="介词 for、between、through、by、at"></a>介词 for、between、through、by、at</h3><blockquote>
<p>The first starting point for remote employees is to have clear separation between home and work.  </p>
</blockquote>
<p>第一句是系表结构，不定式 to have 做表语，按字面意思翻译的话，就是“员工远程工作的起点是把家和工作清楚地分开”，但汉语重意合，没有表语，也不用这么别扭地说话，直接说“远程工作首先要分清楚家和工作”就好了。  </p>
<blockquote>
<p>This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork.  </p>
</blockquote>
<p>第二句话的主句就更简单，主语 this，谓语动词 can be done，this 指代上一句话说的“家和工作分离”这件事，主句的意思是说这件事情能成，形式上看主句的意思已经完整了，但后面还有一大串状语，用介词短语 through 加上名词和介词短语 by 加上动名词，表示方式，通过什么方式，“家和工作”这事才能做成，具体包括物理隔断、在家专设办公区，或者去雷格斯、WeWork 这些共享空间工作。  </p>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul>
<li>第一，既然是空间关系，必然有很多相近的含义。我们要特别注意空间关系相似的介词，比较它们在含义和用法上的差别。有些词典会提醒这些近义词，千万不要放过举一反三的机会。</li>
</ul>
<p>例如上面提到的 between，在空间关系上是夹在 A 和 B 两个物体中间的位置，而意思和 between 近似的 among，在空间关系上是混在两个以上的多个物体中间的位置。这个很容易理解，但我们的思考不能止步于此。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：Our house is between the woods, the river and the village.</span><br><span class="line">翻译：我们的房子在树林、小河和村庄之间。</span><br><span class="line"></span><br><span class="line">例句 2：His house is hidden among the trees.</span><br><span class="line">翻译：他的房子隐藏在树林中。</span><br></pre></td></tr></table></figure>

<p>在例句 1 中，虽然空间里有超过两个的多个物体，我们用 A、B、C 来表示，只要我们仍然可以清楚地分辨出房子和 A、B、C 两两对应的关系，也就是说我们房子在树林和小河之间，又在小河和村庄之间，也在树林和村庄之间，这样的空间关系就需要用 between。在例句 2 中，空间里有多个物体且分不出个数，房子混在一堆物体中无法明确和其他物体的两两对应关系，我们才用介词 among。  </p>
<p>从空间关系引申到抽象关系（比如国家之间的关系），用法也是类似的。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：The trade negotiations between Brazil, Argentina, and Chile are going well.</span><br><span class="line">翻译：巴西、阿根廷和智利之间的贸易谈判进展顺利。（有明确的两两关系）</span><br><span class="line"></span><br><span class="line">例句 2：The trade negotiations among the countries of South America are going well.</span><br><span class="line">翻译：南美洲国家之间的贸易谈判进展顺利。（不存在明确的两两关系）</span><br></pre></td></tr></table></figure>

<ul>
<li>第二，空间的概念是相对的，所以介词的用法也灵活多变。</li>
</ul>
<p>例如，我们经常会比较 at、on、in 这三个常用的介词。如果用维度来解释的话，in 是立体的有长宽高的三维世界；on 是在一个平面上，是二维世界的概念；at 则是具体到某一点，是一个降维的过程。由空间可以引申到时间，也是一样从长到短的过程。  </p>
<p><img src="/2020/06/14/geekbang-column-article-3-successful-remote-working/in-on-at.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Shelly lives in a flat on the third floor of an apartment building at 756 Albert Street.</span><br><span class="line">翻译：雪莉住在阿尔伯特街 756 号一栋旧楼三层的一套公寓里。</span><br></pre></td></tr></table></figure>

<p>按照上图 in-on-at 倒金字塔从大到小的顺序，搭配到上面这句话里却是“公寓 - 楼层 - 整栋楼的地址”这样从小到大的顺序。句子里的介词是不是都用错了呢？如果我们从空间相对性的概念来理解，就比较容易理解这三个介词的正确用法了。“雪莉住在一套公寓里。”从她的角度看，这套公寓无疑是一个三维立体的空间，所以要用 in。而某栋楼里面的楼层，是一个又一个的平面，是一个二维的概念，所以用 on；而一个地址，某条街几号，从地图上看就是一个点，要用 at。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：The plane stops for an hour at Frankfurt. (a point on a journey)</span><br><span class="line">例句 2：She lives in Frankfurt. (somebody’s home)</span><br><span class="line">例句 3：Let’s meet at the club. (a meeting point)</span><br><span class="line">例句 4：It was warm and comfortable in the club. (a place to spend time)</span><br></pre></td></tr></table></figure>

<p>我们来比较一下例句 1 和例句 2，介词后面都是法兰克福，德国乃至欧洲的金融中心，但如果把法兰克福看成我们旅途中的一个点，就需要用 at，如果把法兰克福还原成大城市，就妥妥的要用 in；例句 3 和例句 4 也是一样的道理，如果俱乐部只是我们碰头的一个点，要用 at，如果我们在俱乐部里面坐着，喝酒听音乐，那就是一个三维空间，要用 in。  </p>
<h3 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h3><blockquote>
<p>It is also helpful to have a transition point, <strong>something to replace a commute,</strong> that delineates the shift from being at home to being at work.  </p>
</blockquote>
<p>这句话是由 it 做形式主语的句子，逻辑主语是后面的不定式 to have a transition point。当主语过长，为避免句子头重脚轻，通常会用 it 做形式主语，占个位置，而把较长的主语放在句末，其实应该是 to have a transition point is also helpful。  </p>
<p>这句话还有一个值得一讲的语言现象，就是跟在逻辑主语后面、两个逗号中间的同位语 something to replace a commute，用来对 a transition point 进行解释或补充说明，用来强调“转换点”是 “用来取代上下班通勤”的。  </p>
<p>所以，同位语可以是名词、名词短语或者从句，对前面的另一个名词进行解释说明。同位语有两个很重要的作用：  </p>
<ul>
<li><strong>首先，在不改变句式结构的情况下，它可以非常灵活地增加丰富的补充说明信息。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：In his 1835 paper published in the Magazine of Natural History, Edward Blyth, an acquaintance of Charles Darwin’s, had documented all the leading thoughts of Darwin’s work 24 years ahead of Darwin’s 1859 paper On the Origin of Species.</span><br><span class="line">翻译：爱德华·布莱斯和查尔斯·达尔文不过是泛泛之交，在他 1835 年发表在《自然历史杂志》上的论文中，就已经记录了达尔文著作的所有核心原则，这比达尔文 1859 年发表的论文《物种起源》整整早了 24 年。</span><br></pre></td></tr></table></figure>

<p>上面的例句中，加黑部分是同位语，插入到句子中不影响原句的结构，即使删除句子也是完整的。此外，和定语从句一样，同位语也可以分成非限定性同位语和限定性同位语。非限定性同位语只是起到补充说明、增加信息的作用，需要用逗号隔开。  </p>
<p>例句中第一处加黑部分就是非限定性同位语，对爱德华·布莱斯这个人进行补充说明，强调一下他只是和达尔文认识而已。限定性同位语起到缩小范围的限定作用，不用逗号，直接跟着前面的名词。例如例句中第二处下划线，达尔文在 1859 年可能发表过多篇论文，但通过同位语缩小范围，特指《物种起源》那一篇。  </p>
<ul>
<li><strong>其次，通过对前面名词的解释甚至重复，同位语还可以起到强调的作用。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：This tale, this tragic tale, was full of cruel wars, savage devastation, unnecessary deaths and the inevitable search for bloody vengeance.</span><br><span class="line">翻译：这个故事，这个悲惨的故事，充满了残酷的战争、野蛮的破坏、无辜的的死亡和不可避免的血腥寻仇。</span><br></pre></td></tr></table></figure>

<p>同位语也可以以从句形式出现，同位语从句的形式和定语从句有些相似，需要注意区分。比较下面两个例句：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句 1：The rumor that he was married turned out to be true.</span><br><span class="line">翻译：关于他已婚的谣言竟是真的。</span><br><span class="line"></span><br><span class="line">例句 2：The rumor that you told me yesterday turned out to be true.</span><br><span class="line">翻译：你昨天和我讲的谣言竟是真的。</span><br></pre></td></tr></table></figure>

<p>例句 1 是同位语从句，名词和后面的同位语从句有着“同位关系”。that 只是起到引导从句的作用，在从句中不充当任何成分，和从句没有逻辑关系，且一般不能省略。换言之，同位语从句引导词 that 后面是一个完整的句子，从句“他结婚了”就是“谣言”的内容。  </p>
<p>例句 2 是定语从句，修饰的先行词 rumor 和定语从句没有“同位关系”，定语从句的引导词 that 在从句中充当句子成分。此句中 that 作宾语，所以可以省略。  </p>
<h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><blockquote>
<p>Some people have found <strong>taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.</strong>  </p>
</blockquote>
<p>最后一句话主语和谓语动词都很短，主语是 some people，谓语动词是 have found，有人 + 发现，发现了啥？后面跟了一个长长的宾语从句，从句的主语比较长，taking their dog for a walk, or simply going out the front door and coming in the back door of their house，其实是名词化了的两个动作，出去遛狗或者前门出后门回，后面是系表结构 is enough，“就足够了”，但句子的意思还不完整，足够干什么？这就需要表语补足语来进一步说明，不定式 to make the mental shift and start focusing on work 做补足语，足以“在心理上实现切换”并“开始专注工作”。  </p>
<h1 id="动词：英语宇宙的中心"><a href="#动词：英语宇宙的中心" class="headerlink" title="动词：英语宇宙的中心"></a>动词：英语宇宙的中心</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Establishing a high level of trust among remote managers and employees starts with having good meeting rituals. Meetings should be conducted on video if at all possible, and start with a “check in” for each team member. The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity. Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.</span><br><span class="line">在远程工作过程中，经理和员工之间的高度信任始于一套良好的会议仪式。只要可能，会议就应该通过视频方式进行，并从每个团队成员“报到”开始。报到的过程可以让大家陈述他们当天的感受，还有哪些事情可能影响他们的情绪或生产力。经理们必须以身作则，因为你的行动比你的言辞更重要。关于会议仪式方面的建议，Humble 推荐了《核心协议》作者 Richard Kasperowski 写的《高能团队迷你书》。</span><br><span class="line"></span><br><span class="line">An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a “standup.” Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.</span><br><span class="line">定期的会议日程安排也有助于为分散的团队创建组织秩序。每天的网络短会取代了每日“立会”。因为远程工作团队比同地点办公团队具有更高的独立性，所以每周可能只需要开两次例会，就可以让所有成员保持步调一致。</span><br><span class="line"></span><br><span class="line">One-on-one meetings between employee and manager are extremely important, and must be treated as sacrosanct. These meetings are for the employee, with discussions about their career and other personal concerns. Humble had two absolute rules: The one-on-one is not a status meeting, and managers should never be allowed to cancel the meeting.</span><br><span class="line">员工和经理之间的一对一会议非常重要，必须拥有神圣不可更改的地位。一对一会议是为员工安排的，用于讨论他们的职业生涯和其他个人问题。Humble 有两条铁律：一对一会议不是检查工作进度的会议，管理者永远不得取消一对一会议。</span><br></pre></td></tr></table></figure>

<h3 id="不及物动词-介词"><a href="#不及物动词-介词" class="headerlink" title="不及物动词 + 介词"></a>不及物动词 + 介词</h3><blockquote>
<p>Establishing a high level of trust among remote managers and employees <strong>starts with</strong> having good meeting rituals.  </p>
</blockquote>
<p>英语动词分为及物动词和不及物动词。  </p>
<ul>
<li><p>及物动词（transitive verb，缩写 vt.），就是动词后面可以直接跟“物”的动词。这个“物”就是动作的对象，也是动词的宾语。例如  I invited Tom.（我邀请了汤姆。）<br>汤姆这个人就是那个“物”，invite 是及物动词，后面可以直接跟宾语，而且必须有这个“物”，不然句子不完整，不能说 I invited 后面就没了。  </p>
</li>
<li><p>不及物动词（intransitive verb，缩写 vi.）就是不能直接跟“物”（宾语）的动词。这类动词自身词义完整。例如 walk、smile、sleep，我走、我笑、我睡，都不用说明动作对象，也不能直接跟宾语。<br>如果不及物动词后面想要跟“物”（宾语）的话，例如要说“她对我笑”，怎么办呢？这时候，无处不在、无所不能的介词就要发挥作用了。不及物动词后面加上介词之后，就秒变“及物”动词，我们可以说“She smiled at me, and I smiled back.（她冲我笑笑，我也冲她笑笑。）”。从语法角度讲，smile at me，me 是 at 介词的宾语，at me 整个是 smile 的状语。</p>
</li>
</ul>
<p>积累一个常用的习语 smile from ear to ear，也是加了介词 from，字面意思是“从左边耳朵笑到右边耳朵”，其实就是“眉开眼笑”、“笑得合不拢嘴”的意思。  </p>
<p>此外，需要特别说明一下，在不及物动词后面加的 up、down、in 等小词，并不一定都扮演介词的角色。换言之，只有 up、down、in 等这些小词后面跟了宾语的时候，它们才是介词。有“物”可“介”，才能称为介词。如果无“物”可“介”，也就是小词后面不跟宾语的时候，这些小词起到的是副词的作用，表示前面那个动词的状态，英语语法上也称其为副词小品词（adverb particles）。一个动词可以和副词小品词构成不同的动词短语，例如 break down、give up 等。  </p>
<h3 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h3><blockquote>
<p>Meetings should <strong>be conducted</strong> on video if at all possible, and start with a “check in” for each team member.  </p>
</blockquote>
<p>语态是用来说明主语和动词之间关系的动词形式。英语语法中的语态只有两种，主动语态（active voice）和被动语态（passive voice）。主动语态中主语是动作的执行者，被动语态中主语是动作的承受者。因此，只有及物动词才有被动语态。  </p>
<p>被动语态由“助动词 be+ 及物动词的过去分词”构成，被动语态的时态变化只需要改变 be 的形式，过去分词部分不变。疑问式和否定式的变化也是如此。  </p>
<p><strong>首先，当我们希望强调动作的承受着和动作或事件本身，而不想强调动作的执行者（或者根本不知道动作的执行者）的时候，往往会用被动语态。这样的叙述方式，可以使得句子听上去更加具有客观性，因此这种情况一般在科研、学术著作中较为常见。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Too many books have been written about the Second World War.</span><br></pre></td></tr></table></figure>

<p><strong>其次，很多时候，我们讲话的时候，总是习惯先说已知的旧信息，把新的信息留在句末。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Nice picture! ~Indeed. It was painted by my grandfather.</span><br><span class="line">翻译：这幅画画得真不错! ~ 的确，这是我爷爷画的。（这里要突出的新信息是画的作者，所以放在句子的末尾，其他信息都是已知的。）</span><br></pre></td></tr></table></figure>

<p><strong>此外，有时候为了保持一句话或者几句话里的主语不变，也需要使用被动语态。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Joe left my house around 5 pm, and was hit by a car about 30 minutes later.</span><br><span class="line">翻译：乔下午五点左右离开我家，大约三十分钟后就被车撞了。（可以说 a car hit him，但主语就要发生变化了；主语不变更加自然。）</span><br></pre></td></tr></table></figure>

<p>Meetings should be conducted on video，会议尽量要通过视频方式来开，其实就是会议“被”开，但翻译成中文就听不出被动语态了。首先，这句话希望强调会议本身，而不是开会的人，句子听上去也比较有客观性；第二，meeting 同时充当前半句被动语态（be conducted）和后面半句话主动语态（start with）的主语，这样句子听上去会比较自然。  </p>
<h3 id="宾语从句和定语从句"><a href="#宾语从句和定语从句" class="headerlink" title="宾语从句和定语从句"></a>宾语从句和定语从句</h3><blockquote>
<p>The check in lets people state how they are feeling that day, and what else is going on <strong>that may be affecting their mood or productivity.</strong>  </p>
</blockquote>
<p>这句话的主语是 the check in，动词短语名词化，指“点名”或“报到”这件事情，let 是谓语动词，后面跟宾语加上不带 to 的不定式。let…do…，你把这个当固定短语来记就好。  </p>
<p>加黑部分是 state 的宾语从句，可以让团队成员谈一谈，一是他们当天有何感受 <em>，</em> 二是还有哪些事情。什么事情呢？后面还套了一个定语从句，就是下加黑部分，可能影响他们情绪或生产力的那些事情。串在一起就是“报到”这个形式，让团队成员能谈一谈上面讲的这两个问题。  </p>
<h3 id="lead-by-example"><a href="#lead-by-example" class="headerlink" title="lead by example"></a>lead by example</h3><blockquote>
<p>Managers must <strong>lead by example</strong>, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.  </p>
</blockquote>
<p>固定搭配 lead by example 很常用，指的是领导“身先士卒”“以身作则”。下面这句话是世界卫生组织前任总干事陈冯富珍演讲中说的一句话：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：I must lead by example, and I must be held accountable to Member States.</span><br><span class="line">翻译：我必须以身作则，我也必须对会员国负责。</span><br></pre></td></tr></table></figure>

<p>为什么要以身作则呢？因为 what you do is more important than what you say。有一个英语成语也是这个意思：action speaks louder than words（行胜于言）。  </p>
<h3 id="huddle-和-standup"><a href="#huddle-和-standup" class="headerlink" title="huddle 和 standup"></a>huddle 和 standup</h3><blockquote>
<p>An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a “standup”. Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.  </p>
</blockquote>
<p>huddle，它原本的含义是“（因为寒冷或害怕）挤在一起或缩成一团”，英语解释是 to gather closely together, usually because of cold or fear。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Tired and lost, we huddled together around the fire.</span><br><span class="line">翻译：我们疲惫不堪，又迷了路，于是都围着火堆挤作一团。</span><br></pre></td></tr></table></figure>

<p>后来这个词引申用到一些体育比赛中，指“队员靠拢在一起，磋商比赛战略战术的行为”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：In many sports like football and rugby, the team huddles before each play. The huddle is strategic: it keeps the team informed and connected throughout the game. For software teams, the stand-up is like the team’s huddle to keep everyone aware of the team’s landscape and progress.</span><br><span class="line">翻译：在许多运动中（例如足球和橄榄球），全体队员在每次比赛前都要靠拢在一起磋商战术。这一安排具有战略意义：它在整场比赛中保持全队信息和精神相通。对于软件开发团队来说，每日站会就像球队的赛前战术会，让每个成员都知道团队的最新情况和进展。</span><br></pre></td></tr></table></figure>

<p>“standup”顾名思义，就是大家站着开的会。这是敏捷开发（Agile Development）流程中必不可少的环节，其实就是开发团队全员参加的每日例会，定时定点，时间较短，或者说为了控制会议时间，要求大家站着开会，不说废话，不打瞌睡。团队成员在站会前一般都会准备好需要更新的内容，从而确保会议高效。每日站会的目的，在于预估并安排每日的工作计划，促进团队沟通合作，提高透明度，共享工作的进展和障碍（highlight progress and flag blockers），并得到快速响应。  </p>
<h1 id="参透“主从分明”的树状结构，即可“庖丁解牛”"><a href="#参透“主从分明”的树状结构，即可“庖丁解牛”" class="headerlink" title="参透“主从分明”的树状结构，即可“庖丁解牛”"></a>参透“主从分明”的树状结构，即可“庖丁解牛”</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, which is every four months for C4, and coincides with QCon scheduling. C4 has an annual “all hands” meeting that lasts for four days, which also involves flying everyone into one location. This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.</span><br><span class="line">以远程的方式进行战略性讨论是非常具有挑战性的，所以这些会议通常需要参会者亲自到场。C4 每四个月举行一次现场战略讨论会，这与 QCon 会议的日程安排相吻合。C4 每年要举行一次“全员”大会，所有员工都需要飞到同一个地方参会。这样的会议成本显然很高，对后勤也是一大挑战，但却非常有价值。虽然大家不需要总在同一地点办公，但有些工作要想真正有效开展，只有把一个团队的所有人员都聚到一起，其中包括战略性讨论大会，同时还有助于加强团队成员之间的联系。</span><br><span class="line"></span><br><span class="line">Humble shared a list of tools he and C4 have used. Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.</span><br><span class="line">Humble 分享了他和 C4 使用过的工具清单。Slack 用于即时通讯；Zoom 用于视频会议；Workplace 用于同事闲聊；Google Docs 用于远程协作；15Five 用于个人回顾。虽然这些工具对他的团队很有用，但还有很多其他工具可供选择。重要的是要尝试找到适合自己情况的有效工具，因为不好的工具会对远程工作造成严重影响。</span><br><span class="line"></span><br><span class="line">While remote work is very appealing to some employees, it does come with some trade-offs. Although the time and costs associated with commuting disappear, new costs may be incurred from premium high-speed internet, a good laptop, a nice desk, and especially a good office chair. A subject not often, or easily, discussed regarding remote work is mental health. Burnout is a real, serious issue, and is endemic in IT. Trust and openness is critically important, and allows team members to recognize when someone is struggling, and help them cope, including seeking professional help. Loneliness can also be a problem, and it takes active effort to make your family and your social life a real priority. Pets, exercise, and getting into nature can also help improve mental well-being.</span><br><span class="line">虽然远程工作对一些员工来说很有吸引力，但也一定有得有失。虽然与通勤相关的时间和财务成本消失了，但需要高速网络、一台好的笔记本电脑、一张好的办公桌，尤其是一把舒服的办公椅，这些都可能带来新的成本。在远程工作中，心理健康是一个不经常或不容易讨论的话题。职业倦怠是真实存在的严重问题，在 IT 行业尤其普遍。信任和坦诚非常重要，它能让团队成员发觉有同事在挣扎，并帮助他们应对，包括寻求专业的帮助。孤独也可能成为问题，让家庭和社交真正成为你的生活重心是需要付出积极努力的。养宠物、运动和融入大自然也可以帮助改善心理健康。</span><br></pre></td></tr></table></figure>

<h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h3><blockquote>
<p>Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, <strong>which is every four months for C4, and coincides with QCon scheduling.</strong>  </p>
</blockquote>
<p>我们先来找第一句话的主干，strategic discussions 是主语，战略性的讨论是相对于我们日常工作中的事务性讨论而言的，是公司或团队定方向、定目标的战略会议。主语后面是系动词 are，这一看就是我们熟悉的系表结构，后面的表语是形容词 challenging，“战略会是很有挑战的”。显然这个意思是不完整的，除此之外，我们还需要后面通过不定式 to have remotely 这个表语补足语，来补充说明，以远程的方式来开战略会议是很难的。  </p>
<p>前半句分析完了之后，我们可以看到，逗号后面是 so。大部分情况下，so 是并列连词。也就是说，so 前后的两句话是平起平坐的并列关系，不存在很明确的附属关系（附属关系用 because 的情况较多）。  </p>
<p>既然不是从句，我们就需要把后半句也当成主句来分析。主语是 these，指代的是前半句的主语 discussions，谓语动词是 will usually occur，“战略讨论会通常会发生”，什么时候发生呢？显然意思也没有说完整，需要后面 when 开头的表示时间的状语从句来补充说明，“当所有相关人员都能聚到一起开会的时候”。  </p>
<p>把并列连词 so 前后的两个句子摆在一起，有点不那么强烈的因果关系，原因和结果之间有点引导和推测的意思。比如这句话，前半句讲“战略会远程开存在挑战”，后半句讲“一般都是要把人聚在一起才开”，两者之间的因果关系不那么直接和强烈，所以不构成从属关系。这就是因果关系的并列从句和表示直接原因的状语从句之间的微妙差别。  </p>
<p>逗号的后面还有一个 which 引导的定语从句，一看带逗号和 which，可以判断是非限定性的定语从句，可以用来修饰前面讲的整件事情，而不是用于限定 which 前面的先行词。换句话说，后面的从句是补充说明的作用，而不是缩小范围的作用。  </p>
<h3 id="限定性定语从句"><a href="#限定性定语从句" class="headerlink" title="限定性定语从句"></a>限定性定语从句</h3><blockquote>
<p>C4 has an annual “all hands” meeting <strong>that lasts for four days, which also involves flying everyone into one location.</strong>  </p>
</blockquote>
<p>看完上句的非限定性定语从句，我们马上可以看到下一句话里面的限定性定语从句。主句的“主谓宾”结构非常清晰，C4 是主语，谓语动词是 has。在这里，has 是实义动词而非助动词，宾语是 an annual “all hands” meeting，“C4 有年度全员大会”。宾语 meeting 后面跟的是限定性定语从句，强调是“为期四天”的年度大会。  </p>
<p>前半句话后面是逗号和 which，又是一个非限定性定语从句，它最大的特点就是可以灵活地修饰前面讲的整件事情，而不像前面的限定性定语从句那样只能修饰先行词 meeting。非限定性定语从句补充说明，“年度会议也是需要把公司的所有人都飞到同一个地方”才能开的。  </p>
<h3 id="all-hands-on-the-deck"><a href="#all-hands-on-the-deck" class="headerlink" title="all hands (on the deck)"></a>all hands (on the deck)</h3><p>英语里有一个固定说法叫 all hands on the deck，最初这是大船上让所有船员全部到甲板集合、各就各位的命令。例如，We’re under attack! All hands on deck!（我们受到攻击，全体上甲板！），之后慢慢从“全体船员”引申到“所有帮得上忙的人”。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例句：Your grandmother arrives tomorrow and the house is still a mess—I need all hands on deck to help me clean!</span><br><span class="line">翻译：你们奶奶明天就到了，房子还是一团糟！我需要所有的人都来帮我打扫！</span><br></pre></td></tr></table></figure>

<p>很多地方干脆连 on the deck 都省略了，直接用 all hands 来指“全体人员”。句子里的 all hands meeting 指的就是“全体员工大会”。  </p>
<p>另外，还有一个经常听到的词 town-hall meeting，最早是指“西方国家的竞选者定期在市政厅与当地选民进行的交流会”，通过 town-hall meeting 听取选民意见，回答选民问题，也叫“市政厅会议”，后来慢慢地也引申到企业的“全体员工大会”。  </p>
<p>两个都是“全体员工大会，all hands 和 town-hall 有啥区别呢？我们来看下面这段英文解释：  </p>
<blockquote>
<p>The term “Town Hall” meeting is often used interchangeably with All-Hands meeting however a Town Hall meeting is more question and answer based while All-Hands meetings are generally more focused on conveying a message and making a key presentation.  </p>
</blockquote>
<p>这两个说法意思是差不多的，可以互换使用。如果实在要说差别，town-hall 以偏重回答员工问题为主要形式，而 all-hands 则以作报告、传达企业战略精神为主。  </p>
<h3 id="复习并列句和复杂句"><a href="#复习并列句和复杂句" class="headerlink" title="复习并列句和复杂句"></a>复习并列句和复杂句</h3><blockquote>
<p>This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.  </p>
</blockquote>
<p>logistical 这个词。它是名词 logistics 的形容词，最早在军事领域用得比较多，中国古代称为“粮草辎重”，到近代改称“军需后勤”，之后又把军事后勤的概念延伸到商业领域，形成现代的“物流”概念。不管说法怎么变，其本质都是一样的，都是讨论如何高效地进行物资生产、采购、运输、配给等活动，使得差别更低、速度更快、服务更好。句子里面指的是，全公司的人都要聚到某一个地方（比如迪拜）去开年会，不仅昂贵，而且后勤方面很有挑战。  </p>
<h3 id="water-cooler-chat"><a href="#water-cooler-chat" class="headerlink" title="water cooler chat"></a>water cooler chat</h3><blockquote>
<p>Humble shared a list of tools he and C4 have used. Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.  </p>
</blockquote>
<p>这一段演讲人介绍了一堆他推荐使用的远程工具，大部分大家都非常熟悉，只需要提一下两个词组。第一个是 water cooler chat，我们来看一段英文解释：  </p>
<blockquote>
<p>Water cooler chat, or water cooler talk, or water cooler conversation (whatever you want to call it), is what happens when colleagues take a break from work-related tasks and discuss their hobbies, interests, and other things by gathering around the office water cooler.  </p>
</blockquote>
<p>大一点的公司，每个办公楼层一般都有茶水间，再不济也有一个饮水机，就是这个 water cooler（老外喜欢喝冰水，我们喜欢喝热水）。工作间歇休息的时候，同事们会去接开水，闲聊几句和工作无关的事情。Workplace 则是 Facebook 推出的办公通讯软件，曾被国内媒体称为“企业微信”，Humble 推荐作为同事间的闲聊工具。  </p>
<p>private retrospectives：英文解释 looking back on or dealing with past events or situations，这个词指的是对过去发生过的事情的回顾。以前我们提到过 Agile Development，敏捷开发的工作流程中一般都有 一项 retrospective meetings，开发团队定期召开的回顾会。句子里面的 private 指的是“个人私下的”，也可以用 individual 或者 personal retrospectives，是个人定期回顾自己的工作或者生活，而 15Five 则是团队或个人绩效管理工具，里面有不错的工作回顾功能。  </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><p>“阵而后战，兵法之常，运用之妙，存乎一心。”方法的道理说起来都是比较容易的，但真正要用好，还需要你自己去练习和体会。  </p>
</li>
<li><p>怎么学好介词呢？我们可以从它们的空间关系本源含义入手，进而引申出时间关系和抽象含义，通过例句体会介词变化繁多的用法。  </p>
</li>
<li><p>大部分的介词都是有空间关系的本义，但也有一部分介词空间关系本义并不明显，例如我们上次讲的 despite，这次出现的 for。还是以前讲过的那句老话，所有的语法规则、规律、方法、诀窍，都是帮助我们理解语言含义的工具。我们要学会使用这些工具，但有时候碰到“规律”解释不通的地方，也不要被它们束缚，更不要去钻牛角尖。  </p>
</li>
<li><p>熟练使用同位语，可以帮助我们增添写作的多样性，在不改变句子结构的情况下，能够灵活添加补充信息，使文章内容更加丰富详实，同时还能起到很好的“强调”修辞效果。  </p>
</li>
<li><p>动词作为英语宇宙的中心，变化万千，要讲时态和语态，还能和不同的介词（或者副词小品词）搭配幻化出各种不同的意思，的确不是讲几个语法概念和读几个例句就能囊括的，同样也需要我们日积月累。掌握了动词并且能够运用自如，你就相当于站在宇宙的中心，洞悉万物一切的变化。</p>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://www.gartner.com/smarterwithgartner/with-coronavirus-in-mind-are-you-ready-for-remote-work/">https://www.gartner.com/smarterwithgartner/with-coronavirus-in-mind-are-you-ready-for-remote-work/</a>  </li>
<li><a href="https://www.gartner.com/smarterwithgartner/coronavirus-cio-areas-of-focus-during-the-covid-19-outbreak/">https://www.gartner.com/smarterwithgartner/coronavirus-cio-areas-of-focus-during-the-covid-19-outbreak/</a>  </li>
<li><a href="https://www.englishpage.com/prepositions/prepositions.html">Prepositions</a>  </li>
<li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/for">关于介词 for 的用法</a>  </li>
<li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/between-or-among?q=between">Between or among?</a>  </li>
<li><a href="https://writingexplained.org/between-vs-among-difference">Between vs. Among: What’s the Difference?</a>  </li>
<li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/across-over-or-through?q=through">Across, over or through?</a>  </li>
<li><a href="https://www.grammarly.com/blog/appositive/">Appositives—What They Are and How to Use Them</a>  </li>
<li><a href="https://literaryterms.net/appositive/">Appositive</a>  </li>
<li><a href="https://www.grammar-monster.com/glossary/appositive_apposition.htm">https://www.grammar-monster.com/glossary/appositive_apposition.htm</a></li>
</ul>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="关于及物动词和不及物动词"><a href="#关于及物动词和不及物动词" class="headerlink" title="关于及物动词和不及物动词"></a>关于及物动词和不及物动词</h2><ul>
<li><a href="https://www.grammarly.com/blog/transitive-and-intransitive-verbs/">Transitive and Intransitive Verbs—What’s the Difference?</a>  </li>
<li><a href="https://www.gingersoftware.com/content/grammar-rules/verbs/action-verbs/">Action Verbs-Transitive and Intransitive Verbs</a>  </li>
<li><a href="https://www.myenglishpages.com/site_php_files/grammar-exercise-transitive-intransitive-verbs.php">Grammar Exercise - Transitive and Intransitive Verbs </a>  </li>
<li><a href="https://www.quia.com/quiz/653869.html">Transitive or Intransitive Verbs?</a></li>
</ul>
<h2 id="关于被动语态"><a href="#关于被动语态" class="headerlink" title="关于被动语态"></a>关于被动语态</h2><ul>
<li><a href="https://advice.writing.utoronto.ca/revising/passive-voice/">Passive Voice: When to Use It and When to Avoid It</a>  </li>
<li><a href="https://grammar.yourdictionary.com/grammar/writing/passive-voice-when-to-use-it.html">Passive Voice: When to Use It</a>  </li>
<li><a href="https://www.englishgrammar.org/active-passive-voice-quiz/">Active and Passive Voice Quiz</a>  </li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=passive-voice">English Grammar Quiz: Passive Voice! </a></li>
</ul>
]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>远程办公</tag>
        <tag>介词</tag>
        <tag>同位语</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：只需四步，搞定动态规划算法设计</title>
    <url>/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="数字三角形问题"><a href="#数字三角形问题" class="headerlink" title="数字三角形问题"></a>数字三角形问题</h3><p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/sanjiaoxing.jpg">  </p>
<p>由上到下，第 i 层由 i 个数字组成，目标从第 1 层开始，每次只能向下走到相邻的两个节点，求走到最后一层路径上面数字的最大和值是多少。就像图中标红的一条线路，就是路径和值最大的一条路线，和值为 39。如果给你的是一个 n 层的数字三角形，你该如何解决这个问题呢？  </p>
<h3 id="数学归纳法思想"><a href="#数学归纳法思想" class="headerlink" title="数学归纳法思想"></a>数学归纳法思想</h3><p>如果我们已知到第三层所有点的最大值，那么我们就可以计算得到起始点到第四层每一个的路径最大和值。所有绿色节点和蓝色节点，就是已经求出来的，起始点到其路径最大和值的点。其中的数字是根据上图中的数字三角形计算所得，比如第 2 层的 12，是由图 1 中第 1 层的 3 与原所在位置的 9，相加之和的结果。  </p>
<p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/mathqiujie.jpg">  </p>
<p>如果想求从起始点到红色的点，也就是第 4 行数字 9 点的路径最大和值，那么根据数字三角形的规则，我们只能从图中的两个蓝色点转移到红色点。那究竟选择从哪个点走到红色点呢？当然是选择其中和值较大的了，也就是从和值为 14 的点转移到红色点，得到的就是起始点到红色点的路径最大和值。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若我们已知从起始点到第 i - 1 层上每个点的路径最大和值，那我们又是怎么得到从起始点到第 i 层上每个点的路径最大和值呢？请看下图：  </p>
<p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/tuidao.jpg">  </p>
<p>我们给每一层的节点，从左向右，从 0 开始依次编号，那么第 i 行的第 3 个点对应的坐标就是 (i, 2) 点。从第 1 层的点想要到达红色 (i, 2) 点，可以通过 (i - 1, 1) 点到达，或者通过 (i - 1, 2) 点到达。在已知从起始点到第 i-1 层上每个点的路径最大和值的前提下，从第 1 层到 (i, 2) 点的最大和值，就是在 (i - 1, 1) 和 (i - 1, 2) 这两个值中，选择一个路径和值最大的，然后转移到 (i, 2) 点，即为第 1 层到 (i, 2) 点的路径最大和值。  </p>
<p>所以，我们基本可以确定一件事情了，如果我们要是知道第 1 层 到 i - 1 层的每个点的路径最大和值，那就很容易求得到第 i 层每个点的路径最大和值，从而推导出 i + 1 层、i + 2 层等等的路径最大和值，直到最后一层。  </p>
<p>又因为，我们已知第 1 层到第 1 层每一个点的路径最大和值，就是起始点原本的值，所以沿着上面这个思路，就可以按照层序，来求解第一层到每一层的每个节点的路径最大和值了。  </p>
<h2 id="动态规划算法的四步走"><a href="#动态规划算法的四步走" class="headerlink" title="动态规划算法的四步走"></a>动态规划算法的四步走</h2><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>理解一个动态归划问题的状态定义，是理解其解法的第一步，也是最重要的一步。如果你在往下进行推导的时候，发现进行不下去了，那往往就是状态定义有问题，这时你就需要回到这个第一步，琢磨琢磨新的状态定义了。  </p>
<p>并且，我们一直在强调，对于动态规划的状态定义，不仅仅是要一个数学符号，还要一个明确的语义信息，你的理解可能是：不同的语义信息，对应的不就是不同的数学符号么？那今天，我们就用同一个数学符号，表示不同的语义信息，在接下来的求解过程中，你会发现这两种不同的语义信息，所衍生出来的后续步骤过程，是完全不同的。  </p>
<p>回到前面说的数字三角形问题，我们可以作出两种状态定义：  </p>
<ul>
<li><p><strong>第一种状态定义</strong>：dp[i][j] 代表从起始点，到 (i, j) 点的路径最大值。  </p>
</li>
<li><p><strong>第二种状态定义</strong>：dp[i][j] 代表从底边的某个点出发，到 (i, j) 点的路径最大值。</p>
</li>
</ul>
<p>为了后续讲解方便，我们假设所有坐标都是从 1 开始的，也就是第一行第一个点的坐标是 (1, 1)。你会发现，这两种状态定义，数学符号都是 dp[i][j]，而含义却完全相反，一个是从顶向下走，一个是从底向上走。对于第一种状态定义，如果数字三角形有 n 层的话，问题所求的最大值，就是在最后一层 dp[n] 中的某个值。而第二种状态定义，问题所求的最大值最终会存储在 dp[1][1] 这个状态值中。  </p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>状态转移，就是状态之间的转移，每一个状态的含义，在状态定义中规定的明明白白，而状态与状态之间的转移方式，是需要根据具体的问题以及具体的状态定义，进行具体分析。  </p>
<p>根据刚才作的两种状态定义，我们可以分别画出来这样两种状态转移的方向：  </p>
<p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/zhuangtaizhuanyi.jpg">  </p>
<p>如图所示，我以左边是第一种状态定义下的状态转移方向为例，来说明它是如何转移的。首先，它是自上向下转移的，所以想要求得 dp[i][j] 的值，我们需要知道 dp[i - 1][j - 1] 和 dp[i - 1][j] 的值。因为按照“走向下个相邻两点”的规则，只有 (i - 1, j - 1) 和 (i - 1, j) 这两个点，才能能走到 (i, j)，也就是我们讲到的转移到 (i, j) 点。右边的第二种状态定义转移过程和左边的一样，只是移动方向不一样而已。  </p>
<p>所以，根据两种状态定义，我们可以分别列出这两种状态转移方程：  </p>
<ul>
<li><p>第一种状态转移方程：dp[i][j] &#x3D; max(dp[i - 1][j - 1], dp[i - 1][j]) + val[i][j]  </p>
</li>
<li><p>第二种状态转移方程：dp[i][j] &#x3D; max(dp[i + 1][j], dp[i + 1][j + 1]) + val[i][j]</p>
</li>
</ul>
<p>两种转移方程，都是在能够转移到 (i, j) 点的状态值中选择一个较大值，再加上 (i, j) 原本的数值 val[i][j]，就是各自起始点到达 (i, j) 点的路径最大值，也就是两种状态定义下的 dp[i][j] 的值。  </p>
<p>到这里，你可以看出，<strong>状态定义不一样，直接导致我们的状态转移方程就不一样。所以，虽然是相同的数学符号，定义的含义不同，就会造成后续的解法不同，同时也意味着解决问题的难度不同。</strong>  </p>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>关于状态转移方程的正确性证明，借助的就是程序设计中最重要的数学思维：数学归纳法。  </p>
<p>根据数学归纳法的三步走，我们试着证明一下第一种状态转移方程是正确的，也就是自上而下的状态转移方式。  </p>
<p>第一步，我们已知在这种状态转移方式中，第一个阶段中的所有 dp 值都可以轻松获得，也就是可以很轻松的初始化 dp[1][1] 的值，应该等于 val[1][1] 的值。  </p>
<p>第二步，我们假设如果第 i-1 阶段中的所有状态值，我们都正确的得到了。也就是正确的得到了从起始点到 i-1 层中每个点的路径最大和值。那根据状态转移方程：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j + 1]) + val[i][j] 来说，就可以正确的计算得到第 i 个阶段中的所有状态值。  </p>
<p>第三步，两步联立，就可得出结论，所有阶段中的状态值计算均正确。那么，从起始点到底边的路径最大和值，就在最后一个阶段的若干个状态值中。  </p>
<h3 id="程序设计与实现"><a href="#程序设计与实现" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i, j;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> p[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[n][j] = s[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i + <span class="number">1</span>][j] &gt; p[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                p[i][j] = s[i][j] + p[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               p[i][j] = p[i + <span class="number">1</span>][j + <span class="number">1</span>] + s[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>状态定义，是动态规划算法的重点，无论是解题还是学习，都要从这一步开始。  </li>
<li>不同的状态定义，决定了不同的状态转移方程，同时也可能代表了不同的解题难度，所以，学习如何定义优秀的状态很重要。  </li>
<li>动态规划中的状态转移顺序，是建立在“阶段”概念之上的，只有本阶段的状态值计算完了，下一个阶段的状态值才能得以计算。  </li>
<li>数学归纳法，是证明动态规划状态转移方程正确性的利器，掌握了它，会让你的动态规划学习过程事半功倍！</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>设计</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：用筛法求解其他积性函数</title>
    <url>/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 10000 以内所有数字的因数和。  </p>
<p>可能已经想好的方法：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 循环遍历 1 到 10000 的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 用 j 循环枚举数字 i 可能的因数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当 i%j 不等于 0 时，说明 j 不是 i 的因数</span></span><br><span class="line">            <span class="keyword">if</span> (i % j) <span class="keyword">continue</span>;</span><br><span class="line">            sum[i] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_sum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效率较低，所以弃了。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="数论积性函数"><a href="#数论积性函数" class="headerlink" title="数论积性函数"></a>数论积性函数</h3><p>所谓数论积性函数，首先，是作用在正整数范围的函数，也就是说函数 f(x) &#x3D; y 中的 x 均是正整数。其次，是数论积性函数的一个最重要的性质，就是如果 n 和 m 互质，那么 f(n*m) &#x3D; f(n) * f(m) 。  </p>
<p><img src="/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/shulun.jpg">  </p>
<h3 id="因数个数函数"><a href="#因数个数函数" class="headerlink" title="因数个数函数"></a>因数个数函数</h3><p>因数个数：就不难理解了，它指的是一个数字因数的数量。例如，数字 6，有 1、2、3、6 这 4 个因数，因数个数就是 4。  </p>
<h3 id="素数筛框架"><a href="#素数筛框架" class="headerlink" title="素数筛框架"></a>素数筛框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="type">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_prime</span><span class="params">()</span> &#123;  <span class="comment">//初始化 prime 数组信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//prime[i] 中记录的是数字 i 中最小的素因子</span></span><br><span class="line">        <span class="comment">// 素数中最小的素因子是其本身</span></span><br><span class="line">        prime[i] = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果 j 没有被标记过，就标记成 i</span></span><br><span class="line">            prime[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] == <span class="number">0</span>) prime[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="type">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> g_cnt[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_g_cnt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1 的因数数量就是 1 个</span></span><br><span class="line">    g_cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> n = i, cnt = <span class="number">0</span>, p = prime[i];</span><br><span class="line">        <span class="comment">// 得到数字 n 中，包含 cnt 个最小素因子 p</span></span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            n /= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时数字 n 和最小素数 p 部分，就是互素的</span></span><br><span class="line">        g_cnt[i] = g_cnt[n] * (cnt + <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>所谓代码框架，就是要活学活用。  </li>
<li>在真正的工作中，你所做的事情，大多是在多种代码框架之间做选择及组合拼装，每个算法代码只会解决遇到的一部分问题。而你在使用这些算法代码的时候，往往不能照搬照用，反而要做一些适应性的改变，这些都是“框架思维”中所重视的。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：将素数筛算法写成框架算法</title>
    <url>/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求 1 万以内所有素数的和。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="素数筛算法介绍"><a href="#素数筛算法介绍" class="headerlink" title="素数筛算法介绍"></a>素数筛算法介绍</h3><p>所谓素数筛，是将其产出的信息存储在一个标记数组中，数组的第 i 位，标记的是 i 这个数字是否是合数的信息。如果 i 这个数字是合数，数组下标为 i 的位置就被标记成为 1，如果 i 不是合数，则数组下标为 i 的位置就是 0。素数筛就是通过一套算法流程，产生一个这样的数组。  </p>
<p>算法流程：<br><img src="/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/sushu-algo.jpg">  </p>
<h3 id="素数筛代码框架"><a href="#素数筛代码框架" class="headerlink" title="素数筛代码框架"></a>素数筛代码框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> prime[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 素数筛的标记过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">10000</span>; i++) &#123;  <span class="comment">//从 2 开始遍历到根号 10000，也就是 100。</span></span><br><span class="line">        <span class="comment">//i &lt;= sqrt(10000) == i * i &lt;= 10000</span></span><br><span class="line">        <span class="comment">//这种改变是有好处的，会在代码运行速度上做提升，毕竟开方运算是很慢的，远远没有单独做一个乘法操作要快。</span></span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//判断 i 这个数字是否被标记过的，如果被标记过，就说明是合数，就不执行后续操作。</span></span><br><span class="line">        <span class="comment">// 用 j 枚举所有素数 i 的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= <span class="number">10000</span>; j += i) &#123;</span><br><span class="line">            prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="type">int</span> prime[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化素数表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_prime</span><span class="params">()</span> &#123;</span><br><span class="line">     prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">             prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_prime();</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        sum += i * (<span class="number">1</span> - prime[i]); <span class="comment">// 素数累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：5736396</span></span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，因子分解程序正确性证明"><a href="#1，因子分解程序正确性证明" class="headerlink" title="1，因子分解程序正确性证明"></a>1，因子分解程序正确性证明</h3><blockquote>
<p>所谓的素因子分解，就是把一个整数，表示成为若干个素数相乘的形式，并且我们可以轻松的证明，这种只由素数表示的分解表示法，对于某个特定整数 N 来说，一定是唯一的。<br>例如，67689 这个数字就可以分解为：3 * 3 * 3 * 23 * 109 &#x3D; 67689，其中 3、23、109 都是素数。  </p>
</blockquote>
<p>下面呢，有一段素因子分解的程序：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个素因子，并且在中间输出 * 乘号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_num</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> *flag)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    *flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, i = <span class="number">2</span>, flag = <span class="number">0</span>, raw_n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    raw_n = n;</span><br><span class="line">    <span class="comment">// 循环终止条件，循环到 n 的平方根结束</span></span><br><span class="line">    <span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//①：只要 n 可以被 i 整除，就认为 i 是 n 的一个素因子</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            print_num(i, &amp;flag);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②：如果最后 n 不等于 1，就说明 n 是最后一个素数</span></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) print_num(n, &amp;flag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; = %d\n&quot;</span>, raw_n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试证明：  </p>
<ul>
<li><p>1，第 18 行代码中，只要 n 可以被 i 整除，i 就一定是素数，为什么？<br>假设  i 可以被 n 整除，但 i 不是素数，由算术基本定理可知，一个非素数的数字 N，一定可以分解为几个小于 N 的素数乘积的形式。我们不妨假设 i&#x3D;p1​×p2​，这里 p1​ 和 p2​ 均为素数，如果变量 n 可以被 i 整除，那么 n 也一定可以被小于 i 的素数 p1​ 整除。而根据程序的运行流程，n 中已经不可能存在小于 i 的因子了，所以 p1​ 不具备存在的条件，故原假设不成立，i 是素数。  </p>
</li>
<li><p>2，第 25 行代码中，为什么只要 n 不等于 1，n 就一定是素数呢？<br>在 while 循环处理过程中，数字 n 中已经不可能存在小于等于 i 的所有的因子了，又因为此时 i 是大于根号 n 的一个值，也就是说，在小于等于根号 n 范围内，找不到数字 n 的非 1 因子，而能够满足这种性质的数字，一定是素数。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>想把具体“算法”升华成“算法思维”，首先要习惯性地总结算法的“框架思维”。  </li>
<li>素数筛是用素数去标记掉这个素数所有的倍数。  </li>
<li>清楚地知道素数筛在执行过程中，每一行的性质。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>框架</tag>
        <tag>素数</tag>
        <tag>合数</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计原则：把计算过程交给计算机</title>
    <url>/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 1000 以内所有 3 或 5 倍数的数字的和。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="一份合格的程序实现"><a href="#一份合格的程序实现" class="headerlink" title="一份合格的程序实现"></a>一份合格的程序实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;  <span class="comment">//循环遍历 1000 以内的所有整数</span></span><br><span class="line">        sum += i * (i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>);  <span class="comment">//把 3 或 5 的倍数累加到变量 sum 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);  <span class="comment">//最后输出 sum 变量的值，就是 1000 以内，所有 3 或 5 的倍数和。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提升计算效率"><a href="#提升计算效率" class="headerlink" title="提升计算效率"></a>提升计算效率</h3><p>利用等差数列求和公式：<br><img src="/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/gongshi.jpg">  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum3 = (<span class="number">3</span> + <span class="number">999</span> / <span class="number">3</span> * <span class="number">3</span>) * (<span class="number">999</span> / <span class="number">3</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 3 的倍数的和 sum3</span></span><br><span class="line">    <span class="type">int</span> sum5 = (<span class="number">5</span> + <span class="number">999</span> / <span class="number">5</span> * <span class="number">5</span>) * (<span class="number">999</span> / <span class="number">5</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 5 的倍数的和 sum5</span></span><br><span class="line">    <span class="type">int</span> sum15 = (<span class="number">15</span> + <span class="number">999</span> / <span class="number">15</span> * <span class="number">15</span>) * (<span class="number">999</span> / <span class="number">15</span>) / <span class="number">2</span>; <span class="comment">//1000 以内所有 15 的倍数的和 sum15</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum3 + sum5 - sum15);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，和的平方减平方和"><a href="#1，和的平方减平方和" class="headerlink" title="1，和的平方减平方和"></a>1，和的平方减平方和</h3><blockquote>
<ol>
<li>请编写一个程序，计算 100 以内自然数“和的平方”与“平方和”的差。  </li>
<li>能否通过查阅资料，推导得到等差数列的平方和公式呢？</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hepingfang</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pingfanghe</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//计算 100 以内自然数“和的平方”与“平方和”的差</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d = %d\n&quot;</span>,hepingfang(n),pingfanghe(n),hepingfang(n)-pingfanghe(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>具体的计算过程，计算机比你更擅长，所以请把具体的计算过程，留给计算机。  </li>
<li>编写程序，其实是在描述和规定计算过程，而描述的方式不同，效率也不同。  </li>
<li>不同的效率过程，就是我们所谓的不同的算法过程，记住：算法很重要。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>数字</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>每周一起背10句</title>
    <url>/2020/06/17/geekbang-column-hlwrdyysjk-memorize-10-sentences-a-week/</url>
    <content><![CDATA[<h2 id="week-01"><a href="#week-01" class="headerlink" title="week 01"></a>week 01</h2><p>例句 1：The United States is a sports-minded country, with millions of fans who follow football, baseball, basketball and hockey, among other sports.<br>翻译：美国是一个体育意识很强的国家，有数以百万计的球迷关注足球、棒球、篮球和曲棍球等体育运动。  </p>
<p>例句 2：The difference between proactive people and reactive people is that proactive people take initiative, and they come up with ideas to get things done despite the conditions they are in. Reactive people, on the other hand, usually are the ones to react to a situation rather than take initiative to create a situation.<br>翻译：积极主动的人和消极被动的人之间的区别在于，积极主动的人会采取主动，无论他们所处的环境如何，都会想出办法来完成任务；而消极被动型的人通常只会对形势做出被动的反应，而不会主动采取行动去创造形势。  </p>
<p>例句 3：Don’t jump to conclusions! Perhaps it was his daughter he was dancing with.<br>翻译：别匆忙下结论，和他跳舞的没准是他女儿呢。  </p>
<p>例句 4：The workers approached the manager with a request for shorter working hours.<br>翻译：工人们找经理要求减少工作时间。  </p>
<p>例句 5：His sober approach to the crisis averted a catastrophe.<br>翻译：他对危机的冷静处理避免了一场大灾难。  </p>
<p>例句 6：They take the time to understand how the business works, how the product fits in, and what its goals are.<br>翻译：他们会花时间去了解企业是如何商业运作的，产品又是如何配合商业运作，以及最终要达到什么样的商业目标。  </p>
<p>例句 7：You need to work hard—opportunities don’t just come out of thin air.<br>翻译：你得努力啦，机会不会凭空产生（天上不会掉馅饼）。  </p>
<p>例句 8：He is empathetic with the jobless youth, as he was also struggling for a job in his early years.<br>翻译：他对失业的年轻人感同身受，因为他自己早年也为找工作挣扎过。  </p>
<p>例句 9：Social media technologies have given companies access to an unprecedented flood of new analytics, metrics and user data.<br>翻译：有了社交网络之后，企业获取了空前大量的新分析方法、度量指标和用户数据。  </p>
<p>例句 10：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.<br>翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。  </p>
<h2 id="week-02"><a href="#week-02" class="headerlink" title="week 02"></a>week 02</h2><p>例句 1：Apple will unveil a 10-inch touchscreen tablet device in January, and ship the product in March.<br>翻译：苹果将于一月份推出 10 英寸触屏平板电脑，并于三月份发货。  </p>
<p>例句 2：We define an iteration as a phase or a milestone.<br>翻译：我们将一次迭代定义为一个阶段或一个里程碑。  </p>
<p>例句 3：Her husband was unsympathetic and she felt she had no one to turn to.<br>翻译：她的丈夫不懂得体恤人，她觉得无人可以依靠。  </p>
<p>例句 4：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.<br>翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。  </p>
<p>例句 5：Life is full of trade-offs. You cannot have your cake and eat it too.<br>翻译：生活充满了取舍。鱼和熊掌不可兼得。  </p>
<p>例句 6：Point Break was a breakout film for Kathryn Bigelow in 1991.<br>翻译：凯瑟琳·毕格罗于 1991 年拍摄了《惊爆点》，该片突破了她之前的风格。  </p>
<p>例句 7：I have little knowledge of computer and business, can I still learn Navisio？<br>翻译：我对计算机和商业知之甚少，我还能学习 Navision 系统吗？  </p>
<p>例句 8：I was juggling books, shopping bags and the baby.<br>翻译：我手里又是书，又是购物袋，还抱着孩子，跟演杂技一样。  </p>
<p>例句 9：I’ve always felt that tragedy and comedy are two sides of the same coin. Love and hate are the opposite sides of the same coin.<br>祸福相依、爱恨交织。&#x2F; 塞翁失马焉知非福。  </p>
<p>例句 10：My computer keeps going funny.<br>翻译：我的计算机老出故障。  </p>
<h2 id="week-03"><a href="#week-03" class="headerlink" title="week 03"></a>week 03</h2><p>例句 1：You are strongly encouraged to save your document frequently, back-up regularly, and print your work-in-progress periodically.<br>翻译：强烈建议你们经常保存和备份，并且定期把写作过程中的文稿打印出来。  </p>
<p>例句 2：What Jock had done was beyond my comprehension.<br>翻译：我无法理解乔克的所作所为。  </p>
<p>例句 3：Major breakthroughs have been made in the reform of China’s ownership structure.<br>翻译：中国所有制结构改革也取得了重大突破。  </p>
<p>例句 4：They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.<br>翻译：他们会提供建议和取舍方案，其中某些建议会反映在修订后的产品设计规范中。  </p>
<p>例句 5：After each project, their product understanding deepens, and they start to develop better and better product instincts.<br>翻译：每完成一个项目，他们对产品的理解就会加深，他们开始培养起越来越好的产品直觉。  </p>
<p>例句 6：Children do not know by instinct the difference between right and wrong.<br>翻译：儿童并非生来就会分辨是非。  </p>
<p>例句 7：Tell us what you bring to the table, not just what you want.<br>翻译：告诉我们你能给公司带来什么，而不仅仅是你想要什么。  </p>
<p>例句 8：I’ve delivered the cash as you instructed. Now you must live up to your end of the bargain!<br>翻译：我已经按照你说的把钱送来了。现在该你履行承诺了！  </p>
<p>例句 9：I don’t see the relevance of your question.<br>翻译：我不懂你提的这个问题有什么意义。（口气非常强烈甚至不礼貌）  </p>
<p>例句 10：All happy families resemble one another, each unhappy family is unhappy in its own way.<br>翻译：幸福的家庭都是相似的，不幸的家庭各有各的不幸。  </p>
<h2 id="week-04"><a href="#week-04" class="headerlink" title="week 04"></a>week 04</h2><p>例句 1：Although I don’t like him, I agree he is a good manager.<br>翻译：虽然我不喜欢他，但我承认他是一个出色的经理人。  </p>
<p>例句 2：I’m sorry, I think sleep deprivation contributed to my outburst just then.<br>翻译：抱歉，睡眠不足让我刚才情绪失控了。  </p>
<p>例句 3：The second benefit is teams’ ability to safely experiment and fail fast.<br>翻译：第二个好处是团队能够安全地进行实验并获得“快速失败”的能力。  </p>
<p>例句 4：I empowered my agent to close the deal.<br>翻译：我授权我的经纪人完成这笔交易。  </p>
<p>例句 5：The third benefit open source offers is a better way of building software.<br>翻译：开源的第三个好处是提高软件开发质量。  </p>
<p>例句 6：Well, my mom is really sick, which means that we might have exposed the kids to the flu virus when we had her watch them last week.<br>翻译：嗯，我妈妈病得很重，这意味着上周我们让她看孩子的时候，可能已经让他们接触了流感病毒。  </p>
<p>例句 7：As an immediate result, their teams doubled the amount of code that was developed and shared, which directly reduced the amount and cost of redundant code.<br>翻译：立竿见影的结果是团队将开发和共享的代码量增加了一倍，直接减少了冗余代码的数量和成本。  </p>
<p>例句 8：According to Aitken, the quality of the code increased dramatically because it was exposed to everyone inside the organization.<br>翻译：按照埃特金的说法，由于代码对组织内每一个人开放，代码的质量得以大幅提升。  </p>
<p>例句 9：This led to software developers taking more care in the software they were writing.<br>翻译：这也使得软件开发人员在编写软件时更加用心。  </p>
<p>例句 10：Open source is evolving at a rapid pace, and developers learn new open source technologies every few years.<br>翻译：开源软件发展迅猛，开发人员每隔几年就要学习新的开源技术。  </p>
<h2 id="week-05"><a href="#week-05" class="headerlink" title="week 05"></a>week 05</h2><h3 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h3><p>For both employees and employers, remote work requires intentional design and implementation to be effective. People find remote work challenging because the established mindset says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.<br>无论对于雇员还是雇主，要想使远程工作有效，需要双方有心地设计和实施。人们感觉远程工作很有挑战性，是因为固有的思维模式都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的心理健康。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的好处都足以使其值得一试。  </p>
<h3 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h3><p>The first starting point for remote employees is to have clear separation between home and work. This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.<br>员工在家远程工作，首先要把家和工作分开。要实现这一点，可以通过物理隔断，在家专设办公区或者干脆去共享工作空间（例如雷格斯或者 WeWork 等共创空间）。有时也可以人为设定一个取代通勤的转换点，作为从在家状态到工作状态的切换标志。有人发现，带狗出去散步，或者只是从前门出后门回，就足以使他们在心理上实现这种切换，并开始专注工作。  </p>
<h3 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h3><p>Successful remote work is not just up to the employees. Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”<br>远程工作的成功不仅仅取决于员工。公司和管理者们必须做出额外的努力来展示透明度和建立信任，因为不在同一屋檐下共事，就无法享受轻松面谈和肢体语言的便利。远程工作需要心理安全感，这意味着经理们必须做好准备展现自己的脆弱一面。如果管理者乐于分享自己的难处，那么员工也就会乐于敞开心扉。亨堡说：“你必须完全信任他人，因为你看不到他们在做什么，必须由他们告诉你才行。”  </p>
]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>背诵</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目二：实现一个自己的计算器程序</title>
    <url>/2020/06/13/geekbang-column-implement-your-own-calculator-program/</url>
    <content><![CDATA[<h2 id="计算器程序的功能设计"><a href="#计算器程序的功能设计" class="headerlink" title="计算器程序的功能设计"></a>计算器程序的功能设计</h2><p>一般计算器功能如下：  </p>
<ul>
<li>第一次出现的变量赋值语句，即为变量定义；  </li>
<li>计算表达式的值。</li>
</ul>
<p>这两个功能，看似简单，可实际要考虑的还很多，例如：变量是否有作用域的限制啊，合法变量名的规则，表达式中支持的运算符种类啊，每一种运算符的优先级，等等。这些需要考虑的细节，每一个都会给我们的项目增加一点点难度。  </p>
<p>为了把难度控制在一个可以实现的范围，我们对计算器功能做进一步的细致描述，同时也是降低项目实现难度，重新修订的功能定义如下：  </p>
<ul>
<li>第一次出现的变量赋值语句，即为变量定义；  </li>
<li>计算表达式的值；  </li>
<li>没有作用域的概念，所有变量都是全局变量；  </li>
<li>变量名只允许 26 个小写的英文字母，也就是说，程序中最多有 26 个变量；  </li>
<li>表达式只支持四则混合运算 +、-、*、&#x2F; 以及 ()；  </li>
<li>表达式中参与运算的值均为正整数，除法规则参考 C 语言整形之间的除法规则；  </li>
<li>变量赋值语句和表达式语句，均各占一行。</li>
</ul>
<p>样例输入：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 3</span><br><span class="line">b = a * 3 + 5</span><br><span class="line">(a + 4) * (b + 5)</span><br></pre></td></tr></table></figure>

<p>可以看到，第 1 行输入，定义了变量 a，同时给 a 变量赋值为 3；第 2 行，定义了变量 b，同时给 b 变量赋值为 a * 3 + 5 的值，也就是 14；第 3 行，是一行表达式，计算的是 (a + 4) * (b + 5) 的值，最后的结果应该等于 7 * 19 &#x3D; 133。  </p>
<p>针对这份输入数据，我们的计算器程序分别输出每行表达式对应的值，也就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">14</span><br><span class="line">133</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树，就是每个节点下面最多有两个子节点的结构。如下图所示，就是一个二叉树结构：  </p>
<p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/erchashu.jpg">  </p>
<p>我们把其中的 A 节点叫做“根节点”，B 和 C 是 A 节点的两个“子节点”，同理，E 和 F 是 C 节点的两个子节点，D 是 B 节点的子节点。如果更细致地划分，以 B 为根节点的子树，处于 A 节点的左侧，所以称为 A 节点的左子树，C 称为 A 节点的右子树。反过来，我们把 A 节点称为 B 和 C 节点的父节点，同时它也是 D、E、F 节点的祖先节点。  </p>
<h3 id="三种遍历方式"><a href="#三种遍历方式" class="headerlink" title="三种遍历方式"></a>三种遍历方式</h3><p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/bianlifangshi.jpg">  </p>
<p>每一种遍历的方式，都是采用递归的定义方式。而所谓的前、中、后序遍历，其实说的是根节点的位置：根节点在左右子树遍历之前，那就是前序遍历；夹在左右子树中间，就是中序遍历；位于左右子树遍历之后，那就是后序遍历。  </p>
<p>如果我们将上上图中的二叉树结构，分别按照三种方式进行遍历，会得到如下所示的遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前序遍历：A B D C E F</span><br><span class="line">中序遍历：D B A E C F</span><br><span class="line">后序遍历：D B E F C A</span><br></pre></td></tr></table></figure>

<p>注意，在写某一种遍历结果的时候，一定是按照递归展开的方式。例如：  </p>
<p>在中序遍历中，我们是将根节点左子树所形成的中序遍历结果（D B），放在根节点 A 的左侧，然后是根节点 A，接着是根节点右子树的中序遍历结果（E C F）。所以最后，整棵树的中序遍历结果就是 D B A E C F。  </p>
<h2 id="思维利器：表达式树"><a href="#思维利器：表达式树" class="headerlink" title="思维利器：表达式树"></a>思维利器：表达式树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>任何一个四则混合运算的表达式，都能转换成相对应的二叉树，而原表达式的值，等于对应二叉树的后序遍历结果。例如，下图就是一个加法表达式和它所对应的表达式树：  </p>
<p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/biaodashishu.jpg">  </p>
<p>在表达式树中，根节点就是运算符 +(加号)，加号的左子树是数字 3，右子树是数字 5。根据刚刚所说的对应规则，在表达式树上，按照后序遍历的顺序，得到的就是表达式的值。图 3 中的表达式树，首先遍历得到左子树的数字 3，再遍历得到右子树的数字 5，最后遍历到根节点的运算符 +(加号)，就将左右子树的值做加法，得到原表达式的结果 8。  </p>
<p>我们来看一个稍微复杂一点儿的表达式，以及它所对应的表达式树。  </p>
<p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/fuza-biaodashishu.jpg">  </p>
<p>从图中可见，原表达式是 (3 + 5) * (6 - 2)，而其对应的表达式树中，已经没有了括号的影子。因为，图中表达式树的计算顺序应该是这样的：首先计算左子树所代表的 3 + 5 表达式的值，再计算右子树代表的 6 - 2 表达式的值，最后根据根节点的乘法运算，计算得到左右子树的乘积值。  </p>
<p><strong>表达式树的这种计算顺序，与原表达式添加了括号以后的计算顺序等价。</strong>  </p>
<p>综上所述，我们可知，表达式树中越靠近根节点的运算符，优先级越低，而根节点代表了原表达式中，优先级最低的那个运算符。表达式中原有的括号，其实就是用来控制运算符之间的计算顺序的，这种计算顺序，对应的就是表达式树中的父子节点关系，这就是我们刚刚所说的，原表达式中的括号，被转换成了等价的树形结构关系的含义。  </p>
<h3 id="利用这种思维，解决表达式计算问题"><a href="#利用这种思维，解决表达式计算问题" class="headerlink" title="利用这种思维，解决表达式计算问题"></a>利用这种思维，解决表达式计算问题</h3><p>任何一个表达式，都对应一个等价的表达式树。而这个表达式树的根节点所对应的，就是原表达式中最后一个被计算的运算符。如果我们可以找到这个运算符在原表达式中的位置，那么这个运算符所的左边部分，对应的就是表达式树根节点的左子树，运算符的右边部分，对应的就是表达式树根节点的右子树。  </p>
<p>我们用 String 代表原表达式字符串，op 代表整个表达式中最后一个被计算的运算符，L_String 是 op 运算符左边的字符串，R_String 就是右边的字符串。  </p>
<p>假设，我们有一个函数 get_val(String)，可以得到 String 所代表的表达式的值。那么关于 get_val(String)，我们就可以得到如下递推关系：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_val(String) = get_val(L_String) op get_val(R_String)</span><br></pre></td></tr></table></figure>

<p>也就是当前表达式的值，等于左边表达式的值与右边表达式的值之间的运算结果。举例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_val(&quot;(3+5)*(6-2)&quot;) = get_val(&quot;(3+5)&quot;) * get_val(&quot;(6-2)&quot;)</span><br></pre></td></tr></table></figure>

<p>如果我们能确定，表达式字符串中最后一个被计算的运算符的位置，我们就可以把原表达式字符串分成两部分，进行递归求解。所以，<strong>找到最后一个被计算的运算符的位置，才是我们完成程序的关键。</strong>  </p>
<h2 id="确定运算符顺序的技巧"><a href="#确定运算符顺序的技巧" class="headerlink" title="确定运算符顺序的技巧"></a>确定运算符顺序的技巧</h2><p>问：怎么确定表达式中每一个运算符的计算顺序呢？<br>答：可以通过给每个运算符赋予一个权重，权重越高，代表计算优先级越高。  </p>
<p>问：怎么设置权重？<br>答：根据四则混合运算的基础规则，我们可以给 +、-、<em>、&#x2F; 运算符设定一个基础权重，例如，+、- 权重是 1，</em>、&#x2F; 权重是 2；另外，可以对括号里面的所有运算符，额外加上一个很大的权重。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>二叉树的三种遍历方式：前序遍历、中序遍历与后序遍历，它们主要是依据根节点的位置划分出来的。  </li>
<li>我们掌握了表达式与其对应的表达式树的对应关系。  </li>
<li>表达式树的后续遍历结果，就等于原表达式的值。这种特性，给我们设计表达式求值程序，提供了思维方面的指导。</li>
</ul>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 计算表达式 str 从 l 到 r 位置的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * pos : 根节点运算符的位置，初始化为 -1</span></span><br><span class="line"><span class="comment">    * priority : 根节点运算符的权重</span></span><br><span class="line"><span class="comment">    * temp : 由括号产生的额外权重</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">-1</span>, priority = INF - <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur_priority = INF;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: temp += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: temp -= <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cur_priority = <span class="number">1</span> + temp;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: cur_priority = <span class="number">2</span> + temp;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * cur_priority : 当前运算符的优先级</span></span><br><span class="line"><span class="comment">        * 更新区间内最低优先级的运算符的位置</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_priority &lt;= priority) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            priority = cur_priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果 pos == -1，说明这一段表达式中没有运算符</span></span><br><span class="line"><span class="comment">    * 说明，这一段表达式中只有数字，也就是递归到了树的叶子结点</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 递归计算得到运算符左边及右边表达式的值</span></span><br><span class="line"><span class="comment">    * 再根据当前运算符，得到当前表达式的值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">int</span> a = calc(str, l, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">switch</span> (str[pos]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_val</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, str) != EOF) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, str, get_val(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/geektime-practice/calc">项目地址</a>  </p>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>计算器</tag>
        <tag>二叉树</tag>
        <tag>表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目一：实现一个自己的测试框架</title>
    <url>/2020/06/13/geekbang-column-implement-your-own-testing-framework/</url>
    <content><![CDATA[<h2 id="实现测试框架前的准备"><a href="#实现测试框架前的准备" class="headerlink" title="实现测试框架前的准备"></a>实现测试框架前的准备</h2><h3 id="初识：Google-测试框架"><a href="#初识：Google-测试框架" class="headerlink" title="初识：Google 测试框架"></a>初识：Google 测试框架</h3><p>Google 开发的单元测试框架 Google Test，我们一般称它为 gtest。  </p>
<p>测试代码  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数字 x 是否是素数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个测试用例</span></span><br><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个测试用例</span></span><br><span class="line">TEST(test2, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure>

<p>先看输出内容的第 4 行和第 6 行，意思是说，执行测试用例 test_is_prime.test1 和 test_is_prime.test2，这不就是上面两个以 TEST 开头的两段代码相关的输出内容么？  </p>
<p>接下来从第 7 行到第 21 行是一段报错信息，意思就是说 is_prime(4)，is_prime(0) 与 is_prime(1) 函数返回值错误，也就意味着 is_prime 函数实现有错误，这段错误所涉及的信息，在源代码中的第二个测试用例中有涉及。  </p>
<h3 id="对于-gtest-的三个思考"><a href="#对于-gtest-的三个思考" class="headerlink" title="对于 gtest 的三个思考"></a>对于 gtest 的三个思考</h3><p>面对刚才的演示代码和输出内容，你可能会产生如下三个问题：  </p>
<ul>
<li>1，代码中的 EXPECT_EQ 是做什么的？  </li>
<li>2，以 TEST 开头的代码段，和我们学习的函数很不一样，那它究竟是什么？  </li>
<li>3，主函数中只调用了 RUN_ALL_TESTS 函数，为什么好像是执行了程序中所有的 TEST 代码段？这个功能是怎么实现的？</li>
</ul>
<p>第一个问题不难，查看相关 gtest 的文档资料，你就可以知道，EXPECT_EQ 是 gtest 里面自带的宏，主要作用是判断传入的两部分的值是否相等。如果不相等，就会产生类似于输出内容中第 7 行到第 21 行的输出内容。  </p>
<p>第二个问题，以 TEST 开头的这段代码，明显不符合我们对 C 语言的语法认知，我们确实没有见过不用规定返回值类型，也不用规定参数类型的函数定义方式。关于 TEST 究竟是个什么的问题，更加合理的猜测，就是 TEST 实际上是一个宏。  </p>
<p><strong>宏的作用，是做简单的替换。</strong>正是因为 TEST(test_is_prime, test1) 这段代码实际上是一个宏，所以展开以后，和后面的大括号中的内容一起组成了一段合法的代码内容。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>测试行为，不是测试工程师的专属，你应该把它作为一个开发工程师的习惯。  </li>
<li>单元测试属于白盒测试范畴，Google 的 gtest 就是一种辅助我们编写单元测试的框架。  </li>
<li>gtest 中的 TEST 本质上是一个宏，而这个宏应该展开成怎样的代码内容，还需要你认真思考，这个思考过程对你来说是很有价值的。</li>
</ul>
<h2 id="实现一个自己的测试框架"><a href="#实现一个自己的测试框架" class="headerlink" title="实现一个自己的测试框架"></a>实现一个自己的测试框架</h2><h3 id="初步实现-TEST-宏"><a href="#初步实现-TEST-宏" class="headerlink" title="初步实现 TEST 宏"></a>初步实现 TEST 宏</h3><p>我们实现的所有代码，都会写在一个名字为 <code>geek_test.h</code>的头文件中。(注意：将声明和定义写在一起，在大型工程中是会出现严重的编译错误，在实际的工程开发中，我们并不会这么做。)  </p>
<p>我们的目的，是在不改变这份源代码的前提下，通过在 geek_test.h 中添加一些源码，使得这份代码的运行效果，能够类似于 gtest 的运行效果。  </p>
<p>想要完成这个目标，我们就要先来思考 TEST 宏这里的内容，请你仔细观察这段由 TEST 宏定义的测试用例的相关代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TEST(test1, test_is_prime) 这部分应该是在调用 TEST 宏，而这部分被预处理器展开以后的内容，只有和后面大括号里的代码组合在一起，才是一段合法的 C 语言代码，也只有这样，这份代码才能通过编译。既然如此，我们就不难想到，TEST 宏展开以后，它应该是一个函数定义的头部，后面大括号里的代码，就是这个展开以后的函数头部的函数体部分，这样一切就都说得通了。  </p>
<p>在实现 TEST 宏之前，我们还需要想清楚一个问题：由于程序中可以定义多个 TEST 测试用例，如果每一个 TEST 宏展开都是一个函数头部的话，那这个展开的函数的名字是什么呢？如果每一个 TEST 宏展开的函数名字都一样，那程序一定无法通过编译，编译器会报与函数名重复相关的错误，所以， TEST 宏是如何确定展开函数的名字呢？  </p>
<p>注意，TEST 宏需要传入两个参数，这两个参数在输出信息中与测试用例的名字有关。那我们就该想到，可以使用这两个参数拼接出一个函数名，只要 TEST 传入的这两个参数不一样，那扩展出来的函数名就不同。最后，我们就可以初步得到如下的 TEST 宏的一个实现：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name()</span></span><br></pre></td></tr></table></figure>

<p>如代码所示的 TEST 宏实现，我们将 TEST 宏的两个参数内容使用 ## 连接在一起，中间用一个额外的下划线连接，组成一个函数名字，这个函数的返回值类型是 void，无传入参数。根据这个实现，预处理器会将源代码中两处 TEST 宏的内容，替换成如下代码所示内容：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1_test_is_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2_test_is_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="attribute-：让其它函数先于主函数执行"><a href="#attribute-：让其它函数先于主函数执行" class="headerlink" title="__attribute__：让其它函数先于主函数执行"></a>__attribute__：让其它函数先于主函数执行</h3><p>先，我们先来看如下代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_output</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello geek!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello main!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行以后，会输出一行字符串 “hello main!”。  </p>
<p>接下来呢，我们对上述代码稍微修改，在 pre_output 函数前面加上__attribute__((constructor)) 。这样，pre_output 函数就会先于主函数执行，代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_output</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello geek!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello main!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码执行以后，程序会输出两行内容，第 1 行是 pre_output 函数输出的内容 “hello geek!”，第 2 行才是主函数的执行输出内容 “hello main!”。  </p>
<p>从输出内容可以看出，<strong>加了__attribute__((constructor)) 以后，pre_output 函数会先于 main 主函数执行。</strong>  </p>
<h3 id="RUN-ALL-TESTS-函数设计"><a href="#RUN-ALL-TESTS-函数设计" class="headerlink" title="RUN_ALL_TESTS 函数设计"></a>RUN_ALL_TESTS 函数设计</h3><p>从主函数中调用 RUN_ALL_TESTS 函数的方式来看，RUN_ALL_TESTS 函数应该是一个返回值为整型的函数。这样，我们可以得到这样的函数声明形式：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RUN_ALL_TESTS</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>从测试框架的执行输出结果中看，RUN_ALL_TESTS 函数可以依次性地执行每一个 TEST 宏扩展出来的测试用例函数，这是怎么做到的呢？  </p>
<p>我们可以这样认为：在主函数执行 RUN_ALL_TESTS 函数之前，有一些函数过程，就已经把测试用例函数的相关信息，记录在了一个 RUN_ALL_TESTS 函数可以访问到的地方，等到 RUN_ALL_TESTS 函数执行的时候，就可以根据这些记录的信息，依次性地执行这些测试用例函数。整个过程，如下图所示：  </p>
<p><img src="/2020/06/13/geekbang-column-implement-your-own-testing-framework/run-all-test.jpg">  </p>
<p>图中红色部分，就是我们推测的，某些完成测试用例函数信息注册的函数，它们先于主函数执行，将测试用例的信息，写入到一个公共存储区中。  </p>
<p>接下来，我们需要考虑的就是这些注册函数，究竟将什么信息存储到了公共存储区中，才能使得 RUN_ALL_TESTS 函数可以调用到这些测试用例？你自己也可以想想是什么。答案就是这个信息是测试用例函数的函数地址，因为只有把函数地址存储到这个存储区中，才能保证 RUN_ALL_TESTS 函数可以调用它们。所以，这片公共存储区，就应该是一个函数指针数组。  </p>
<p>那如何解决注册函数问题呢？最简单直接的设计方法，就是每多一个由 TEST 宏定义的测试用例，就配套一个注册函数，所以这个注册函数的逻辑，可以设计在 TEST 宏展开的内容中。这就需要我们对 TEST 宏进行重新设计。  </p>
<p>我们先来完成 RUN_ALL_TESTS 函数从存储区中，读取并执行测试用例的过程：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">test_function_t</span>)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">test_function_t</span> test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> test_function_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RUN_ALL_TESTS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RUN TEST : %d\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        test_function_arr[i]();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RUN TEST DONE\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中用到了函数指针相关的技巧，其中 test_function_t 是我们定义的函数指针类型，这种函数指针类型的变量，可以用来指向返回值是 void，传入参数为空的函数。  </p>
<p>之后，定义了一个有 100 位的函数指针数组 test_function_arr，数组中的每个位置，都可以存储一个函数地址，数组中元素数量，记录在整型变量 test_function_cnt 中。这样，RUN_ALL_TESTS 函数中的逻辑就很简单了，就是依次遍历函数指针数组中的每个函数，然后依次执行这些函数，这些函数每一个都是一个测试用例。  </p>
<h3 id="重新设计：TEST-宏"><a href="#重新设计：TEST-宏" class="headerlink" title="重新设计：TEST 宏"></a>重新设计：TEST 宏</h3><p>根据前面的分析，TEST 扩展出来的内容，不仅要有测试用例的函数头部，还需要有先于主函数执行的注册函数，主要用于注册 TEST 扩展出来的测试用例函数。由此，我们可以得出如下示例代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name(); \</span></span><br><span class="line"><span class="meta">__attribute__((constructor)) \</span></span><br><span class="line"><span class="meta">void register_##test_name##_##func_name() &#123; \</span></span><br><span class="line"><span class="meta">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span></span><br><span class="line"><span class="meta">    test_function_cnt++; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name()</span></span><br></pre></td></tr></table></figure>

<p>这个新设计的 TEST 宏，除了末尾保留了原 TEST 宏内容以外，在扩展的测试用例函数头部添加了一段扩展内容，这段新添加的扩展内容，会扩展出来一个函数声明，以及一个以 register 开头的会在主函数执行之前执行的注册函数；注册函数内部的逻辑很简单，就是将测试函数的函数地址，存储在函数指针数组 test_function_arr 中，这部分区域中的数据，后续会被 RUN_ALL_TESTS 函数使用。  </p>
<p>如果以如上 TEST 宏作为实现，原程序中的两个测试用例代码，会被展开成如下样子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1_test_is_prime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_test1_test_is_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    test_function_arr[test_function_cnt] = test1_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1_test_is_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2_test_is_prime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_test2_test_is_prime</span><span class="params">()</span> &#123; </span><br><span class="line">    test_function_arr[test_function_cnt] = test2_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2_test_is_prime</span><span class="params">()</span> &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就算是初步完成了测试框架中关键的两个部分的设计：一个是 TEST 宏，另外一个就是 RUN_ALL_TESTS 函数。它们同时也是串起测试框架流程最重要的两部分。  </p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>attribute</strong>((constructor)) 可以修饰函数，使修饰的函数先于主函数执行。  </li>
<li>RUN_ALL_TESTS 之所以可以获得程序中所有测试用例的函数信息，是因为有一批注册函数，将测试用例函数记录下来了。  </li>
<li>通过测试框架这个项目，我们再一次看到，宏可以将原本看似不合理的代码，变得合理。</li>
</ul>
<p><a href="https://github.com/geektime-practice/mygtest">项目地址</a>  </p>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>框架</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>判断与循环_给程序加上处理逻辑</title>
    <url>/2020/05/21/geekbang-column-judge-and-loop-add-processing-logic-to-your-program/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果我给你一个由年月日组成的日期，再给你一个数字 X，你能否准确地让程序输出 X 天后的日期呢？<br>例如  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1989 11 20</span><br><span class="line">20</span><br><span class="line">1989 12 10</span><br></pre></td></tr></table></figure>

<p>数据中给出了 1989 年 11 月 20 日这个日期，然后问你 20 天后的日期是多少，你的程序应该输出 1989 年 12 月 10 日。特别需要注意的是，在这个任务中，你需要考虑到闰年中 2 月份的特殊性，闰年的 2 月有 29 天。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>首先需要有一个循环，循环每一次，让计算机帮我们计算一次下一天的日期。</li>
<li>每次在计算下一天日期的过程中，先让日子加1，判断是否跨月，如果跨过了一个月份，就让日子从1开始，让月份加1，再判断是否跨年，如果跨年了，就让月份从1开始，年份加1。  </li>
<li>注意2月份的月份天数的计算方法。<br>闰年的判断方法，满足其一即可：能被4整除，但不能被100整除；能被400整除。因此代码逻辑应该是这样  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> y, m, d, X; <span class="comment">// 定义存储 年月日 和 X 的变量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;y, &amp;m, &amp;d); <span class="comment">// 读入年月日</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X); <span class="comment">// 读入 X 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123; <span class="comment">// 循环 X 次，每次向后推一天</span></span><br><span class="line">        d += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (m) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:&#123; <span class="comment">// 第一部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">31</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">13</span>) m = <span class="number">1</span>, y += <span class="number">1</span>;</span><br><span class="line">            &#125;; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>: &#123; <span class="comment">// 第二部分逻辑 </span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">30</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// 第三部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d &gt; <span class="number">29</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">28</span>) &#123;</span><br><span class="line">                    d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, y, m, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，打印乘法表"><a href="#1，打印乘法表" class="headerlink" title="1，打印乘法表"></a>1，打印乘法表</h3><blockquote>
<p>使用循环和条件判断，打印一个格式优美的 66 乘法表<br>要求 1：输出内容及样式参照下面给出的样例<br>要求 2：每两列之间用 \t 字符进行分隔，行尾无多余 \t 字符  </p>
</blockquote>
<p>例子  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2  2*2=4</span><br><span class="line">1*3=3  2*3=6  3*3=9</span><br><span class="line">1*4=4  2*4=8  3*4=12  4*4=16</span><br><span class="line">1*5=5  2*5=10  3*5=15  4*5=20  5*5=25</span><br><span class="line">1*6=6  2*6=12  3*6=18  4*6=24  5*6=30  6*6=36</span><br></pre></td></tr></table></figure>

<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;  <span class="comment">//外层循环控制行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;  <span class="comment">//内层循环控制每一行的列数</span></span><br><span class="line">            <span class="comment">//第 i 行应该有 i 列，所以内层循环是从 1 循环到 i 为止。</span></span><br><span class="line">            j == <span class="number">1</span> || <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);  <span class="comment">//如果左边条件不满足，就不会执行右边的的代码，所以：第一列前面不会多输出一个 \t 字符。而其他的情况呢，均会执行 printf(&quot;\t&quot;) 代码        </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d&quot;</span>, j, i, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>判断</tag>
        <tag>循环</tag>
        <tag>switch语句</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识数据结构：链表结构和思维</title>
    <url>/2020/06/03/geekbang-column-linked-list-structure-and-thinking/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>首先，我们定义一种数字名称，叫做“快乐数”。所谓快乐数就是经过有限次变换以后，等于 1 的数字。这个变换规则，给出一个非 1 的数字 a ，把它的位数拎出来，求各个位数的平方和，得到一个数字 b，如果数字 b 不是 1，那就对数字 b 的每一位数再做平方和，得到数字 c……经过不停的变换，确定最后能否得到 1。  </p>
<p>例如，一开始的数字是 19，经过变换规则 12+92&#x3D;82，得到数字 82；因为不是 1 ，所以接着做变换，就是 82+22&#x3D;68，再做一次变换 62+82&#x3D;100，最后一次做变换 12+02+02&#x3D;1，得到了 1 以后，停止。  </p>
<p>注：<a href="https://leetcode-cn.com/problems/happy-number/">此题LeetCode链接</a>  </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>首先，我们知道，整型表示的最大值是 231−1，大约是 20 亿左右。  </li>
<li>例如，从 19 开始，依次得到的是：82、68、100、1 这些数字。也就是说，从一个数字开始，按照快乐数的计算规则，会得到一串数字序列。这其中就蕴含着链表重要的结构思维：<strong>从当前节点，唯一映射到下一个节点。快乐数序列中的数字，就是链表中的节点，如果当前数字确定了，下一个数字也就是确定了的，就像数字 19，下一个肯定是数字 82，这种映射规则，就是链表节点之间的指向关系。</strong>  </li>
<li>思维映射：所谓快乐数序列，最终的目标是能到 1，这个数字 1，其实就可以看成是链表中的空地址。</li>
<li>在整型范围内解决快乐数问题的话，1999999999 这个数字，按照各位平方和来进行计算，得到的下一个数字应该是 (9∗9^2+1)&#x3D;730————&gt;这个快乐数链表中，节点数量绝对不会超过 731 个。一个不超过 731 个节点的链表，还总也走不到末尾，说明这个链表中有环。  </li>
<li>因此，<strong>判断一个数字是否是快乐数，等价于判断链表中是否有环。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// p 是慢指针，q 是快指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> head, *q = head;</span><br><span class="line">    <span class="comment">// 每次循环，p 走1步，q 走2步</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != q &amp;&amp; q); </span><br><span class="line">    <span class="keyword">return</span> p == q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><p>有如下函数接口定义：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node *<span class="title function_">erase</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> ind)</span>;</span><br></pre></td></tr></table></figure>

<p>请你参照链表插入操作，实现一个链表节点删除的操作，删除函数传入两个参数，分别代表指向链表头结点的指针变量 head，以及要删除的节点位置 ind，返回值代表删除节点以后的链表头结点地址。  </p>
<p>代码  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node *<span class="title function_">erase</span><span class="params">(strcut Node *head, <span class="type">int</span> ind)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">ret</span>, *<span class="title">p</span> =</span> &amp;ret, *q;</span><br><span class="line">    ret.next = head;</span><br><span class="line">    <span class="keyword">while</span> (ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist.jpg">  </p>
<h3 id="如何求解环的长度，如上图，环的长度就是5"><a href="#如何求解环的长度，如上图，环的长度就是5" class="headerlink" title="如何求解环的长度，如上图，环的长度就是5"></a>如何求解环的长度，如上图，环的长度就是5</h3><p>如果链表中有环，那么采用快慢指针的方法，两个指针一定会在环中相遇。此时，可以让其中一个指针不动，另外一个指针再沿着环走一圈，直到两个指针再次相遇，这样，就能得到环的长度了。  </p>
<h3 id="如何找到环的起点，如上图，3号点就是环的起点"><a href="#如何找到环的起点，如上图，3号点就是环的起点" class="headerlink" title="如何找到环的起点，如上图，3号点就是环的起点"></a>如何找到环的起点，如上图，3号点就是环的起点</h3><p>首先，假设从链表起始点到环的起点距离为 x，那么当快慢指针中的慢指针 p 刚刚走到环的起始点位置的时候，q 指针应该在环内部距离环起始点 x 的位置上，如图所示：  </p>
<p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist2.jpg">  </p>
<p>图中，q 指针距离环起始点 x 步，q 指针沿着链表向前走 y 步，就又可以到达环的起始点位置，如图所示 x + y 等于环长。也就是说，q 指针想要遇到 p 指针，就必须要追上 y 步的距离，又因为 p 指针每次走 1 步，q 指针每轮走 2 步，所以 q 指针每轮追上 1 步，也就是说，从此刻开始，当 q 指针追上 p 指针的时候，p 指针正好向前走了 y 步，如图所示：  </p>
<p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist3.jpg">  </p>
<p>此时，你会发现  p 点在环中走了 y 步以后，p 和 q 相遇了，也就意味着  p 点再走 x 步就到环的起始点了。而恰巧，从链表头结点开始到环的起始点也是 x 步，所以此时只需要让 p 站在相遇点，q 指针回到链表的起始点，然后两个指针以相同的速度，一起往后走，直到二者再次相遇的时候，相遇点就是环的起始点了。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>数据结构 &#x3D; 结构定义 + 结构操作，这个等式说明了我们学习数据结构的方法顺序。  </li>
<li>单向链表节点中，存在数据域和指针域，指针域控制了链表的结构，一般不会根据应用场景的变化而变化，而数据域是根据应用场景的需求而设计的。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数学归纳法：搞定循环与递归的钥匙</title>
    <url>/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现一个可变循环层数的程序。  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们可以一开始假设，有一个函数，是实现 5 层循环打印的程序，那么它会循环 n 次，每次调用一个实现 4 层循环打印的程序。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码框架</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_loop</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//代表 k 层循环的程序，然后循环 n 次，每次调用一个 k - 1 层循环的程序。</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完善程序  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入参：</span></span><br><span class="line"><span class="comment">total_k，代表了一共有多少层循环，这个参数是为了方便我们最后确定循环输出的上界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_loop</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> total_k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = total_k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != total_k) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[k] = i;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n, total_k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段程序中，fib 函数是求菲波那契数列第 n 项值的函数。菲波那契数列的定义如下：<br><img src="/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/fib.jpg"><br>根据如上内容，你需要完成两个小的思考题：</p>
<h3 id="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"><a href="#1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。" class="headerlink" title="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"></a>1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归写法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (n == 1 || n == 2) return 1; // 终止条件 -- 数学归纳法step1</span></span><br><span class="line"><span class="comment">        return fib(n-1) + fib(n-2); // 处理过程 -- 数学归纳法step2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写法</span></span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"><a href="#2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。" class="headerlink" title="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"></a>2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//数学归纳法中所谓的 k0​ 成立，这一步保证了，fib 函数计算的第 1 项 和 第 2 项的斐波那契函数值一定是正确的。</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  <span class="comment">//数学归纳法中的第二步，假设 ki​ 成立，证明 ki+1​ 也成立。</span></span><br><span class="line">    <span class="comment">//最后结论，这个fib 递归函数设计是正确的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>数学归纳法中重要的两部分，一是要边界条件成立，二是证明转移过程成立。  </li>
<li>程序设计最重要的是正确性，递归函数的正确性可以利用数学归纳法来保证。  </li>
<li>递归程序设计中的重要的两部分：边界条件和处理过程。所谓边界条件，就是当递归函数中的参数等于多少的时候，可以直接返回的条件。处理过程呢，就是设计程序过程，处理递归调用的返回结果，根据递归调用的返回结果，得到本函数的结果。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>循环</tag>
        <tag>数学</tag>
        <tag>归纳</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>指针系列_指针变量也是变量</title>
    <url>/2020/05/23/geekbang-column-pointer-variables-are-also-variables/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有如下结构体数组，请看如下代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>请用尽可能多的形式，替换下面代码中 &amp;a[1].x 的部分，使得代码效果不变：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> =</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;a[<span class="number">1</span>].x);</span><br></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="方法一，间接引用"><a href="#方法一，间接引用" class="headerlink" title="方法一，间接引用"></a>方法一，间接引用</h3><p>减号大于号（-&gt;），组合起来，叫做“间接引用”运算符，作用可以和“直接引用”运算符对比。  </p>
<p>例如：a 是一个结构体变量，a 中有一个字段叫做 x，由 a 去找到 x，这个过程比较直接，我们就用 a.x 来表示。可如果 p 是一个指针，指向 a 变量，如果要是由 p 去找到 x，这个过程就是个间接的过程，所以我们就使用 p-&gt;x。<br>简单来说，就是：<strong>是结构体变量引用字段，就直接引用，如果是指针想引用字段，就是间接引用。</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> =</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;((a + <span class="number">1</span>)-&gt;x));  <span class="comment">//用a+1定位到第二个结构体元素的首地址，然后间接引用x字段，最后再对 x 字段取地址，那么得到的和原任务中所输出的地址是一样的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二，巧妙使用指针类型"><a href="#方法二，巧妙使用指针类型" class="headerlink" title="方法二，巧妙使用指针类型"></a>方法二，巧妙使用指针类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> =</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;(a[<span class="number">0</span>].y) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure>

<p>利用地址类型这个知识点，先定位到 a[0] 元素中 y 字段的首地址，然后对 y 字段取地址，这个时候，由于 y 字段是整型，所以取到的地址类型就是整型地址，之后再对这个整型地址执行 +1 操作，得到的也是 a[1].x 的首地址。  </p>
<p><img src="/2020/05/23/geekbang-column-pointer-variables-are-also-variables/address.jpg" alt="a数组内存结构示意图">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>可以通过 C 语言里面的工具来描述这种类型的特点，这个可以用来描述和定义新类型的工具，就叫做：结构体。  </li>
<li>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。  </li>
<li>结构体的字段在内存中存储的顺序，是按照结构体定义时的顺序排布的，而且当本存储单元不够安放的时候，就从下个存储单元的头部开始安放。  </li>
<li>指针是变量，指针是一种用来存储地址的变量。  </li>
<li>指针的类型，决定了指针取值时所取的字节数量。  </li>
<li>指针的类型，决定了指针加减法过程中，所跨越的字节数量。  </li>
<li>无论是什么类型的指针，大小都相等，因为地址信息是统一规格的。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>结构体</tag>
        <tag>地址</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解：容斥原理与递推算法</title>
    <url>/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>众所周知，在不计算小于 1 元钱的面额的前提下，我国的纸币系统中，曾经拥有如下面值：1 元、2 元、5 元、10 元、20 元、50 元 和 100 元。假设，每一种面值的纸币，我们都有无限张，现在想用这些钱凑出 1000 元，请问你有多少种不同的方案？  </p>
<p>这里说的不同方案，是不关注钱币之间的顺序的，例如要凑 7 元钱，可以是 1 元、5 元、1 元，也可以是 1 元、1 元、5 元，这两种方案我们视为同一种。  </p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>一般在计数问题中，为了保证计数准确，必须注意两个事情：一是没有重复，二是没有遗漏。  </p>
<p>容斥原理的基本思想：<strong>先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排除出去，使得计算的结果既无遗漏又无重复。简单来说，就是在计算过程中，如果加多了，就把加多的部分减掉，如果发现又减多了，就再加回来一部分，一直到不多不少为止。</strong>  </p>
<p>例如，求 1000 以内，3 或者 5 倍数的所有数字和的问题：  </p>
<p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/3-5set.jpg">  </p>
<h3 id="一个递推算法例子：兔子繁殖问题"><a href="#一个递推算法例子：兔子繁殖问题" class="headerlink" title="一个递推算法例子：兔子繁殖问题"></a>一个递推算法例子：兔子繁殖问题</h3><p>假设在一片草原上，莫名其妙来了一只外星兔子，这种外星兔子呢，第一个月的时候是幼体，第二个月成长为成体，从第三个月开始，成体兔子每个月都会产生出一只克隆体的幼体兔子，而且这种兔子不会衰老，一旦成体以后，就会一直生下去。按照这种情况，请你计算出第 n 个月，草原上有多少只兔子？  </p>
<p>给出前 6 个月，草原上兔子数量的情况：  </p>
<p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/6month-tuzi.jpg">  </p>
<p>第6个月的兔子数量与前两个月兔子数量关系：  </p>
<p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/guanxi.jpg">  </p>
<p>由于：第 6 个月的成兔数量等于第 5 个月的兔子总数，第 6 个月的幼兔数量等于第 4 个月的兔子总数，因此可以得出这样的一个结论：<strong>第 n 个月的兔子总数，等于该月的成兔数量与幼兔数量之和，也就等于第 n - 1 个月的兔子数量与第 n - 2 个月的兔子数量之和。</strong>  </p>
<h3 id="递推问题求解步骤，以兔子繁殖问题为例"><a href="#递推问题求解步骤，以兔子繁殖问题为例" class="headerlink" title="递推问题求解步骤，以兔子繁殖问题为例"></a>递推问题求解步骤，以兔子繁殖问题为例</h3><p><strong>递推问题，通常分成三步进行求解。第一步，确定递推状态，也叫做状态定义；第二步，推导递推公式；最后一步，程序设计与编写。</strong>  </p>
<h4 id="确定递推状态"><a href="#确定递推状态" class="headerlink" title="确定递推状态"></a>确定递推状态</h4><p>确定一个有明确含义的数学符号，这里重要的是这个明确含义，而非那个数学符号。  </p>
<p>先分析问题中的自变量和因变量。自变量，就是问题中那些不受控制的量，就像兔子繁殖问题中的月份。而因变量就是那些随自变量改变而改变的量，就像兔子繁殖问题中兔子的数量，是随着月份而改变的。  </p>
<p>所以，<strong>我们把和问题求解量相关的自变量，都作为数学符号中的参数，然后将相关问题求解量作为数学符号映射值。</strong>f(n)代表第n个月兔子的数量，在这个状态定义中，将问题求解量，也就是兔子数量，作为函数映射值的含义；而与问题求解量，即兔子数量相关的自变量只有一个，那就是月份，所以我们将月份作为函数的参数。  </p>
<h4 id="推导递推公式"><a href="#推导递推公式" class="headerlink" title="推导递推公式"></a>推导递推公式</h4><p>在推导递推公式的时候，这里需要用到前面我们定义的递推状态，并且，使用时一定要严格遵守递推状态的语义信息。  </p>
<p>例如，在兔子繁殖问题中，如果你想用状态 f(n) 做公式推导的时候，那么 f(n - 1) 就代表了第 n - 1 个月兔子的数量，而 f(n - 2) 就代表第 n - 2 个月兔子的数量。  </p>
<p>一般做递推公式推导的时候，我们主要思考的事情是，当前递推状态和前几项递推状态之间的关系。例如，在兔子繁殖问题中，当我们确定了递推状态 f(n) 以后，通过分析可以得到如下递推公式：  </p>
<p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/ditui.jpg">  </p>
<h4 id="程序设计与编写"><a href="#程序设计与编写" class="headerlink" title="程序设计与编写"></a>程序设计与编写</h4><ul>
<li>1，使用循环的程序实现方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal_rabbit_num_loop</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2，使用递归的程序实现方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal_rabbit_num</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal_rabbit_num(n - <span class="number">1</span>) + cal_rabbit_num(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="凑钱币问题解决"><a href="#凑钱币问题解决" class="headerlink" title="凑钱币问题解决"></a>凑钱币问题解决</h3><ul>
<li><p>第一步，让我们来确定递推状态。确定递推状态之前，我们需要分析清楚题目中的自变量与因变量。因变量比较好分析，就是方案总数，那这个方案总数都受什么影响呢？很明显，是钱币的种类和拼凑目标金额。也就是说，钱币种类发生变化，方案总数就会发生变化；同理，如果拼凑的目标金额发生变化，方案总数也一定会发生变化。所以，自变量是 2 个，钱币种类和拼凑的钱币数量。因变量是 1 个，就是方案总数。通过上面的分析，我们就可以列出状态定义：f(i, j) ，代表使用前 i 种钱币，拼凑 j 元钱的方案总数。例如，f[3][10] 就代表使用前 3 种钱币，也就是只使用 1 元、2 元、5 元，凑 10 元钱的方案总数。<br>通过上面的分析，我们就可以列出状态定义：f(i, j) ，代表使用前 i 种钱币，拼凑 j 元钱的方案总数。例如，f[3][10] 就代表使用前 3 种钱币，也就是只使用 1 元、2 元、5 元，凑 10 元钱的方案总数。</p>
</li>
<li><p>第二步，就是用这个状态定义，进行递推公式推导，关键就是分析当前项与前几项的关系。核心思想其实就是容斥原理，也就是用某几项表示 f(i, j) ，如果发现这些表示 f(i, j) 的项之间存在交集，就将交集部分减去，如果减多了再加回来一些，直到正好表示 f(i, j) 为止。<br>好在这道题目还算是一道简单的递推问题，我们可以将 f(i, j) 划分成性质不同且互为补集的两部分。在 f(i, j) 所代表的所有方案中，一部分方案是使用了第 i 种钱币的，另外一部分方案中是没有使用第 i 种钱币的，我们就用这个性质，将 f(i, j) 表示成两项相加之和的形式。<br>例如，在用前三种钱币，拼凑 10 元钱的所有方案中，可以按照方案中是否使用第 3 种钱币，也就是是否使用了 5 元钱，将所有方案划分成两类。<br>其中一类方案不包含第 3 种钱币，也就是不用 5 元这个钱币，这些方案的数量，等价于使用前 2 种钱币拼凑 10 元钱的方案总数，也就是 f[2][10] 的值。另外一类方案中，使用了至少 1 张 5 块钱，那么我们可以在这些方案中，都拿掉一张 5 元钱，剩余的部分组成的方案数量，就等于 f[3][5]，也就是用前 3 种钱币凑 5 元钱的方案总数。</p>
</li>
</ul>
<p><strong>这样我们就推导出了递推公式：f[3][10] &#x3D; f[2][10] + f[3][5]。</strong>  </p>
<p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/couqianbi.jpg">  </p>
<p>在 f(i, j) 代表的所有方案中，没有使用第 i 种钱币，拼凑 j 元钱的方案数量，就是 f(i - 1, j)，代表使用前 i - 1 种钱币拼凑 j 元钱的方案总数。剩下的使用了第 i 种钱币的方案中，由于都存在第 i 种钱币至少 1 张，假设第 i 种钱币的面额是 val[i]，也就意味着，我们可以使用前 i 种钱币，凑 j - val[i] 的钱数，给第 i 种钱币留出一个位置，这么做所对应的方案总数就是 f(i, j - val[i])。  </p>
<p>最终，我们推导出了递推公式：**f(i, j) &#x3D; f(i - 1, j) + f(i, j - val[i])**。其中，边界条件是 f(1, k * val[1]) &#x3D; 1，也就是用在只使用第 1 种钱币的条件下，想要凑第 1 种钱币的整数倍面额的方案总数都是 1。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cal_coins</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j % val[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal_coins(i - <span class="number">1</span>, j) + cal_coins(i, j - val[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cal_coins(<span class="number">3</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(有bug，待修正)  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>递推问题第一步是要确定递推状态，也就是给出一个数学符号，以及数学符号的相关描述。  </li>
<li>在设计递推状态的时候，主要分析自变量与因变量的关系，一般因变量都是问题求解的那个量。  </li>
<li>递推问题的第二步是推导递推公式，而容斥原理的思想，对于这一步的求解，十分重要。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>兔子繁殖</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与单调队列：滑动区间最大值</title>
    <url>/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>滑动区间最大值，就是指在固定区间长度的前提下，在一个序列上，从前到后滑动这个区间窗口，每次窗口内部的最大值，就组成了滑动区间最大值。  </p>
<p>例如，给你如下包含 8 个数字的序列，区间长度设置为 3：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[6 4 2] 10 3 8 5 9 -&gt; 6</span><br><span class="line">6 [4 2 10] 3 8 5 9 -&gt; 10</span><br><span class="line">6 4 [2 10 3] 8 5 9 -&gt; 10</span><br><span class="line">6 4 2 [10 3 8] 5 9 -&gt; 10</span><br><span class="line">6 4 2 10 [3 8 5] 9 -&gt; 8</span><br><span class="line">6 4 2 10 3 [8 5 9] -&gt; 9</span><br></pre></td></tr></table></figure>

<p>滑动区间从数字 6 开始出发，每次向右移动一个数字，同时把左边的一个数字丢出去，保持区间长度为 3，最后移动到数字 9 停止。可以看到，这个序列共包含 8 个数字，所以最后形成的滑动区间最大值共有 6 个，依次是 6、10、10、10、8、9。  </p>
<p>常规解法：采用 O(nm) 的算法来完成，n 是区间长度，m 是窗口长度，就是枚举区间的终止位置，每次扫描区间内部，获得最大值。  </p>
<p><strong>要求解法：时间复杂度降低到 O(n)。</strong>  </p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="初识队列"><a href="#初识队列" class="headerlink" title="初识队列"></a>初识队列</h3><p>先到先得，先入先出，每个元素都是从队列尾部入队，在头部被处理完后再出队。如下图所示：  </p>
<p><img src="/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/queues.jpg">  </p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>单调队列的作用，就是用来维护在队列处理顺序中的区间最大值。维护的就是区间长度为 3 时候的最大值。当一个新的元素入队的时候，它会把其前面违反单调性的元素，都从队列中踢掉，最终将一直维护着一个最大值。  </p>
<h3 id="滑动区间最大值"><a href="#滑动区间最大值" class="headerlink" title="滑动区间最大值"></a>滑动区间最大值</h3><p>本身就是求区间最大值的，所以也符合了单调队列应用的场景：维护在队列处理顺序中的区间最大值。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="type">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interval_max_number</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// a[i] 入队，将违反单调性的从队列 q 中踢出</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[q[tail - <span class="number">1</span>]] &lt; a[i]) tail--;</span><br><span class="line">        q[tail++] = i; <span class="comment">// i 入队</span></span><br><span class="line">        <span class="comment">// 判断队列头部元素是否出了窗口范围</span></span><br><span class="line">        <span class="keyword">if</span> (i - m == q[head]) head++;</span><br><span class="line">        <span class="comment">// 输出区间内最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;interval(%d, %d)&quot;</span>, i - m + <span class="number">1</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; = %d\n&quot;</span>, a[q[head]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部，依次处理数组中的每个元素，每次处理相应元素的时候，涉及到两个过程：  </p>
<ul>
<li>第一个过程，是将当前元素入队。在入队之前，将队列尾部违反单调性的元素都从队列中踢出，这个就是第 7 行 while 过程的作用，之后就是将编号 i 入队即可。这里注意，单调队列里面，存储的是 a 数组的下标，而不是 a 数组的值。其实存储了下标，我们就可以索引到值，而在上一节二分查找的课里面，我们也见识过了，要是存储了值，想要反向索引下标是比较困难的。  </li>
<li>第二个过程，就是判断单调队列头部的元素是否超出了窗口范围，也就是前面我们例子中你的学长毕业的过程，如果元素下标已经超出了窗口范围，就将队列头部元素出队。</li>
</ul>
<p>这样就可以保证，我们每次输出的，就都是滑动窗口内部的区间最大值了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>单调队列应用的场景：就是维护队列处理顺序中的区间最大值。  </li>
<li>定义一种性质，并且维护这种性质。单调队列，维护的就是单调性。  </li>
<li>单调队列处理单个元素的平均时间复杂度为什么是 O(1) 的。假设我们要处理 n 个元素，从整体上来看，每个元素会入队列 1 次，出队列最多也是 1 次，那么 n 个元素的总操作次数不会超过 2×n 次，平均到一个元素上就是 2 次，也就是常数次，记作 O(1) 时间复杂度。由此得知，处理 n 个元素的总时间复杂度，就是 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>滑动区间</tag>
      </tags>
  </entry>
  <entry>
    <title>随机函数：随机实验真的可以算 π 值吗</title>
    <url>/2020/05/22/geekbang-column-random-function/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>圆周率 π 对你来说肯定不是一个陌生的概念，它指的是圆的周长与直径的比值。在古代，数学家们为了计算 π 的精确值想尽方法，可能穷尽一生也不过精确到小数点后几位而已。但到了现在，你可能不相信，只要你知道 π 的定义，就可以利用编程轻易计算出 π 的值。那究竟怎么做到呢？  </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="rand用法"><a href="#rand用法" class="headerlink" title="rand用法"></a>rand用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand() % <span class="number">1000</span>); <span class="comment">// 永远输出固定值</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand() % <span class="number">1000</span>); <span class="comment">// 每次运行都不同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在第 6 行代码里，我们虽然使用了 rand() 函数，可每次运行都将输出同样的值，这是因为我们没有设置随机种子，每次运行时 rand() 函数所记录的起始值都相同，所以每次运行输出的随机值也都相同。  </p>
</li>
<li><p>第 8 行代码中，由于我们根据程序运行时的当前时间设置了随机种子，每次运行程序，第 8 行都将输出不同的值。事实上，如果你在 srand() 函数里面设置一个固定值，每次运行程序，结果也都将是一样的。</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//循环每一次，让计算机帮我们做一次实验</span></span><br><span class="line">        <span class="type">double</span> x = <span class="number">1.0</span> * rand() / RAND_MAX;  <span class="comment">//rand() 随机函数，返回值的范围是[0, RAND_MAX]，通过该表达式计算，我们就得到了一个[0.0, 1.0] 之间的随机值了。</span></span><br><span class="line">        <span class="type">double</span> y = <span class="number">1.0</span> * rand() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span> (x * x + y * y &lt;= <span class="number">1.0</span>) m += <span class="number">1</span>;  <span class="comment">//判断一下随机选择的点，是否在圆内部；如果在，我们就记录一次</span></span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="number">4.0</span> * m / n); <span class="comment">//最后用落在圆里的次数比上总实验次数再乘以 4，就得到了 π 的近似值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">3.141664</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，设计迷你随机函数"><a href="#1，设计迷你随机函数" class="headerlink" title="1，设计迷你随机函数"></a>1，设计迷你随机函数</h3><blockquote>
<p>设计一个循环过程，循环 100 次，以不太明显的规律输出 1～100 中的每个数字。<br>要求 1：规律尽量不明显。<br>要求 2：只能使用循环和最基本的运算，不允许超前使用数组。  </p>
</blockquote>
<p>例如  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 5 15 45 34  1  3  9 27 81 41</span><br><span class="line">22 66 97 89 65 94 80 38 13 39</span><br><span class="line">16 48 43 28 84 50 49 46 37 10</span><br><span class="line">30 90 68  2  6 18 54 61 82 44</span><br><span class="line">31 93 77 29 87 59 76 26 78 32</span><br><span class="line">96 86 56 67100 98 92 74 20 60</span><br><span class="line">79 35  4 12 36  7 21 63 88 62</span><br><span class="line">85 53 58 73 17 51 52 55 64 91</span><br><span class="line">71 11 33 99 95 83 47 40 19 57</span><br><span class="line">70  8 24 72 14 42 25 75 23 69</span><br></pre></td></tr></table></figure>

<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d &quot;</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">//十个一列</span></span><br><span class="line">        n = (n * <span class="number">3</span>) % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序的灵魂在算法，算法的灵魂在数学。</strong>  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>学习<code>rand</code>用法。  </li>
<li>计算机中都是伪随机函数，也就是说，下一次的随机值，跟本次的随机值是相关的。  </li>
<li>使用<code>srand</code>函数设置随机种子，也就是设置伪随机过程中的第一个起始点的位置。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>π</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章了解基本的Java语法</title>
    <url>/2020/06/16/geekbang-column-sjmszm-learn-all-the-java-syntax-used-in-the-column/</url>
    <content><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>在 Java 中，所有的代码都必须写在类里面，所以，我们定义一个 HelloWorld 类。main() 函数是程序执行的入口。main() 函数中调用了 Java 开发包 JDK 提供的打印函数 System.out.println() 来打印 hello world 字符串。除此之外，Java 中有两种代码注释方式，第一种是“&#x2F;&#x2F; 注释…”双斜杠，表示后面的字符串都是注释，第二种是“&#x2F;* 注释…*&#x2F;”，表示中间的内容都是注释。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*hello world程序*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//打印Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li><p>整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）  </p>
</li>
<li><p>浮点类型：float（单精度浮点）、double（双精度浮点）  </p>
</li>
<li><p>字符型：char  </p>
</li>
<li><p>布尔型：boolean</p>
</li>
</ul>
<p>定义一个基本类型变量：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>除此之外，为了方便我们使用，Java 还提供了一些封装这些基本数据类型的类，这些类实现了一些常用的功能函数，可以直接拿来使用。常用的有下面几个类：  </p>
<ul>
<li><p>Integer：对应封装了基本类型 int；  </p>
</li>
<li><p>Long：对应封装了基本类型 long；  </p>
</li>
<li><p>Float：对应封装了基本类型 float；  </p>
</li>
<li><p>Double：对应封装了基本类型 double；  </p>
</li>
<li><p>Boolean：对应封装了基本类型 boolean；  </p>
</li>
<li><p>String：对应封装了字符串类型 char[]。</p>
</li>
</ul>
<p>定义一个 Integer 对象：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">oa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中，我们使用[]来定义一个数组，如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">//定义了一个长度是10的int类型数组</span></span><br></pre></td></tr></table></figure>

<p>在 Java 中，我们通过如下方式访问数组中的元素：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">//将下标是1的数组元素赋值为3</span></span><br><span class="line">System.out.println(a[<span class="number">2</span>]); <span class="comment">//打印下标是2的数组元素值</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>if-else 语句，代码示例如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法一</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch-case 语句，代码示例如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//执行代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//执行代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//默认执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for、while 循环，代码示例如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环执行10次此代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// 循环执行10次此代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>continue、break、return，代码示例如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">//跳过本次循环，不会打印出4这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//提前终止循环，只会打印0、1、2、3</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//结束一个函数，从此处返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类、对象"><a href="#类、对象" class="headerlink" title="类、对象"></a>类、对象</h2><p>Java 语言使用关键词 class 来定义一个类，类中包含成员变量（也叫作属性）和方法（也叫作函数），其中有一种特殊的函数叫作构造函数，其命名比较固定，跟类名相同。除此之外，Java 语言通过 new 关键词来创建一个类的对象，并且可以通过构造函数，初始化一些成员变量的值。代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123; <span class="comment">// 定义了一个Dog类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 属性或者成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeigt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">2</span>, <span class="number">10</span>);<span class="comment">//通过new关键词创建了一个Dog对象dog1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dog1.getAge();<span class="comment">//调用dog1的getAge()方法</span></span><br><span class="line">dog1.run();<span class="comment">//调用dog1的run()方法</span></span><br></pre></td></tr></table></figure>

<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>在前面的代码示例中，我们多次用到 private、public，它们跟 protected 一起，构成了 Java 语言的三个权限修饰符。权限修饰符可以修饰函数、成员变量。  </p>
<ul>
<li>private 修饰的函数或者成员变量，只能在类内部使用。  </li>
<li>protected 修饰的函数或者成员变量，可以在类及其子类内使用。  </li>
<li>public 修饰的函数或者成员变量，可以被任意访问。</li>
</ul>
<p>对于权限修饰符的理解，我们可以参看下面的代码示例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;<span class="comment">// public修饰类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// private修饰属性，只能在类内部使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="comment">//public修饰的方法，任意代码都是可以调用</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java 语言使用 extends 关键字来实现继承。被继承的类叫作父类，继承类叫作子类。子类继承父类的所有非 private 属性和方法。具体的代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeigt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 子类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(age, weight); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wangwang</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">//子类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(age, weight); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">miaomiao</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用举例</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">dog.run();</span><br><span class="line">dog.wangwang();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cat.run();</span><br><span class="line">cat.miaomiao();</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java 语言通过 interface 关键字来定义接口。接口中只能声明方法，不能包含实现，也不能定义属性。类通过 implements 关键字来实现接口中定义的方法。在专栏的第 8 讲中，我们会详细讲解接口，所以，这里我只简单介绍一下语法。具体的代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 属性或者成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeigt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//实现接口中定义的run()方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Java 提供了一些现成的容器。容器可以理解为一些工具类，底层封装了各种数据结构。比如 ArrayList 底层就是数组，LinkedList 底层就是链表，HashMap 底层就是散列表等。这些容器我们可以拿来直接使用，不用从零开始开发，大大提高了编码的效率。具体的代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;User&gt; users;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    users.add(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Java 提供了异常这种出错处理机制。我们可以指直接使用 JDK 提供的现成的异常类，也可以自定义异常。在 Java 中，我们通过关键字 throw 来抛出一个异常，通过 throws 声明函数抛出异常，通过 try-catch-finally 语句来捕获异常。代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123; <span class="comment">// 自定义一个异常</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserNotFoundException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserNotFoundException</span><span class="params">(String message, Throwable e)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UseRepository userRepo)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userRepo = userRepo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> userId)</span> <span class="keyword">throws</span> UserNotFoundException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123; <span class="comment">// throw用来抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>();<span class="comment">//代码从此处返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//捕获异常</span></span><br><span class="line">      user = userService.getUserById(userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UserNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;User not found: &quot;</span> + userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">//不管异常会不会发生，finally包裹的语句块总会被执行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;I am always printed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="package-包"><a href="#package-包" class="headerlink" title="package 包"></a>package 包</h2><p>Java 通过 pacakge 关键字来分门别类地组织类，通过 import 关键字来引入类或者 package。具体的代码示例如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*class DemoA*/</span></span><br><span class="line"><span class="keyword">package</span> com.xzg.cd; <span class="comment">// 包名com.xzg.cd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*class DemoB*/</span></span><br><span class="line"><span class="keyword">package</span> com.xzg.alg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap; <span class="comment">// Java工具包JDK中的类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> com.xzg.cd.DemoA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoB</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learn-java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与单调栈：最大矩形面积</title>
    <url>/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有一面木板墙，每块木板的宽度都是 1，你现在想在木板墙上，沿着平行于地面的方向，切割出一块矩形区域。问题来了，如果给出了每一块木板的高度，那么如何切出面积最大的矩形区域？矩形木板墙如下图所示：  </p>
<p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/mubanqiang.jpg">  </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>图中有 7 块木板，每块木板的高度分别为：2、1、4、5、1、3、3。经过尝试，我们发现最大矩形就是红色阴影部分所示，也就是切割了高度为 4 和 5 两块木板，形成了一个高度为 4，宽度为 2 的矩形区域，这个最大面积为 8。  </p>
<p>结论：<strong>切下来的最大的矩形，一定是以最大矩形所在区域最短那块木板作为其高度值。</strong>  </p>
<p>因此，可以枚举每一块木板，每次都以当前木板作为高度，就是把当前这块木板，当成是切出来的矩形区域中的最矮的木板，然后向左边和右边分别做延伸，切出此时的最大矩形区域。当把所有木板都试过一遍后，我们在所有枚举结果中比较出最大值，这个最大值就是我们要求的最大矩形面积。如果木板的个数为  n，那这种做法的时间复杂度接近于 O(n2)。  </p>
<p>任务要求：将这个时间复杂度降低到 O(n)。  </p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="栈：维护一种完全包含关系的结构"><a href="#栈：维护一种完全包含关系的结构" class="headerlink" title="栈：维护一种完全包含关系的结构"></a>栈：维护一种完全包含关系的结构</h3><p>栈就是一种后进先出的结构。  </p>
<p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/stack.jpg">  </p>
<p>图中所示，入栈顺序分别是 蓝、绿、红，那么出栈顺序就一定是红、绿、蓝。图中每一个颜色的方块上标注的数字，就是每一个方块入栈及出栈的顺序。  </p>
<p>从示意图中，我们还可以观察到一个有趣的事情，在顺序上而言，红色方块被绿色方块包裹着，绿色方块被蓝色方块包裹着。这种结构，像是程序的调用过程，如果把蓝色方块，看成是主函数的话，那么绿色方块就是主函数中调用的一个函数 A，红色方块就是 A 函数中调用的另外一个函数 B，三个函数调用的顺序是主函数、函数 A、函数 B。<br>而它们的执行结束顺序恰恰是相反的，首先是 函数 B 结束，然后是 函数 A 结束，最后是主函数结束。  </p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/dandiaozhan.jpg">  </p>
<p>如果说单调队列是维护区间最值的高效结构，单调栈就是维护最近大于或小于关系的高效结构。  </p>
<h3 id="最大矩形面积"><a href="#最大矩形面积" class="headerlink" title="最大矩形面积"></a>最大矩形面积</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ？ (a) : (b))</span></span><br><span class="line"><span class="type">int</span> s[MAX_N + <span class="number">5</span>], top;</span><br><span class="line"><span class="type">int</span> l[MAX_N + <span class="number">5</span>], r[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">max_matrix_area</span><span class="params">(<span class="type">int</span> *h, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到每一块木板，左边第一块比其矮的木板编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        l[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到每一块木板，右边第一块比其矮的木板编号</span></span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        r[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在所有木板中，找到面积最大的矩形</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, (r[i] - l[r] - <span class="number">1</span>) * h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：代码中假设木板的编号是从 1 到 n 的，然后，在数组的 0 位 及 n + 1 位分别加入两块高度为 -1 的虚拟木板，这是边界控制的一种技巧。也就是说，在每块木板向左搜索的时候，最远也就搜索到 0 号位就停止了，向右搜索的时候呢，最远搜索到 n + 1 位也就停止了。  </p>
<p><strong>通过加入虚拟木板，代码中就少了相关的边界条件判断，这是一种很实用的技巧。</strong>  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>单调栈是用来维护最近大于或小于关系的数据结构。  </li>
<li>单调栈就是堵住出口的单调队列，所以其时间复杂度与单调队列一致，平均到每个处理元素上，都是 O(1) 的时间复杂度。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串_printf 的高级用法</title>
    <url>/2020/05/23/geekbang-column-strings-advanced-usage-of-printf/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>Q:printf 函数在输出浮点型数据的时候，如何保留位数呢？  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line"><span class="comment">//输出：3.14</span></span><br></pre></td></tr></table></figure>
<p>A:%lf 是 double 双精度浮点型输出的格式占位符，<strong>当我们想要保留小数点后两位的时候，只需要在 % 和 lf 中间加上 .2 即可</strong>，2 写在 .(点) 的后面代表小数点后 2 位。  </p>
<p>实现一个能够保留小数点后 n 位的程序，这里的 n 是我们程序读入的一个变量。<br>例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入1：3.1415926 2</span><br><span class="line">输出1：3.14</span><br><span class="line"></span><br><span class="line">输入2：3.1415926 3</span><br><span class="line">输出3:3.142</span><br></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一种：用<code>switch case</code>语句做  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>, num); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如何优化呢？？？  </p>
<p>第二种：printf 函数的第一个参数不就是个字符串，既然是字符串信息，那我只需要在 printf 语言前，拼接合适的字符串信息传给 printf 函数即可。  </p>
<p>例如，要求保留 1 位小数的时候，我就拼接出来 “%.1lf” 字符串信息，要求保留 2 位小数的时候，就拼接处理出 “%.2lf”字符串信息即可。  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> num;  <span class="comment">//定义一个浮点型变量 num</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//定义一个整型变量 n</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];  <span class="comment">//定义一个字符数组 str</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%%.%dlf\n&quot;</span>, n); <span class="comment">// %% 代表输出一个 %</span></span><br><span class="line">    <span class="built_in">printf</span>(str, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，体验利器"><a href="#1，体验利器" class="headerlink" title="1，体验利器"></a>1，体验利器</h3><blockquote>
<p>刚刚在上面，介绍了 sprintf 和 sscanf 两个字符串处理的利器工具，那么就请使用 sprintf 函数实现 strlen、strcpy、strcat 函数的功能，注意哦，只允许使用 sprintf 函数，模仿如上三个函数的功能。  </p>
</blockquote>
<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">1000</span>], str2[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\tstr2 = %s\n&quot;</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">&quot;%s&quot;</span>, str1);   <span class="comment">// strlen(str1)，输出str1 字符串中的字符数量</span></span><br><span class="line">    <span class="comment">//printf(&quot;strlen= %s\n&quot;,str1);</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">&quot;%s&quot;</span>, str2);   <span class="comment">// strcpy(str1, str2)，把 str2 的内容复制到了 str1 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\tstr2 = %s\n&quot;</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">&quot;%s%s&quot;</span>, str1, str2);   <span class="comment">// strcat(str1, str2)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\tstr2 = %s\n&quot;</span>, str1, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，优美的遍历技巧"><a href="#2，优美的遍历技巧" class="headerlink" title="2，优美的遍历技巧"></a>2，优美的遍历技巧</h3><blockquote>
<p>介绍完了字符串的相关知识以后，请思考如下问题，如何在不计算字符串长度的情况下，遍历字符串的每一位呢？<br>程序设计要求是，读入一个字符串，然后在不计算字符串长度的情况下，输出字符串中的每一个字符，每个字符占一行。其中所谓计算字符串长度的方法，包括但不限于 strlen，sprintf，先行 for 循环遍历统计等。  </p>
</blockquote>
<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环的结束条件：</span></span><br><span class="line"><span class="comment">    任何信息在底层都是二进制存储的，那么其余字符均为非零值，也就是代表条件成立。</span></span><br><span class="line"><span class="comment">    只有一个字符的值是零值，就是我们之前所说的字符串中的最后一个特殊的，看不见的字符，\0 字符，</span></span><br><span class="line"><span class="comment">    这个字符所对应的整型值就是 0，也就是我们所谓的假值。那么这个循环，就会一直循环到字符串的最后一位，才会停止。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>具体结果就是值，明确知道等于多少的就是值。存储这些值的地方，就是变量，就是在程序中用来指代某片存储空间的名称，值就是存储空间里面的具体内容。  </li>
<li>字符串信息可以存储在字符数组中，字符数组就是“变量”的概念，字符串就是“值”的概念。  </li>
<li>sscanf 和 sprintf 函数，本质上在做的是以字符串为中间值，做各种数据类型之间的转换。</li>
</ul>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
  </entry>
  <entry>
    <title>教你输出彩色的文字</title>
    <url>/2020/05/19/geekbang-column-teach-you-to-output-colored-text/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>学到如何设计一个读入字符串，并且按照字符串信息中规定的颜色，输出相应颜色文本内容的方法程序。<br>例如当我们：</p>
<ul>
<li>输入：red:color content， 输出红色的：color content</li>
<li>输入：blue:color content，输出蓝色的：color content</li>
<li>输入：yellow:color content，输出黄色的：color content</li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>输入输出很好设计，关键是<strong>如何让字体显示不同的颜色呢</strong>  </p>
<p>转义字符  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：\033[属性代码&#123;;属性代码...&#125;m输出内容\033[0m</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;4;33mhello color\033[0m&quot;</span>);  <span class="comment">//输入高亮黄色带下划线的 hello color</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>0 代表关闭所有属性</li>
<li>1 代表高亮 &#x2F; 粗体</li>
<li>4 代表下划线</li>
<li>33 代表黄色</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，位数输出"><a href="#1，位数输出" class="headerlink" title="1，位数输出"></a>1，位数输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算一个输入整数的十进制表示的位数？</span><br><span class="line">条件 1：允许有多余输出的情况下，怎么实现？</span><br><span class="line">条件 2：只允许输出数字位数的时候，又该怎么实现？</span><br><span class="line">请单纯考虑使用 printf 一族函数方法实现。</span><br></pre></td></tr></table></figure>

<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; has %d digits\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n)); <span class="comment">// 有多余输出</span></span><br><span class="line">    <span class="type">char</span> output[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">sprintf</span>(output, <span class="string">&quot;%d&quot;</span>, n);  <span class="comment">//sprintf 也是 printf 一族函数中的一员，它的返回值与 printf 含义相同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret); <span class="comment">// 无多余输出</span></span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，读入一行字符串"><a href="#2，读入一行字符串" class="headerlink" title="2，读入一行字符串"></a>2，读入一行字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请大家自行实现一个读入一行字符串，并且输出相关内容的程序，思考如下：</span><br><span class="line">条件 1：如果字符串中没有空格，怎么实现？</span><br><span class="line">条件 2：如果字符串中有空格，又该怎么实现？</span><br><span class="line">请单纯考虑用 scanf 一族函数方法实现。</span><br></pre></td></tr></table></figure>

<p>实现  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//[]代表了一个集合，用来控制 %s 在读入过程中可以读入的字符集合的</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);  <span class="comment">//只要不是换行符，就可以继续读入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="部分颜色代码"><a href="#部分颜色代码" class="headerlink" title="部分颜色代码"></a>部分颜色代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字背景颜色: 40--49                字颜色: 30--39</span><br><span class="line">40: 黑                           30: 黑</span><br><span class="line">41: 红                           31: 红</span><br><span class="line">42: 绿                           32: 绿</span><br><span class="line">43: 黄                           33: 黄</span><br><span class="line">44: 蓝                           34: 蓝</span><br><span class="line">45: 紫                           35: 紫</span><br><span class="line">46: 深绿                         36: 深绿</span><br><span class="line">47：白色                         37：白色</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此文记录我复习和巩固C语言基础的开端，后面会发布一系列学习笔记，加油！</p>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>文字</tag>
        <tag>C语言</tag>
        <tag>输入</tag>
        <tag>输出</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目一点五：升级自己的测试框架</title>
    <url>/2020/06/13/geekbang-column-upgrade-your-own-testing-framework/</url>
    <content><![CDATA[<h2 id="完善测试框架的功能与提示"><a href="#完善测试框架的功能与提示" class="headerlink" title="完善测试框架的功能与提示"></a>完善测试框架的功能与提示</h2><h3 id="温故知新，gtest-的输出结果"><a href="#温故知新，gtest-的输出结果" class="headerlink" title="温故知新，gtest 的输出结果"></a>温故知新，gtest 的输出结果</h3><p>第一部分，一套单元测试的相关信息：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br></pre></td></tr></table></figure>

<p>第二部分，是每个单元测试运行信息的输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure>

<p>如上所示，第一个单元测试 test_is_prime.test1 运行结果正确，所用时间是 1ms；第二个单元测试 test_is_prime.test2 中，有三个判等 EXPECT 断言的结果是错误的，也就是 is_prime 函数的返回值，和测试用例中期望的返回值不符，这说明 is_prime 函数存在 Bug。  </p>
<p>第三部分，就是这套单元测试的总结信息，以及整个程序单元测试结果的汇总信息。这段信息，有兴趣的小伙伴可以自己理解着看一下，由于不是咱们今天课程的重点，就不展开介绍了。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED</span><br></pre></td></tr></table></figure>

<h3 id="从哪些方面来完善测试框架？"><a href="#从哪些方面来完善测试框架？" class="headerlink" title="从哪些方面来完善测试框架？"></a>从哪些方面来完善测试框架？</h3><p>通过观察第二部分的输出，我们基本要从三个方面完善测试框架的输出信息。  </p>
<ul>
<li>在每个测试用例运行之前，要先行输出相关测试用例的名字；  </li>
<li>每个测试用例运行结束以后，要输出测试用例的运行时间与运行结果（OK 或者 FAILED）；  </li>
<li>若测试用例中的 EXPECT 断言出错，需要输出错误提示信息。</li>
</ul>
<h3 id="测试用例的名字输出"><a href="#测试用例的名字输出" class="headerlink" title="测试用例的名字输出"></a>测试用例的名字输出</h3><p>首先是如何输出测试用例的名字。我们先回忆一下上节课设计的注册函数，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name(); \</span></span><br><span class="line"><span class="meta">__attribute__((constructor)) \</span></span><br><span class="line"><span class="meta">void register_##test_name##_##func_name() &#123; \</span></span><br><span class="line"><span class="meta">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span></span><br><span class="line"><span class="meta">    test_function_cnt++; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name()</span></span><br></pre></td></tr></table></figure>

<p>注册函数是随着 TEST 展开的，从展开的代码逻辑中可以看到，它只是将测试用例的函数地址记录在了函数指针数组中。要想 RUN_ALL_TESTS 函数后续能够输出测试用例的函数名称的话，我们只需要修改注册函数的功能逻辑即可，也就是让注册函数在记录函数信息的时候，增加记录对应测试用例的名称。  </p>
<p>而这个名称信息，应该记录在哪里呢？有两种代码实现方式：  </p>
<ul>
<li>1，另外开辟一个记录测试用例名称的字符串数组；  </li>
<li>2，修改 test_function_arr 数组中的元素类型，将新增的测试用例名称以及函数地址信息打包成一个数据元素。</li>
</ul>
<p>显然，相较于第一种实现方式，第二种代码实现方式会使程序具有更好的封装特性。  </p>
<p>面就是我们将函数指针信息和测试用例名称信息，封装成的一个新的结构体类型：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="type">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们定义了一种新的数据类型，叫做 test_function_info_t。这种结构体类型包含了指向测试用例的函数指针 func 字段， 与指向测试用例名称的字符串指针 name 字段，并且我们将这种结构体类型，作为 test_function_arr 数组新的元素类型。  </p>
<p>既然测试用例信息的存储区 test_function_arr 的数据类型发生了改变，那么负责存储信息的注册函数，与使用信息的 RUN_ALL_TESTS 函数的相关逻辑都需要作出改变。  </p>
<p>首先，我们来看注册函数的改变。想要修改注册函数的逻辑，就是修改 TEST 宏，从功能上来说，注册函数中需要额外记录一个测试用例名称信息，示例代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name(); \</span></span><br><span class="line"><span class="meta">__attribute__((constructor)) \</span></span><br><span class="line"><span class="meta">void register_##test_name##_##func_name() &#123; \</span></span><br><span class="line"><span class="meta">    test_function_arr[test_function_cnt].func = test_name##_##func_name; \</span></span><br><span class="line"><span class="meta">    test_function_arr[test_function_cnt].name = #func_name <span class="string">&quot;.&quot;</span> #test_name; \</span></span><br><span class="line"><span class="meta">    test_function_cnt++; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name()</span></span><br></pre></td></tr></table></figure>

<p>代码中主要是增加了第 6 行的逻辑，这一行的代码将 TEST 宏参数的两部分，拼成一个字符串，中间用点 (.) 连接，例如 TEST(test1, test_is_prime) 宏调用中，拼凑的字符串就是 test_is_prime.test1，和 gtest 中的输出的测试用例名称信息格式是一致的。  </p>
<p>改完了注册函数的逻辑以后，最后调整一下 RUN_ALL_TESTS 中使用 test_function_arr 数组的逻辑代码即可：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RUN_ALL_TESTS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ RUN      ] %s\n&quot;</span>, test_function_arr[i].name);  <span class="comment">//仿照 gtest 的输出格式进行调整的，在输出测试用例名称之前，先输出一段包含 RUN 英文的标志信息。</span></span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RUN TEST DONE\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就完成了输出测试用例名字的框架功能改造。  </p>
<h3 id="输出测试用例的运行结果信息"><a href="#输出测试用例的运行结果信息" class="headerlink" title="输出测试用例的运行结果信息"></a>输出测试用例的运行结果信息</h3><p>以下是我们示例代码中的 2 个测试用例，在 gtest 框架下的运行结果信息输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[     OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ FAILED ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure>

<p>根据输出的信息，我们可知  gtest 会统计每个测试用例运行的时间，并以毫秒为计量单位，输出此时间信息。不仅如此，gtest 还会输出与测试用例是否正确相关的信息，如果测试用例运行正确，就会输出一行包含 OK 的标志信息，否则就输出一行包含 FAILED 的标志信息。  </p>
<p>根据我们自己测试框架的设计，这行信息只有可能是在 RUN_ALL_TESTS 函数的 for 循环中，执行完每一个测试用例函数以后输出的信息。  </p>
<p>由此，我们面临的是两个需要解决的问题：  </p>
<ul>
<li><p>1，如何统计函数过程的运行时间？<br>函数 clock() 。它的返回值代表了：从运行程序开始，到调用 clock() 函数时，经过的 CPU 时钟计时单元。并且，这个 clock() 函数的返回值，实际上反映的是我们程序的运行时间。那这个 CPU 时钟计时单元究竟是什么呢？你可以把 1 个 CPU 时钟计时单元，简单的理解成是一个单位时间长度，只不过这个单位时间长度，不是我们常说的 1 秒钟。<br>宏 CLOCKS_PER_SEC 。它实际上是一个整型值，代表多少个 CPU 时钟计时单元是 1 秒。  </p>
</li>
<li><p>2，如何确定获得每一个测试用例函数的测试结果是否正确？<br>记录一个全局变量，代表测试用例结果正确与否。当测试用例中的 EXPECT_EQ 断言发生错误时，就修改这个全局变量的值，这样我们的 RUN_ALL_TESTS 函数，就可以在测试用例函数执行结束以后，得知执行过程是否有错。</p>
</li>
</ul>
<p>综合以上所有信息，我们可以重新设计 RUN_ALL_TESTS 函数如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> test_run_flag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_EQ(a, b) test_run_flag &amp;= ((a) == (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RUN_ALL_TESTS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ RUN      ] %s\n&quot;</span>, test_function_arr[i].name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t1 = clock();</span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[       OK ] &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[  FAILED  ] &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, test_function_arr[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; (%.0lf ms)\n\n&quot;</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的第 8 行是在测试用例运行之前，记录一个开始时间值 t1；代码中的第 10 行是在测试用例函数执行完后，记录一个结束时间值 t2；在代码的第 17 行，根据 t1 、t2 以及 CLOCKS_PER_SEC 的值，计算得到测试用例函数实际运行的时间，并输出得到的结果。  </p>
<p>这段代码中增加了一个全局变量“test_run_flag”，这个变量每次在测试用例执行之前，都会被初始化为 1，当测试用例结束执行以后，RUN_ALL_TESTS 函数中，根据 test_run_flag 变量的值，选择输出 OK 或者 FAILED 的标志信息。同时，我们可以看到，test_run_flag 变量的值只有在 EXPECT_EQ 断言中，才可能被修改。  </p>
<h3 id="EXPECT-EQ-断言的实现"><a href="#EXPECT-EQ-断言的实现" class="headerlink" title="EXPECT_EQ 断言的实现"></a>EXPECT_EQ 断言的实现</h3><p>首先，EXPECT_EQ(a, b) 在 a，b 两部分值相等的时候，不会产生额外的输出信息，而当 a，b 两部分不相等的时候，就会输出相应的提示信息。如下所示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>

<p>这段输出信息，对应的是源代码中的 “EXPECT_EQ(is_prime(4), 0); ”的输出。如你所见，第 1 行的输出内容包含了源文件名（gtest_test.cpp），EXPECT_EQ 宏所在的代码位置（25），以及一个提示结果（Failure）。  </p>
<p>对于函数调用部分，EXPECE_EQ 会输出这个函数的调用形式及返回值信息，也就是输出中的 “is_prime(4)”“Which is: 1” 这段内容。而对于数值信息，只会输出数值信息本身，也就是输出信息中第 5 行的那个 0。  </p>
<p>实际上，要想在宏中实现类似于这种根据传入参数类型，选择输出形式的功能，对于现在的你来说可能有点困难。所以，我们可以重新设计一种输出形式，只要能够清晰地展示错误信息就可以。<br>重新设计的输出提示，如下所示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected (is_prime(4) == 0):</span><br><span class="line">    Which is: (1 == 0)</span><br></pre></td></tr></table></figure>

<p>修改完以后的输出信息，你可以看到，第 2 行就是传入 EXPECT_EQ 宏两部分的比较，第 3 行是这两部分实际输出值的比较。<br>重新设计了输出信息以后，就可以来看看 EXPECT_EQ 宏的实现了：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT(a, b, comp) &#123; \</span></span><br><span class="line"><span class="meta">    __typeof(a) val_a = (a), val_b = (b); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(val_a comp val_b)) &#123; \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;%s:%d: Failure\n&quot;</span>, __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;Expected (%s %s %s):\n&quot;</span>, #a, #comp, #b); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Which is: (%d %s %d)\n&quot;</span>, val_a, #comp, val_b); \</span></span><br><span class="line"><span class="meta">        test_run_flag = 0; \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_EQ(a, b) EXPECT(a, b, ==)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_LT(a, b) EXPECT(a, b, &lt;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_GT(a, b) EXPECT(a, b, &gt;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPECT_NE(a, b) EXPECT(a, b, !=)</span></span><br></pre></td></tr></table></figure>

<p>在这段实现中，你会发现，我们不仅实现了 EXPECT_EQ，还额外实现了 EXPECT_LT、EXPECT_GT、EXPECT_NE 等用于比较的宏。其中，LT 是英文 little 的缩写，是判断小于关系的；GT 是 great 的缩写，是判断大于关系的；NE 是 not equal 的缩写，是判断不等于关系的。而这些所有的宏，都是基于 EXPECT 宏实现的。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>工程开发中的一个基本原则：功能迭代，数据先行。也就是说，无论我们做什么样的功能开发，首先要考虑的是与数据相关的部分。  </p>
<h2 id="链表知识在测试框架中的应用"><a href="#链表知识在测试框架中的应用" class="headerlink" title="链表知识在测试框架中的应用"></a>链表知识在测试框架中的应用</h2><h3 id="用链表存储测试用例"><a href="#用链表存储测试用例" class="headerlink" title="用链表存储测试用例"></a>用链表存储测试用例</h3><p>重新审视下面这段函数指针数组 test_function_arr 的代码设计，来思考一下这个测试框架中还有没有可以优化的地方。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="type">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码中，我们使用了数组来定义存储测试函数信息的存储区，这个数组的大小有 100 位，也就是说，最多可以存储 100 个测试用例函数信息。  </p>
<h3 id="要是有程序中定义了-1000-个测试用例，怎么办呢？"><a href="#要是有程序中定义了-1000-个测试用例，怎么办呢？" class="headerlink" title="要是有程序中定义了 1000 个测试用例，怎么办呢？"></a>要是有程序中定义了 1000 个测试用例，怎么办呢？</h3><p>第一步，我们需要改变 test_function_info_t 的结构定义，也就是把原先存储测试用例函数信息的结构体类型，改装成链表结构。最简单的方法，就是在结构体的定义中，增加一个指针字段，指向下一个 test_function_info_t 类型的数据，代码如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="type">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> <span class="title">head</span>, *<span class="title">tail</span> =</span> &amp;head;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们给 test_function_info_t 结构体类型增加了一个链表中的 next 字段，除此之外，我们还定义了一个虚拟头节点 head 和一个指针变量 tail。这里你需要注意，head 是虚拟头节点，后续我们会向 head 所指向链表中插入链表节点，tail 指针则指向了整个链表的最后一个节点的地址。  </p>
<p>第二步，在准备好了数据存储结构以后，需要改写的就是函数注册的逻辑了。在改写 TEST 宏中的注册函数逻辑之前呢，我们先准备一个工具函数 add_test_function，这个工具函数的作用，就是根据传入的参数，新建一个链表节点，并且插入到整个链表的末尾：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_test_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">test_function_t</span> func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = (<span class="keyword">struct</span> <span class="type">test_function_info_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">test_function_info_t</span>));</span><br><span class="line">    node-&gt;func = func;</span><br><span class="line">    node-&gt;name = name;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = node;</span><br><span class="line">    tail = node;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写 TEST 宏中注册函数的逻辑：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name(); \</span></span><br><span class="line"><span class="meta">__attribute__((constructor)) \</span></span><br><span class="line"><span class="meta">void register_##test_name##_##func_name() &#123; \</span></span><br><span class="line"><span class="meta">    add_test_function(#func_name <span class="string">&quot;.&quot;</span> #test_name, \</span></span><br><span class="line"><span class="meta">                      test_name##_##func_name); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">void test_name##_##func_name()</span></span><br></pre></td></tr></table></figure>

<p>最后一步，处理完了数据写入的过程以后，来让我们修改一下使用这份数据的代码逻辑，那就是 RUN_ALL_TESTS 函数中的相关逻辑。之前，RUN_ALL_TESTS 函数中，循环遍历数组中的每一个测试用例，并且执行相关的测试用例函数，对这一部分，修改成针对于链表结构的遍历方式即可，代码如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RUN_ALL_TESTS</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">p</span> =</span> head.next;</span><br><span class="line">    <span class="keyword">for</span> (; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ RUN      ] %s\n&quot;</span>, p-&gt;name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t1 = clock();</span><br><span class="line">        p-&gt;func();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[       OK ] &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[  FAILED  ] &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; (%.0lf ms)\n\n&quot;</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就彻底完成了测试用例函数信息存储部分的“链表”改造过程。  </p>
]]></content>
      <categories>
        <category>Intro-programming</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>框架</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-哈希表、映射、集合的实现与特性</title>
    <url>/2021/01/22/geekbang-gatc-05-hashmap-and-set/</url>
    <content><![CDATA[<h2 id="哈希表（Hash-Table）"><a href="#哈希表（Hash-Table）" class="headerlink" title="哈希表（Hash Table）"></a>哈希表（Hash Table）</h2><p><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/hash-table.png">  </p>
<p>工程实践：电话号码簿、用户信息表、缓存（LRU Cache）、键值对存储（Redis）。  </p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>哈希函数：<br><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/hash-func.png">  </p>
<p>哈希碰撞：<br><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/hash-collisions.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/hash-collisions2.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/wanzheng.png">  </p>
<h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><p><img src="/2021/01/22/geekbang-gatc-05-hashmap-and-set/map-set.png">  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html">Set Java 12 doc</a>  </p>
<p><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html">Map Java 12 doc</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>映射</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-分治、回溯的实现和特性</title>
    <url>/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/</url>
    <content><![CDATA[<h2 id="分治的思想"><a href="#分治的思想" class="headerlink" title="分治的思想"></a>分治的思想</h2><p><img src="/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/digui-tree.png">  </p>
<p>本质就是<strong>找重复性和分解问题，以及最后组合每个子问题的结果。</strong>  </p>
<p>例如：  </p>
<p><img src="/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/divide.png">  </p>
<p>代码模板：  </p>
<p><img src="/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/divide-code.png">  </p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>百度百科解释：  </p>
<p><img src="/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/back-baidu.png">  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-深度优先搜索、广度优先搜索的实现和特性</title>
    <url>/2021/01/23/geekbang-gatc-09-dfs-and-bfs/</url>
    <content><![CDATA[<h2 id="搜索-遍历"><a href="#搜索-遍历" class="headerlink" title="搜索-遍历"></a>搜索-遍历</h2><ul>
<li>每个节点都要访问一次  </li>
<li>每个节点仅仅要访问一次（不做无用功）  </li>
<li>对于节点的访问顺序不限：dfs &#x2F; bfs</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="DFS算法模板"><a href="#DFS算法模板" class="headerlink" title="DFS算法模板"></a>DFS算法模板</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">        <span class="comment"># already visited</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    visited.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># process current node</span></span><br><span class="line">    <span class="comment"># ... logic here</span></span><br><span class="line"></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br></pre></td></tr></table></figure>

<h3 id="DFS代码-递归写法"><a href="#DFS代码-递归写法" class="headerlink" title="DFS代码-递归写法"></a>DFS代码-递归写法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node,visited</span>):</span><br><span class="line">    visited.add(node)</span><br><span class="line">    <span class="comment"># process current node here</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(<span class="built_in">next</span> node,visited)</span><br></pre></td></tr></table></figure>

<h3 id="DFS代码-非递归写法"><a href="#DFS代码-非递归写法" class="headerlink" title="DFS代码-非递归写法"></a>DFS代码-非递归写法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self,tree</span>):</span><br><span class="line">    <span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    visited,stack = [].[tree.root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generagte_related_nodes(node)</span><br><span class="line">        stack.push(nodes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># other processing work</span></span><br></pre></td></tr></table></figure>

<h3 id="BFS代码"><a href="#BFS代码" class="headerlink" title="BFS代码"></a>BFS代码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">graph,start,end</span>):</span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generagte_related_nodes(node)</span><br><span class="line">        queue.push(nodes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># other processing work</span></span><br></pre></td></tr></table></figure>


<h2 id="DFS和BFS遍历顺序"><a href="#DFS和BFS遍历顺序" class="headerlink" title="DFS和BFS遍历顺序"></a>DFS和BFS遍历顺序</h2><p><img src="/2021/01/23/geekbang-gatc-09-dfs-and-bfs/shunxu.png">  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://visualgo.net/en">https://visualgo.net/en</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-栈和队列的实现与特性</title>
    <url>/2021/01/22/geekbang-gatc-04-stack-and-queue/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>想象成一个先入后出的容器：  </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/stack.png">  </p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>像排队，先来先出： </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/queue.png">  </p>
<h2 id="栈和队列关键点"><a href="#栈和队列关键点" class="headerlink" title="栈和队列关键点"></a>栈和队列关键点</h2><ul>
<li>栈（Stack）：先入后出；添加、删除操作的时间复杂度都为O(1)，查询为O(n)</li>
<li>队列（Queue）：先入后出；添加、删除操作的时间复杂度都为O(1),查询为O(n)</li>
</ul>
<h2 id="双端队列-Double-End-Queue"><a href="#双端队列-Double-End-Queue" class="headerlink" title="双端队列(Double End Queue)"></a>双端队列(Double End Queue)</h2><p>首端和尾端都可以添加、删除元素：  </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/dequeue.png">  </p>
<ul>
<li>简单理解：两端都可以进出的队列；  </li>
<li>插入和删除都是O(1)的操作。</li>
</ul>
<h2 id="Stack、Queue、Deque的工程实现"><a href="#Stack、Queue、Deque的工程实现" class="headerlink" title="Stack、Queue、Deque的工程实现"></a>Stack、Queue、Deque的工程实现</h2><p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/stack-java.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/queue-java.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/deque-java.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/stack-queue-python.png">  </p>
<h2 id="优先队列-Priority-Queue"><a href="#优先队列-Priority-Queue" class="headerlink" title="优先队列(Priority Queue)"></a>优先队列(Priority Queue)</h2><ul>
<li>插入操作：O(1)  </li>
<li>取出操作：O(logN)-按照元素的优先级取出  </li>
<li>底层具体实现的数据结构较为多样和复杂：heap、bst、treap</li>
</ul>
<h2 id="Java源码分析"><a href="#Java源码分析" class="headerlink" title="Java源码分析"></a>Java源码分析</h2><p><a href="http://developer.classpath.org/doc/java/util/Stack-source.html">Stack-source Java</a>  </p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="/2021/01/22/geekbang-gatc-04-stack-and-queue/fuzadu.png">  </p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul>
<li>1，用新的api-addfirst,addlast去改写  </li>
<li>2，分析Queue，Priority Queue源码</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Stack.html">Stack Java 12 doc</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The Stack class represents a last-in-first-out (LIFO) stack of objects. It extends class Vector with five operations that allow a vector to be treated as a stack. The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, and a method to search the stack for an item and discover how far it is from the top.</span><br><span class="line">When a stack is first created, it contains no items.</span><br><span class="line"></span><br><span class="line">A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/PriorityQueue.html">Priority Queue Java 12 doc</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>优先队列</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-贪心的实现、特性及实战题目解析</title>
    <url>/2021/02/23/geekbang-gatc-10-greedy-algo/</url>
    <content><![CDATA[<h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法-Greedy"></a>贪心算法-Greedy</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。  </p>
<p>贪心算法与动态规划的不同在于<strong>它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</strong>  </p>
<ul>
<li>贪心：当下做局部最优判断  </li>
<li>回溯：能够回退  </li>
<li>动态规划：最优判断 + 回溯</li>
</ul>
<h3 id="可以解决的最优化问题"><a href="#可以解决的最优化问题" class="headerlink" title="可以解决的最优化问题"></a>可以解决的最优化问题</h3><ul>
<li>求图中的最小生成树  </li>
<li>求哈夫曼编码等</li>
</ul>
<p><strong>由于贪心法的高效性以及所求得的答案比较接近最优结果，贪心算法可以用作辅助算法或直接解决一些要求结果不特别精确的问题。</strong>  </p>
<h2 id="适用贪心算法的场景"><a href="#适用贪心算法的场景" class="headerlink" title="适用贪心算法的场景"></a>适用贪心算法的场景</h2><p>简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。  </p>
<h2 id="实战题目"><a href="#实战题目" class="headerlink" title="实战题目"></a>实战题目</h2><p><a href>leetcode-322.Coin Change</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-Trie树、并查集的基本实现和特性</title>
    <url>/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/</url>
    <content><![CDATA[<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><img src="/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/tree.png">  </p>
<ul>
<li>前序(Pre-order)：根-左-右  </li>
<li>中序(In-order)：左-根-右  </li>
<li>后序(Post-order)：左-右-根</li>
</ul>
<p>记忆方法：<strong>前序-&gt;根在最前面，中序-&gt;根在中间，后序-&gt;根在最后，左永远在右的前面。</strong>  </p>
<p>示例代码  </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self,root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.preorder(root.left)</span><br><span class="line">        self.preorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self,root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        selft.inorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">self,root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/btree.png">  </p>
<p>是子树的关系，并不是儿子和父亲的关系。<br>定义：任何一个结点，<strong>它的左子树的所有的结点都要小于这个根结点，它的右子树的所有结点都要大于根结点，且对于它的任何子树同样地以此类推，对于任何子树都满足这样的特性</strong>。<br>另外一个特性：二叉搜索树是一个升序的序列。  </p>
<h3 id="极端情况（链表）"><a href="#极端情况（链表）" class="headerlink" title="极端情况（链表）"></a>极端情况（链表）</h3><p><img src="/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/jiduan.png">  </p>
<p>思考：如何平衡？  </p>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><img src="/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/trie-tree.png">  </p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul>
<li>1，结点本身不存在完整单词  </li>
<li>2，从根结点到某一结点，路径上经过的</li>
<li>3，每个结点的所有子结点路径代表的字符都不相同</li>
</ul>
<h3 id="结点的内部实现"><a href="#结点的内部实现" class="headerlink" title="结点的内部实现"></a>结点的内部实现</h3><p><a href="./geekbang-gatc-13-dictionary-tree-and-union-loopup/neibushixian.png"></a>  </p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>Trie树的核心思想是空间换时间<br>利用字符串的公共前缀来降低查询的时间的开销以达到提高效率的目的  </p>
<h2 id="相关题目解析"><a href="#相关题目解析" class="headerlink" title="相关题目解析"></a>相关题目解析</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">leetcode-208.实现Trie</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-二分查找的实现、特性及实战题目解析</title>
    <url>/2021/02/23/geekbang-gatc-11-binary-search/</url>
    <content><![CDATA[<h2 id="二分查找的前提"><a href="#二分查找的前提" class="headerlink" title="二分查找的前提"></a>二分查找的前提</h2><p>1，目标函数单调性（单调递增或者递减）——在有序的里面查找<br>2，存在上下界（bounded）<br>3，能够通过索引访问（index accessible）  </p>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>(一定要写的非常熟练)  </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">left,right := <span class="number">0</span>,<span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid := (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-动态规划的实现及关键点</title>
    <url>/2021/01/22/geekbang-gatc-12-dynamic-programming/</url>
    <content><![CDATA[<h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划-Dynamic Programming"></a>动态规划-Dynamic Programming</h2><p>1，<a href="https://en.wikipedia.org/wiki/Dynamic_programming">wiki定义</a><br>2，in a recursive manner<br>3，Divide &amp; Conquer + Optimal substructure——分治+最优子结构  </p>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li>动态规划和递归或者分治没有根本区别（关键看有无最优的子结构）  </li>
<li>共性：找到重复子问题  </li>
<li>差异性：最优子结构、中途可以淘汰次优解</li>
</ul>
<h2 id="顺推模板"><a href="#顺推模板" class="headerlink" title="顺推模板"></a>顺推模板</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fuction DP():</span><br><span class="line">    dp = [][] <span class="comment">#二维情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0.</span>.M &#123;</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">0.</span>.N &#123;</span><br><span class="line">            dp[i][j] = _Fuction(dp[i<span class="string">&#x27;][j&#x27;</span>]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[M][N]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-AVL树和红黑树的实现和特性</title>
    <url>/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/</url>
    <content><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul>
<li>发明者：Adelson-Velsky and Landis Tree  </li>
<li>Blance Factor(平衡因子)：是它的左子树的高度减去它的右子树的高度（有时相反）。balance factor&#x3D; {-1,0,1}  </li>
<li>通过旋转操作来进行平衡（四种）  </li>
<li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing binary search tree</a>  </li>
<li>不足：结点需要存储额外信息、且调整次数频繁</li>
</ul>
<h3 id="记录左右子树高度"><a href="#记录左右子树高度" class="headerlink" title="记录左右子树高度"></a>记录左右子树高度</h3><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/hight.png">  </p>
<p>例如F点，右子树高度1 - 左子树高度2 &#x3D; -1  </p>
<h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>1，左旋  </p>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoxuan.png">  </p>
<p>2，右旋  </p>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youxuan.png">  </p>
<p>3，左右旋  </p>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoyouxuan2.png">  </p>
<p>4，右左旋  </p>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youzuoxuan.png">  </p>
<h2 id="红黑树-Red-black-Tree"><a href="#红黑树-Red-black-Tree" class="headerlink" title="红黑树(Red-black Tree)"></a>红黑树(Red-black Tree)</h2><p>红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>。具体来说，红黑树是满足如下条件的二叉搜索树：  </p>
<ul>
<li>每个结点要么是红色，要么是黑色；  </li>
<li>根结点是黑色；  </li>
<li>每个叶结点(NIL结点、空结点)是黑色的；  </li>
<li>不能有相邻的两个红色结点；  </li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。  </li>
<li>关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li>
</ul>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree.png">  </p>
<p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree2.png"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/duibi-en.png">  </p>
<p>翻译：  </p>
<ul>
<li>AVL树提供了更快的查询，因为它是严格平衡的；  </li>
<li>红黑树提供了更快的插入和删除的操作，因为AVL的旋转操作会更多而红黑树会更少一点；  </li>
<li>AVL存在<code>factors</code>或<code>heights</code>更多一点，它需要更多的内存附加在每个结点里面来存这些了额外的信息，而红黑树要的信息非常少，它只要一个<code>bit</code>就是来存0和1表示黑或者是红；  </li>
<li>红黑树是用在你们常常写的一些高级语言的库里面，比如C++中的<code>map、set</code>；如果用在数据库里面的话一般用<code>AVL</code></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">wiki-AVL树</a><br><a href="https://zhuanlan.zhihu.com/p/63272157">leetcode刷题(十）：树（红黑树，B树）</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-高级搜索</title>
    <url>/2021/03/01/geekbang-gatc-14-advanced-search/</url>
    <content><![CDATA[<h2 id="剪枝的实现和特性"><a href="#剪枝的实现和特性" class="headerlink" title="剪枝的实现和特性"></a>剪枝的实现和特性</h2><h3 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h3><ul>
<li>1，朴素搜索：暴力搜索；  </li>
<li>2，优化方式：不重复(fibonacci)、剪枝(生成括号问题)；  </li>
<li>3，搜索方向：深度优先搜索、广度优先搜索、双向搜索、启发式搜索。</li>
</ul>
<h2 id="双向BFS的实现、特性"><a href="#双向BFS的实现、特性" class="headerlink" title="双向BFS的实现、特性"></a>双向BFS的实现、特性</h2><p>单向BFS  </p>
<p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs.png">  </p>
<p>变形：  </p>
<p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs2.png">  </p>
<p>双向BFS  </p>
<p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/Tbfs.png">  </p>
<h2 id="启发式搜索的实现、特性-Heuristc-Search-A"><a href="#启发式搜索的实现、特性-Heuristc-Search-A" class="headerlink" title="启发式搜索的实现、特性 - Heuristc Search(A*)"></a>启发式搜索的实现、特性 - Heuristc Search(A*)</h2><p>代码模板  </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AstarSearch</span>(<span class="params">graph, start, end</span>):	</span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级 —&gt; 估价函数	</span></span><br><span class="line">    pq.append([start]) 	</span><br><span class="line">    visited.add(start)	</span><br><span class="line">    <span class="keyword">while</span> pq: 		</span><br><span class="line">        node = pq.pop() <span class="comment"># can we add more intelligence here ?		</span></span><br><span class="line">        visited.add(node)		</span><br><span class="line">        process(node) 		</span><br><span class="line">        nodes = generate_related_nodes(node)    </span><br><span class="line">        unvisited = [node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]		</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure>

<h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>启发式搜索：h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点<code>n</code>的目标结点路径的估计成本。<br>启发式搜索是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。  </p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><ul>
<li><a href="https://leetcode-cn.com/problems/word-ladder/">https://leetcode-cn.com/problems/word-ladder/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">https://leetcode-cn.com/problems/minimum-genetic-mutation/</a></li>
</ul>
<h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><ul>
<li><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/sliding-puzzle/">https://leetcode-cn.com/problems/sliding-puzzle/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/sudoku-solver/">https://leetcode-cn.com/problems/sudoku-solver/</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/">AlphaZero Explained</a><br><a href="https://en.wikipedia.org/wiki/Game_complexity">棋类复杂度</a><br><a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw/read">A*代码模板</a><br><a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/">相似度测量方法</a><br><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python">二进制矩阵中的最短路径的 A* 解法</a><br><a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/">8 puzzles 解法比较</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>剪枝</tag>
        <tag>双向BFS</tag>
        <tag>双向DFS</tag>
        <tag>启发式搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-布隆过滤器、LRUCache的实现和应用</title>
    <url>/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/</url>
    <content><![CDATA[<h2 id="布隆过滤器-Bloom-filter"><a href="#布隆过滤器-Bloom-filter" class="headerlink" title="布隆过滤器-Bloom filter"></a>布隆过滤器-Bloom filter</h2><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/hashtable.png">  </p>
<h3 id="Bloom-filter-vs-Hash-Table"><a href="#Bloom-filter-vs-Hash-Table" class="headerlink" title="Bloom filter vs Hash Table"></a>Bloom filter vs Hash Table</h3><p>一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。  </p>
<p>优点：空间效率和查询时间都远远超过一般的算法。  </p>
<p>缺点：有一定的误识别率和删除困难。  </p>
<p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/buloom.png">  </p>
<p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bloom2.png">  </p>
<p>结论：如果这个元素在布隆过滤器查不到，那肯定不存在；如果查得到，那可能存在。  </p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1，比特币网络<br>2，分布式系统（Map-Reduce）——Hadoop、Search Engine<br>3，Redis缓存<br>4，垃圾邮件、评论等的过滤  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bpython.png">  </p>
<h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><h3 id="Cache缓存"><a href="#Cache缓存" class="headerlink" title="Cache缓存"></a>Cache缓存</h3><p>1，记忆<br>2，钱包-储物柜<br>3，代码模块  </p>
<ul>
<li>两个要素：大小、替换策略  </li>
<li>Hash Table + Double LinkedList  </li>
<li>O(1)查询，修改、更新</li>
</ul>
<p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/lru-cache-work.png">  </p>
<p>代码示例：  </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>(<span class="title class_ inherited__">object</span>): 	</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>): 		</span><br><span class="line">        self.dic = collections.OrderedDict() 		</span><br><span class="line">        self.remain = capacity	<span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>): 		</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic: 			</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> 		</span><br><span class="line">            v = self.dic.pop(key) 		</span><br><span class="line">            self.dic[key] = v   <span class="comment"># key as the newest one 		</span></span><br><span class="line">            <span class="keyword">return</span> v 	</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>): 		</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> self.dic: 			</span><br><span class="line">                self.dic.pop(key) 		</span><br><span class="line">            <span class="keyword">else</span>: 			</span><br><span class="line">                <span class="keyword">if</span> self.remain &gt; <span class="number">0</span>: 				</span><br><span class="line">                    self.remain -= <span class="number">1</span> 			</span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># self.dic is full				</span></span><br><span class="line">                    self.dic.popitem(last=<span class="literal">False</span>) 		</span><br><span class="line">            self.dic[key] = value</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 使用 哈希表 + 双端链表 实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedNode</span> &#123;  constructor(key = <span class="number">0</span>, val = <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="built_in">this</span>.key = key    </span><br><span class="line">    <span class="built_in">this</span>.val = val    </span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>    </span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;  </span><br><span class="line">    constructor() &#123;    <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>()    <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>()    <span class="built_in">this</span>.head.next = <span class="built_in">this</span>.tail    <span class="built_in">this</span>.tail.prev = <span class="built_in">this</span>.head  &#125;  insertFirst(node) &#123;    node.next = <span class="built_in">this</span>.head.next    node.prev = <span class="built_in">this</span>.head    <span class="built_in">this</span>.head.next.prev = node    <span class="built_in">this</span>.head.next = node  &#125;  remove(node) &#123;    node.prev.next = node.next    node.next.prev = node.prev  &#125;  removeLast() &#123;    <span class="keyword">if</span> (<span class="built_in">this</span>.tail.prev === <span class="built_in">this</span>.head) <span class="keyword">return</span> <span class="literal">null</span>    <span class="type">let</span> <span class="variable">last</span> <span class="operator">=</span> <span class="built_in">this</span>.tail.prev    <span class="built_in">this</span>.remove(last)    <span class="keyword">return</span> last  &#125;&#125;<span class="comment">/** * <span class="doctag">@param</span> &#123;number&#125; capacity */</span><span class="type">var</span> <span class="variable">LRUCache</span> <span class="operator">=</span> function(capacity) &#123;  <span class="built_in">this</span>.capacity = capacity  <span class="built_in">this</span>.keyNodeMap = <span class="keyword">new</span> <span class="title class_">Map</span>()  <span class="built_in">this</span>.cacheLink = <span class="keyword">new</span> <span class="title class_">LinkedList</span>()&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key * <span class="doctag">@return</span> &#123;number&#125; */</span>LRUCache.prototype.get = function(key) &#123;  <span class="keyword">if</span> (!<span class="built_in">this</span>.keyNodeMap.has(key)) <span class="keyword">return</span> -<span class="number">1</span>  <span class="type">let</span> <span class="variable">val</span> <span class="operator">=</span> <span class="built_in">this</span>.keyNodeMap.get(key).val  <span class="built_in">this</span>.put(key, val)  <span class="keyword">return</span> val&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key  * <span class="doctag">@param</span> &#123;number&#125; value * <span class="doctag">@return</span> &#123;void&#125; */</span>LRUCache.prototype.put = function(key, value) &#123;  <span class="type">let</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.keyNodeMap.size  <span class="title function_">if</span> <span class="params">(<span class="built_in">this</span>.keyNodeMap.has(key)</span>) &#123;    <span class="built_in">this</span>.cacheLink.remove(<span class="built_in">this</span>.keyNodeMap.get(key));     --size   &#125;  <span class="keyword">if</span> (size &gt;= <span class="built_in">this</span>.capacity) &#123;    <span class="built_in">this</span>.keyNodeMap.delete(<span class="built_in">this</span>.cacheLink.removeLast().key)  &#125;  <span class="type">let</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value)  <span class="built_in">this</span>.keyNodeMap.set(key, node)  <span class="built_in">this</span>.cacheLink.insertFirst(node)&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/cpselvis/p/6265825.html">布隆过滤器(Bloom Filter)的原理和实现</a><br><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877">使用BloomFilter布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a><br><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">Bloom Filters – Introduction and Implementation</a><br><a href="https://github.com/jhgg/pybloof">Github-Pybloof</a><br><a href="https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java">布隆过滤器Java实现示例1</a><br><a href="https://github.com/Baqend/Orestes-Bloomfilter">布隆过滤器Java实现示例2</a><br><a href="https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/">Understanding the Meltdown exploit – in my own simple words</a><br><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Cache replacement policies</a><br><a href="https://shimo.im/docs/tTxRkGwJpXG6WkGY/read">LRU Cache Python代码</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>LRUCache</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-初级排序和高级排序的实现和特性</title>
    <url>/2021/02/24/geekbang-gatc-18-sort-algo/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1，比较类排序"><a href="#1，比较类排序" class="headerlink" title="1，比较类排序"></a>1，比较类排序</h3><p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。  </p>
<h3 id="2，非比较类排序"><a href="#2，非比较类排序" class="headerlink" title="2，非比较类排序"></a>2，非比较类排序</h3><p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。  </p>
<p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort.png">  </p>
<p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort2.png">  </p>
<p>(大厂一般回考时间复杂度为<code>nlogn</code>的排序算法——<strong>堆排序、快速排序、归并排序</strong>，比如快速排序和归并排序用到了分治思想)  </p>
<h2 id="初级排序-O-n-2"><a href="#初级排序-O-n-2" class="headerlink" title="初级排序-O(n^2)"></a>初级排序-O(n^2)</h2><ul>
<li><p>1,选择排序<br>每次找最小值，然后放到待排序数组的起始位置。  </p>
</li>
<li><p>2，插入排序<br>从前往后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  </p>
</li>
<li><p>3，冒泡排序<br>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p>
</li>
</ul>
<h2 id="高级排序-O-N-LogN"><a href="#高级排序-O-N-LogN" class="headerlink" title="高级排序-O(N*LogN)"></a>高级排序-O(N*LogN)</h2><ul>
<li>快速排序<br>数组取标杆<code>pivot</code>，将小元素放<code>pivot</code>左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line">func <span class="title function_">quickSort</span><span class="params">(array []<span class="type">int</span>, begin, end <span class="type">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> end &lt;= begin &#123;</span><br><span class="line">                 <span class="keyword">return</span>   </span><br><span class="line">                 &#125;   </span><br><span class="line">    pivot := partition(array, begin, end)   </span><br><span class="line">    quickSort(array, begin, pivot-<span class="number">1</span>)   </span><br><span class="line">    quickSort(array, pivot+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">partition</span><span class="params">(array []<span class="type">int</span>, begin, end <span class="type">int</span>)</span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于pivot的元素的个数   </span></span><br><span class="line">    pivot, counter := end, begin   </span><br><span class="line">    <span class="keyword">for</span> i := begin; i &lt; end; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; array[pivot] &#123;</span><br><span class="line">            array[i], array[counter] = array[counter], array[i]         </span><br><span class="line">            counter++      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    array[pivot], array[counter] = array[counter], array[pivot]   </span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序——分治<br>1，把长度为<code>n</code>的输入序列分成两个长度为<code>n/2</code>的子序列；<br>2，把这两个子序列分别采用归并排序；<br>3，将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">//(left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array,left,mid);</span><br><span class="line">    mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">    merge(array,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line">    <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>归并和快排具有相似性，但步骤顺序相反</strong>  </p>
<p>归并：先排序左右子数组，然后合并两个有序子数组；<br>快排：先调配出左右子数组，然后对于左右子数组进行排序。  </p>
<ul>
<li>堆排序——堆插入O(logN)，取最大&#x2F;小值O(1)<br>1，数组元素依次建立小顶堆；<br>2，依次取堆顶元素，并删除。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cpp</span></span><br></pre></td></tr></table></figure>


<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a><br><a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/read">快速排序算法示例</a><br><a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/">归并排序算法示例</a><br><a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/">堆排序代码示例</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-位运算基础及实战要点</title>
    <url>/2021/01/22/geekbang-gatc-16-bit-operation/</url>
    <content><![CDATA[<p><img src="/2021/01/22/geekbang-gatc-16-bit-operation/wei-yun-suan-fu.png">   </p>
<p><img src="/2021/01/22/geekbang-gatc-16-bit-operation/wei-yun-suan-fu-2.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-16-bit-operation/xor-yi-huo.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-16-bit-operation/zhi-ding-wei-zhi.png">  </p>
<p><img src="/2021/01/22/geekbang-gatc-16-bit-operation/shi-zhan.png">  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6">如何从十进制转换为二进制</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-字符串基础知识、高级字符串算法、字符串匹配算法</title>
    <url>/2021/02/24/geekbang-gatc-20-string-algo/</url>
    <content><![CDATA[<h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="字符串基础问题"><a href="#字符串基础问题" class="headerlink" title="字符串基础问题"></a>字符串基础问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/to-lower-case/">https://leetcode-cn.com/problems/to-lower-case/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/length-of-last-word/">https://leetcode-cn.com/problems/length-of-last-word/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/jewels-and-stones/">https://leetcode-cn.com/problems/jewels-and-stones/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li>
</ul>
<h3 id="字符串操作问题"><a href="#字符串操作问题" class="headerlink" title="字符串操作问题"></a>字符串操作问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/">https://leetcode-cn.com/problems/longest-common-prefix/description/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-string-ii/">https://leetcode-cn.com/problems/reverse-string-ii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-only-letters/">https://leetcode-cn.com/problems/reverse-only-letters/</a></li>
</ul>
<h3 id="异位词问题"><a href="#异位词问题" class="headerlink" title="异位词问题"></a>异位词问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li>
</ul>
<h3 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li>
</ul>
<h3 id="最长子串、子序列问题"><a href="#最长子串、子序列问题" class="headerlink" title="最长子串、子序列问题"></a>最长子串、子序列问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li>
</ul>
<h3 id="字符串-DP-问题"><a href="#字符串-DP-问题" class="headerlink" title="字符串 +DP 问题"></a>字符串 +DP 问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/wildcard-matching/">https://leetcode-cn.com/problems/wildcard-matching/</a></li>
<li><a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></li>
</ul>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul>
<li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-string-ii/">https://leetcode-cn.com/problems/reverse-string-ii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/reverse-only-letters/">https://leetcode-cn.com/problems/reverse-only-letters/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/isomorphic-strings/">https://leetcode-cn.com/problems/isomorphic-strings/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/wildcard-matching">https://leetcode-cn.com/problems/wildcard-matching</a>  </li>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">https://leetcode-cn.com/problems/longest-valid-parentheses</a>  </li>
<li><a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://lemire.me/blog/2017/07/07/are-your-strings-immutable/">不可变字符串</a><br><a href="https://shimo.im/docs/KkDKkpWxjjrJXdpY/read">Atoi 代码示例</a><br><a href="http://xn--https-ni33a/www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">Boyer-Moore 算法</a><br><a href="https://blog.csdn.net/u012505432/article/details/52210975">Sunday 算法</a><br><a href="https://shimo.im/docs/dQDxQW8yXPXxh3Hg/read">字符串匹配暴力法代码示例</a><br><a href="https://shimo.im/docs/KXDdkT99TVtXvTXP/read">Rabin-Karp 代码示例</a><br><a href="https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171">KMP 字符串匹配算法视频</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的 KMP 算法</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>高级字符串算法</tag>
        <tag>字符串匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营总结和收获</title>
    <url>/2021/03/03/geekbang-gatc-gain/</url>
    <content><![CDATA[<p>花了将近一个月终于刷完了算法训练营，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、<code>AVL Tree</code>、红黑树这种高级数据结构，让我不得不感人类思想的伟大。  </p>
<p>字符串算法和排序算法很重要，面试经常考，要及时掌握，同时不能放弃刷题，要时刻保持做题手感，同时要时刻借鉴别人优秀的解题思路。这样编程能力以及算法的基本功会慢慢得到提升。  </p>
<p>加油！^_^  </p>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://octopuslian.github.io/categories/GATC/">GATC</a><br><a href="https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/">时间复杂度和空间复杂度分析</a><br><a href="https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/">数组、链表、跳表</a><br><a href="https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/">树、二叉树、二叉搜索树</a><br><a href="https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/">递归</a><br><a href="https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/">算法体验营-结课考试题</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-04-stack-and-queue/">栈和队列</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-12-dynamic-programming/">动态规划</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/">Trie树、并查集</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-16-bit-operation/">位运算基础</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-05-hashmap-and-set/">哈希表、映射、集合</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/">分治、回溯</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-09-dfs-and-bfs/">深度优先搜索、广度优先搜索</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/">贪心算法</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/">二分查找</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/">初级排序和高级排序</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/">字符串基础知识、高级字符串算法、字符串匹配算法</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/">高级搜索</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/">AVL树和红黑树</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/">布隆过滤器、LRUCache</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/">动态规划、状态转移方程</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>收获</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年市场行情如何？我该跳槽吗？</title>
    <url>/2020/06/16/geekbang-live-2020-how-is-the-market-this-year-should-i-switch-jobs/</url>
    <content><![CDATA[<h2 id="直播介绍"><a href="#直播介绍" class="headerlink" title="直播介绍"></a>直播介绍</h2><p>直播嘉宾：Bendy PAN，资深技术猎头。  </p>
<h2 id="如何正确地选择工作机会"><a href="#如何正确地选择工作机会" class="headerlink" title="如何正确地选择工作机会"></a>如何正确地选择工作机会</h2><ul>
<li>结合市场趋势和自身优点。  </li>
<li>兼顾自己的兴趣爱好，抬头看天，脚踏实地，少走弯路。  </li>
<li>对于暂时够不到的位置：定高目标，努力拼搏。  </li>
<li>职位推荐渠道的选择：直投，内推和猎头</li>
</ul>
<h2 id="如何更好地准备面试"><a href="#如何更好地准备面试" class="headerlink" title="如何更好地准备面试"></a>如何更好地准备面试</h2><ul>
<li>针对目标公司要求做更加充分的准备；  </li>
<li>有针对性地优化简历，理顺简历上所做过的任何一个项目，最好连上下游都要了解；  </li>
<li>项目中可能遇到的技术细节着重复习（针对初级和中级岗位）。</li>
</ul>
<h2 id="如何更好地准备面试-1"><a href="#如何更好地准备面试-1" class="headerlink" title="如何更好地准备面试"></a>如何更好地准备面试</h2><ul>
<li>有针对性地刷题；  </li>
<li>对于高级岗位，架构和设计也要列入复习的范围；  </li>
<li>对于管理岗位，更加注重沟通和软技能。</li>
</ul>
<h2 id="如何优雅地谈薪资"><a href="#如何优雅地谈薪资" class="headerlink" title="如何优雅地谈薪资"></a>如何优雅地谈薪资</h2><ul>
<li>尽可能详细列出自己目前可能有的收入并提供相应的材料证明；  </li>
<li>根据市场信息，结合整个面试的自我认知，综合给出一个自己的期望；  </li>
<li>诚实稳重，守住自己的底线，但也不要好高骛远，漫天要价；  </li>
<li>参考网上信息，但也要细分自己所处的细分领域职位。</li>
</ul>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="从二线和一线薪资涨幅怎么算"><a href="#从二线和一线薪资涨幅怎么算" class="headerlink" title="从二线和一线薪资涨幅怎么算"></a>从二线和一线薪资涨幅怎么算</h3><p>衣食住行算进去，再涨个30%~40%。  </p>
<h3 id="一开始工资就很低怎么办"><a href="#一开始工资就很低怎么办" class="headerlink" title="一开始工资就很低怎么办"></a>一开始工资就很低怎么办</h3><p>看机会，只能尽可能让HR帮你涨薪。  </p>
<h3 id="去银行之类可行吗"><a href="#去银行之类可行吗" class="headerlink" title="去银行之类可行吗"></a>去银行之类可行吗</h3><p>技术比较传统，因为还是要求稳。  </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>字节跳动，外企比较注重算法；  </li>
<li>一般5-10年工作经验，涨幅在30~40%左右比较合适；  </li>
<li>找一些同行里比较厉害的，帮你做下系统性的规划；  </li>
<li>选择计算机行业就注定要不断、积极地努力学习；</li>
</ul>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>职业规划</tag>
        <tag>市场行情</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练营-动态规划、状态转移方程串讲</title>
    <url>/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/</url>
    <content><![CDATA[<h2 id="常见的DP题目和状态转移方程"><a href="#常见的DP题目和状态转移方程" class="headerlink" title="常见的DP题目和状态转移方程"></a>常见的DP题目和状态转移方程</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/pa-lou-ti.png">  </p>
<h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/bu-tong-lu-jing.png">  </p>
<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/da-jia-jie-she.png">  </p>
<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/zui-xiao.png">  </p>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/gu-piao.png">  </p>
<p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/2-gu-piao.png">  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/">一个通用方法团灭 6 道股票问题</a></p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_7天算法体验营_Day2-数组、链表、跳表的基本实现和特性</title>
    <url>/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/</url>
    <content><![CDATA[<h2 id="数组、链表、跳表的基本实现和特性"><a href="#数组、链表、跳表的基本实现和特性" class="headerlink" title="数组、链表、跳表的基本实现和特性"></a>数组、链表、跳表的基本实现和特性</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组-Array"></a>数组-Array</h3><p>时间复杂度  </p>
<ul>
<li>prepend O(1)  </li>
<li>append O(n)  </li>
<li>lookup O(1)  </li>
<li>insert O(n)  </li>
<li>delete O(n)</li>
</ul>
<h3 id="链表-Link-List"><a href="#链表-Link-List" class="headerlink" title="链表-Link-List"></a>链表-Link-List</h3><p>时间复杂度  </p>
<ul>
<li>prepend O(1)  </li>
<li>append O(1)  </li>
<li>lookup O(n)  </li>
<li>insert O(1)  </li>
<li>delete O(1)</li>
</ul>
<h3 id="跳表-skip-list"><a href="#跳表-skip-list" class="headerlink" title="跳表-skip-list"></a>跳表-skip-list</h3><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sktedian.png">  </p>
<h3 id="如何给有序的链表加速"><a href="#如何给有序的链表加速" class="headerlink" title="如何给有序的链表加速"></a>如何给有序的链表加速</h3><p><strong>一维数据的加速方式——升级为二维。</strong>  </p>
<p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sk1.png">  </p>
<p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sk2.png">  </p>
<h3 id="跳表查询的时间复杂度分析"><a href="#跳表查询的时间复杂度分析" class="headerlink" title="跳表查询的时间复杂度分析"></a>跳表查询的时间复杂度分析</h3><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sktime.png">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>数组、链表、跳表的原理和实现  </li>
<li>三者的时间复杂度、空间复杂度  </li>
<li>跳表：升维思想 + 空间换时间</li>
</ul>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>学习了数组、链表、跳表三种数据结构的特点和时间复杂度分析，虽然项目中用的最多的还是数组，但后期如果优化的还是可以借鉴链表和跳表的设计思想。  </p>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a>  </li>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/b1ab4a170c3c">简书_LRU缓存算法</a><br><a href="https://leetcode-cn.com/problems/lru-cache/">leetcode-146. LRU 缓存机制</a><br><a href="https://www.zhihu.com/question/20202931/answer/30983057">为啥 redis 使用跳表(skiplist)而不是使用 red-black？</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>链表</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_7天算法体验营_Day1-时间复杂度和空间复杂度分析</title>
    <url>/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/</url>
    <content><![CDATA[<h2 id="常见的7种时间复杂度"><a href="#常见的7种时间复杂度" class="headerlink" title="常见的7种时间复杂度"></a>常见的7种时间复杂度</h2><ul>
<li>O(1)：常数复杂度；  </li>
<li>O(log n)：对数复杂度；  </li>
<li>O(n)：线性时间复杂度；  </li>
<li>O(n^2)：平方；  </li>
<li>O(n^3)：立方；  </li>
<li>O(2^n)：指数；  </li>
<li>O(n!)：阶乘法。</li>
</ul>
<h2 id="通过代码来分析时间复杂度-Golang"><a href="#通过代码来分析时间复杂度-Golang" class="headerlink" title="通过代码来分析时间复杂度(Golang)"></a>通过代码来分析时间复杂度(Golang)</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">100</span></span><br><span class="line">fmt.Print(n)</span><br></pre></td></tr></table></figure>

<p>程序只执行1次。  </p>
<h3 id="O-N"><a href="#O-N" class="headerlink" title="O(N)"></a>O(N)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello:&quot;</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将<code>fmt.Println(&quot;hello&quot;)</code>执行了n次。  </p>
<h3 id="O-N-2"><a href="#O-N-2" class="headerlink" title="O(N^2)"></a>O(N^2)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello:&quot;</span>,i,j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将<code>fmt.Println(&quot;hello&quot;)</code>执行力n*n&#x3D;n^2次。  </p>
<p>拓展：如果是以下代码，时间复杂度是多少？  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello:&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello:&quot;</span>,j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个循环是并列关系，所以<code>fmt.Println(&quot;hello&quot;)</code>被执行了2*n次，我们忽略常数系数，所以时间复杂度是O(N)。  </p>
<p><strong>总结：如果循环是N层嵌套关系，则时间复杂度是O(N^N)，如果循环是并列关系，则时间复杂度是O(N)。</strong>  </p>
<h3 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log(n))"></a>O(log(n))</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i=i*<span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello:,&quot;</span>i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="O-k-n"><a href="#O-k-n" class="headerlink" title="O(k^n)"></a>O(k^n)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span><span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个递归程序。  </p>
<h2 id="时间复杂度曲线图"><a href="#时间复杂度曲线图" class="headerlink" title="时间复杂度曲线图"></a>时间复杂度曲线图</h2><p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/time.png">  </p>
<ul>
<li>一定要在写程序的时候时刻考虑时间复杂度；  </li>
<li>能够用最简单的时间复杂度和空间复杂度完成这段程序的话基本是一个顶尖职业选手的必备素养。</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="计算1-2-3-…-n"><a href="#计算1-2-3-…-n" class="headerlink" title="计算1+2+3+…+n"></a>计算1+2+3+…+n</h3><h4 id="方法一：循环"><a href="#方法一：循环" class="headerlink" title="方法一：循环"></a>方法一：循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = 0</span><br><span class="line">for i = 1 to n:</span><br><span class="line">    y += i</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)  </p>
<h4 id="方法二：求和公式"><a href="#方法二：求和公式" class="headerlink" title="方法二：求和公式"></a>方法二：求和公式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = n * (n + 1) / 2</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)  </p>
<h3 id="求斐波那契数列第n项和"><a href="#求斐波那契数列第n项和" class="headerlink" title="求斐波那契数列第n项和"></a>求斐波那契数列第n项和</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span><span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画出递归树分析时间复杂度：  </p>
<p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/tree.png">  </p>
<h2 id="主定理（重要）"><a href="#主定理（重要）" class="headerlink" title="主定理（重要）"></a>主定理（重要）</h2><p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/master.png">  </p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li><p>二叉树遍历-前序、中序、后序：时间复杂度是多少？  </p>
</li>
<li><p>图的遍历：时间复杂度是多少？  </p>
</li>
<li><p>搜索算法：DFS、BFS时间复杂度是多少？  </p>
</li>
<li><p>二分查找：时间复杂度是多少？</p>
</li>
</ul>
<h2 id="面试四件套"><a href="#面试四件套" class="headerlink" title="面试四件套"></a>面试四件套</h2><ul>
<li>１，和面试官沟通清楚问题，扫清问题的盲点；  </li>
<li>２，想所有可能的解决方案；  </li>
<li>３，比较时间和空间复杂度，找出最优解；  </li>
<li>４，写程序实现；  </li>
<li>５，测试结果。</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>通过亮点来分析：  </p>
<ul>
<li><p>数组的长度  </p>
</li>
<li><p>递归的深度（特殊说明）</p>
</li>
</ul>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/">https://leetcode-cn.com/problems/climbing-stairs/solution/</a>  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>常用工具配置  </li>
<li>基本功和编程功法  </li>
<li>常见的时间、空间复杂度</li>
</ul>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>我最开始体会到时间复杂度的优势是在大二参加算法竞赛前夕，犹记得在搜索某一个算法题目的题解的时候，眼睁睁看着作者将一段复杂的程序通过微积分优化成一行简易的代码，AC一遍直接通过，这使我留下了时刻的印象。<br>工作后虽然我主要做的是开发，但有些优化时间复杂度的思想有时也会用在业务逻辑中，希望我后期可以<strong>最简单的时间复杂度和空间复杂度完成一段程序，达到职业选手的素养！</strong>  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.zhihu.com/question/21387264/answer/422323594">知乎_如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等？</a>  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>体验营</tag>
        <tag>极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_7天算法体验营_Day3-树、二叉树、二叉搜索树的实现和特性</title>
    <url>/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/tree.png">  </p>
<ul>
<li>Linked List就是特殊化的Tree  </li>
<li>Tree是特殊化的Graph（因为多了个环）</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/btree.png">  </p>
<p>节点只有两个。  </p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li>1，前序（Pre-order）：根-左-右  </li>
<li>2，中序（In-order）：左-根-右  </li>
<li>3，后序（Post-order）：左-右-根</li>
</ul>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/bstree1.png">  </p>
<p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/bstree2.png">  </p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/complex.png">  </p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>树的面试题解法一般都是递归，为什么？</li>
</ul>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>树这个数据结构在项目中经常被使用，面试也经常被问到二叉树相关的题目，所以要熟悉它的流程，多刷题，争取掌握它！  </p>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>极客时间</tag>
        <tag>树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_7天算法体验营_Day5-算法体验营-结课考试题</title>
    <url>/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/</url>
    <content><![CDATA[<h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><ul>
<li>1,数组作为函数参数传递的是（A）</li>
</ul>
<p>A. 数组的首地址</p>
<p>B. 数组元素个数</p>
<p>C. 数组中各元素值</p>
<p>D. 数组的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：考察的是数组传递给函数作为参数的原理。</span><br><span class="line"></span><br><span class="line">传递方式如下三种：每种方式都会告诉编译器要接收一个指针，及数组的地址（首元素地址）</span><br><span class="line">void myFunction(int *param)</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个指针</span><br><span class="line">&#125;</span><br><span class="line">void myFunction(int param[10])</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个已定义大小的数组</span><br><span class="line">&#125;</span><br><span class="line">void myFunction(int param[])</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个未定义大小的数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2,在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。 （A）</li>
</ul>
<p>A. n-i，n-i+1  </p>
<p>B. n-i+1，n-i  </p>
<p>C. n-i，n-i  </p>
<p>D. n-i+1，n-i+1  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：删除第i个元素，要移动后面n-i个元素</span><br><span class="line"></span><br><span class="line">在第i个元素之前插入，要移动包括i在内的n-i+1个元素</span><br></pre></td></tr></table></figure>

<h2 id="链表相关"><a href="#链表相关" class="headerlink" title="链表相关"></a>链表相关</h2><p>3,带头结点head的单向循环链表L为空的判断条件是？（C）  </p>
<p>A. head&#x3D;&#x3D;NULL  </p>
<p>B. head-&gt;next&#x3D;&#x3D;NULL  </p>
<p>C. head-&gt;next&#x3D;&#x3D;head  </p>
<p>D. head!&#x3D;NULL  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：基础概念，单向循环链表且带有头节点，判断为空，即循环链表只有头节点，自己指向自己，head-&gt;next = head，因此选C。</span><br></pre></td></tr></table></figure>

<h2 id="栈、队列相关"><a href="#栈、队列相关" class="headerlink" title="栈、队列相关"></a>栈、队列相关</h2><p>4,队列和栈有什么区别？(A)  </p>
<p>A. 队列先进先出，栈后进先出  </p>
<p>B. 队列和栈都是先进先出  </p>
<p>C. 队列和栈都是后进先出  </p>
<p>D. 栈先进先出，队列后进先出  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案解析】：相同点：从&quot;数据结构&quot;的角度看，它们都是线性结构，即数据元素之间的关系相同。</span><br><span class="line"></span><br><span class="line">不同点：栈（Stack）是限定只能在表的一端进行插入和删除操作的线性表。 队列（Queue）是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。它们是完全不同的数据类型。除了它们各自的基本操作集不同外，主要区别是对插入和删除操作的&quot;限定&quot;。</span><br><span class="line"></span><br><span class="line">栈必须按&quot;后进先出&quot;的规则进行操作：比如说，小学老师批改学生的作业，如果不打乱作业本的顺序的话，那么老师批改的第一份作业一定是最后那名同学交的那份作业，如果把所有作业本看作是一个栈中的元素，那么最后一个同学交的作业本就是栈顶元素，而第一个同学交的，也就是最低端的作业本，就是栈底元素，这就是对栈的读取规则。</span><br><span class="line"></span><br><span class="line">而队列必须按&quot;先进先出&quot;的规则进行操作：打个比方，一些人去银行办理业务，一定是先去排队的最先得到服务，当然他也是第一个走出银行的（假设这些人都在一个窗口排队）。如果把所有这些等候服务的人看作是队的元素，第一个人就是对头元素，相应的，最后一个人就是队尾元素。这是队的读取规则。</span><br></pre></td></tr></table></figure>

<h2 id="二叉树相关"><a href="#二叉树相关" class="headerlink" title="二叉树相关"></a>二叉树相关</h2><p>5,已知某二叉树的前序为（1-2-3-4-5-6-7-8-9），中序为（2-3-1-6-7-8-5-9-4），则它的后续为？ （A）  </p>
<p>A. 3-2-8-7-6-9-5-4-1  </p>
<p>B. 1-2-6-5-4-3-8-7-9  </p>
<p>C. 5-4-2-1-3-7-6-9-8  </p>
<p>D. 2-3-5-4-6-7-9-1-8  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：根据前序遍历可以确定根节点为1，再根据中序遍历可以确定A的左侧为左子树23，其余为右子树，再根据前序遍历得到左子树的根节点为2，右子树的根节点为4，然后递归下去就能恢复二叉树，然后后续遍历得到结果328769541。</span><br></pre></td></tr></table></figure>

<p>6,在任意一棵二叉树的前序序列和后序序列中，各叶子之间的相对次序关系（ B ）  </p>
<p>A. 不一定相同  </p>
<p>B. 都相同  </p>
<p>C. 都不相同  </p>
<p>D. 互为逆序  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：</span><br><span class="line"></span><br><span class="line">前序序列：根结点 --&gt; 左子树 --&gt; 右子树    </span><br><span class="line"></span><br><span class="line">后序序列：左子树 --&gt; 右子树 --&gt; 根结点   </span><br><span class="line"></span><br><span class="line">根据题目结合前序、后续的遍历顺序规则，如下图： </span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/tree.png">  </p>
<ul>
<li><p>第一个二叉树叶子节点D、C 先序和后序顺序均为先D后C  </p>
</li>
<li><p>第二个二叉树叶子节点B、D 先序和后序属性均为先B后D</p>
</li>
</ul>
<p><strong>结论</strong>：叶子节点位于左右两个分支上，先序和后序的遍历属性均是左子树在右子树之前（相对次序一定相同），和二叉树的样式无关。  </p>
<h2 id="递归相关"><a href="#递归相关" class="headerlink" title="递归相关"></a>递归相关</h2><ul>
<li>7,采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是（D）</li>
</ul>
<p>A. 递归次数与初始数据的排列次序无关  </p>
<p>B. 每次划分后，先处理较长的分区可以减少递归次数  </p>
<p>C. 每次划分后，先处理较短的分区可以减少递归次数  </p>
<p>D. 递归次数与每次划分后得到的分区处理顺序无关  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。</span><br><span class="line"></span><br><span class="line">而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数</span><br></pre></td></tr></table></figure>

<ul>
<li>8,对递归程序的优化的一般的手段是？（A）</li>
</ul>
<p>A. 尾递归优化  </p>
<p>B. 循环优化  </p>
<p>C. 堆栈优化  </p>
<p>D. 停止值优化  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：尾递归是指，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</span><br><span class="line"></span><br><span class="line">以斐波那契数列为例子，普通的递归版本如下：</span><br><span class="line"></span><br><span class="line">int fab(int n)&#123; </span><br><span class="line">    if(n&lt;3) </span><br><span class="line">        return 1; </span><br><span class="line">    else </span><br><span class="line">        return fab(n-1)+fab(n-2);   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">具有&quot;线性迭代过程&quot;特性的递归---尾递归过程</span><br><span class="line"></span><br><span class="line">int fab(int n,int b1=1,int b2=1,int c=3)&#123; </span><br><span class="line">    if(n&lt;3) </span><br><span class="line">        return 1; </span><br><span class="line">    else &#123; </span><br><span class="line">        if(n==c) </span><br><span class="line">             return b1+b2; </span><br><span class="line">        else </span><br><span class="line">             return fab1(n,b2,b1+b2,c+1); </span><br><span class="line">    &#125; 以fab(4)为例子 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">普通递归fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3  6次调用 </span><br><span class="line"></span><br><span class="line">尾递归fab(4,1,1,3)=fab(4,1,2,4)=1+2=3                2次调用</span><br></pre></td></tr></table></figure>

<h2 id="分治相关"><a href="#分治相关" class="headerlink" title="分治相关"></a>分治相关</h2><p>9,在快速排序，归并排序，插入排序，选择排序，冒泡排序中，使用到分治思想的算法个数有几个（B）  </p>
<p>A. 1  </p>
<p>B. 2  </p>
<p>C. 3  </p>
<p>D. 4  </p>
<p>【答案解析】：分治思想是很多高效算法的基础，如归并排序、快速排序、傅立叶变换（快速傅立叶变换）。  </p>
<h2 id="DFS相关"><a href="#DFS相关" class="headerlink" title="DFS相关"></a>DFS相关</h2><ul>
<li>10,图的Depth-First Search(DFS)遍历思想实际上是二叉树（A）遍历方法的推广。</li>
</ul>
<p>A. 先序  </p>
<p>B. 中序  </p>
<p>C. 后序  </p>
<p>D. 层序  </p>
<p>【答案解析】：深度先序，广度层次。  </p>
<h2 id="BFS相关"><a href="#BFS相关" class="headerlink" title="BFS相关"></a>BFS相关</h2><ul>
<li>11,图的BFS生成树的树高比DFS生成树的树高(A)</li>
</ul>
<p>A. 小或相等  </p>
<p>B. 小  </p>
<p>C. 大或相等  </p>
<p>D. 大  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：BFS是广度优先遍历，DFS是深度优先遍历。</span><br><span class="line"></span><br><span class="line">对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。 一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小</span><br></pre></td></tr></table></figure>

<h2 id="排序相关"><a href="#排序相关" class="headerlink" title="排序相关"></a>排序相关</h2><ul>
<li>12,假设你只有100M的内存，需要对1G的数据进行排序，最合适的算法是？（A）</li>
</ul>
<p>A. 归并排序  </p>
<p>B. 插入排序  </p>
<p>C. 快速排序  </p>
<p>D. 冒泡排序  </p>
<p>【答案解析】：归并排序的典型例子，很简单的题目，应该做对。</p>
<ul>
<li>13,一个数据表有51233个元素，如果仅要求找出其中最大的12个元素，你觉得采用下列哪种算法比较节省时间？（A）</li>
</ul>
<p>A. 堆排序  </p>
<p>B. 希尔排序  </p>
<p>C. 快速排序  </p>
<p>D. 直接选择排序  </p>
<p>【答案解析】：本题比较常见排序算法，TopK问题，堆排序，因此选A  </p>
<h2 id="堆、时间复杂度相关"><a href="#堆、时间复杂度相关" class="headerlink" title="堆、时间复杂度相关"></a>堆、时间复杂度相关</h2><ul>
<li>14,从n个数里面找最大的两个数理论上最少需要比较多少次？（C）</li>
</ul>
<p>A. 2logn  </p>
<p>B. 2logn -1  </p>
<p>C. n+ logn -2  </p>
<p>D. 2n-3  </p>
<p>【答案解析】：在n个数中找到最大的两个数的最少比较次数，可以考虑堆排序，首先建堆是时间复杂度为O(n)或比较n-1次，找到最大的一个，然后调整堆，找到次大元素，比较logn-1，因此选C。</p>
<h2 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h2><ul>
<li>15,下面关于哈希查找的说法正确的是？（C）</li>
</ul>
<p>A. 哈希函数构造的越复杂越好，因为这样随机性好，冲突小  </p>
<p>B. 除留余数法是所有哈希函数中最好的  </p>
<p>C. 不存在特别好与坏的哈希函数，要视情况而定  </p>
<p>D. 若需在哈希表中删去一个元素，不管用任何方法解决冲突都只要简单地将该元素删去即可  </p>
<p>【答案解析】：考察哈希，关于哈希有xxx的构造方法，具体哈希算法的好坏需要看情况而定，没有绝对的好与坏。A. 对于数据结构中的哈希函数有两个特点：简单，均匀性。所谓简单就是可以很快的产生一个较好的hash值，均匀性是指所有的数据可以均匀的映射到各个hash值上，避免产生大部分数据映射到少数的hash值上。B.不同的hash函数有不同的适应场景，各有优缺点。主要的方法有，直接定址法，数字分析法，平方取中法，折叠法，随机数法，除留余数法。D.对于空域法，还需要把冲突记录去掉。  </p>
<h2 id="二分查找相关"><a href="#二分查找相关" class="headerlink" title="二分查找相关"></a>二分查找相关</h2><ul>
<li>16,若有序表的关键字序列为（b,c,d,e,f,g,q,r,s,t)，则在二分查找关键字b的过程中，先后进行比较的关键字依次是？（A）</li>
</ul>
<p>A. f,c,b  </p>
<p>B. f,d,b  </p>
<p>C. g,c,d  </p>
<p>D. g,d,b  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：考察二分查找，对于(b,c,d,e,f,g,q,r,s,t)</span><br><span class="line"></span><br><span class="line">第一次查找，left = 0, right = 9, mid = 4, 关键字是f, f != b &amp;&amp; f &gt; b</span><br><span class="line"></span><br><span class="line">第二次查找，left = 0, right = 3, mid = 1, 关键字是c, c != b &amp;&amp; c &gt; b</span><br><span class="line"></span><br><span class="line">第三次查找，left = 0, right = 0, mid = 0, 关键字是b, b == b 查找到</span><br><span class="line"></span><br><span class="line">因此是关键字依次是(f,c,b)</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度、排序相关"><a href="#时间复杂度、排序相关" class="headerlink" title="时间复杂度、排序相关"></a>时间复杂度、排序相关</h2><ul>
<li>17,在最坏的情况下，下列排序方法中时间复杂度最小的是？（D）</li>
</ul>
<p>A. 冒泡排序  </p>
<p>B. 快速排序  </p>
<p>C. 插入排序  </p>
<p>D. 堆排序  </p>
<p>【答案解析】：常见排序算法最坏时间复杂度比较，其中冒泡排序和插入排序O(n^2)，快速排序最坏情况为O(n^2)，只有堆排序比较稳定复杂度为O(nlogn)。  </p>
<h2 id="线性表，二叉平衡树，哈希，高级算法相关"><a href="#线性表，二叉平衡树，哈希，高级算法相关" class="headerlink" title="线性表，二叉平衡树，哈希，高级算法相关"></a>线性表，二叉平衡树，哈希，高级算法相关</h2><ul>
<li>18,下列关于线性表，二叉平衡树，哈希表存储数据的优劣描述错误的是？ （D）</li>
</ul>
<p>A. 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；  </p>
<p>B. 线性表实现相对比较简单  </p>
<p>C. 平衡二叉树的各项操作的时间复杂度为O（logn）  </p>
<p>D. 平衡二叉树的插入节点比较快  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【答案解析】：哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。 </span><br><span class="line"></span><br><span class="line">在平衡二叉树中插入结点要随时保证插入后整棵二叉树是平衡的，所以可能需要通过一次或多次树旋转来重新平衡这个树</span><br></pre></td></tr></table></figure>

<h2 id="动态规划相关"><a href="#动态规划相关" class="headerlink" title="动态规划相关"></a>动态规划相关</h2><ul>
<li>19,下面关于动态规划说法正确的是 （A）</li>
</ul>
<p>A. 他是利用子结构，进行自底而上的算法设计  </p>
<p>B. 他需要后来多次计算的问题进行缓存，减少重复子问题的计算  </p>
<p>C. 他所求问题的整体最优解可以通过一系列局部最优的选择  </p>
<p>D. 他将分解后的子问题看成相互独立的.  </p>
<p>【答案解析】：  </p>
<ul>
<li><p>动态规划利用最优子结构，自底向上从子问题的最优解逐步构成整个问题的最优解  </p>
</li>
<li><p>用空间换时间只是一种技巧，不是动态规划的本质  </p>
</li>
<li><p>贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择,即贪心选择来达到。   </p>
</li>
<li><p>与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的，它们可能共享更小的子问题，被称为重叠子问题。</p>
</li>
</ul>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><ul>
<li>20,字符串 <a href="http://www.qq.com/">www.qq.com</a> 所有非空子串（两个子串如果内容相同则只算一个）个数是（D）</li>
</ul>
<p>A. 1024  </p>
<p>B. 1018  </p>
<p>C. 55  </p>
<p>D. 50  </p>
<p>【答案解析】：非空子串的个数共有n(n+1)&#x2F;2个，n&#x3D;10即55个，由于相同子串算一个，其中w(两次）, ww, q, ., 有重复。故 55 - 5 &#x3D; 50。  </p>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><ul>
<li>基础还是有些薄弱，后期准备再系统学习以下数据结构和算法；  </li>
<li>不懂的一定要尽快搞清楚；  </li>
<li>多刷题，多总结。</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础冲刺营_Day1_Golang基础语法和Web框架起步</title>
    <url>/2021/07/18/geekbang-live-go-basic-sprint-day-1/</url>
    <content><![CDATA[<h2 id="环境按照"><a href="#环境按照" class="headerlink" title="环境按照"></a>环境按照</h2><p>略  </p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="main函数要点"><a href="#main函数要点" class="headerlink" title="main函数要点"></a>main函数要点</h3><ul>
<li>无参数、无返回值  </li>
<li>main方法必须要在main包里面  </li>
<li><code>go run main.go</code>就可以执行  </li>
<li>如果文件不叫<code>main.go</code>，则需要<code>go build</code>之后再<code>go run</code></li>
</ul>
<h3 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h3><ul>
<li>语法形式：package xxx  </li>
<li>字母和下划线的组合  </li>
<li>可以和文件夹不同名字  </li>
<li>同一个文件夹下的声明一致  </li>
<li>引入包语法形式：import [alias] xxx  </li>
<li>如果一个包引入了但是没有使用，会报错  </li>
<li>匿名引入：前面多一个下划线</li>
</ul>
<h3 id="string声明"><a href="#string声明" class="headerlink" title="string声明"></a>string声明</h3><ul>
<li>双引号引起来，则内部双引号需要使用<code>\</code>转义  </li>
<li><code>引号引起来，则内部</code> 需要\转义</li>
</ul>
<h3 id="string和基础类型"><a href="#string和基础类型" class="headerlink" title="string和基础类型"></a>string和基础类型</h3><h4 id="string长度"><a href="#string长度" class="headerlink" title="string长度"></a>string长度</h4><ul>
<li>字节长度：和编码无关，用<code>len(str)</code>获取  </li>
<li>字符数量：和编码无关，用编码库计算</li>
</ul>
<p><strong>新人入门第一坑</strong>：<code>len</code>统计的是字节，而不是字符。  </p>
<h4 id="strings包"><a href="#strings包" class="headerlink" title="strings包"></a>strings包</h4><ul>
<li>string 的拼接直接使用 + 号就可以。 注意的是，某些语言支持 string 和别的类型拼接， 但是golang 不可以  </li>
<li>strings 主要方法（你所需要的全部都可以找到） ：<br>• 查找和替换<br>• 大小写转换<br>• 子字符串相关<br>• 相等</li>
</ul>
<h4 id="rune类型"><a href="#rune类型" class="headerlink" title="rune类型"></a>rune类型</h4><ul>
<li>rune， 直观理解， 就是字符  </li>
<li>rune 不是 byte!  </li>
<li>rune 本质是 int32， 一个 rune 四个字节  </li>
<li>rune 在很多语言里面是没有的， 与之对应的是， golang 没有 char 类型。 rune 不是数字，也不是 char， 也不是 byte！  </li>
<li>实际中不太常用</li>
</ul>
<h4 id="bool-int-uint-float-家族"><a href="#bool-int-uint-float-家族" class="headerlink" title="bool, int, uint, float 家族"></a>bool, int, uint, float 家族</h4><ul>
<li>bool: true, false  </li>
<li>int8, int16, int32, int64, int  </li>
<li>uint8, uint16, uint32, uint64, uint  </li>
<li>float32, float64</li>
</ul>
<h4 id="byte-类型"><a href="#byte-类型" class="headerlink" title="byte 类型"></a>byte 类型</h4><ul>
<li>byte， 字节， 本质是 uint8  </li>
<li>对应的操作包在 bytes 上</li>
</ul>
<h4 id="类型总结"><a href="#类型总结" class="headerlink" title="类型总结"></a>类型总结</h4><ul>
<li>golang 的数字类型明确标注了长度、 有无符号  </li>
<li>golang 不会帮你做类型转换， 类型不同无法通过编译。 也因此， string 只能和string 拼接  </li>
<li>golang 有一个很特殊的 rune 类型， 接近一般语言的 char 或者 character 的概念， 非面试情况下， 可以理解为 “ rune &#x3D; 字符”  </li>
<li>string 遇事不决找 strings 包</li>
</ul>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="变量声明-var"><a href="#变量声明-var" class="headerlink" title="变量声明 var"></a>变量声明 var</h4><p>• var， 语法： var name type &#x3D; value<br>  • 局部变量<br>  • 包变量<br>  • 块声明  </p>
<ul>
<li>驼峰命名  </li>
<li>首字符是否大写控制了访问性： 大写包外可访问；  </li>
<li>golang 支持类型推断</li>
</ul>
<h4 id="变量声明-x3D"><a href="#变量声明-x3D" class="headerlink" title="变量声明 :&#x3D;"></a>变量声明 :&#x3D;</h4><ul>
<li>只能用于局部变量， 即方法内部  </li>
<li>golang 使用类型推断来推断类型。 数字会被理解为 int 或者 float64。 （所以要其它类型的数字， 就得用 var 来声明）</li>
</ul>
<h4 id="变量声明易错点"><a href="#变量声明易错点" class="headerlink" title="变量声明易错点"></a>变量声明易错点</h4><ul>
<li>变量声明了没有使用  </li>
<li>类型不匹配  </li>
<li>同作用域下， 变量只能声明一次</li>
</ul>
<h4 id="常量声明-const"><a href="#常量声明-const" class="headerlink" title="常量声明 const"></a>常量声明 const</h4><ul>
<li>首字符是否大写控制了访问性： 大写包外可访问；  </li>
<li>驼峰命名  </li>
<li>支持类型推断  </li>
<li>无法修改值</li>
</ul>
<h3 id="方法声明与调用"><a href="#方法声明与调用" class="headerlink" title="方法声明与调用"></a>方法声明与调用</h3><h4 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h4><ul>
<li>关键字 func  </li>
<li>方法名字： 首字母是否大写决定了作用域  </li>
<li>参数列表： [<name type>]  </name></li>
<li>返回列表: [<name type>]</name></li>
</ul>
<h4 id="方法声明（推荐写法）"><a href="#方法声明（推荐写法）" class="headerlink" title="方法声明（推荐写法）"></a>方法声明（推荐写法）</h4><ul>
<li>参数列表含有参数名  </li>
<li>返回值不具有返回值名</li>
</ul>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul>
<li>使用 _ 忽略返回值</li>
</ul>
<h4 id="方法声明与调用总结"><a href="#方法声明与调用总结" class="headerlink" title="方法声明与调用总结"></a>方法声明与调用总结</h4><ul>
<li>golang 支持多返回值， 这是一个很大的不同点  </li>
<li>golang 方法的作用域和变量作用域一样， 通过大小写控制  </li>
<li>golang 的返回值是可以有名字的， 可以通过给予名字让调用方清楚知道你返回的是什么</li>
</ul>
<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>数组和别的语言的数组差不多， 语法是： [cap]type  </p>
<ul>
<li><ol>
<li>初始化要指定长度（或者叫做容量）</li>
</ol>
</li>
<li><ol start="2">
<li>直接初始化</li>
</ol>
</li>
<li><ol start="3">
<li>arr[i]的形式访问元素</li>
</ol>
</li>
<li><ol start="4">
<li>len 和 cap 操作用于获取数组长度</li>
</ol>
</li>
</ul>
<p>切片,语法： []type  </p>
<ul>
<li><ol>
<li>直接初始化</li>
</ol>
</li>
<li><ol start="2">
<li>make初始化:make([]type, length, capacity)</li>
</ol>
</li>
<li><ol start="3">
<li>arr[i] 的形式访问元素</li>
</ol>
</li>
<li><ol start="4">
<li>append 追加元素</li>
</ol>
</li>
<li><ol start="5">
<li>len 获取元素数量</li>
</ol>
</li>
<li><ol start="6">
<li>cap 获取切片容容量</li>
</ol>
</li>
<li><ol start="7">
<li>推荐写法： s1 :&#x3D; make([]type, 0, capacity)</li>
</ol>
</li>
</ul>
<p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87.png">  </p>
<h3 id="子切片"><a href="#子切片" class="headerlink" title="子切片"></a>子切片</h3><p>数组和切片都可以通过[start:end] 的形式来获取子切片:  </p>
<ul>
<li><ol>
<li>arr[start:end]， 获得[start, end)之间的元素</li>
</ol>
</li>
<li><ol start="2">
<li>arr[:end]， 获得[0, end) 之间的元素</li>
</ol>
</li>
<li><ol start="3">
<li>arr[start:]， 获得[start, len(arr))之间的元素</li>
</ol>
</li>
</ul>
<p><strong>Tip： 左闭右开原则</strong>  </p>
<h3 id="如何理解切片"><a href="#如何理解切片" class="headerlink" title="如何理解切片"></a>如何理解切片</h3><p>最直观的对比： ArrayList， 即基于数组的 List 的实现， 切片的底层也是数组  </p>
<p>跟 ArrayList 的区别：  </p>
<ul>
<li><ol>
<li>切片操作是有限的， 不支持随机增删（即没有 add, delete 方法， 需要自己写代码）</li>
</ol>
</li>
<li><ol start="2">
<li>只有 append 操作</li>
</ol>
</li>
<li><ol start="3">
<li>切片支持子切片操作， 和原本切片是共享底层数组</li>
</ol>
</li>
</ul>
<p><strong>Tip： 遇事不决用切片， 不容易错</strong>  </p>
<h3 id="共享底层（optional）"><a href="#共享底层（optional）" class="headerlink" title="共享底层（optional）"></a>共享底层（optional）</h3><p>核心： 共享数组  </p>
<p>子切片和切片究竟会不会互相影响， 就抓住一点： 它们是不是还共享数组？<br>什么意思？ 就是如果它们结构没有变化， 那肯定是共享的；<br>但是结构变化了， 就可能不是共享了<br>有余力的同学可以运行一下 ShareSlice()  </p>
<p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/shareslice.png">  </p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for 和别的语言差不多， 有三种形式：  </p>
<ul>
<li><ol>
<li>for {} ， 类似 while 的无限循环</li>
</ol>
</li>
<li><ol start="2">
<li>for i， 一般的按照下标循环</li>
</ol>
</li>
<li><ol start="3">
<li>for range 最为特殊的 range 遍历</li>
</ol>
</li>
<li><ol start="4">
<li>break 和 continue 和别的语言一样</li>
</ol>
</li>
</ul>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if - else"></a>if - else</h3><p>带局部变量声明的 if- else：  </p>
<ul>
<li><ol>
<li>distance 只能在 if 块， 或者后边所有的 else 块里面使用</li>
</ol>
</li>
<li><ol start="2">
<li>脱离了 if - else 块， 则不能再使用</li>
</ol>
</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch 和别的语言差不多<br>switch 后面可以是基础类型和字符串， 或者满足特定条件的结构体<br>最大的差别：终于不用加 break 了  </p>
<p><strong>Tip： 大多数时候， switch 后面只会用基础类型或者字符串</strong>  </p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ul>
<li>计算斐波那契数列  </li>
<li>实现切片的 Add 和 Delete 方法  </li>
<li>去 leetcode 上试试（先看答案， 再尝试用 go 写出来） ：  </li>
<li><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a>  </li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a>  </li>
<li>我们课上用了很多 fmt 来格式化字符串， 那么如何输出：  </li>
<li>3.1 保留两位小数的数字  </li>
<li>3.2 将[]byte 输出为16进制  </li>
<li>预习 type 的用法</li>
</ul>
<h2 id="最简单的Web服务器"><a href="#最简单的Web服务器" class="headerlink" title="最简单的Web服务器"></a>最简单的Web服务器</h2><p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/web.png">  </p>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>基础</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_7天算法体验营_Day4-递归的实现、特性以及思维要点</title>
    <url>/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/</url>
    <content><![CDATA[<h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归-Recursion"></a>递归-Recursion</h2><p>通过函数体来循环调用自己。  </p>
<h3 id="Python代码模板"><a href="#Python代码模板" class="headerlink" title="Python代码模板"></a>Python代码模板</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Recursion</span>(<span class="params">level,param1,param2,...</span>):</span><br><span class="line">    <span class="comment">#递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; MAX_LEVEL:</span><br><span class="line">        process_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#处理当前层逻辑</span></span><br><span class="line">    process(level,data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#下探到下一层</span></span><br><span class="line">    self.Recursion(level+<span class="number">1</span>,p1,...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#清理当前层</span></span><br></pre></td></tr></table></figure>

<h3 id="Java代码模板"><a href="#Java代码模板" class="headerlink" title="Java代码模板"></a>Java代码模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> level,<span class="type">int</span> param)</span> &#123;</span><br><span class="line">    <span class="comment">//terminator</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">        <span class="comment">//process result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//process current logic</span></span><br><span class="line">    process(level,param);</span><br><span class="line">    <span class="comment">//drill down</span></span><br><span class="line">    recur(level:level+<span class="number">1</span>,newParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//restore current status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思维要点"><a href="#思维要点" class="headerlink" title="思维要点"></a>思维要点</h3><ul>
<li>不要人肉递归（最大误区）  </li>
<li>找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）  </li>
<li>数学归纳法思维</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Algorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础冲刺营_Day2_type定义与Server抽象</title>
    <url>/2021/07/19/geekbang-live-go-basic-sprint-day-2/</url>
    <content><![CDATA[<h1 id="http库"><a href="#http库" class="headerlink" title="http库"></a>http库</h1><h2 id="Request概览"><a href="#Request概览" class="headerlink" title="Request概览"></a>Request概览</h2><ul>
<li>Body和GetBody  </li>
<li>URL  </li>
<li>Method  </li>
<li>Header  </li>
<li>Form</li>
</ul>
<h2 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h2><ul>
<li>Body：只能读取一次，意味着你读了别人就不能读了；别人读了你就不能读了。</li>
</ul>
<h2 id="Request-Body-GetBody"><a href="#Request-Body-GetBody" class="headerlink" title="Request Body - GetBody"></a>Request Body - GetBody</h2><ul>
<li>GetBody：原则上是可以多次读取，但是在原生的http.Request里面，这个是 nil  </li>
<li>在读取到 body 之后，我们就可以用于反序列化，比如说将json格式的字符串转化为一个对象等</li>
</ul>
<h2 id="Request-Query"><a href="#Request-Query" class="headerlink" title="Request Query"></a>Request Query</h2><ul>
<li>除了 Body，我们还可能传递参数的地方是 Query  </li>
<li>所有的值都被解释为字符串，所以需要自己解析为数字等</li>
</ul>
<h2 id="Request-URL"><a href="#Request-URL" class="headerlink" title="Request URL"></a>Request URL</h2><ul>
<li>包含路径方面的所有信息和一些很有用的操作  </li>
<li>URL 里面 Host 不一定有值  </li>
<li>r.Host 一般都有值，是Host这个header的值  </li>
<li>RawPath 也是不一定有  </li>
<li>Path肯定有</li>
</ul>
<h2 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h2><ul>
<li>header大体上是两类，一类是http 预定义的；一类是自己定义的  </li>
<li>Go 会自动将 header 名字转为标准名字——其实就是大小写调整  </li>
<li>一般用 X 开头来表明是自己定义的，比如说 X-mycompanyyour&#x3D;header</li>
</ul>
<h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><ul>
<li>Form 和 ParseForm  </li>
<li>要先调用 ParseForm  </li>
<li>建议加上 Content-Type:application&#x2F;x-www-formurlencoded</li>
</ul>
<h1 id="基础语法type"><a href="#基础语法type" class="headerlink" title="基础语法type"></a>基础语法type</h1><h2 id="interface-定义"><a href="#interface-定义" class="headerlink" title="interface 定义"></a>interface 定义</h2><ul>
<li>基本语法 type 名字 interface {}  </li>
<li>里面只能有方法，方法也不需要 func 关键字  </li>
<li>啥是接口（interface）：接口是一组行为的抽象  </li>
<li>尽量用接口，以实现面向接口编程</li>
</ul>
<h2 id="struct-定义"><a href="#struct-定义" class="headerlink" title="struct 定义"></a>struct 定义</h2><ul>
<li>基本语法:</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name <span class="keyword">struct</span> &#123;</span><br><span class="line">fieldName FieldType</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体和结构体的字段都遵循大小写控制访问性的原则</li>
</ul>
<h2 id="type-A-B"><a href="#type-A-B" class="headerlink" title="type A B"></a>type A B</h2><ul>
<li>基本语法: type TypeA TypeB  </li>
<li>我一般是，在我使用第三方库又没有办法修改源码的情况下，又想在扩展这个库的结构体的方法，就会用这个</li>
</ul>
<h2 id="type-A-x3D-B"><a href="#type-A-x3D-B" class="headerlink" title="type A &#x3D; B"></a>type A &#x3D; B</h2><ul>
<li>基本语法: type TypeA &#x3D; TypeB  </li>
<li>别名，除了换了一个名字，没有任何区别</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>Go 没有构造函数！！  </li>
<li>初始化语法： Struct{}  </li>
<li>获取指针： &amp;Struct{}  </li>
<li>获取指针2： new(Struct)  </li>
<li>new 可以理解为 Go 会为你的变量分配内存，并且把内存都置为0</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>和 C， C++ 一样， *表示指针，&amp;取地址  </li>
<li>如果声明了一个指针，但是没有赋值，那么它是 nil</li>
</ul>
<h2 id="结构体自引用"><a href="#结构体自引用" class="headerlink" title="结构体自引用"></a>结构体自引用</h2><ul>
<li>结构体内部引用自己，只能使用指针  </li>
<li>准确来说，在整个引用链上，如果构成循环，那就只能用指针</li>
</ul>
<h2 id="方法接收器"><a href="#方法接收器" class="headerlink" title="方法接收器"></a>方法接收器</h2><ul>
<li>结构体接收器内部永远不要修改字段</li>
</ul>
<h2 id="方法接收器用哪个？"><a href="#方法接收器用哪个？" class="headerlink" title="方法接收器用哪个？"></a>方法接收器用哪个？</h2><ul>
<li>设计不可变对象，用结构体接收器  </li>
<li>其它用指针</li>
</ul>
<p><strong>总结：遇事不决用指针</strong>  </p>
<h1 id="Server与Context抽象"><a href="#Server与Context抽象" class="headerlink" title="Server与Context抽象"></a>Server与Context抽象</h1><h1 id="简单支持RESTFul-API"><a href="#简单支持RESTFul-API" class="headerlink" title="简单支持RESTFul API"></a>简单支持RESTFul API</h1>]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础冲刺营_Day4_并发编程、文件操作与泛型</title>
    <url>/2021/08/18/geekbang-live-go-basic-sprint-day-4/</url>
    <content><![CDATA[<h1 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h1><h2 id="监听系统信号"><a href="#监听系统信号" class="headerlink" title="监听系统信号"></a>监听系统信号</h2><p>服务器难免要遇到重启、升级的问题。那么当我们的服务器关闭的时候，我们需要考虑：  </p>
<ol>
<li>拒绝新的请求  </li>
<li>等待当前的所有请求处理完毕  </li>
<li>释放资源  </li>
<li>关闭服务器  </li>
<li>如果这中间超时了， 我们要强制关闭了</li>
</ol>
<h3 id="基础语法-——-goroutine"><a href="#基础语法-——-goroutine" class="headerlink" title="基础语法 —— goroutine"></a>基础语法 —— goroutine</h3><ul>
<li>一段异步执行的代码  </li>
<li>用关键字 go 启动</li>
</ul>
<h2 id="channel-与-select"><a href="#channel-与-select" class="headerlink" title="channel 与 select"></a>channel 与 select</h2><h3 id="基础语法——-channel"><a href="#基础语法——-channel" class="headerlink" title="基础语法—— channel"></a>基础语法—— channel</h3><ul>
<li>使用 make 创建 channel  </li>
<li>带缓冲和不带缓冲的channel  </li>
<li>用 &lt;- 符号来表达收发</li>
</ul>
<h3 id="基础语法-——-channel-带缓冲"><a href="#基础语法-——-channel-带缓冲" class="headerlink" title="基础语法 —— channel 带缓冲"></a>基础语法 —— channel 带缓冲</h3><p><img src="/2021/08/18/geekbang-live-go-basic-sprint-day-4/have-buffer-channel.png">  </p>
<ul>
<li>放满阻塞生产者  </li>
<li>空了阻塞消费者</li>
</ul>
<h3 id="基础语法——-channel-不带缓冲"><a href="#基础语法——-channel-不带缓冲" class="headerlink" title="基础语法—— channel 不带缓冲"></a>基础语法—— channel 不带缓冲</h3><p><img src="/2021/08/18/geekbang-live-go-basic-sprint-day-4/no-buffer-channel.png">  </p>
<ul>
<li>缺了任何一边都要阻塞另外一边</li>
</ul>
<h3 id="基础语法-——-select"><a href="#基础语法-——-select" class="headerlink" title="基础语法 —— select"></a>基础语法 —— select</h3><ul>
<li>等待多个 channel  </li>
<li>select 比较常见和 for 循环一起使用</li>
</ul>
<h3 id="基础语法-——-Go源文件命名与平台"><a href="#基础语法-——-Go源文件命名与平台" class="headerlink" title="基础语法 —— Go源文件命名与平台"></a>基础语法 —— Go源文件命名与平台</h3><ul>
<li>模式：name_platform_arch.go  </li>
<li>一般最多就是根据 OS 来分。因为到了区分架构那个地步，就太底层了</li>
</ul>
<h2 id="Hook（钩子函数）设计"><a href="#Hook（钩子函数）设计" class="headerlink" title="Hook（钩子函数）设计"></a>Hook（钩子函数）设计</h2><h3 id="Http-Server-——-注册-Hook"><a href="#Http-Server-——-注册-Hook" class="headerlink" title="Http Server —— 注册 Hook"></a>Http Server —— 注册 Hook</h3><ul>
<li>我们这 WaitForShutdown 啥都没干，而我们是期望它能够完成拒绝新请求，等待旧请求，然后再我们改造一下 WaitForShutdown 让它可以接收Hook。  </li>
<li>考虑到我们的 Hook 可能写出 BUG 无法退出，所以我们还需要超时机制。  </li>
<li>我们利用 context 包来达成目标</li>
</ul>
<h3 id="Http-Server-——-关闭动作"><a href="#Http-Server-——-关闭动作" class="headerlink" title="Http Server —— 关闭动作"></a>Http Server —— 关闭动作</h3><p>按照我们的设计，我们需要：  </p>
<ol>
<li>拒绝新的请求：需要一个开关  </li>
<li>等待当前的所有请求处理完毕：维持请求计数  </li>
<li>释放资源：用户可能需要自己释放一些资源  </li>
<li>关闭服务器：把所有启动的 Server 都关闭了  </li>
<li>如果这中间超时了， 我们要强制关闭了</li>
</ol>
<h3 id="Http-Server-——-拒绝请求并记录"><a href="#Http-Server-——-拒绝请求并记录" class="headerlink" title="Http Server —— 拒绝请求并记录"></a>Http Server —— 拒绝请求并记录</h3><p>我们这 WaitForShutdown 啥都没干，按照我们的设计，我们需要：  </p>
<ul>
<li><ol>
<li>拒绝新的请求：需要一个开关</li>
</ol>
</li>
<li><ol start="2">
<li>等待当前的所有请求处理完毕：需要维持请求计数</li>
</ol>
</li>
</ul>
<p>我们需要注册一个 Hook，在收到信号之后关闭开关，然后停下来等待  </p>
<p>这是一个很典型的 AOP 场景，所以我们可以考虑使用 filter 来判断要不要拒绝请求，并且维持请求计数  </p>
<h2 id="context-与-atomic"><a href="#context-与-atomic" class="headerlink" title="context 与 atomic"></a>context 与 atomic</h2><h3 id="基础语法-——-context-包"><a href="#基础语法-——-context-包" class="headerlink" title="基础语法 —— context 包"></a>基础语法 —— context 包</h3><p>context.Context 是 Go 提供的线程安全工具，称为上下文。<br>方法：<br>• WithTimeout：一般用户控制超时<br>• WithCancel：用于取消整条链上的任务<br>• WithDeadline：控制时间<br>• WithValue：往里面塞入 key-value<br>• Backgroud：返回一个空的 context.Context<br>• ToDo：返回一个空的 context.Context，但是这个标记着你也不知道传什么  </p>
<h3 id="基础语法-——-context-与-thread-local"><a href="#基础语法-——-context-与-thread-local" class="headerlink" title="基础语法 —— context 与 thread-local"></a>基础语法 —— context 与 thread-local</h3><ul>
<li>Go 官方没有支持 thread-local（或者说 goroutine-local）  </li>
<li>第三方有人搞出来了类似的东西，但是一般不建议使用，因为实现太奇诡，大部分人都没胆子用在自己的<br>项目上  </li>
<li>因为缺乏 thread-local，所以很多时候我们要实现类似的功能，都只能依赖于 context 在方法直接传递。<br>因此一般建议自己的方法签名，都把 context.Context 作为第一个参数</li>
</ul>
<h3 id="基础语法-——-atomic-包"><a href="#基础语法-——-atomic-包" class="headerlink" title="基础语法 —— atomic 包"></a>基础语法 —— atomic 包</h3><p>方法分成这几类：<br>• AddXXX：操作一个数字类型，加上一个数字<br>• LoadXXX：读取一个值<br>• CompareAndSwapXXX：大名鼎鼎的 CAS 操作<br>• StoreXXX：写入一个值<br>• SwapXXX：写入一个值，并且返回旧的值。<br>它和 CompareAndSwap 的区别在于它不关心旧的值是什么  </p>
<p>• unsafepointer 相关方法，不建议使用。<br>难写也难读，不到逼不得已不要去用。尤其是不要为了优化而故意用 unsafepoint  </p>
<h2 id="静态资源服务"><a href="#静态资源服务" class="headerlink" title="静态资源服务"></a>静态资源服务</h2><h2 id="server-Context-复用"><a href="#server-Context-复用" class="headerlink" title="server Context 复用"></a>server Context 复用</h2><h2 id="接口的实现的注册与发现"><a href="#接口的实现的注册与发现" class="headerlink" title="接口的实现的注册与发现"></a>接口的实现的注册与发现</h2>]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>并发编程</tag>
        <tag>文件操作</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础冲刺营_Day3_错误处理与简单路由树实现</title>
    <url>/2021/08/18/geekbang-live-go-basic-sprint-day-3/</url>
    <content><![CDATA[<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="基础语法-——-错误处理"><a href="#基础语法-——-错误处理" class="headerlink" title="基础语法 —— 错误处理"></a>基础语法 —— 错误处理</h3><ul>
<li>error：一般用于表达可以被处理的错误  </li>
<li>error只是一个内置的接口  </li>
<li>panic：一般用于表达非常严重不可恢复的错误</li>
</ul>
<h3 id="基础语法-——-errors-包"><a href="#基础语法-——-errors-包" class="headerlink" title="基础语法 —— errors 包"></a>基础语法 —— errors 包</h3><ul>
<li>New 创建一个新的 error  </li>
<li>Is 判断是不是特定的某个error  </li>
<li>As 类型转换为特定的 error  </li>
<li>Unwrap 解除包装，返回被包装的 error</li>
</ul>
<h3 id="基础语法-——-error-和-panic-选用哪个？"><a href="#基础语法-——-error-和-panic-选用哪个？" class="headerlink" title="基础语法 —— error 和 panic 选用哪个？"></a>基础语法 —— error 和 panic 选用哪个？</h3><ul>
<li>遇事不决选 error  </li>
<li>当你怀疑可以用 error 的时候，就说明你不需要 panic  </li>
<li>一般情况下，只有快速失败的过程，才会考虑panic</li>
</ul>
<h3 id="基础语法-——-从-panic-中恢复"><a href="#基础语法-——-从-panic-中恢复" class="headerlink" title="基础语法 —— 从 panic 中恢复"></a>基础语法 —— 从 panic 中恢复</h3><ul>
<li>某些时候，你可能需要从 panic 中恢复过来：比如某个库，发生 panic 的场景是你不希望发生的场景。这时候，你需要我们的 recover</li>
</ul>
<p><strong>Tip：如果你自己panic了，然后又要恢复过来，那么应该考虑不要用panic了</strong>  </p>
<h3 id="Golang-语法-——-defer"><a href="#Golang-语法-——-defer" class="headerlink" title="Golang 语法 —— defer"></a>Golang 语法 —— defer</h3><ul>
<li>用于在方法返回之前执行某些动作  </li>
<li>像栈一样，先进后出  </li>
<li>defer 语义接近 java 的 finally 块，所以我们经常使用 defer 来释放资源，例如释放锁</li>
</ul>
<h3 id="Golang-语法-——-闭包"><a href="#Golang-语法-——-闭包" class="headerlink" title="Golang 语法 —— 闭包"></a>Golang 语法 —— 闭包</h3><ul>
<li>函数闭包：匿名函数 + 定义它的上下文  </li>
<li>它可以访问定义之外的变量  </li>
<li>Go 很强大的特性，很常用</li>
</ul>
<h3 id="Golang-语法-——-闭包延时绑定"><a href="#Golang-语法-——-闭包延时绑定" class="headerlink" title="Golang 语法 —— 闭包延时绑定"></a>Golang 语法 —— 闭包延时绑定</h3><ul>
<li>闭包里面使用的闭包外的参数，其值是在最终调用的时候确定下来的</li>
</ul>
<h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul>
<li><ol>
<li>error 其实就是一个内置的普通的接口。error 相关的操作在 errors 包里面</li>
</ol>
</li>
<li><ol start="2">
<li>panic 强调的是无可挽回了。但是也可以用 recover 恢复过来</li>
</ol>
</li>
<li><ol start="3">
<li>闭包是很强大的特性，但是要小心延时绑定</li>
</ol>
</li>
</ul>
<h2 id="AOP设计——责任链模式"><a href="#AOP设计——责任链模式" class="headerlink" title="AOP设计——责任链模式"></a>AOP设计——责任链模式</h2><ul>
<li>为 server 支持一些 AOP 逻 辑  </li>
<li>AOP：横向关注点，一般用于解决 Log, tracing，metric，熔断，限流等  </li>
<li>filter：我们希望请求在真正被处理之前能够经过一大堆的 filter</li>
</ul>
<p><img src="/2021/08/18/geekbang-live-go-basic-sprint-day-3/aop.png">  </p>
<h3 id="要点总结-1"><a href="#要点总结-1" class="headerlink" title="要点总结"></a>要点总结</h3><ol>
<li>责任链是很常见的用于解决 AOP 的一种方式。  </li>
<li>类似的也叫做 middleware, interceptor… 本质是一样的  </li>
<li>Go 函数是一等公民，所以可以考虑用闭包来实现责任链  </li>
<li>filter 很常见，比如说鉴权，日志，tracing，以及跨域等都可以用 filter 来实现</li>
</ol>
<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><h3 id="基础语法-——-sync-Map"><a href="#基础语法-——-sync-Map" class="headerlink" title="基础语法 —— sync.Map"></a>基础语法 —— sync.Map</h3><ul>
<li>key 和 value 类型都是interface{}。意味着你要搞各种类型断言</li>
</ul>
<h3 id="基础语法-——类型断言"><a href="#基础语法-——类型断言" class="headerlink" title="基础语法 ——类型断言"></a>基础语法 ——类型断言</h3><ul>
<li><p>形式：t, ok :&#x3D; x.(T) 或者 t :&#x3D; x.(T)  </p>
</li>
<li><p>T 可以是结构体或者指针  </p>
</li>
<li><p>如何理解？<br>即x是不是T；类似Java instanceOf + 强制类型转换合体。  </p>
</li>
<li><p>如果 x 是 nil，那么永远是 false  </p>
</li>
<li><p>编译器不会帮你检查</p>
</li>
</ul>
<h3 id="基础语法-——类型转换"><a href="#基础语法-——类型转换" class="headerlink" title="基础语法 ——类型转换"></a>基础语法 ——类型转换</h3><ul>
<li>形式：y :&#x3D; T(x)  </li>
<li>如何理解？记住数字类型转换，string 和 []byte 互相转  </li>
<li>类似Java强制类型转换  </li>
<li>编译器会进行类型检查，不能转换的会编译错误</li>
</ul>
<h3 id="基础语法-——-sync-Mutex-和-sync-RWMutex"><a href="#基础语法-——-sync-Mutex-和-sync-RWMutex" class="headerlink" title="基础语法 —— sync.Mutex 和 sync.RWMutex"></a>基础语法 —— sync.Mutex 和 sync.RWMutex</h3><p>sync 包提供了基本的并发工具  </p>
<ul>
<li>sync.Map：并发安全 map  </li>
<li>sync.Mutex：锁  </li>
<li>sync.RWMutex：读写锁  </li>
<li>sync.Once：只执行一次  </li>
<li>sync.WaitGroup: goroutine 之间同步</li>
</ul>
<h3 id="基础语法-——-mutex家族注意事项"><a href="#基础语法-——-mutex家族注意事项" class="headerlink" title="基础语法 —— mutex家族注意事项"></a>基础语法 —— mutex家族注意事项</h3><ul>
<li>尽量用 RWMutext  </li>
<li>尽量用 defer 来释放锁，防止panic没有释放锁  </li>
<li>不可重入：lock 之后，即便是同一个线程(goroutine)，也无法再次加锁（写递归函数要小心）  </li>
<li>不可升级：加了读锁之后，如果试图加写锁，锁不升级</li>
</ul>
<h3 id="基础语法-——-sync-Once"><a href="#基础语法-——-sync-Once" class="headerlink" title="基础语法 —— sync.Once"></a>基础语法 —— sync.Once</h3><h3 id="要点总结-2"><a href="#要点总结-2" class="headerlink" title="要点总结"></a>要点总结</h3><ol>
<li>尽量用 sync.RWMutex  </li>
<li>sync.Once 可以保证代码只会执行一次，一般用来解决一些初始化的需求  </li>
<li>sync.WaitGroup 能用来在多个 goroutine 之间进行同步</li>
</ol>
<h2 id="路由树设计与实现-待更新"><a href="#路由树设计与实现-待更新" class="headerlink" title="路由树设计与实现(待更新)"></a>路由树设计与实现(待更新)</h2>]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>极客Live-大厂面试那些问题，平时真的不会用到吗</title>
    <url>/2020/03/17/geekbang-live-interview-problem-to-solve-work/</url>
    <content><![CDATA[<h2 id="直播简介"><a href="#直播简介" class="headerlink" title="直播简介"></a>直播简介</h2><p>直播老师：李玥-京东资深架构师  </p>
<p>你将获得：  </p>
<ul>
<li>1，大厂面试题考点  </li>
<li>2，如何在平时工作中积累自己的核心能力  </li>
<li>3，面试题和实际工作的交集与并集</li>
</ul>
<h2 id="直播笔记"><a href="#直播笔记" class="headerlink" title="直播笔记"></a>直播笔记</h2><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>你能走多远，取决于你填坑的能力有多大。  </p>
<h3 id="关于简历"><a href="#关于简历" class="headerlink" title="关于简历"></a>关于简历</h3><p>简历可以适当夸大，比如精通xx，熟练yy,zz.  </p>
<h3 id="高并发与海量数据"><a href="#高并发与海量数据" class="headerlink" title="高并发与海量数据"></a>高并发与海量数据</h3><p>小厂：单机，人肉，低可用  </p>
<p>大厂：分布式，自动化，高可用  </p>
<h3 id="大厂面试套路"><a href="#大厂面试套路" class="headerlink" title="大厂面试套路"></a>大厂面试套路</h3><ul>
<li><p>项目经历  </p>
</li>
<li><p>基础知识  </p>
</li>
<li><p>智力测验  </p>
</li>
<li><p>目标职位需要的技术知识<br>可以看看MQ;分布式;  </p>
</li>
<li><p>高并发和海量数据  </p>
</li>
<li><p>知识的深度和广度  </p>
</li>
<li><p>对前沿技术的了解</p>
</li>
</ul>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li><p>如果有十年以上经验，要面试大厂，建议看看顶级学术期刊的最新最前沿的论文；  </p>
</li>
<li><p>用<code>google</code>搜索  </p>
</li>
<li><p>仔细看开源项目的文档  </p>
</li>
<li><p>架构师是个<code>title</code>，平时还需要写代码；但有些公司的架构师相当于技术顾问</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>直播</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间直播_乔新亮_为什么毕业5年后，同学间的差距越来越大</title>
    <url>/2020/07/07/geekbang-live-why-5-years-after-graduation-the-gap-between-classmates-is-growing/</url>
    <content><![CDATA[<h2 id="直播介绍"><a href="#直播介绍" class="headerlink" title="直播介绍"></a>直播介绍</h2><p>直播嘉宾：乔新亮，彩食鲜CTO  </p>
<h3 id="你将获得"><a href="#你将获得" class="headerlink" title="你将获得"></a>你将获得</h3><ul>
<li>去做事，提高能力，钱自然会来  </li>
<li>努力是为了提高下限，选择是为了提高上限  </li>
<li>往上去想，往下去做  </li>
<li>领导，只要你敢让我做，我就敢上。</li>
</ul>
<h2 id="选择和努力"><a href="#选择和努力" class="headerlink" title="选择和努力"></a>选择和努力</h2><ul>
<li>逆水行舟，不进则退。5年一道坎，不断提高自己的下限和上限。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如30岁当个技术总监，不算老，但30岁还是普通程序员，就很老</span><br><span class="line"></span><br><span class="line">比如40岁当个CTO，不算老，但50岁才是CTO就很老</span><br><span class="line"></span><br><span class="line">五年一道坎，跨不过去就会倒退</span><br></pre></td></tr></table></figure>

<ul>
<li><p>居安思危，不要当鸵鸟，问题不会因为你把头埋进沙子就不存在了。  </p>
</li>
<li><p>连接是人类最大的价值，努力让自己成为一个有价值的点，选择进入更高等级的网络，技术的迭代+学习&#x3D;跨越网络阶层最高效的方法  </p>
</li>
<li><p>刚毕业的时候不要在意钱，要在意做事的机会</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你知道你：10年后，睡前收入，1年等于毕业时10年，17年后，税前收入，1年等于毕业时200年</span><br><span class="line">你会怎么决定？</span><br></pre></td></tr></table></figure>

<ul>
<li>站在未来看现在，站在全局看自己</li>
</ul>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><ul>
<li><p>能力提升很重要，技不压身，一直可以跟随你的是能力  </p>
</li>
<li><p>T型人才：一竖，专业深度；一横，架构广度</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">专业上，敢于挑战任何人</span><br></pre></td></tr></table></figure>

<ul>
<li><p>10年的工作经验 VS 一年的工作经验用了10年  </p>
</li>
<li><p>深度洞察，看清事物本质  </p>
</li>
<li><p>逻辑推理，一切都有因果</p>
</li>
</ul>
<h2 id="做事"><a href="#做事" class="headerlink" title="做事"></a>做事</h2><ul>
<li><p>敢于决策，敢于承担  </p>
</li>
<li><p>猛将必发于卒伍，为什么我说人活着就要不停的做事  </p>
</li>
<li><p>只要你敢让我上，我就敢上</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">做砸了，至少还有公司，我还锻炼了能力</span><br><span class="line">做好了，那恭喜</span><br></pre></td></tr></table></figure>

<ul>
<li><p>锻炼的机会稍纵即逝，相信领导的眼光  </p>
</li>
<li><p>往上去想，看清全局；往下去做，脚踏实地  </p>
</li>
<li><p>契约精神  </p>
</li>
<li><p>认知到位+彪悍执行&#x3D;成功交付  </p>
</li>
<li><p>有问题吗？第一反应——搞定它  </p>
</li>
<li><p>事情做砸了怎么办？做砸了呗，拼尽权利，轻松心态  </p>
</li>
<li><p>接受自己一切的不完美，相信自己会成长，丑小鸭不停在进步</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人最怕否定自己</span><br></pre></td></tr></table></figure>

<ul>
<li><p>成长性思维：客观的肯定过去的成就；客观的认识过去存在的问题；接受自己的一切不完美；相信自己会成长。  </p>
</li>
<li><p>持续学习，学以致用，终身成长</p>
</li>
</ul>
<h2 id="金钱观"><a href="#金钱观" class="headerlink" title="金钱观"></a>金钱观</h2><ul>
<li><p>为什么每个人都要有财务思维  </p>
</li>
<li><p>不要为了钱工作，为了能力工作，能力会吸引钱来  </p>
</li>
<li><p>努力挣钱的目的恰恰不是为了钱，是为了让自己不受钱的困扰，让自己有选择的权力，更是一种经历  </p>
</li>
<li><p>提升能力可以鱼和熊掌剪得，成就感 VS 金钱  </p>
</li>
<li><p>提升能力是在赚未来的钱，薪资是赚的当下的钱  </p>
</li>
<li><p>不要总要立刻看到回报，一切的努力都不会白费，都会有回报  </p>
</li>
<li><p>方向大致对了，剩下的交给时间，做时间的朋友  </p>
</li>
<li><p>卓越，top(*10) Talent(一横一竖)  </p>
</li>
<li><p>把自己当成一个公司经营，明确公司的方向、目标、年度目标、季度目标比月度目标，周度目标重要，价值投资、趋势投资、投机投资</p>
</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul>
<li><p>一个人的时间非常少  </p>
</li>
<li><p>少看朋友圈，多读书  </p>
</li>
<li><p>每时每刻，专注那一刹那</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">专注谈方案，读一小时书，陪小孩玩，吃午饭，和别人聊天</span><br></pre></td></tr></table></figure>

<h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul>
<li><p>乐趣，专注与平静，心在身上，活在当下  </p>
</li>
<li><p>享受专注的乐趣，想想自己喜欢的运动，比如打羽毛球，工作中，专注做一件事  </p>
</li>
<li><p>多巴胺——经历新鲜、刺激或具有挑战性的事情；内啡肽有低变高——成就感、运动、深呼吸；血清素——健康饮食和锻炼  </p>
</li>
<li><p>人啊，一定要活的真实一点，别装  </p>
</li>
<li><p>热爱生活</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>成功者的叙事风格，会将一切都归纳于自己的先知先觉；  </p>
</li>
<li><p>成长性思维；  </p>
</li>
<li><p>站在未来看现在，站在全局看自己；  </p>
</li>
<li><p>做T字型人才；  </p>
</li>
<li><p>努力和选择是一个事情的两个方面（人生状态），都很重要；  </p>
</li>
<li><p>专注，心在身上，感受自己心灵的平静，感受自己做事的乐趣。</p>
</li>
</ul>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul>
<li><p>如何跳出舒适区？<br>结论：如果舒适了，就要考虑跳出来。  </p>
</li>
<li><p>怎么找到领域导师，让自己更有深度？<br>沟通，观察。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>毕业</tag>
        <tag>极客邦</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间直播_王争_前Google工程师的算法学习与面试经验分享</title>
    <url>/2020/01/09/geekbang-live-wangzheng-algo-interview/</url>
    <content><![CDATA[<h2 id="嘉宾"><a href="#嘉宾" class="headerlink" title="嘉宾"></a>嘉宾</h2><p>王争，前<code>Google</code>工程师  </p>
<h2 id="直播大纲"><a href="#直播大纲" class="headerlink" title="直播大纲"></a>直播大纲</h2><ul>
<li>1，掌握数据结构和算法的方法；  </li>
<li>2，判定掌握数据结构和算法的标准；  </li>
<li>3，应对算法面试的一些技巧分享。</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="学习算法的目的"><a href="#学习算法的目的" class="headerlink" title="学习算法的目的"></a>学习算法的目的</h3><ul>
<li>1，用于工作  </li>
<li>2，应付面试  </li>
<li>3，潜移默化的提高逻辑思维能力，提高编码能力</li>
</ul>
<h3 id="应付面试"><a href="#应付面试" class="headerlink" title="应付面试"></a>应付面试</h3><ul>
<li>1，看一些优秀的算法专栏  </li>
<li>2，刷<code>leetcode</code></li>
</ul>
<h3 id="算法面试到底考察候选人什么？"><a href="#算法面试到底考察候选人什么？" class="headerlink" title="算法面试到底考察候选人什么？"></a>算法面试到底考察候选人什么？</h3><ul>
<li>1，逻辑思维能力  </li>
<li>2，编写复杂代码的能力  </li>
<li>3，基本数据结构和算法的掌握  </li>
<li>4，时间空间复杂度分析的能力，代码的性能分析能力  </li>
<li>5，编写Bug，free代码的能力  </li>
<li>6，代码是否整洁，是否符合编码规范</li>
</ul>
<h2 id="应对算法面试多一些小技巧"><a href="#应对算法面试多一些小技巧" class="headerlink" title="应对算法面试多一些小技巧"></a>应对算法面试多一些小技巧</h2><ul>
<li><p>1，多搜面经，知己知彼  </p>
</li>
<li><p>2，练习白板编程<br>在面试前，你要在纸上多练习一下，能够做到脑袋里想好算法之后，能一气呵成的写出代码。  </p>
</li>
<li><p>3，尽量保证代码没有bug<br>测试要考虑正确情况，错误情况和边界情况。  </p>
</li>
<li><p>4，尽量保证代码规范<br>在纸上写完之后，如果看着太乱，建议再迅速的抄写一遍。  </p>
</li>
<li><p>5，要有时间意识<br>对于一些简单算法题目，面试官还会考察你是否能快速写出代码。  </p>
</li>
<li><p>6，先用最简单的方法解决<br>拿到一道算法题后，先想最简单的解决方法，说给面试官听，然后再进行优化。<br>这样做的目的是一方面是缓和自己的紧张情绪，另一方面可能要闷头想很久，面试官很难知道你的进度，也没法做指导。</p>
</li>
</ul>
<h2 id="算法面试书籍推荐"><a href="#算法面试书籍推荐" class="headerlink" title="算法面试书籍推荐"></a>算法面试书籍推荐</h2><p>个人整理的一些适合准备算法面试时看的书籍，欢迎补充  </p>
<ul>
<li>《程序员面试金典（第6版）》</li>
<li>《编程之美》</li>
<li>《剑指offer》</li>
<li>《程序员代码面试指南：IT名企算法与数据结构题目最优解》</li>
</ul>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
        <tag>直播</tag>
        <tag>极客邦</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间_直播 畅聊技术人学习&amp;晋升法则</title>
    <url>/2020/11/25/geektime-live-thanksgiving-share-work-experience/</url>
    <content><![CDATA[<h2 id="李运华-聊聊晋升背后的“潜规则”"><a href="#李运华-聊聊晋升背后的“潜规则”" class="headerlink" title="李运华_聊聊晋升背后的“潜规则”"></a>李运华_聊聊晋升背后的“潜规则”</h2><h3 id="明面上的晋升规则"><a href="#明面上的晋升规则" class="headerlink" title="明面上的晋升规则"></a>明面上的晋升规则</h3><p>绩效+年限+红线+附件条件  </p>
<h3 id="价值原则"><a href="#价值原则" class="headerlink" title="价值原则"></a>价值原则</h3><p><strong>员工为企业创造了价值，且能力提升了，才有机会晋升。</strong>  </p>
<ul>
<li><p>不能只埋头干活，要考虑通过做事和自我学习来提升能力  </p>
</li>
<li><p>能力提升要能为企业带来价值，不要“自嗨式”提升  </p>
</li>
<li><p>企业会有一套流程机制来防止“拉关系”晋升</p>
</li>
</ul>
<h3 id="成长原则"><a href="#成长原则" class="headerlink" title="成长原则"></a>成长原则</h3><p><strong>能力提升到下一级别，才有机会晋升。</strong>  </p>
<ul>
<li><p>不要沉迷已有的熟练技能带来的满足感，要主动“打破舒适区”  </p>
</li>
<li><p>不管业务结果好坏，你都可以成长，关键在于“总结提炼”  </p>
</li>
<li><p>一年经验重复五年是不能满足晋升要求的</p>
</li>
</ul>
<h3 id="主动原则"><a href="#主动原则" class="headerlink" title="主动原则"></a>主动原则</h3><p><strong>主动寻找晋升机会，才有机会晋升。</strong>  </p>
<ul>
<li><p>明确自己的晋升规划，找主管沟通达成一致；  </p>
</li>
<li><p>主动挖掘成长点，包括专业能力、业务能力、管理能力；  </p>
</li>
<li><p>主动争取更大的任务和挑战，不要被动等待别人安排任务<br>（建议一年聊一次）</p>
</li>
</ul>
<h2 id="李佳-从100多位老师身上得到的5点启发"><a href="#李佳-从100多位老师身上得到的5点启发" class="headerlink" title="李佳_从100多位老师身上得到的5点启发"></a>李佳_从100多位老师身上得到的5点启发</h2><h3 id="工作那么忙，哪来时间学习？"><a href="#工作那么忙，哪来时间学习？" class="headerlink" title="工作那么忙，哪来时间学习？"></a>工作那么忙，哪来时间学习？</h3><ul>
<li>减少精力消耗，脑子决策时间，要程序化工作；  </li>
<li>管理自己的理念，10分钟也能学很多东西；</li>
</ul>
<h3 id="不擅长的事如何快速解决？"><a href="#不擅长的事如何快速解决？" class="headerlink" title="不擅长的事如何快速解决？"></a>不擅长的事如何快速解决？</h3><ul>
<li>找个好老师且自己值得被帮助  </li>
<li>20个小时速成一个技能</li>
</ul>
<h3 id="学好英语的程序员有多爽？"><a href="#学好英语的程序员有多爽？" class="headerlink" title="学好英语的程序员有多爽？"></a>学好英语的程序员有多爽？</h3><ul>
<li>微习惯，知行合一  </li>
<li>推荐《老友记》  </li>
<li>每天看一段《This is water》</li>
</ul>
<h3 id="事事较真好不好？"><a href="#事事较真好不好？" class="headerlink" title="事事较真好不好？"></a>事事较真好不好？</h3><ul>
<li>较真，是因为执念  </li>
<li>不较真，是因为开放  </li>
<li>讲究而不将就</li>
</ul>
<h3 id="35岁焦虑吗？"><a href="#35岁焦虑吗？" class="headerlink" title="35岁焦虑吗？"></a>35岁焦虑吗？</h3><ul>
<li>踏踏实实，认真做事，没有心思去焦虑  </li>
<li>首先要认可自己的焦虑  </li>
<li>克服焦虑从行动开始，而行动从习惯中养成  </li>
<li>花上10-30分钟吐槽焦虑，然后投入工作</li>
</ul>
<h2 id="池建强-写作是职场人最重要的通用技能之一"><a href="#池建强-写作是职场人最重要的通用技能之一" class="headerlink" title="池建强_写作是职场人最重要的通用技能之一"></a>池建强_写作是职场人最重要的通用技能之一</h2><ul>
<li>推荐书《软件随想录》  </li>
<li>写作可以推广你的思想，让你更加有影响</li>
</ul>
<h2 id="池建强-学习从来不该急功近利"><a href="#池建强-学习从来不该急功近利" class="headerlink" title="池建强_学习从来不该急功近利"></a>池建强_学习从来不该急功近利</h2><ul>
<li>１，树立目标  </li>
<li>２，拆解  </li>
<li>３，奖励  </li>
<li>４，产出</li>
</ul>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>直播</tag>
        <tag>职场</tag>
        <tag>极客时间</tag>
        <tag>感恩节</tag>
      </tags>
  </entry>
  <entry>
    <title>Git更改远程推送的仓库地址</title>
    <url>/2019/06/29/git-change-push-remote-rep/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>本地代码推送到远程仓库地址时，有时地址会发生变更，所以需要更改，<code>git</code>命令如下  </p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><p><code>git remote -v</code></p>
<h3 id="添加远程仓库链接"><a href="#添加远程仓库链接" class="headerlink" title="添加远程仓库链接"></a>添加远程仓库链接</h3><p><code>git remote add 远程仓库链接</code></p>
<p>所以当年<code>push</code>代码的时候，是<code>git push -u 链接名 分支名</code></p>
<h3 id="更改远程仓库链接名"><a href="#更改远程仓库链接名" class="headerlink" title="更改远程仓库链接名"></a>更改远程仓库链接名</h3><p><code>git remote rename 老链接名 新链接名</code></p>
<h3 id="删除远程链接仓库链接名"><a href="#删除远程链接仓库链接名" class="headerlink" title="删除远程链接仓库链接名"></a>删除远程链接仓库链接名</h3><p><code>git remote remove 链接名</code></p>
]]></content>
      <categories>
        <category>Learn-git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>push</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架数据绑定和验证</title>
    <url>/2022/06/12/gin-data-binding-and-validation/</url>
    <content><![CDATA[<h1 id="数据绑定介绍"><a href="#数据绑定介绍" class="headerlink" title="数据绑定介绍"></a>数据绑定介绍</h1><p>Gin提供了两类绑定方法：  </p>
<h2 id="Must-bind"><a href="#Must-bind" class="headerlink" title="Must bind"></a>Must bind</h2><ul>
<li>Methods: Bind,BindJSON,BindXML,BindQuery,BindYAML  </li>
<li>这些方法属于MustBindWith的具体调用。 如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind) 。响应状态码被设置为 400 并且Content-Type被设置为text&#x2F;plain; charset&#x3D;utf-8 。 如果您在此之后尝试设置响应状态码，Gin会输出日志[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422 。 如果您希望更好地控制绑定，考虑使用ShouldBind等效方法。</li>
</ul>
<h2 id="Should-bind"><a href="#Should-bind" class="headerlink" title="Should bind"></a>Should bind</h2><ul>
<li>Methods: ShouldBind,ShouldBindJSON,ShouldBindXML,ShouldBindQuery,ShouldBindYAML  </li>
<li>这些方法属于ShouldBindWith的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</li>
</ul>
<h1 id="数据绑定-Should-bind"><a href="#数据绑定-Should-bind" class="headerlink" title="数据绑定-Should bind"></a>数据绑定-Should bind</h1><p>可以绑定Form、QueryString、Json，uri<br>form标签：Form、QueryString<br>json标签：Json<br>uri标签：uri</p>
<p>form的绑定示例代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span> <span class="string">`form:&quot;id&quot; json:&quot;id&quot;`</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`form:&quot;name&quot; json:&quot;name&quot;`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：structTag：指定字段名称，不用使用首字母大写的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">context.ShouldBind(&amp;user)</span><br><span class="line">fmt.Println(user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端</span></span><br><span class="line">&lt;form action=<span class="string">&quot;/dobind&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>QueryString的绑定示例代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体中structTag的form起作用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">context.ShouldBind(&amp;user)</span><br><span class="line">fmt.Println(user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">访问：http:<span class="comment">//127.0.0.1:8080/tobind?name=zhiliao&amp;age=110</span></span><br></pre></td></tr></table></figure>

<p>json的绑定示例代码  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体中structTag的json起作用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoBind</span><span class="params">(context *gin.Context)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    context.ShouldBind(&amp;user)</span><br><span class="line"></span><br><span class="line">    fmt.Println(user)</span><br><span class="line"></span><br><span class="line">    context.JSON(<span class="number">200</span>,gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:<span class="number">200</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">前端：ajax</span><br><span class="line"></span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> id=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;提交&quot;</span> id=<span class="string">&quot;btn_add&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> btn_add = document.getElementById(<span class="string">&quot;btn_add&quot;</span>);</span><br><span class="line">    btn_add.onclick = function (ev) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = document.getElementById(<span class="string">&quot;name&quot;</span>).value;</span><br><span class="line">        <span class="keyword">var</span> age = document.getElementById(<span class="string">&quot;age&quot;</span>).value;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&quot;/dobind&quot;</span>,</span><br><span class="line">            <span class="keyword">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">            contentType: <span class="string">&quot;application/json; charset=utf-8&quot;</span>,</span><br><span class="line">            dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">            data:JSON.stringify(&#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>:name,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>:Number(age)</span><br><span class="line">            &#125;),</span><br><span class="line">            success:function (data) &#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            fail:function (data) &#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<br>contentType: “application&#x2F;json; charset&#x3D;utf-8”,<br>dataType: “json”,<br>“age”:Number(age)<br>age是个int类型，必须得转成int类型才可以直接绑定  </p>
<h1 id="数据绑定–Must-bind"><a href="#数据绑定–Must-bind" class="headerlink" title="数据绑定–Must bind"></a>数据绑定–Must bind</h1><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>可以绑定Form、QueryString、Json等</p>
<p>和ShouldBind的区别在于，ShouldBind没有绑定成功不报错，就是空值，Bind会报错  </p>
<h2 id="BindQuery等"><a href="#BindQuery等" class="headerlink" title="BindQuery等"></a>BindQuery等</h2><p>BindJSON,BindXML,BindQuery,BindYAML等函数只绑定对应格式的参数  </p>
]]></content>
      <categories>
        <category>LearnGin</category>
      </categories>
      <tags>
        <tag>Gin</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>Github开源项目crawlergo介绍</title>
    <url>/2023/05/27/github-crawlergo-introduction/</url>
    <content><![CDATA[<h1 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h1><p><code>crawlergo</code>是一个使用<code>chrome headless</code>模式进行URL收集的浏览器爬虫。它对整个网页的关键位置与DOM渲染阶段进行HOOK，自动进行表单填充并提交，配合智能的JS事件触发，<br>尽可能的收集网站暴露出的入口。内置URL去重模块，过滤掉了大量伪静态URL，对于大型网站仍保持较快的解析与抓取速度，最后得到高质量的请求结果集合。</p>
<p><code>crawlergo</code>目前支持以下特性：</p>
<ul>
<li>原生浏览器环境，协程池调度任务  </li>
<li>表单智能填充、自动化提交  </li>
<li>完整DOM事件收集，自动化触发  </li>
<li>智能URL去重，去掉大部分的重复请求  </li>
<li>全面分析收集，包括javascript文件内容、页面注释、robots.txt文件和常见路径Fuzz  </li>
<li>支持Host绑定，自动添加Referer  </li>
<li>支持请求代理，支持爬虫结果主动推送</li>
</ul>
<p>项目整体结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── [4.0K]  cmd</span><br><span class="line">│   └── [4.0K]  crawlergo</span><br><span class="line">│       ├── [7.4K]  flag.go</span><br><span class="line">│       └── [8.5K]  main.go</span><br><span class="line">├── [ 941]  Disclaimer.md</span><br><span class="line">├── [ 858]  dockerfile</span><br><span class="line">├── [4.0K]  examples</span><br><span class="line">│   ├── [1.2K]  host_binding.py</span><br><span class="line">│   ├── [1.2K]  request_with_cookie.py</span><br><span class="line">│   ├── [ 513]  subprocess_call.py</span><br><span class="line">│   └── [1.6K]  zombie_clean.py</span><br><span class="line">├── [ 690]  get_chrome.sh</span><br><span class="line">├── [ 588]  go.mod</span><br><span class="line">├── [9.6K]  go.sum</span><br><span class="line">├── [4.0K]  imgs</span><br><span class="line">│   ├── [ 36K]  bypass.png</span><br><span class="line">│   ├── [ 15K]  chrome_path.png</span><br><span class="line">│   ├── [1.1M]  demo.gif</span><br><span class="line">│   └── [220K]  skp.png</span><br><span class="line">├── [ 34K]  LICENSE</span><br><span class="line">├── [ 925]  Makefile</span><br><span class="line">├── [4.0K]  pkg</span><br><span class="line">│   ├── [4.0K]  config</span><br><span class="line">│   │   ├── [4.5K]  config.go</span><br><span class="line">│   │   └── [ 424]  config_test.go</span><br><span class="line">│   ├── [ 861]  domain_collect.go</span><br><span class="line">│   ├── [4.0K]  engine</span><br><span class="line">│   │   ├── [6.0K]  after_dom_tasks.go</span><br><span class="line">│   │   ├── [5.4K]  after_loaded_tasks.go</span><br><span class="line">│   │   ├── [2.8K]  browser.go</span><br><span class="line">│   │   ├── [2.0K]  collect_links.go</span><br><span class="line">│   │   ├── [8.8K]  intercept_request.go</span><br><span class="line">│   │   ├── [ 11K]  tab.go</span><br><span class="line">│   │   └── [ 525]  tab_test.go</span><br><span class="line">│   ├── [4.0K]  filter</span><br><span class="line">│   │   ├── [1.9K]  simple_filter.go</span><br><span class="line">│   │   ├── [ 20K]  smart_filter.go</span><br><span class="line">│   │   └── [1.7K]  smart_filter_test.go</span><br><span class="line">│   ├── [4.0K]  js</span><br><span class="line">│   │   └── [ 16K]  javascript.go</span><br><span class="line">│   ├── [4.0K]  logger</span><br><span class="line">│   │   └── [ 449]  logger.go</span><br><span class="line">│   ├── [4.0K]  model</span><br><span class="line">│   │   ├── [4.0K]  request.go</span><br><span class="line">│   │   ├── [3.6K]  url.go</span><br><span class="line">│   │   └── [2.0K]  url_test.go</span><br><span class="line">│   ├── [5.3K]  path_expansion.go</span><br><span class="line">│   ├── [5.3K]  taskconfig.go</span><br><span class="line">│   ├── [1.7K]  taskconfig_test.go</span><br><span class="line">│   ├── [7.5K]  task_main.go</span><br><span class="line">│   └── [4.0K]  tools</span><br><span class="line">│       ├── [1.4K]  common.go</span><br><span class="line">│       ├── [1.3K]  random.go</span><br><span class="line">│       └── [4.0K]  requests</span><br><span class="line">│           ├── [5.7K]  requests.go</span><br><span class="line">│           ├── [ 581]  response.go</span><br><span class="line">│           └── [ 510]  utils.go</span><br><span class="line">├── [ 11K]  README.md</span><br><span class="line">└── [9.6K]  README_zh-cn.md</span><br></pre></td></tr></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>首先确保已经安装了Go语言环境。</p>
<p>执行<code>make build</code>，会在当前目录下生成一个<code>bin</code>目录的文件夹。</p>
<p>假设你的chromium安装在 <code>/tmp/chromium/</code> ，开启最大10标签页，爬取AWVS靶场：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ bin/crawlergo -c /home/neo/Downloads/chrome-linux/chrome -t 10 http://testphp.vulnweb.com/</span><br><span class="line">INFO[0000] Init crawler task, host: testphp.vulnweb.com, max tab count: 10, max crawl count: 200. </span><br><span class="line">INFO[0000] filter mode: smart                           </span><br><span class="line">INFO[0000] If no matches, default form input text: Crawlergo </span><br><span class="line">INFO[0000] Start crawling.                              </span><br><span class="line">INFO[0000] filter repeat, target count: 2               </span><br><span class="line">INFO[0000] Crawling GET https://testphp.vulnweb.com/    </span><br><span class="line">INFO[0000] Crawling GET http://testphp.vulnweb.com/     </span><br><span class="line">WARN[0005] navigate <span class="built_in">timeout</span> https://testphp.vulnweb.com/ </span><br><span class="line">INFO[0007] Crawling GET http://testphp.vulnweb.com/index.php </span><br><span class="line">INFO[0007] Crawling GET http://testphp.vulnweb.com/artists.php </span><br><span class="line">INFO[0007] Crawling GET http://testphp.vulnweb.com/AJAX/index.php </span><br><span class="line">INFO[0007] Crawling GET http://testphp.vulnweb.com/guestbook.php </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><h2 id="初始化，声明作者，项目名称等信息"><a href="#初始化，声明作者，项目名称等信息" class="headerlink" title="初始化，声明作者，项目名称等信息"></a>初始化，声明作者，项目名称等信息</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">author := cli.Author&#123;</span><br><span class="line">  Name:  <span class="string">&quot;9ian1i&quot;</span>,</span><br><span class="line">  Email: <span class="string">&quot;9ian1itp@gmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app := &amp;cli.App&#123;</span><br><span class="line">  Name:      <span class="string">&quot;crawlergo&quot;</span>,</span><br><span class="line">  Usage:     <span class="string">&quot;A powerful browser crawler for web vulnerability scanners&quot;</span>,</span><br><span class="line">  UsageText: <span class="string">&quot;crawlergo [global options] url1 url2 url3 ... (must be same host)&quot;</span>,</span><br><span class="line">  Version:   Version,</span><br><span class="line">  Authors:   []*cli.Author&#123;&amp;author&#125;,</span><br><span class="line">  Flags:     cliFlags,</span><br><span class="line">  Action:    run,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := app.Run(os.Args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  logger.Logger.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(c *cli.Context)</span></span> <span class="type">error</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>使用channel来等待信号的到来，从而达到等待程序退出的目的。如果程序需要在接收到信号时进行一些特定的处理，可以在程序中添加对应的处理逻辑。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">signalChan = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)  <span class="comment">// 创建一个带缓冲的channel signalChan</span></span><br><span class="line">signal.Notify(signalChan, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGINT)  <span class="comment">//注册3个系统信号SIGTERM、SIGQUIT、SIGINT。这些信号可以被操作系统或者其他程序发送给本程序，表示一些事件的发生，比如程序需要退出、用户按下了键盘上的 CTRL+C 等。</span></span><br><span class="line"><span class="keyword">if</span> c.Args().Len() == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">// 如果在运行程序时未设置 url ，则会记录日志并返回一个错误，提示用户必须设置 url。</span></span><br><span class="line">  logger.Logger.Error(<span class="string">&quot;url must be set&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">&quot;url must be set&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置日志输出级别"><a href="#设置日志输出级别" class="headerlink" title="设置日志输出级别"></a>设置日志输出级别</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">level, err := logrus.ParseLevel(logLevel)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  logger.Logger.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">logger.Logger.SetLevel(level)</span><br></pre></td></tr></table></figure>


<h2 id="检查自定义的表单参数配置"><a href="#检查自定义的表单参数配置" class="headerlink" title="检查自定义的表单参数配置"></a>检查自定义的表单参数配置</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">taskConfig.CustomFormValues, err = parseCustomFormValues(customFormTypeValues.Value())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  logger.Logger.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">taskConfig.CustomFormKeywordValues, err = keywordStringToMap(customFormKeywordValues.Value())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  logger.Logger.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开始爬虫任务"><a href="#开始爬虫任务" class="headerlink" title="开始爬虫任务"></a>开始爬虫任务</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">task, err := pkg.NewCrawlerTask(targets, taskConfig)  <span class="comment">// 新建爬虫任务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  logger.Logger.Error(<span class="string">&quot;create crawler task failed.&quot;</span>)</span><br><span class="line">  os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(targets) != <span class="number">0</span> &#123;</span><br><span class="line">  logger.Logger.Info(fmt.Sprintf(<span class="string">&quot;Init crawler task, host: %s, max tab count: %d, max crawl count: %d.&quot;</span>,</span><br><span class="line">  targets[<span class="number">0</span>].URL.Host, taskConfig.MaxTabsCount, taskConfig.MaxCrawlCount))</span><br><span class="line">  logger.Logger.Info(<span class="string">&quot;filter mode: &quot;</span>, taskConfig.FilterMode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示自定义表单填充参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(taskConfig.CustomFormValues) &gt; <span class="number">0</span> &#123;</span><br><span class="line">  logger.Logger.Info(<span class="string">&quot;Custom form values, &quot;</span> + tools.MapStringFormat(taskConfig.CustomFormValues))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提示自定义表单填充参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(taskConfig.CustomFormKeywordValues) &gt; <span class="number">0</span> &#123;</span><br><span class="line">  logger.Logger.Info(<span class="string">&quot;Custom form keyword values, &quot;</span> + tools.MapStringFormat(taskConfig.CustomFormKeywordValues))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := taskConfig.CustomFormValues[<span class="string">&quot;default&quot;</span>]; !ok &#123;</span><br><span class="line">  logger.Logger.Info(<span class="string">&quot;If no matches, default form input text: &quot;</span> + config.DefaultInputText)</span><br><span class="line">  taskConfig.CustomFormValues[<span class="string">&quot;default&quot;</span>] = config.DefaultInputText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> handleExit(task)  <span class="comment">// 等待系统信号，并在接收到信号时关闭程序</span></span><br><span class="line">logger.Logger.Info(<span class="string">&quot;Start crawling.&quot;</span>)</span><br><span class="line">task.Run()  <span class="comment">// 核心逻辑</span></span><br><span class="line">result := task.Result</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置请求代理</span></span><br><span class="line"><span class="keyword">if</span> pushAddress != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  logger.Logger.Info(<span class="string">&quot;pushing results to &quot;</span>, pushAddress, <span class="string">&quot;, max pool number:&quot;</span>, pushProxyPoolMax)</span><br><span class="line">  Push2Proxy(result.ReqList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputResult</span><span class="params">(result *pkg.Result)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 输出结果</span></span><br><span class="line">  <span class="keyword">if</span> outputMode == <span class="string">&quot;json&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 result 对象以 JSON 格式序列化并输出</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;--[Mission Complete]--&quot;</span>)</span><br><span class="line">    resBytes := getJsonSerialize(result)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(resBytes))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> outputMode == <span class="string">&quot;console&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 逐个打印 result 中抓取到的所有请求和它们的响应</span></span><br><span class="line">    <span class="keyword">for</span> _, req := <span class="keyword">range</span> result.ReqList &#123;</span><br><span class="line">      req.FormatPrint()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(outputJsonPath) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在命令行输入了可选参数 outputJsonPath ，那么将结果以 JSON 格式序列化并保存到指定的文件中。</span></span><br><span class="line">    resBytes := getJsonSerialize(result)</span><br><span class="line">    tools.WriteFile(outputJsonPath, resBytes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnCrawler</category>
      </categories>
      <tags>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言调试工具-Dlv使用</title>
    <url>/2019/07/28/go-dlv-tool-use/</url>
    <content><![CDATA[<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./dlv debug</span><br></pre></td></tr></table></figure>

<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b 文件名.go:行号 或 函数名</span><br></pre></td></tr></table></figure>

<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c(continue)</span><br></pre></td></tr></table></figure>

<p>重启  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r(restart)</span><br></pre></td></tr></table></figure>

<h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n (next)</span><br></pre></td></tr></table></figure>

<h3 id="进入函数"><a href="#进入函数" class="headerlink" title="进入函数"></a>进入函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s (step)</span><br></pre></td></tr></table></figure>

<h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stepout</span><br></pre></td></tr></table></figure>

<h3 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure>

<h3 id="查看打了断点的列表"><a href="#查看打了断点的列表" class="headerlink" title="查看打了断点的列表"></a>查看打了断点的列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bp (breakpoints)</span><br></pre></td></tr></table></figure>

<h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear 断点号</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>delve</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go文件操作大全</title>
    <url>/2019/02/25/go-file-operation-finish/</url>
    <content><![CDATA[<h1 id="Go文件操作大全"><a href="#Go文件操作大全" class="headerlink" title="Go文件操作大全"></a>Go文件操作大全</h1><h2 id="1，介绍"><a href="#1，介绍" class="headerlink" title="1，介绍"></a>1，介绍</h2><h3 id="1-1-万物皆文件"><a href="#1-1-万物皆文件" class="headerlink" title="1.1 万物皆文件"></a>1.1 万物皆文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One of the fundamental aspects of UNIX is that everything is a file. We don&#x27;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&#x27;s device drivers. The operating system provides us an interface to the device in the form of a file.</span><br><span class="line"></span><br><span class="line">The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data. Look in /dev to find available devices. Some will require elevated privileges to access.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在此引用刘超老师专栏里写的话  </p>
<h4 id="Linux一切皆文件"><a href="#Linux一切皆文件" class="headerlink" title="Linux一切皆文件"></a>Linux一切皆文件</h4><ul>
<li>启动一个进程，需要一个程序文件，这是一个二进制文件  </li>
<li>启动的时候，要加载一些配置文件，例如yml、properties等，这是配置文件；启动之后会打印一些日志，如果写到硬盘上，也是文本文件；如果我想把日志打印到交互控制台上，在命令行上打印出来，这是一个标准输出的stdout文件  </li>
<li>这个进程的输出可以作为另一个进程的输入，这种方式称为管道，它也是一个文件  </li>
<li>进程可以通过网络和其他进程进行通信，建立的Socket，也是一个文件  </li>
<li>进程需要访问外部设备，设备也是一个文件  </li>
<li>文件都被存储在文件夹里面，文件夹也是一个文件  </li>
<li>进程运行起来，要想看到进程运行的情况，会在&#x2F;proc下面有对应的进程号，也是一系列的文件</li>
</ul>
<h2 id="2，基本操作"><a href="#2，基本操作" class="headerlink" title="2，基本操作"></a>2，基本操作</h2><h3 id="2-1-创建空文件"><a href="#2-1-创建空文件" class="headerlink" title="2.1 创建空文件"></a>2.1 创建空文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    newFile *os.File</span><br><span class="line">    err     <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newFile, err = os.Create(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(newFile)</span><br><span class="line">    newFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-缩短文件"><a href="#2-2-缩短文件" class="headerlink" title="2.2 缩短文件"></a>2.2 缩短文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 裁剪一个文件到100个字节。</span></span><br><span class="line">    <span class="comment">// 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。</span></span><br><span class="line">    <span class="comment">// 如果文件本来超过100个字节，则超过的字节会被抛弃。</span></span><br><span class="line">    <span class="comment">// 这样我们总是得到精确的100个字节的文件。</span></span><br><span class="line">    <span class="comment">// 传入0则会清空文件。</span></span><br><span class="line">    err := os.Truncate(<span class="string">&quot;test.txt&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-获取文件信息"><a href="#2-3-获取文件信息" class="headerlink" title="2.3 获取文件信息"></a>2.3 获取文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo os.FileInfo</span><br><span class="line">    err      <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">    fileInfo, err = os.Stat(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;File name:&quot;</span>, fileInfo.Name())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Size in bytes:&quot;</span>, fileInfo.Size())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Permissions:&quot;</span>, fileInfo.Mode())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Last modified:&quot;</span>, fileInfo.ModTime())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Is Directory: &quot;</span>, fileInfo.IsDir())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;System interface type: %T\n&quot;</span>, fileInfo.Sys())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;System info: %+v\n\n&quot;</span>, fileInfo.Sys())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-重命名和移动文件"><a href="#2-4-重命名和移动文件" class="headerlink" title="2.4 重命名和移动文件"></a>2.4 重命名和移动文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalPath := <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">    newPath := <span class="string">&quot;test2.txt&quot;</span></span><br><span class="line">    err := os.Rename(originalPath, newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除一个文件"><a href="#2-5-删除一个文件" class="headerlink" title="2.5 删除一个文件"></a>2.5 删除一个文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Remove(<span class="string">&quot;test.txt&quot;</span>)  <span class="comment">//Remove 移除</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-6-打开和关闭文件"><a href="#2-6-打开和关闭文件" class="headerlink" title="2.6 打开和关闭文件"></a>2.6 打开和关闭文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 简单地以只读的方式打开。下面的例子会介绍读写的例子。</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// OpenFile提供更多的选项。</span></span><br><span class="line">    <span class="comment">// 最后一个参数是权限模式permission mode</span></span><br><span class="line">    <span class="comment">// 第二个是打开时的属性    </span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 下面的属性可以单独使用，也可以组合使用。</span></span><br><span class="line">    <span class="comment">// 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：</span></span><br><span class="line">    <span class="comment">// os.O_CREATE|os.O_APPEND</span></span><br><span class="line">    <span class="comment">// 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY</span></span><br><span class="line">    <span class="comment">// os.O_RDONLY // 只读</span></span><br><span class="line">    <span class="comment">// os.O_WRONLY // 只写</span></span><br><span class="line">    <span class="comment">// os.O_RDWR // 读和写</span></span><br><span class="line">    <span class="comment">// os.O_APPEND // 往文件末尾添加（Append）</span></span><br><span class="line">    <span class="comment">// os.O_CREATE // 如果文件不存在时则先创建这个文件</span></span><br><span class="line">    <span class="comment">// os.O_TRUNC // 文件打开时裁剪文件</span></span><br><span class="line">    <span class="comment">// os.O_EXCL // 和O_CREATE一起使用，文件不能存在</span></span><br><span class="line">    <span class="comment">// os.O_SYNC // 以同步I/O的方式打开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-判断这个文件是否存在"><a href="#2-7-判断这个文件是否存在" class="headerlink" title="2.7 判断这个文件是否存在"></a>2.7 判断这个文件是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo *os.FileInfo</span><br><span class="line">    err      <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在则返回error</span></span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;File does not exist.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;File does exist. File information:&quot;</span>)</span><br><span class="line">    log.Println(fileInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-8-检查读写权限"><a href="#2-8-检查读写权限" class="headerlink" title="2.8 检查读写权限"></a>2.8 检查读写权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子测试写权限，如果没有写权限则返回error。</span></span><br><span class="line">    <span class="comment">// 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;Error: Write permission denied.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 测试读权限</span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;Error: Read permission denied.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-9-改变权限、拥有者、时间戳"><a href="#2-9-改变权限、拥有者、时间戳" class="headerlink" title="2.9 改变权限、拥有者、时间戳"></a>2.9 改变权限、拥有者、时间戳</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Linux风格改变文件权限</span></span><br><span class="line">    err := os.Chmod(<span class="string">&quot;test.txt&quot;</span>, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变文件所有者</span></span><br><span class="line">    err = os.Chown(<span class="string">&quot;test.txt&quot;</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变时间戳</span></span><br><span class="line">    twoDaysFromNow := time.Now().Add(<span class="number">48</span> * time.Hour)</span><br><span class="line">    lastAccessTime := twoDaysFromNow</span><br><span class="line">    lastModifyTime := twoDaysFromNow</span><br><span class="line">    err = os.Chtimes(<span class="string">&quot;test.txt&quot;</span>, lastAccessTime, lastModifyTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-10-硬链接和软链接"><a href="#2-10-硬链接和软链接" class="headerlink" title="2.10 硬链接和软链接"></a>2.10 硬链接和软链接</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个硬链接。</span></span><br><span class="line">    <span class="comment">// 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。</span></span><br><span class="line">    <span class="comment">// 删除和重命名不会影响另一个。</span></span><br><span class="line">    err := os.Link(<span class="string">&quot;original.txt&quot;</span>, <span class="string">&quot;original_also.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;creating sym&quot;</span>)</span><br><span class="line">    <span class="comment">// Create a symlink</span></span><br><span class="line">    err = os.Symlink(<span class="string">&quot;original.txt&quot;</span>, <span class="string">&quot;original_sym.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。</span></span><br><span class="line">    <span class="comment">// Symlink在Windows中不工作。</span></span><br><span class="line">    fileInfo, err := os.Lstat(<span class="string">&quot;original_sym.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Link info: %+v&quot;</span>, fileInfo)</span><br><span class="line">    <span class="comment">//改变软链接的拥有者不会影响原始文件。</span></span><br><span class="line">    err = os.Lchown(<span class="string">&quot;original_sym.txt&quot;</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3，读写"><a href="#3，读写" class="headerlink" title="3，读写"></a>3，读写</h2><h3 id="3-1-复制文件"><a href="#3-1-复制文件" class="headerlink" title="3.1 复制文件"></a>3.1 复制文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开原始文件</span></span><br><span class="line">    originalFile, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> originalFile.Close()</span><br><span class="line">    <span class="comment">// 创建新的文件作为目标文件</span></span><br><span class="line">    newFile, err := os.Create(<span class="string">&quot;test_copy.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">    <span class="comment">// 从源中复制字节到目标文件</span></span><br><span class="line">    bytesWritten, err := io.Copy(newFile, originalFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Copied %d bytes.&quot;</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 将文件内容flush到硬盘中</span></span><br><span class="line">    err = newFile.Sync()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-跳转到文件指定位置（Seek）"><a href="#3-2-跳转到文件指定位置（Seek）" class="headerlink" title="3.2 跳转到文件指定位置（Seek）"></a>3.2 跳转到文件指定位置（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, _ := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 偏离位置，可以是正数也可以是负数</span></span><br><span class="line">    <span class="keyword">var</span> offset <span class="type">int64</span> = <span class="number">5</span></span><br><span class="line">    <span class="comment">// 用来计算offset的初始位置</span></span><br><span class="line">    <span class="comment">// 0 = 文件开始位置</span></span><br><span class="line">    <span class="comment">// 1 = 当前位置</span></span><br><span class="line">    <span class="comment">// 2 = 文件结尾处</span></span><br><span class="line">    <span class="keyword">var</span> whence <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    newPosition, err := file.Seek(offset, whence)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Just moved to 5:&quot;</span>, newPosition)</span><br><span class="line">    <span class="comment">// 从当前位置回退两个字节</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">-2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Just moved back two:&quot;</span>, newPosition)</span><br><span class="line">    <span class="comment">// 使用下面的技巧得到当前的位置</span></span><br><span class="line">    currentPosition, err := file.Seek(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Current position:&quot;</span>, currentPosition)</span><br><span class="line">    <span class="comment">// 转到文件开始处</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Position after seeking 0,0:&quot;</span>, newPosition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-3-写文件"><a href="#3-3-写文件" class="headerlink" title="3.3 写文件"></a>3.3 写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可写方式打开文件</span></span><br><span class="line">    file, err := os.OpenFile(</span><br><span class="line">        <span class="string">&quot;test.txt&quot;</span>,</span><br><span class="line">        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,</span><br><span class="line">        <span class="number">0666</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 写字节到文件中</span></span><br><span class="line">    byteSlice := []<span class="type">byte</span>(<span class="string">&quot;Bytes!\n&quot;</span>)</span><br><span class="line">    bytesWritten, err := file.Write(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Wrote %d bytes.\n&quot;</span>, bytesWritten)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-快写文件"><a href="#3-4-快写文件" class="headerlink" title="3.4 快写文件"></a>3.4 快写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := ioutil.WriteFile(<span class="string">&quot;test.txt&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hi\n&quot;</span>), <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-5-使用缓存写"><a href="#3-5-使用缓存写" class="headerlink" title="3.5 使用缓存写"></a>3.5 使用缓存写</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只写</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 为这个文件创建buffered writer</span></span><br><span class="line">    bufferedWriter := bufio.NewWriter(file)</span><br><span class="line">    <span class="comment">// 写字节到buffer</span></span><br><span class="line">    bytesWritten, err := bufferedWriter.Write(</span><br><span class="line">        []<span class="type">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Bytes written: %d\n&quot;</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 写字符串到buffer</span></span><br><span class="line">    <span class="comment">// 也可以使用 WriteRune() 和 WriteByte()   </span></span><br><span class="line">    bytesWritten, err = bufferedWriter.WriteString(</span><br><span class="line">        <span class="string">&quot;Buffered string\n&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Bytes written: %d\n&quot;</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 检查缓存中的字节数</span></span><br><span class="line">    unflushedBufferSize := bufferedWriter.Buffered()</span><br><span class="line">    log.Printf(<span class="string">&quot;Bytes buffered: %d\n&quot;</span>, unflushedBufferSize)</span><br><span class="line">    <span class="comment">// 还有多少字节可用（未使用的缓存大小）</span></span><br><span class="line">    bytesAvailable := bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Available buffer: %d\n&quot;</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 写内存buffer到硬盘</span></span><br><span class="line">    bufferedWriter.Flush()</span><br><span class="line">    <span class="comment">// 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer</span></span><br><span class="line">    <span class="comment">// 当你想将缓存传给另外一个writer时有用</span></span><br><span class="line">    bufferedWriter.Reset(bufferedWriter)</span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Available buffer: %d\n&quot;</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 重新设置缓存的大小。</span></span><br><span class="line">    <span class="comment">// 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。</span></span><br><span class="line">    <span class="comment">// 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，</span></span><br><span class="line">    <span class="comment">// 而是writer的原始大小的缓存，默认是4096。</span></span><br><span class="line">    <span class="comment">// 它的功能主要还是为了扩容。</span></span><br><span class="line">    bufferedWriter = bufio.NewWriterSize(</span><br><span class="line">        bufferedWriter,</span><br><span class="line">        <span class="number">8000</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// resize后检查缓存的大小</span></span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Available buffer: %d\n&quot;</span>, bytesAvailable)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-6-读取最多N个字节"><a href="#3-6-读取最多N个字节" class="headerlink" title="3.6 读取最多N个字节"></a>3.6 读取最多N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 从文件中读取len(b)字节的文件。</span></span><br><span class="line">    <span class="comment">// 返回0字节意味着读取到文件尾了</span></span><br><span class="line">    <span class="comment">// 读取到文件会返回io.EOF的error</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>)</span><br><span class="line">    bytesRead, err := file.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, bytesRead)</span><br><span class="line">    log.Printf(<span class="string">&quot;Data read: %s\n&quot;</span>, byteSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-7-读取正好N个字节"><a href="#3-7-读取正好N个字节" class="headerlink" title="3.7 读取正好N个字节"></a>3.7 读取正好N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// file.Read()可以读取一个小文件到大的byte slice中，</span></span><br><span class="line">    <span class="comment">// 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    numBytesRead, err := io.ReadFull(file, byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">&quot;Data read: %s\n&quot;</span>, byteSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-8-读取至少N个字节"><a href="#3-8-读取至少N个字节" class="headerlink" title="3.8 读取至少N个字节"></a>3.8 读取至少N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>)</span><br><span class="line">    minBytes := <span class="number">8</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留</span></span><br><span class="line">    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">&quot;Data read: %s\n&quot;</span>, byteSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-9-读取全部字节"><a href="#3-9-读取全部字节" class="headerlink" title="3.9 读取全部字节"></a>3.9 读取全部字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// os.File.Read(), io.ReadFull(), and</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast() all work with a fixed</span></span><br><span class="line">    <span class="comment">// byte slice that you make before you read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioutil.ReadAll() will read every byte</span></span><br><span class="line">    <span class="comment">// from the reader (in this case a file),</span></span><br><span class="line">    <span class="comment">// and return a slice of unknown slice</span></span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Data as hex: %x\n&quot;</span>, data)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Data as string: %s\n&quot;</span>, data)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Number of bytes read:&quot;</span>, <span class="built_in">len</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-10-快速读到内存中"><a href="#3-10-快速读到内存中" class="headerlink" title="3.10 快速读到内存中"></a>3.10 快速读到内存中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件到byte slice中</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Data read: %s\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-11-使用缓存读"><a href="#3-11-使用缓存读" class="headerlink" title="3.11 使用缓存读"></a>3.11 使用缓存读</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，创建buffered reader</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader := bufio.NewReader(file)</span><br><span class="line">    <span class="comment">// 得到字节，当前指针不变</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">    byteSlice, err = bufferedReader.Peek(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Peeked at 5 bytes: %s\n&quot;</span>, byteSlice)</span><br><span class="line">    <span class="comment">// 读取，指针同时移动</span></span><br><span class="line">    numBytesRead, err := bufferedReader.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read %d bytes: %s\n&quot;</span>, numBytesRead, byteSlice)</span><br><span class="line">    <span class="comment">// 读取一个字节, 如果读取不成功会返回Error</span></span><br><span class="line">    myByte, err := bufferedReader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read 1 byte: %c\n&quot;</span>, myByte)     </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回byte slice</span></span><br><span class="line">    dataBytes, err := bufferedReader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read bytes: %s\n&quot;</span>, dataBytes)           </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回字符串</span></span><br><span class="line">    dataString, err := bufferedReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read string: %s\n&quot;</span>, dataString)     </span><br><span class="line">    <span class="comment">//这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-12-使用-scanner"><a href="#3-12-使用-scanner" class="headerlink" title="3.12 使用 scanner"></a>3.12 使用 scanner</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To define your own split function, match this fingerprint</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>, atEOF <span class="type">bool</span>)</span></span> (advance <span class="type">int</span>, token []<span class="type">byte</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returning (0, nil, nil) will tell the scanner</span></span><br><span class="line"><span class="comment">// to scan again, but with a bigger buffer because</span></span><br><span class="line"><span class="comment">// it wasn&#x27;t enough data to reach the delimiter</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(file)</span><br><span class="line">    <span class="comment">// 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。</span></span><br><span class="line">    <span class="comment">// 也可以定制一个SplitFunc类型的分隔函数</span></span><br><span class="line">    scanner.Split(bufio.ScanWords)</span><br><span class="line">    <span class="comment">// scan下一个token.</span></span><br><span class="line">    success := scanner.Scan()</span><br><span class="line">    <span class="keyword">if</span> success == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="comment">// 出现错误或者EOF是返回Error</span></span><br><span class="line">        err = scanner.Err()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;Scan completed and reached EOF&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到数据，Bytes() 或者 Text()</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;First word found:&quot;</span>, scanner.Text())</span><br><span class="line">    <span class="comment">// 再次调用scanner.Scan()发现下一个token</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4，压缩"><a href="#4，压缩" class="headerlink" title="4，压缩"></a>4，压缩</h2><h3 id="4-1-打包文件"><a href="#4-1-打包文件" class="headerlink" title="4.1 打包文件"></a>4.1 打包文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;archive/zip&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a file to write the archive buffer to</span></span><br><span class="line">    <span class="comment">// Could also use an in memory buffer.</span></span><br><span class="line">    outFile, err := os.Create(<span class="string">&quot;test.zip&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a zip writer on top of the file writer</span></span><br><span class="line">    zipWriter := zip.NewWriter(outFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add files to archive</span></span><br><span class="line">    <span class="comment">// We use some hard coded data to demonstrate,</span></span><br><span class="line">    <span class="comment">// but you could iterate through all the files</span></span><br><span class="line">    <span class="comment">// in a directory and pass the name and contents</span></span><br><span class="line">    <span class="comment">// of each file, or you can take data from your</span></span><br><span class="line">    <span class="comment">// program and write it write in to the archive</span></span><br><span class="line">    <span class="comment">// without </span></span><br><span class="line">    <span class="keyword">var</span> filesToArchive = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Name, Body <span class="type">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;String contents of file&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;test2.txt&quot;</span>, <span class="string">&quot;\x61\x62\x63\n&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and write files to the archive, which in turn</span></span><br><span class="line">    <span class="comment">// are getting written to the underlying writer to the</span></span><br><span class="line">    <span class="comment">// .zip file we created at the beginning</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> filesToArchive &#123;</span><br><span class="line">            fileWriter, err := zipWriter.Create(file.Name)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            _, err = fileWriter.Write([]<span class="type">byte</span>(file.Body))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    err = zipWriter.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-解压文件"><a href="#4-2-解压文件" class="headerlink" title="4.2 解压文件"></a>4.2 解压文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;archive/zip&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zipReader, err := zip.OpenReader(<span class="string">&quot;test.zip&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zipReader.Close()</span><br><span class="line">    <span class="comment">// 遍历打包文件中的每一文件/文件夹</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> zipReader.Reader.File &#123;</span><br><span class="line">        <span class="comment">// 打包文件中的文件就像普通的一个文件对象一样</span></span><br><span class="line">        zippedFile, err := file.Open()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> zippedFile.Close()</span><br><span class="line">        <span class="comment">// 指定抽取的文件名。</span></span><br><span class="line">        <span class="comment">// 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。</span></span><br><span class="line">        <span class="comment">// 我们这个例子使用打包文件中相同的文件名。</span></span><br><span class="line">        targetDir := <span class="string">&quot;./&quot;</span></span><br><span class="line">        extractedFilePath := filepath.Join(</span><br><span class="line">            targetDir,</span><br><span class="line">            file.Name,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 抽取项目或者创建文件夹</span></span><br><span class="line">        <span class="keyword">if</span> file.FileInfo().IsDir() &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹并设置同样的权限</span></span><br><span class="line">            log.Println(<span class="string">&quot;Creating directory:&quot;</span>, extractedFilePath)</span><br><span class="line">            os.MkdirAll(extractedFilePath, file.Mode())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//抽取正常的文件</span></span><br><span class="line">            log.Println(<span class="string">&quot;Extracting file:&quot;</span>, file.Name)</span><br><span class="line">            outputFile, err := os.OpenFile(</span><br><span class="line">                extractedFilePath,</span><br><span class="line">                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,</span><br><span class="line">                file.Mode(),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line">            <span class="comment">// 通过io.Copy简洁地复制文件内容</span></span><br><span class="line">            _, err = io.Copy(outputFile, zippedFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-压缩文件"><a href="#4-3-压缩文件" class="headerlink" title="4.3 压缩文件"></a>4.3 压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;compress/gzip&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outputFile, err := os.Create(<span class="string">&quot;test.txt.gz&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipWriter := gzip.NewWriter(outputFile)</span><br><span class="line">    <span class="keyword">defer</span> gzipWriter.Close()</span><br><span class="line">    <span class="comment">// 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。</span></span><br><span class="line">    <span class="comment">// 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。</span></span><br><span class="line">    _, err = gzipWriter.Write([]<span class="type">byte</span>(<span class="string">&quot;Gophers rule!\n&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;Compressed data written to file.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;compress/gzip&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个gzip文件。</span></span><br><span class="line">    <span class="comment">// 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，</span></span><br><span class="line">    <span class="comment">// 它的内容不是一个文件，而是一个内存流</span></span><br><span class="line">    gzipFile, err := os.Open(<span class="string">&quot;test.txt.gz&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipReader, err := gzip.NewReader(gzipFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gzipReader.Close()</span><br><span class="line">    <span class="comment">// 解压缩到一个writer,它是一个file writer</span></span><br><span class="line">    outfileWriter, err := os.Create(<span class="string">&quot;unzipped.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outfileWriter.Close()</span><br><span class="line">    <span class="comment">// 复制内容</span></span><br><span class="line">    _, err = io.Copy(outfileWriter, gzipReader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5，其它"><a href="#5，其它" class="headerlink" title="5，其它"></a>5，其它</h2><h3 id="5-1-临时文件和目录"><a href="#5-1-临时文件和目录" class="headerlink" title="5.1 临时文件和目录"></a>5.1 临时文件和目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">&quot;os&quot;</span></span><br><span class="line">     <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">     <span class="string">&quot;log&quot;</span></span><br><span class="line">     <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 在系统临时文件夹中创建一个临时文件夹</span></span><br><span class="line">     tempDirPath, err := ioutil.TempDir(<span class="string">&quot;&quot;</span>, <span class="string">&quot;myTempDir&quot;</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">&quot;Temp dir created:&quot;</span>, tempDirPath)</span><br><span class="line">     <span class="comment">// 在临时文件夹中创建临时文件</span></span><br><span class="line">     tempFile, err := ioutil.TempFile(tempDirPath, <span class="string">&quot;myTempFile.txt&quot;</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">&quot;Temp file created:&quot;</span>, tempFile.Name())</span><br><span class="line">     <span class="comment">// ... 做一些操作 ...</span></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     err = tempFile.Close()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除我们创建的资源</span></span><br><span class="line">     err = os.Remove(tempFile.Name())</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">     err = os.Remove(tempDirPath)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-通过HTTP下载文件"><a href="#5-2-通过HTTP下载文件" class="headerlink" title="5.2 通过HTTP下载文件"></a>5.2 通过HTTP下载文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">&quot;os&quot;</span></span><br><span class="line">     <span class="string">&quot;io&quot;</span></span><br><span class="line">     <span class="string">&quot;log&quot;</span></span><br><span class="line">     <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     newFile, err := os.Create(<span class="string">&quot;devdungeon.html&quot;</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">     url := <span class="string">&quot;http://www.devdungeon.com/archive&quot;</span></span><br><span class="line">     response, err := http.Get(url)</span><br><span class="line">     <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">     <span class="comment">// 将HTTP response Body中的内容写入到文件</span></span><br><span class="line">     <span class="comment">// Body满足reader接口，因此我们可以使用ioutil.Copy</span></span><br><span class="line">     numBytesWritten, err := io.Copy(newFile, response.Body)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     log.Printf(<span class="string">&quot;Downloaded %d byte file.\n&quot;</span>, numBytesWritten)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-3-哈希和摘要"><a href="#5-3-哈希和摘要" class="headerlink" title="5.3 哈希和摘要"></a>5.3 哈希和摘要</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 得到文件内容</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算Hash</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Md5: %x\n\n&quot;</span>, md5.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sha1: %x\n\n&quot;</span>, sha1.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sha256: %x\n\n&quot;</span>, sha256.Sum256(data))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sha512: %x\n\n&quot;</span>, sha512.Sum512(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">//创建一个新的hasher,满足writer接口</span></span><br><span class="line">    hasher := md5.New()</span><br><span class="line">    _, err = io.Copy(hasher, file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算hash并打印结果。</span></span><br><span class="line">    <span class="comment">// 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。</span></span><br><span class="line">    sum := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Md5 checksum: %x\n&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6，参考"><a href="#6，参考" class="headerlink" title="6，参考"></a>6，参考</h2><ul>
<li><a href="https://www.devdungeon.com/content/working-files-go">Working with Files in Go</a>  </li>
<li><a href="https://golang.org/pkg">Go Standard Library Documentation</a>  </li>
<li><a href="https://www.linux.com/learn/understanding-linux-file-permissions">understanding-linux-file-permissions</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go导出Excel文件</title>
    <url>/2022/05/11/go-download-excel-file/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>业务上经常会遇到要导出查询结果的<code>Excel</code>文档，我平时会用<code>excelize</code>包来做。  </p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>安装  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="number">360</span>EntSecGroup-Skylar/excelize</span><br></pre></td></tr></table></figure>

<p>更新  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/360EntSecGroup-Skylar/excelize</span><br></pre></td></tr></table></figure>

<h2 id="创建Excel"><a href="#创建Excel" class="headerlink" title="创建Excel"></a>创建Excel</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/360EntSecGroup-Skylar/excelize&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个文件</span></span><br><span class="line">    f := excelize.NewFile()</span><br><span class="line">    <span class="comment">// 创建一个工作表</span></span><br><span class="line">    index := f.NewSheet(<span class="string">&quot;Sheet2&quot;</span>)</span><br><span class="line">    <span class="comment">// 合并单元格</span></span><br><span class="line">    f.MergeCell(<span class="string">&quot;Sheet1&quot;</span>, <span class="string">&quot;A1&quot;</span>, <span class="string">&quot;J1&quot;</span>)  </span><br><span class="line">    <span class="comment">// 设置单元格的值</span></span><br><span class="line">    f.SetCellValue(<span class="string">&quot;Sheet2&quot;</span>, <span class="string">&quot;A2&quot;</span>, <span class="string">&quot;Hello world.&quot;</span>)</span><br><span class="line">    f.SetCellValue(<span class="string">&quot;Sheet1&quot;</span>, <span class="string">&quot;B2&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 设置工作簿的默认工作表</span></span><br><span class="line">    f.SetActiveSheet(index)</span><br><span class="line">    <span class="comment">// 根据指定路径保存文件</span></span><br><span class="line">    err := f.SaveAs(<span class="string">&quot;./Book1.xlsx&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取Excel"><a href="#读取Excel" class="headerlink" title="读取Excel"></a>读取Excel</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/360EntSecGroup-Skylar/excelize&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := excelize.OpenFile(<span class="string">&quot;./Book1.xlsx&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取工作表中指定单元格的值</span></span><br><span class="line">    cell, err := f.GetCellValue(<span class="string">&quot;Sheet1&quot;</span>, <span class="string">&quot;B2&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(cell)</span><br><span class="line">    <span class="comment">// 获取 Sheet1 上所有单元格</span></span><br><span class="line">    rows, err := f.GetRows(<span class="string">&quot;Sheet1&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">        <span class="keyword">for</span> _, colCell := <span class="keyword">range</span> row &#123;</span><br><span class="line">            fmt.Print(colCell, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bookstack.cn/books/excelize-v2.0">Excelize v2.0 中文文档</a></p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的优点和缺点</title>
    <url>/2020/05/10/go-language-advantages-and-disadvantages/</url>
    <content><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>1，性能  </p>
</li>
<li><p>2，语言性能很重要  </p>
</li>
<li><p>3，发者效率&amp;不要过于创新  </p>
</li>
<li><p>4，并发性&amp;通道  </p>
</li>
<li><p>5，快速的编译时间  </p>
</li>
<li><p>6，打造团队的能力  </p>
</li>
<li><p>7，强大的生态系统  </p>
</li>
<li><p>8，GOFMT，强制代码格式  </p>
</li>
<li><p>9，gRPC 和 Protocol Buffers</p>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p>1，缺少框架  </p>
</li>
<li><p>2，错误处理  </p>
</li>
<li><p>3，软件包管理</p>
</li>
</ul>
<h2 id="个人使用感受"><a href="#个人使用感受" class="headerlink" title="个人使用感受"></a>个人使用感受</h2><p>个人觉得<code>Go</code>语言在做后端并发时非常方便，起一个<code>go func()</code>即可。缺点的话，目前（2020.5月之前）只遇到过<code>Go</code>因垃圾回收而引起的<code>CPU</code>占满的<code>Bug</code>。<br><code>Go</code>有<code>C</code>语言的指针和<code>Python</code>语法的优雅，写起来很舒服，同时也有强大的调试工具<code>Delve</code>。  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://studygolang.com/articles/12907">Go 语言的优点，缺点和令人厌恶的设计 </a>  </li>
<li><a href="https://www.sohu.com/a/220085058_657921">Go 在 TiDB 的实践</a>  </li>
<li><a href="https://developer.51cto.com/art/201710/555200.htm">Go语言的9大优势和3大缺点</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>开发</tag>
        <tag>优点</tag>
        <tag>缺点</tag>
      </tags>
  </entry>
  <entry>
    <title>Go微服务框架go-micro v3快速入门</title>
    <url>/2023/03/07/go-micro-v3-quick-get-start/</url>
    <content><![CDATA[<h1 id="go-micro-v3和micro-v3是什么关系？"><a href="#go-micro-v3和micro-v3是什么关系？" class="headerlink" title="go-micro v3和micro v3是什么关系？"></a>go-micro v3和micro v3是什么关系？</h1><h2 id="go-micro是什么？"><a href="#go-micro是什么？" class="headerlink" title="go-micro是什么？"></a>go-micro是什么？</h2><ul>
<li>一个go微服务开放框架  </li>
<li>Framework（程序开放框架）：用来方便编写微服务  </li>
<li>Clients（多语言客户端）：支持多语言访问服务端</li>
</ul>
<h2 id="go-micro-v3与micro-v3的关系"><a href="#go-micro-v3与micro-v3的关系" class="headerlink" title="go-micro v3与micro v3的关系"></a>go-micro v3与micro v3的关系</h2><ul>
<li>micro v3版本类似isito把基础设施抽象成能力  </li>
<li>micro的技术体系和官方平台绑定较多  </li>
<li>go-micro v3为微服务开发框架，自由度相对较高</li>
</ul>
<h1 id="go-micro-v3整体架构"><a href="#go-micro-v3整体架构" class="headerlink" title="go-micro v3整体架构"></a>go-micro v3整体架构</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>注册-Registry：提供了服务发现机制  </li>
<li>选择器-Selector：能够实现负载均衡  </li>
<li>传输-Transport：服务与服务之间通信接口  </li>
<li>代理-Broker：提供异步通信的消息发布&#x2F;订阅接口  </li>
<li>编码-Codec：消息传输到两端时进行编码与解码</li>
</ul>
]]></content>
      <categories>
        <category>LearnMicroservices</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>让Go“恐慌”的十种方法</title>
    <url>/2021/09/05/go-panic-ten-method/</url>
    <content><![CDATA[<p>本内容来源于书籍《Go语言编程之旅》  </p>
<p>本文内容将运行让Go程序遇到“恐慌”的代码例子  </p>
<h2 id="数组-x2F-切片索引越界"><a href="#数组-x2F-切片索引越界" class="headerlink" title="数组&#x2F;切片索引越界"></a>数组&#x2F;切片索引越界</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	names := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;3&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	name := names[<span class="built_in">len</span>(names)]  <span class="comment">//应该改为 names[len(names) - 1]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: %s&quot;</span>,name)  <span class="comment">//panic: runtime error: index out of range [3] with length 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空指针调用"><a href="#空指针调用" class="headerlink" title="空指针调用"></a>空指针调用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span>GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := &amp;User&#123;Name: <span class="string">&quot;Neo&quot;</span>&#125;</span><br><span class="line">	s = <span class="literal">nil</span></span><br><span class="line">	s.GetName()  <span class="comment">//panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过早关闭HTTP响应体"><a href="#过早关闭HTTP响应体" class="headerlink" title="过早关闭HTTP响应体"></a>过早关闭HTTP响应体</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp,err := http.Get(<span class="string">&quot;https://xxx&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()  <span class="comment">//panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;http.Get err: %v&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="除以零"><a href="#除以零" class="headerlink" title="除以零"></a>除以零</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	divide(<span class="number">1</span>,<span class="number">0</span>)  <span class="comment">//panic: runtime error: integer divide by zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向已经关闭的通道发送消息"><a href="#向已经关闭的通道发送消息" class="headerlink" title="向已经关闭的通道发送消息"></a>向已经关闭的通道发送消息</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>,<span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="string">&quot;neo&quot;</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	ch &lt;- <span class="string">&quot;come on&quot;</span>  <span class="comment">//panic: send on closed channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重复关闭通道"><a href="#重复关闭通道" class="headerlink" title="重复关闭通道"></a>重复关闭通道</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>,<span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="string">&quot;neo&quot;</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	<span class="built_in">close</span>(ch)  <span class="comment">//panic: close of closed channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭未初始化的通道"><a href="#关闭未初始化的通道" class="headerlink" title="关闭未初始化的通道"></a>关闭未初始化的通道</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">	<span class="built_in">close</span>(ch)  <span class="comment">//panic: close of nil channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未初始化map"><a href="#未初始化map" class="headerlink" title="未初始化map"></a>未初始化map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	m[<span class="string">&quot;neo&quot;</span>] = <span class="string">&quot;come on&quot;</span>  <span class="comment">//panic: assignment to entry in nil map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨协程的“恐慌”处理"><a href="#跨协程的“恐慌”处理" class="headerlink" title="跨协程的“恐慌”处理"></a>跨协程的“恐慌”处理</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;revover err: %v&quot;</span>,err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		handle()</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> divide(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a / b  <span class="comment">//panic: runtime error: integer divide by zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync计数为负值"><a href="#sync计数为负值" class="headerlink" title="sync计数为负值"></a>sync计数为负值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">-1</span>)  <span class="comment">//panic: sync: negative WaitGroup counter</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/OctopusLian/c07175249607e3c523704a08fb05e47f">代码地址</a>  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>panic</tag>
      </tags>
  </entry>
  <entry>
    <title>Go项目miniblog学习总结</title>
    <url>/2024/08/02/go-project-miniblog/</url>
    <content><![CDATA[<h1 id="miniblog-实现的功能"><a href="#miniblog-实现的功能" class="headerlink" title="miniblog 实现的功能"></a>miniblog 实现的功能</h1><ul>
<li>用户管理： 支持 用户注册、用户登录、获取用户列表、获取用户详情、更新用户信息、修改用户密码、注销用户 7 种用户操作；  </li>
<li>博客管理： 支持 创建博客、获取博客列表、获取博客详情、更新博客内容、删除博客、批量删除博客 6 种博客操作。</li>
</ul>
<p>涉及技术栈，点击<a href="https://github.com/OctopusLian/miniblog">github</a>    </p>
<h1 id="miniblog-目录结构"><a href="#miniblog-目录结构" class="headerlink" title="miniblog 目录结构"></a>miniblog 目录结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── api # Swagger / OpenAPI 文档存放目录</span><br><span class="line">│   └── openapi</span><br><span class="line">│       └── openapi.yaml # OpenAPI 3.0 API 接口文档</span><br><span class="line">├── cmd # main 文件存放目录</span><br><span class="line">│   └── miniblog</span><br><span class="line">│       └── miniblog.go</span><br><span class="line">├── configs # 配置文件存放目录</span><br><span class="line">│   ├── miniblog.sql # 数据库初始化 SQL</span><br><span class="line">│   ├── miniblog.yaml # miniblog 配置文件</span><br><span class="line">│   └── nginx.conf # Nginx 配置</span><br><span class="line">├── docs # 项目文档</span><br><span class="line">│   ├── devel # 开发文档</span><br><span class="line">│   │   ├── en-US # 英文文档</span><br><span class="line">│   │   └── zh-CN # 中文文档</span><br><span class="line">│   │       ├── architecture.md # miniblog 架构介绍</span><br><span class="line">│   │       ├── conversions # 规范文档存放目录</span><br><span class="line">│   │       │   ├── api.md # 接口规范</span><br><span class="line">│   │       │   ├── commit.md # Commit 规范</span><br><span class="line">│   │       │   ├── directory.md # 目录结构规范</span><br><span class="line">│   │       │   ├── error_code.md # 错误码规范</span><br><span class="line">│   │       │   ├── go_code.md # 代码规范</span><br><span class="line">│   │       │   ├── log.md # 日志规范</span><br><span class="line">│   │       │   └── version.md # 版本规范</span><br><span class="line">│   │       └── README.md</span><br><span class="line">│   ├── guide # 用户文档</span><br><span class="line">│   │   ├── en-US # 英文文档</span><br><span class="line">│   │   └── zh-CN # 中文文档</span><br><span class="line">│   │       ├── announcements.md # 动态与公告</span><br><span class="line">│   │       ├── best-practice # 最佳实践</span><br><span class="line">│   │       ├── faq # 常见问题</span><br><span class="line">│   │       ├── installation # 安装指南</span><br><span class="line">│   │       ├── introduction # 产品介绍</span><br><span class="line">│   │       ├── operation-guide # 操作指南</span><br><span class="line">│   │       ├── quickstart # 快速入门</span><br><span class="line">│   │       └── README.md</span><br><span class="line">│   └── images # 项目图片存放目录</span><br><span class="line">├── examples # 示例源码</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── init # Systemd Unit 文件保存目录</span><br><span class="line">│   ├── miniblog.service # miniblog systemd unit</span><br><span class="line">├── internal # 内部代码保存目录，这里面的代码不能被外部程序引用</span><br><span class="line">│   ├── miniblog # miniblog 代码实现目录</span><br><span class="line">│   │   ├── biz # biz 层代码</span><br><span class="line">│   │   ├── controller # controller 层代码</span><br><span class="line">│   │   │   └── v1 # API 接口版本</span><br><span class="line">│   │   │       ├── post # 博客相关代码实现</span><br><span class="line">│   │   │       │   ├── create.go # 创建博客</span><br><span class="line">│   │   │       │   ├── delete_collection.go #批量删除博客</span><br><span class="line">│   │   │       │   ├── delete.go # 删除博客</span><br><span class="line">│   │   │       │   ├── get.go # 获取博客详情</span><br><span class="line">│   │   │       │   ├── list.go # 获取博客列表</span><br><span class="line">│   │   │       │   ├── post.go # 博客 Controller 结构定义、创建</span><br><span class="line">│   │   │       │   └── update.go # 更新博客</span><br><span class="line">│   │   │       └── user</span><br><span class="line">│   │   │           ├── change_password.go # 修改用户密码</span><br><span class="line">│   │   │           ├── create.go #创建用户</span><br><span class="line">│   │   │           ├── delete.go # 删除用户</span><br><span class="line">│   │   │           ├── get.go # 获取用户详情</span><br><span class="line">│   │   │           ├── list.go # 获取用户列表</span><br><span class="line">│   │   │           ├── login.go # 用户登录</span><br><span class="line">│   │   │           ├── update.go  # 更新用户</span><br><span class="line">│   │   │           └── user.go # 用户 Controller 结构定义、创建</span><br><span class="line">│   │   ├── helper.go # 工具类代码存放文件</span><br><span class="line">│   │   ├── miniblog.go # miniblog 主业务逻辑实现代码</span><br><span class="line">│   │   ├── router.go # Gin 路由加载代码</span><br><span class="line">│   │   └── store # store 层代码</span><br><span class="line">│   └── pkg # 内部包保存目录</span><br><span class="line">│       ├── core # core 包，用来保存一些核心的函数</span><br><span class="line">│       ├── errno # errno 包，实现了 miniblog 的错误码功能</span><br><span class="line">│       │   ├── code.go # 错误码定义文件</span><br><span class="line">│       │   └── errno.go # errno 包功能函数文件</span><br><span class="line">│       ├── known # 存放项目级的常量定义</span><br><span class="line">│       ├── log # miniblog 自定义 log 包</span><br><span class="line">│       ├── middleware # Gin 中间件包</span><br><span class="line">│       │   ├── authn.go # 认证中间件</span><br><span class="line">│       │   ├── authz.go # 授权中间件</span><br><span class="line">│       │   ├── header.go # 指定 HTTP Response Header</span><br><span class="line">│       │   └── requestid.go # 请求 / 返回头中添加 X-Request-ID</span><br><span class="line">│       └── model # GORM Model</span><br><span class="line">├── LICENSE # 声明代码所遵循的开源协议</span><br><span class="line">├── Makefile # Makefile 文件，一般大型软件系统都是采用 make 来作为编译工具</span><br><span class="line">├── _output # 临时文件存放目录</span><br><span class="line">├── pkg # 可供外部程序直接使用的 Go 包存放目录</span><br><span class="line">│   ├── api # REST API 接口定义存放目录</span><br><span class="line">│   ├── proto # Protobuf 接口定义存放目录</span><br><span class="line">│   ├── auth # auth 包，用来完成认证、授权功能</span><br><span class="line">│   │   ├── authn.go # 认证功能</span><br><span class="line">│   │   └── authz.go # 授权功能</span><br><span class="line">│   ├── db # db 包，用来完成 MySQL 数据库连接</span><br><span class="line">│   ├── token # JWT Token 的签发和解析</span><br><span class="line">│   ├── util # 工具类包存放目录</span><br><span class="line">│   │   └── id # id 包，用来生成唯一短 ID</span><br><span class="line">│   └── version # version 包，用来保存 / 输出版本信息</span><br><span class="line">├── README-en.md # 英文 README</span><br><span class="line">├── README.md # 中文 README</span><br><span class="line">├── scripts # 脚本文件</span><br><span class="line">│   ├── boilerplate.txt # 指定版权头信息</span><br><span class="line">│   ├── coverage.awk # awk 脚本，用来计算覆盖率</span><br><span class="line">│   ├── make-rules # 子 Makefile 保存目录</span><br><span class="line">│   │   ├── common.mk # 存放通用的 Makefile 变量</span><br><span class="line">│   │   ├── golang.mk # 用来编译源码</span><br><span class="line">│   │   └── tools.mk # 用来完成工具的安装</span><br><span class="line">│   └── wrktest.sh # wrk 性能测试脚本</span><br><span class="line">└── third_party # 第三方 Go 包存放目录</span><br></pre></td></tr></table></figure>

<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="为什么考虑用mariadb而不是mysql"><a href="#为什么考虑用mariadb而不是mysql" class="headerlink" title="为什么考虑用mariadb而不是mysql"></a>为什么考虑用mariadb而不是mysql</h2><p>查看<a href="https://mariadb.org/zh/">MariaDB中文文档</a>提到  </p>
<blockquote>
<p>当 MariaDB Server 的前身 MySQL 于 2009 年被 Oracle 收购时，MySQL 创始人 Michael “Monty” Widenius 出于对 Oracle 管理权的担忧而分叉了该项目，并将新项目命名为 MariaDB。 MySQL 以他的第一个女儿 My 命名，而 MariaDB 则以他的第二个女儿 Maria 命名。<br>它可用于高可用性事务数据、分析、作为嵌入式服务器。</p>
</blockquote>
<p>mariadb基于mysql做了优化，所以可以将mariadb当做mysql使用。  </p>
<h2 id="Biz层相当于SpringBoot中的Service层？"><a href="#Biz层相当于SpringBoot中的Service层？" class="headerlink" title="Biz层相当于SpringBoot中的Service层？"></a>Biz层相当于SpringBoot中的Service层？</h2><p>是的。  </p>
<h2 id="type-UserBiz-interface存在的意义？"><a href="#type-UserBiz-interface存在的意义？" class="headerlink" title="type UserBiz interface存在的意义？"></a><code>type UserBiz interface</code>存在的意义？</h2><p><img src="/2024/08/02/go-project-miniblog/qa-2.png">  </p>
<p>为了确保代码可测，不然，你测试Service层的代码时，要去创建一个Biz层的实例，Biz层的实例，有时候可能会有一些依赖，这些依赖测试环境不一定能满足。<br>用接口，可以直接用mock工具，mock一个。<br>按照mockgen的规则来写，然后一键生成mock文件。<br><img src="/2024/08/02/go-project-miniblog/qa-2-1.jpg">  </p>
<h2 id="go-mod以github-com-xx开头是为了什么？"><a href="#go-mod以github-com-xx开头是为了什么？" class="headerlink" title="go.mod以github.com/xx开头是为了什么？"></a>go.mod以<code>github.com/xx</code>开头是为了什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/marmotedu/miniblog</span><br><span class="line"></span><br><span class="line">go 1.19</span><br></pre></td></tr></table></figure>

<p><a href="https://colobu.com/2021/06/28/dive-into-go-module-1/">深入Go Module之go.mod文件解析</a></p>
<blockquote>
<p>go.mod的第一行是module path, 一般采用仓库+module name的方式定义。这样我们获取一个module的时候，就可以到它的仓库中去查询，或者让go proxy到仓库中去查询。  </p>
</blockquote>
<h2 id="每个Go文件前加Copyright的意义是什么？"><a href="#每个Go文件前加Copyright的意义是什么？" class="headerlink" title="每个Go文件前加Copyright的意义是什么？"></a>每个Go文件前加Copyright的意义是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Copyright 2022 Innkeeper Belm(孔令飞) &lt;nosbelm@qq.com&gt;. All rights reserved.</span><br><span class="line">// Use of this source code is governed by a MIT style</span><br><span class="line">// license that can be found in the LICENSE file. The original repo for</span><br><span class="line">// this file is https://github.com/marmotedu/miniblog.</span><br></pre></td></tr></table></figure>

<p>这个版权应该是可以在Goland中设置，跟<code>LICENSE</code>文件绑定</p>
<h2 id="miniblog封装的log库，要写一个key，这样设计书出于什么业务场景的考虑？"><a href="#miniblog封装的log库，要写一个key，这样设计书出于什么业务场景的考虑？" class="headerlink" title="miniblog封装的log库，要写一个key，这样设计书出于什么业务场景的考虑？"></a>miniblog封装的log库，要写一个key，这样设计书出于什么业务场景的考虑？</h2><p><img src="/2024/08/02/go-project-miniblog/qa-5.jpg">  </p>
<p>格式化的日志，方便日志系统按字段过滤，解析。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，miniblog完全可以作为中小项目的脚手架，我目前已经将在企业中开发的设备服务基于<code>miniblog</code>重构，后期考虑实现<code>minidocker</code>，<code>miniredis</code>项目也统一用这个设计。  </p>
]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Go项目结构设计过程点滴记录</title>
    <url>/2019/04/22/go-project-struct-design-note/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前在知识星球里星主让用<code>SMTP</code>协议实现邮件发送功能，看了<code>Max Li</code>的设计，并和他交流了一小时，在此将设计经验记录下来。  </p>
<h1 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h1><p>设计一个项目的结构，有时候就像写文章一样，得分清层级。下面我将把讨论出的设计经验记录下来。  </p>
<ul>
<li><p>main.go文件，当做项目的入口，里面可以写明版本号，读取配置文件，以及日志的初始化；  </p>
</li>
<li><p>gomod文件，包管理  </p>
</li>
<li><p>makefile文件，如果启动程序较多，可以写入makefile文件中，到时运行直接make即可；  </p>
</li>
<li><p>pkg文件夹，存放项目的主要源代码  </p>
</li>
<li><p>cmd文件夹，存放项目生成的可执行文件  </p>
</li>
<li><p>config文件夹，存放配置文件，包含项目的基本配置信息  </p>
</li>
<li><p>vendor文件夹，将依赖的包放入此目录中  </p>
</li>
<li><p>util文件夹，项目中所写的小工具，例如进制转换，查错，类型转换，时间转时间戳等放入该文件件</p>
</li>
</ul>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"><a href="#1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？" class="headerlink" title="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"></a>1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？</h2><h2 id="2，如何做到在项目build同时自己更新tag号？"><a href="#2，如何做到在项目build同时自己更新tag号？" class="headerlink" title="2，如何做到在项目build同时自己更新tag号？"></a>2，如何做到在项目build同时自己更新tag号？</h2><p>参考<a href="https://github.com/ahmetb/govvv">govvv</a>  </p>
<h2 id="3，怎样设计出一个框架，支持易扩展可维护呢？"><a href="#3，怎样设计出一个框架，支持易扩展可维护呢？" class="headerlink" title="3，怎样设计出一个框架，支持易扩展可维护呢？"></a>3，怎样设计出一个框架，支持易扩展可维护呢？</h2><p>我能想到的是，<code>web</code>服务设计接口，在接口中添加操作。  </p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://idiomaticgo.com/post/best-practice/server-project-layout/">Server Project Layout</a>  </p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写<code>demo</code>的时候，还是忍不住将所有的程序写进一个<code>main</code>函数里，又或者是新建一个<code>server.go</code>文件，然后一股脑的在里面做文章。  </p>
<p>今天早上看星球里的朋友提出了一个问题，我觉得很对，在此摘录如下  </p>
<blockquote>
<p>提高编程技能是很不容易的，一个人一旦习惯了某种编程思维就很难再突破。就说说我自己，一个业务用一般方法能实现的，我很难再去想到用接口，函数类型，闭包，反射等。虽然业务实现了，但总感觉代码写的很烂，自己看了都恶心。我相信大家一定有同感，教程和视频看了很多，也知道很多概念，但等到自己用的时候，又回到了旧的思维习惯。我觉得老大在布道go时，更应关注这方面的培养，知识的细节和技巧可以慢慢积累，但思维定势不突破，永远也不可能提高。  </p>
</blockquote>
<p>今天和<code>Max Li</code>的沟通，还有在做项目时不断的以工程思维冲击着以前遗留下来的旧的思维习惯，我只想说，越早做出好的改变，成长的空间的也就越大。  </p>
<p>共勉！  </p>
<p><img src="/2019/04/22/go-project-struct-design-note/road"></p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Go</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第1课_Go程序是怎么跑起来的</title>
    <url>/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/</url>
    <content><![CDATA[<h1 id="开场闲聊"><a href="#开场闲聊" class="headerlink" title="开场闲聊"></a>开场闲聊</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="语⾔深度"><a href="#语⾔深度" class="headerlink" title="语⾔深度"></a>语⾔深度</h3><p>调度原理、调试技巧、汇编反汇编、内部数据结构实现、常⻅ syscall、函数<br>调⽤规约(待定)、内存管理与垃圾回收、并发编程  </p>
<h3 id="应⽤深度"><a href="#应⽤深度" class="headerlink" title="应⽤深度"></a>应⽤深度</h3><p>框架原理、社区框架分析、模块分层、linter 规范、中台场景实现、性能调优  </p>
<h3 id="架构⼴度"><a href="#架构⼴度" class="headerlink" title="架构⼴度"></a>架构⼴度</h3><p>模块拆分、CI&#x2F;CD 实战(coding 平台)、监控与可观测性、服务发现&#x2F;信息检索&#x2F;<br>定时任务&#x2F;MQ 等基础设施、稳定性保障、未来架构、语⾔前沿  </p>
<h2 id="跨语⾔学习者"><a href="#跨语⾔学习者" class="headerlink" title="跨语⾔学习者"></a>跨语⾔学习者</h2><h3 id="PHP-转-Go："><a href="#PHP-转-Go：" class="headerlink" title="PHP 转 Go："></a>PHP 转 Go：</h3><p>PHP-FPM 是多进程模型，FPM 内单线程执⾏。PHP 底层是 C 语⾔实现，整套系统难精通。⽐如我遇到过 PHP 底层的 bug，束⼿⽆策。<br>Go 从⽤户代码⼀直到底层都是 Go(会有⼀些汇编)，相对来说要从上层学到底层容易很多，不要有⼼理负担。<br>Go 代码是强类型语⾔的写法，分层之间有清晰的结构体定义，⼤项⽬好维护。  </p>
<h3 id="Python-转-Go："><a href="#Python-转-Go：" class="headerlink" title="Python 转 Go："></a>Python 转 Go：</h3><p>Python 转 Go 同样也是⼀个趋势，Python 底层是 C 实现，想把整套系统学精通有⼀定难度。<br>在线系统中 Go 的性能要⽐ Python 好很多。<br>因为强类型的写法，Go 代码要⽐ Python 好维护。  </p>
<h2 id="⼯程师的学习与进步"><a href="#⼯程师的学习与进步" class="headerlink" title="⼯程师的学习与进步"></a>⼯程师的学习与进步</h2><p>多写代码，积累代码量(⾄少积累⼏⼗万的代码量，才能对设计有⾃⼰的观点)，要总结和思考，如何对过去的⼯作进⾏改进(如⾃动化&#x2F;系统化)；积累⾃⼰的代码库、笔记库、开源项⽬。<br>读好书，建⽴知识体系(⽐如像 Designing Data-Intensive Application 这种书，应该读好多遍) 。<br>关注⼀些靠谱的国内外新闻源，通过问题出发，主动使⽤ Google，主动去 reddit、hackernews 上参与讨论，避免被困在信息茧房中。<br>锻炼⼝才和演讲能⼒，内部分享 -&gt; 外部分享。在公司内，该演要演，不要只是闷头⼲活。<br>通过输出促进输⼊(博客、公众号、分享)，打造个⼈品牌，通过读者的反馈循环提升⾃⼰的认知。<br>信息源：Github Trending、reddit、medium、hacker news，morning paper(作者不⼲了)，acm.org，oreily，国外的领域相关⼤会(如 OSDI，SOSP，VLDB)论⽂，国际⼀流公司的技术博客，YouTube 上的国外⼯程师演讲。  </p>
<h1 id="理解可执⾏⽂件"><a href="#理解可执⾏⽂件" class="headerlink" title="理解可执⾏⽂件"></a>理解可执⾏⽂件</h1><p>代码  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>$ go build hello.go</code>，可以看到生成的可执行文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ls</span><br><span class="line">hello  hello.go</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/go-builx-x.png">  </p>
<p>可执⾏⽂件在不同的操作系统上规范不⼀样，  </p>
<p>Linux：ELF<br>Windows：PE<br>MacOS：Mach-O  </p>
<p>Linux 的可执⾏⽂件 ELF(Executable and Linkable Format) 为例，ELF 由⼏部分构成：  </p>
<ul>
<li>ELF header  </li>
<li>Section header  </li>
<li>Sections</li>
</ul>
<p><a href="https://github.com/corkami/pics/blob/28cb0226093ed57b348723bc473cea0162dad366/binary/elf101/elf101.pdf">github-elf101</a>  </p>
<p>操作系统执⾏可执⾏⽂件的步骤(以 linux 为例)：  </p>
<p>解析<code>ELF header</code> -&gt; 加载⽂件内容⾄内存 -&gt; 从<code>entry point</code>开始执⾏代码。  </p>
<p>通过 entry point 找到 Go 进程的执⾏⼊⼝，使⽤ readelf：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/entry-point.png">  </p>
<h1 id="Go-进程的启动与初始化"><a href="#Go-进程的启动与初始化" class="headerlink" title="Go 进程的启动与初始化"></a>Go 进程的启动与初始化</h1><h2 id="计算机是怎么执⾏我们的程序的呢？"><a href="#计算机是怎么执⾏我们的程序的呢？" class="headerlink" title="计算机是怎么执⾏我们的程序的呢？"></a>计算机是怎么执⾏我们的程序的呢？</h2><p>CPU ⽆法理解⽂本，只能执⾏⼀条⼀条的⼆进制机器码指令每次执⾏完⼀条指令，pc 寄存器就指向下⼀条继续执⾏。  </p>
<p>在 64 位平台上 pc 寄存器 &#x3D; rip。  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/pc.png">  </p>
<h2 id="Go-语⾔是⼀⻔有-runtime-的语⾔，那么-runtime-是什么？"><a href="#Go-语⾔是⼀⻔有-runtime-的语⾔，那么-runtime-是什么？" class="headerlink" title="Go 语⾔是⼀⻔有 runtime 的语⾔，那么 runtime 是什么？"></a>Go 语⾔是⼀⻔有 runtime 的语⾔，那么 runtime 是什么？</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/go-runtime.png">  </p>
<p>可以认为 runtime 是为了实现额外的功能，⽽在程序运⾏时⾃动加载&#x2F;运⾏的⼀些模块。  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/go-exec.png">  </p>
<p>Go 语⾔的 runtime 包括：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/snmg.png">  </p>
<p>这些模块中，最核⼼的就是 Scheduler，它负责串联所有的 runtime 流程。  </p>
<p>通过 entry point 找到 Go 进程的执⾏⼊⼝：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/runtime.png">  </p>
<p>m0: Go 程序启动后创建的第⼀个线程；  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/runtime-rt0.png">  </p>
<h1 id="调度组件与调度循环"><a href="#调度组件与调度循环" class="headerlink" title="调度组件与调度循环"></a>调度组件与调度循环</h1><h2 id="当我每次写下一个完整的helloworld的时候，到底发⽣了什么？"><a href="#当我每次写下一个完整的helloworld的时候，到底发⽣了什么？" class="headerlink" title="当我每次写下一个完整的helloworld的时候，到底发⽣了什么？"></a>当我每次写下一个完整的helloworld的时候，到底发⽣了什么？</h2><p>答：你其实是向 runtime 提交了⼀个计算任务。<code>func() &#123; xxxxx &#125; </code>⾥包裹的代码就是这个计算任务的内容。  </p>
<p>Go 的调度流程本质上是⼀个⽣产-消费流程  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/comsume2.png">  </p>
<h2 id="调度组件-go-func去了哪⾥？"><a href="#调度组件-go-func去了哪⾥？" class="headerlink" title="调度组件,go func去了哪⾥？"></a>调度组件,go func去了哪⾥？</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/diaodu.png">  </p>
<p>goroutine 的⽣产端：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/goroutine-product.png">  </p>
<p>goroutine 的消费端：  </p>
<p>M 执⾏调度循环时，必须与⼀个 P 绑定  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/go-comsu.png">  </p>
<p>Work stealing 就是说的 runqsteal -&gt; runqgrab 这个流程  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/go-comsu2.png">  </p>
<p>现在我们再来看看这些⽂字定义，是不是就很好懂了：  </p>
<ul>
<li>G：goroutine，⼀个计算任务。由需要执⾏的代码和其上下⽂组成，上下⽂包括：当前代码位置，栈顶、栈底地址，状态等。  </li>
<li>M：machine，系统线程，执⾏实体，想要在 CPU 上执⾏代码，必须有线程，与 C 语⾔中的线程相同，通过系统调⽤ clone 来创建。  </li>
<li>Processor，虚拟处理器，M 必须获得 P 才能执⾏代码，否则必须陷⼊休眠(后台监控线程除外)，你也可以将其理解为⼀种 token，有这个 token，才有在物理 CPU 核⼼上执⾏的权⼒。</li>
</ul>
<p>但是：<strong>仅仅能够处理正常情况是不⾏的，如果程序中有阻塞，那线程不就全被堵上了？</strong>  </p>
<h1 id="处理阻塞"><a href="#处理阻塞" class="headerlink" title="处理阻塞"></a>处理阻塞</h1><p>在线程发⽣阻塞的时候，会⽆限制地创建线程么？——并不会!!!例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//channel send</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//channel recv</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">//time sleep</span></span><br><span class="line">time.Sleep(time.Hour)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//net read</span></span><br><span class="line"><span class="keyword">var</span> c net.Conn</span><br><span class="line"><span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//data not ready,block here</span></span><br><span class="line">n,err := c.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//net write</span></span><br><span class="line"><span class="keyword">var</span> c net.Conn</span><br><span class="line"><span class="keyword">var</span> buf = []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//send buffer full,wirte blocked</span></span><br><span class="line">n,err := c.Write(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//no case ready,block</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;ch1 ready&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;ch2 ready&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l sync.RWMutex</span><br><span class="line"><span class="comment">//somebody already grab the lock</span></span><br><span class="line"><span class="comment">//block here</span></span><br><span class="line">l.Lock</span><br></pre></td></tr></table></figure>

<p>这些情况不会阻塞调度循环，⽽是会把 goroutine 挂起，所谓的挂起，其实让 g 先进某个数据结构，待 ready 后再继续执⾏，<strong>不会占⽤线程</strong>。这时候，线程会进⼊ schedule，继续消费队列，执⾏其它的 g  </p>
<p>各种情况：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/lock1.png">  </p>
<p>应⽤阻塞在锁上的情况：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/lock2.png">  </p>
<h2 id="为啥有的等待是-sudog，有的是-g"><a href="#为啥有的等待是-sudog，有的是-g" class="headerlink" title="为啥有的等待是 sudog，有的是 g?"></a>为啥有的等待是 sudog，有的是 g?</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/sudog.png">  </p>
<p>就是说⼀个 g 可能对应多个 sudog，⽐如⼀个 g 会同时 select 多个channel。  </p>
<p>前⾯这些都是能被 runtime 拦截到的阻塞，还有⼀些是 runtime ⽆法拦截的：  </p>
<p>CGO  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/cgo.png">  </p>
<p>&#x2F;&#x2F;sysnb: syscall nonblocking<br>&#x2F;&#x2F;sys: syscall blocking  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/syscall-blocking.png">  </p>
<p>在执⾏ c 代码，或者阻塞在 syscall 上时，必须占⽤⼀个线程。  </p>
<p>sysmon: system monitor，⾼优先级，在专有线程中执⾏，不需要绑定 P 就可以执⾏。  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/sm.png">  </p>
<h1 id="调度器的发展历史"><a href="#调度器的发展历史" class="headerlink" title="调度器的发展历史"></a>调度器的发展历史</h1><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/gmp-history.png">  </p>
<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="可执⾏⽂件-ELF："><a href="#可执⾏⽂件-ELF：" class="headerlink" title="可执⾏⽂件 ELF："></a>可执⾏⽂件 ELF：</h2><ul>
<li>使⽤ go build -x 观察编译和链接过程  </li>
<li>通过 readelf -H 中的 entry 找到程序⼊⼝  </li>
<li>在 dlv 调试器中 b *entry_addr 找到代码位置</li>
</ul>
<h2 id="启动流程："><a href="#启动流程：" class="headerlink" title="启动流程："></a>启动流程：</h2><p>处理参数 -&gt; 初始化内部数据结构 -&gt; 主线程 -&gt; 启动调度循环  </p>
<h2 id="Runtime-构成："><a href="#Runtime-构成：" class="headerlink" title="Runtime 构成："></a>Runtime 构成：</h2><p>Scheduler、Netpoll、内存管理、垃圾回收  </p>
<h2 id="GMP："><a href="#GMP：" class="headerlink" title="GMP："></a>GMP：</h2><ul>
<li>M，任务消费者；  </li>
<li>G，计算任务；  </li>
<li>P，可以使⽤ CPU 的 token</li>
</ul>
<h2 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h2><p>P 的本地 runnext 字段 -&gt; P 的 local run queue -&gt; global run queue，多级队列减少锁竞争  </p>
<h2 id="调度循环："><a href="#调度循环：" class="headerlink" title="调度循环："></a>调度循环：</h2><p>线程 M 在持有 P 的情况下不断消费运⾏队列中的 G 的过程。  </p>
<h2 id="处理阻塞："><a href="#处理阻塞：" class="headerlink" title="处理阻塞："></a>处理阻塞：</h2><ul>
<li>可以接管的阻塞：channel 收发，加锁，⽹络连接读&#x2F;写，select  </li>
<li>不可接管的阻塞：syscall，cgo，⻓时间运⾏需要剥离 P 执⾏</li>
</ul>
<h2 id="sysmon："><a href="#sysmon：" class="headerlink" title="sysmon："></a>sysmon：</h2><ul>
<li>⼀个后台⾼优先级循环，执⾏时不需要绑定任何的P  </li>
<li>负责：<br>（1）检查是否已经没有活动线程，如果是，则崩溃<br>（2）轮询 netpoll<br>（3）剥离在 syscall 上阻塞的 M 的P<br>（4）发信号，抢占已经执⾏时间过⻓的 G</li>
</ul>
<h1 id="与调度有关的常⻅问题"><a href="#与调度有关的常⻅问题" class="headerlink" title="与调度有关的常⻅问题"></a>与调度有关的常⻅问题</h1><h2 id="Goroutine-⽐-Thread-优势在哪？"><a href="#Goroutine-⽐-Thread-优势在哪？" class="headerlink" title="Goroutine ⽐ Thread 优势在哪？"></a>Goroutine ⽐ Thread 优势在哪？</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/goroutine-thread.png">  </p>
<h2 id="goroutine-的切换成本"><a href="#goroutine-的切换成本" class="headerlink" title="goroutine 的切换成本"></a>goroutine 的切换成本</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/gobuf.png">  </p>
<p>gobuf 描述⼀个 goroutine 所有现场，从⼀个 g 切换到另⼀个 g，只要把这⼏个现场字段保存下来，再把 g 往队列⾥⼀扔，m 就可以执⾏其它g了⽆需进⼊内核态。  </p>
<h2 id="⼀个⽆聊的输出顺序的问题"><a href="#⼀个⽆聊的输出顺序的问题" class="headerlink" title="⼀个⽆聊的输出顺序的问题"></a>⼀个⽆聊的输出顺序的问题</h2><h2 id="死循环导致进程-hang-死问题"><a href="#死循环导致进程-hang-死问题" class="headerlink" title="死循环导致进程 hang 死问题"></a>死循环导致进程 hang 死问题</h2><h2 id="与-GMP-有关的⼀些缺陷：创建的-M-正常情况下是⽆法被回收"><a href="#与-GMP-有关的⼀些缺陷：创建的-M-正常情况下是⽆法被回收" class="headerlink" title="与 GMP 有关的⼀些缺陷：创建的 M 正常情况下是⽆法被回收"></a>与 GMP 有关的⼀些缺陷：创建的 M 正常情况下是⽆法被回收</h2><h2 id="与-GMP-有关的⼀些缺陷：runtime-中有⼀个-allgs-数组所有创建过的-g-都会进该数组⼤⼩与-g-瞬时最⾼值相关"><a href="#与-GMP-有关的⼀些缺陷：runtime-中有⼀个-allgs-数组所有创建过的-g-都会进该数组⼤⼩与-g-瞬时最⾼值相关" class="headerlink" title="与 GMP 有关的⼀些缺陷：runtime 中有⼀个 allgs 数组所有创建过的 g 都会进该数组⼤⼩与 g 瞬时最⾼值相关"></a>与 GMP 有关的⼀些缺陷：runtime 中有⼀个 allgs 数组所有创建过的 g 都会进该数组⼤⼩与 g 瞬时最⾼值相关</h2><p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/gmp-pprof.png">  </p>
<h2 id="怎么在代码⾥找到这些阻塞场景的？"><a href="#怎么在代码⾥找到这些阻塞场景的？" class="headerlink" title="怎么在代码⾥找到这些阻塞场景的？"></a>怎么在代码⾥找到这些阻塞场景的？</h2><p>要知道 runtime 中可以接管的阻塞是通过 gopark&#x2F;goparkunlock 挂起和 goready 恢复的，那么我们只要找到 runtime.gopark 的调⽤⽅，就可以知道在哪些地⽅会被 runtime 接管了：  </p>
<p><img src="/2021/11/07/go-senior-engineer-1-how-does-the-go-program-run/gopark.png">  </p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="为什么-Go-语⾔适合现代的后端编程环境？"><a href="#为什么-Go-语⾔适合现代的后端编程环境？" class="headerlink" title="为什么 Go 语⾔适合现代的后端编程环境？"></a>为什么 Go 语⾔适合现代的后端编程环境？</h2><ul>
<li>服务类应⽤以 API 居多，IO 密集型，且⽹络 IO 最多</li>
<li>运⾏成本低，⽆ VM。⽹络连接数不多的情况下内存占⽤低。</li>
<li>强类型语⾔，易上⼿，易维护。</li>
</ul>
<h2 id="为什么适合基础设施？"><a href="#为什么适合基础设施？" class="headerlink" title="为什么适合基础设施？"></a>为什么适合基础设施？</h2><ul>
<li>k8s、etcd、istio、docker 已经证明了 Go 的能⼒</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/corkami/pics/blob/28cb0226093ed57b348723bc473cea0162dad366/binary/elf101/elf101.pdf">ELF ⽂件解析</a><br><a href="https://github.com/golang-design/history#scheduler">Go Scheduler 变更历史</a><br><a href="https://www.geeksforgeeks.org/golang-goroutine-vs-thread/">Goroutine vs Thread</a><br><a href="https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threa">Measuring context switching and memory overheads for Linux threads </a>  </p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第2课_语法背后的秘密</title>
    <url>/2021/11/08/go-senior-engineer-2-grammar-behind-secret/</url>
    <content><![CDATA[<h1 id="编译原理基础"><a href="#编译原理基础" class="headerlink" title="编译原理基础"></a>编译原理基础</h1><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><h3 id="下面两段程序，哪个快一些"><a href="#下面两段程序，哪个快一些" class="headerlink" title="下面两段程序，哪个快一些?"></a>下面两段程序，哪个快一些?</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b = person&#123;<span class="number">111</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a = &amp;b</span><br><span class="line">	<span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b = person&#123;<span class="number">111</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a = &amp;b</span><br><span class="line">	<span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换是啥原理"><a href="#类型转换是啥原理" class="headerlink" title="类型转换是啥原理?"></a>类型转换是啥原理?</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">var</span> b = []<span class="type">byte</span>(a)</span><br><span class="line">	<span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎么找make和new这些函数的具体实现"><a href="#怎么找make和new这些函数的具体实现" class="headerlink" title="怎么找make和new这些函数的具体实现?"></a>怎么找make和new这些函数的具体实现?</h3><h3 id="会员服务，给用户分等级"><a href="#会员服务，给用户分等级" class="headerlink" title="会员服务，给用户分等级"></a>会员服务，给用户分等级</h3><ul>
<li>初级会员，发帖数&gt;10；</li>
<li>中级会员，充值&gt;1000人民币；  </li>
<li>高级会员，发帖数&gt;100，充值&gt;10000人民币。</li>
</ul>
<p>如果项目数 &#x3D; 几百，每个项目都有自己的会员规则，怎么办？  </p>
<h3 id="封装统一的数值查询服务"><a href="#封装统一的数值查询服务" class="headerlink" title="封装统一的数值查询服务"></a>封装统一的数值查询服务</h3><p>用户提供查询条件，会经常变，代理去不同的模块查数据，外部模块没有统一的数据获取规范。  </p>
<p>每次我们的用户提了需求，我们就一定要写一遍代码吗？  </p>
<h3 id="公司想从Thrift切换到gRPC"><a href="#公司想从Thrift切换到gRPC" class="headerlink" title="公司想从Thrift切换到gRPC"></a>公司想从Thrift切换到gRPC</h3><p>已经有了大量的Thrift IDL，想提供gRPC接口，手工把Thrift IDL抄写成pb文件效率太低，怎么办？  </p>
<h3 id="SQL审计"><a href="#SQL审计" class="headerlink" title="SQL审计"></a>SQL审计</h3><p>我是SQL专家，我知道怎么获取到表的索引，我可以把用户代码里的SQL扫描出来…<br>我想在上线的时候能自动做一些拦截，提醒用户去给表加索引，怎么办？  </p>
<h3 id="公司卖出去的服务软件，客户要自己定制，但不想给客户源码"><a href="#公司卖出去的服务软件，客户要自己定制，但不想给客户源码" class="headerlink" title="公司卖出去的服务软件，客户要自己定制，但不想给客户源码"></a>公司卖出去的服务软件，客户要自己定制，但不想给客户源码</h3><p>要支持客户写的扩展代码能在我们的模块上运行。  </p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/by-process.png">  </p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="number">1</span> + <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/lexical-analysis.png">  </p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/syntax-analysis.png">  </p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/semantic-analysis.png">  </p>
<p>在抽象语法树AST上做类型检查  </p>
<h2 id="中间代码-SSA-生成与优化"><a href="#中间代码-SSA-生成与优化" class="headerlink" title="中间代码(SSA)生成与优化"></a>中间代码(SSA)生成与优化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="number">8</span></span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">4</span> + b*c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/ssa.png">  </p>
<p>SSA的两大要点：  </p>
<ul>
<li>Static：每个变量只能赋值一次；  </li>
<li>Single：每个表达式只能做一个简单运算，对于复杂的表达式<code>a*b+c*d</code>要拆分成图片里的形式。</li>
</ul>
<h2 id="机器码生成"><a href="#机器码生成" class="headerlink" title="机器码生成"></a>机器码生成</h2><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/mcode.png">  </p>
<h2 id="虚拟地址重定位"><a href="#虚拟地址重定位" class="headerlink" title="虚拟地址重定位"></a>虚拟地址重定位</h2><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/relocation.png">  </p>
<h1 id="编译与反编译⼯具"><a href="#编译与反编译⼯具" class="headerlink" title="编译与反编译⼯具"></a>编译与反编译⼯具</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">var</span> b = []<span class="type">byte</span>(a)</span><br><span class="line">	<span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行输入<code>go tool compile -S ./hello.go | grep &quot;hello.go:5&quot;</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.main STEXT size=109 args=0x0 locals=0x58 funcid=0x0</span><br><span class="line">        0x0000 00000 (./hello.go:3)     TEXT    &quot;&quot;.main(SB), ABIInternal, $88-0</span><br><span class="line">        0x0000 00000 (./hello.go:3)     CMPQ    SP, 16(R14)</span><br><span class="line">        0x0004 00004 (./hello.go:3)     PCDATA  $0, $-2</span><br><span class="line">        0x0004 00004 (./hello.go:3)     JLS     102</span><br><span class="line">        0x0006 00006 (./hello.go:3)     PCDATA  $0, $-1</span><br><span class="line">        0x0006 00006 (./hello.go:3)     SUBQ    $88, SP</span><br><span class="line">        0x000a 00010 (./hello.go:3)     MOVQ    BP, 80(SP)</span><br><span class="line">        0x000f 00015 (./hello.go:3)     LEAQ    80(SP), BP</span><br><span class="line">        0x0014 00020 (./hello.go:3)     FUNCDATA        $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">        0x0014 00020 (./hello.go:3)     FUNCDATA        $1, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)</span><br><span class="line">        0x0014 00020 (./hello.go:5)     LEAQ    &quot;&quot;..autotmp_2+40(SP), AX</span><br><span class="line">        0x0019 00025 (./hello.go:5)     LEAQ    go.string.&quot;hello&quot;(SB), BX</span><br><span class="line">        0x0020 00032 (./hello.go:5)     MOVL    $5, CX</span><br><span class="line">        0x0025 00037 (./hello.go:5)     PCDATA  $1, $0</span><br><span class="line">        0x0025 00037 (./hello.go:5)     CALL    runtime.stringtoslicebyte(SB)  #var b = []byte(a)</span><br><span class="line">        0x002a 00042 (./hello.go:6)     MOVQ    AX, &quot;&quot;.b.ptr+72(SP)</span><br><span class="line">        0x002f 00047 (./hello.go:6)     MOVQ    BX, &quot;&quot;.b.len+24(SP)</span><br><span class="line">        0x0034 00052 (./hello.go:6)     MOVQ    CX, &quot;&quot;.b.cap+32(SP)</span><br><span class="line">        0x0039 00057 (./hello.go:6)     PCDATA  $1, $1</span><br><span class="line">        0x0039 00057 (./hello.go:6)     CALL    runtime.printlock(SB)</span><br><span class="line">        0x003e 00062 (./hello.go:6)     MOVQ    &quot;&quot;.b.ptr+72(SP), AX</span><br><span class="line">        0x0043 00067 (./hello.go:6)     MOVQ    &quot;&quot;.b.len+24(SP), BX</span><br><span class="line">        0x0048 00072 (./hello.go:6)     MOVQ    &quot;&quot;.b.cap+32(SP), CX</span><br><span class="line">        0x004d 00077 (./hello.go:6)     PCDATA  $1, $0</span><br><span class="line">        0x004d 00077 (./hello.go:6)     CALL    runtime.printslice(SB)</span><br><span class="line">        0x0052 00082 (./hello.go:6)     CALL    runtime.printnl(SB)</span><br><span class="line">        0x0057 00087 (./hello.go:6)     CALL    runtime.printunlock(SB)</span><br><span class="line">        0x005c 00092 (./hello.go:7)     MOVQ    80(SP), BP</span><br><span class="line">        0x0061 00097 (./hello.go:7)     ADDQ    $88, SP</span><br><span class="line">        0x0065 00101 (./hello.go:7)     RET</span><br><span class="line">        0x0066 00102 (./hello.go:7)     NOP</span><br><span class="line">        0x0066 00102 (./hello.go:3)     PCDATA  $1, $-1</span><br><span class="line">        0x0066 00102 (./hello.go:3)     PCDATA  $0, $-2</span><br><span class="line">        0x0066 00102 (./hello.go:3)     CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">        0x006b 00107 (./hello.go:3)     PCDATA  $0, $-1</span><br><span class="line">        0x006b 00107 (./hello.go:3)     JMP     0</span><br><span class="line">        0x0000 49 3b 66 10 76 60 48 83 ec 58 48 89 6c 24 50 48  I;f.v`H..XH.l$PH</span><br><span class="line">        0x0010 8d 6c 24 50 48 8d 44 24 28 48 8d 1d 00 00 00 00  .l$PH.D$(H......</span><br><span class="line">        0x0020 b9 05 00 00 00 e8 00 00 00 00 48 89 44 24 48 48  ..........H.D$HH</span><br><span class="line">        0x0030 89 5c 24 18 48 89 4c 24 20 e8 00 00 00 00 48 8b  .\$.H.L$ .....H.</span><br><span class="line">        0x0040 44 24 48 48 8b 5c 24 18 48 8b 4c 24 20 e8 00 00  D$HH.\$.H.L$ ...</span><br><span class="line">        0x0050 00 00 e8 00 00 00 00 e8 00 00 00 00 48 8b 6c 24  ............H.l$</span><br><span class="line">        0x0060 50 48 83 c4 58 c3 e8 00 00 00 00 eb 93           PH..X........</span><br><span class="line">        rel 28+4 t=15 go.string.&quot;hello&quot;+0</span><br><span class="line">        rel 38+4 t=7 runtime.stringtoslicebyte+0</span><br><span class="line">        rel 58+4 t=7 runtime.printlock+0</span><br><span class="line">        rel 78+4 t=7 runtime.printslice+0</span><br><span class="line">        rel 83+4 t=7 runtime.printnl+0</span><br><span class="line">        rel 88+4 t=7 runtime.printunlock+0</span><br><span class="line">        rel 103+4 t=7 runtime.morestack_noctxt+0</span><br><span class="line">go.cuinfo.packagename. SDWARFCUINFO dupok size=0</span><br><span class="line">        0x0000 6d 61 69 6e                                      main</span><br><span class="line">&quot;&quot;..inittask SNOPTRDATA size=24</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00                          ........</span><br><span class="line">go.string.&quot;hello&quot; SRODATA dupok size=5</span><br><span class="line">        0x0000 68 65 6c 6c 6f                                   hello</span><br><span class="line">gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size=8</span><br><span class="line">        0x0000 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">gclocals·9fb7f0986f647f17cb53dda1484e0f7a SRODATA dupok size=10</span><br><span class="line">        0x0000 02 00 00 00 01 00 00 00 00 01                    ..........</span><br></pre></td></tr></table></figure>

<h1 id="使⽤调试⼯具"><a href="#使⽤调试⼯具" class="headerlink" title="使⽤调试⼯具"></a>使⽤调试⼯具</h1><p>调试汇编时，使用SI到JMP目标位置  </p>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/jmp.png">  </p>
<p>使用c(continue)从上一个断点到下一个断点  </p>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/c.png">  </p>
<p>用disass反汇编  </p>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/disass.png">  </p>
<p><a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">官方文档</a>  </p>
<h1 id="语法实现分析"><a href="#语法实现分析" class="headerlink" title="语法实现分析"></a>语法实现分析</h1><h2 id="go-func"><a href="#go-func" class="headerlink" title="go func"></a>go func</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/gofunc.png">  </p>
<h2 id="channel-send-amp-recv"><a href="#channel-send-amp-recv" class="headerlink" title="channel send &amp; recv"></a>channel send &amp; recv</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	a &lt;- <span class="number">666</span></span><br><span class="line"></span><br><span class="line">	x := &lt;-a</span><br><span class="line">	<span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/chansr.png">  </p>
<h2 id="非阻塞recv"><a href="#非阻塞recv" class="headerlink" title="非阻塞recv"></a>非阻塞recv</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">		<span class="keyword">default</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/fzsrecv.png">  </p>
<h2 id="找到这张图中所有报错的内部代码位置"><a href="#找到这张图中所有报错的内部代码位置" class="headerlink" title="找到这张图中所有报错的内部代码位置"></a>找到这张图中所有报错的内部代码位置</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go run hello.go </span><br><span class="line">panic: close of nil channel</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /home/neo/Code/go/src/test/hello.go:5 +0x1b</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/send-to-nil.png">  </p>
<h1 id="Parser-场景示例"><a href="#Parser-场景示例" class="headerlink" title="Parser 场景示例"></a>Parser 场景示例</h1><h2 id="内置AST工具"><a href="#内置AST工具" class="headerlink" title="内置AST工具"></a>内置AST工具</h2><h3 id="简单的规则引擎"><a href="#简单的规则引擎" class="headerlink" title="简单的规则引擎"></a>简单的规则引擎</h3><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/ast1.png">  </p>
<h3 id="从Go的注释到swagger"><a href="#从Go的注释到swagger" class="headerlink" title="从Go的注释到swagger"></a>从Go的注释到swagger</h3><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/ast2.png">  </p>
<h2 id="使用社区Parser"><a href="#使用社区Parser" class="headerlink" title="使用社区Parser"></a>使用社区Parser</h2><h3 id="从Thrift切换到gRPC"><a href="#从Thrift切换到gRPC" class="headerlink" title="从Thrift切换到gRPC"></a>从Thrift切换到gRPC</h3><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/thrift.png">  </p>
<h3 id="SQL审计-1"><a href="#SQL审计-1" class="headerlink" title="SQL审计"></a>SQL审计</h3><ul>
<li>Vitess  </li>
<li>PingCAP</li>
</ul>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/sql1.png">  </p>
<h3 id="统一数据接入服务"><a href="#统一数据接入服务" class="headerlink" title="统一数据接入服务"></a>统一数据接入服务</h3><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/sql2.png">  </p>
<h3 id="客户定制需求"><a href="#客户定制需求" class="headerlink" title="客户定制需求"></a>客户定制需求</h3><p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/xuqiu.png">  </p>
<h1 id="函数调⽤规约"><a href="#函数调⽤规约" class="headerlink" title="函数调⽤规约"></a>函数调⽤规约</h1><h2 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h2><p>为什么Go可以一个函数多个返回值  </p>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/funchello.png">  </p>
<p>局部变量，只要不逃逸，都在栈上分配空间。  </p>
<p>当我们调用其它函数时：  </p>
<p><img src="/2021/11/08/go-senior-engineer-2-grammar-behind-secret/callerBP.png" alt="callerBP">  </p>
<p>函数调用规约：  </p>
<ul>
<li>The order in which atomic parameters,or individual parts of a complex parameters,are allocated  </li>
<li>How parameters are passed(push on the stack,placed in registers,or a mix of both)  </li>
<li>Which registers the called function must preserve for the caller(also known as:callee-saved registers or non-volatile registers)  </li>
<li>How the task of preparing the stack for,and restoring after,a function call is divided between the caller and the callee.</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://dev.to/nakabonne/digging-deeper-into-the-analysis-of-go-code-31af">Go 的词法分析和语法&#x2F;语义分析过程</a><br><a href="https://www.tutorialspoint.com/compiler_design/compiler_design_phases_of_compiler.htm">编译器各阶段的简单介绍</a><br><a href="https://golearn.coding.net/p/gonggongbanji/files/all/DF9">Linkers and loaders，只看内部对 linker 的职责描述就⾏，不⽤看原理</a><br><a href="https://mp.weixin.qq.com/s/UhxFOQBpW8EUVpFvqH2tMg">SSA 的简单介绍(*只做了解)</a><br><a href="https://eli.thegreenplace.net/2019/go-compiler-internals-adding-a-new-statement-to-go-part-2/">⽼外的写的如何定制 Go 编译器，⾥⾯对 Go 的编译过程介绍更详细，SSA 也说明得很好，只做了解</a><br><a href="https://sitano.github.io/2018/03/18/howto-read-gossa/">如何阅读 go 的 SSA,难，只做了解</a><br><a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/lectures/09-ssa.pdf">CMU 的编译器课，讲 SSA，难，只做了解 </a><br><a href="https://malwareunicorn.org/#/workshops">对逆向感兴趣的话扩展内容</a><br><a href="https://github.com/xwb1989/sqlparser">Vitess 的 SQL Parser</a><br><a href="https://github.com//pingcap/parser">PingCAP 的 TiDB 的 SQL Parser</a><br><a href="https://gocn.vip/topics/12090">GoCN 上的 dlv 的新译⽂</a><br>[C语⾔调⽤规约](<a href="https://github.com/cch123/llp-trans/blob/master/part3/translation-details/function-calling-sequence/calling%02convention.md">https://github.com/cch123/llp-trans/blob/master/part3/translation-details/function-calling-sequence/callingconvention.md</a>)<br><a href="https://go.googlesource.com/proposal/+/refs/changes/78/248178/1/design/40724-register-calling.md">Go 语⾔新版调⽤规约</a></p>
<h1 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h1><ul>
<li>C 语⾔的调⽤规约是寄存器与栈混合使⽤的，Go 语⾔⽬前只使⽤了栈(1.17 中会有⽤上寄存器的新⽅式)</li>
<li>有⼀些⽐较奇怪的问题，可以⽤<code>SSA</code>的⽹⻚来看到底是哪个阶段导致的，⽐如：<a href="https://xargin.com/addr-of-empty-struct-may-not%02eq/%EF%BC%8C%E5%AF%B9%E4%BA%8E%E2%BC%A4%E5%A4%9A%E6%95%B0">https://xargin.com/addr-of-empty-struct-may-noteq/，对于⼤多数</a> Gopher 只要知道这件事情是优化阶段⼲的就可以了，不需要研究明⽩优化每个阶段都在⼲什么</li>
<li>Go 语⾔的参数和返回值都是 caller 提供空间，在<code>callee</code>中需要根据<code>FP</code>寄存器找到位置，需要⼀定的汇编知识。</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第3课_神奇的内置数据结构</title>
    <url>/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/</url>
    <content><![CDATA[<h1 id="内置数据结构⼀览"><a href="#内置数据结构⼀览" class="headerlink" title="内置数据结构⼀览"></a>内置数据结构⼀览</h1><p>Too easy:<br><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/container.png"></p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/runtime.png">  </p>
<p>Concurrent programming will cover this:<br><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/sync.png">  </p>
<p>Netpoll will cover this:<br><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/netpoll.png">  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/memory.png">  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/os.png">    </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/context.png">  </p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p><a href="https://www.figma.com/proto/vfhlrTqsKicCO5ZbQZXgD4/runtime-structs?page-id=24:0&node-id=25:2&viewport=220,260,0.04483279958367348&scaling=contain">基本执行流程</a>  </p>
<h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/chan_send.png">  </p>
<h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/chan_recv.png">  </p>
<h2 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEVGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">charecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEVGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chansend、chanrecv、closechan 都是要加锁的  </p>
<h2 id="挂起与唤醒"><a href="#挂起与唤醒" class="headerlink" title="挂起与唤醒"></a>挂起与唤醒</h2><ul>
<li>Sender 挂起，⼀定是由 receiver(或 close) 唤醒  </li>
<li>Receiver 挂起，⼀定是由 sender(或 close)唤醒</li>
</ul>
<p>在第⼀课时，我们提到过可接管的阻塞，均是由 gopark 挂起，每⼀个 gopark 都会对应⼀个唤醒⽅。  </p>
<p>与 gopark 其对应的 goready 位置为：  </p>
<ul>
<li>channel send -&gt; channel recv&#x2F;close  </li>
<li>Lock -&gt; Unlock  </li>
<li>Read -&gt; Read Ready，epoll_wait 返回了该 fd 事件时  </li>
<li>Timer -&gt; checkTimers，检查到期唤醒</li>
</ul>
<p>可以⽤与之前类似的办法找 goready 的所有调⽤⽅<br><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/goready.png">  </p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><h2 id="四叉堆"><a href="#四叉堆" class="headerlink" title="四叉堆"></a>四叉堆</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/four-fork-heap.png">  </p>
<p><a href="https://github.com/golang/go/issues/15133">https://github.com/golang/go/issues/15133</a>  </p>
<h2 id="多个四叉堆"><a href="#多个四叉堆" class="headerlink" title="多个四叉堆"></a>多个四叉堆</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/n-four-fork-heap.png">  </p>
<p>CPU 密集计算任务会导致 timer 唤醒延迟  </p>
<h2 id="在-schedule-中检查-timer"><a href="#在-schedule-中检查-timer" class="headerlink" title="在 schedule 中检查 timer"></a>在 schedule 中检查 timer</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/schedule-timer.png">  </p>
<h2 id="Timer-1-14"><a href="#Timer-1-14" class="headerlink" title="Timer 1.14"></a>Timer 1.14</h2><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><ul>
<li>Timer heap 和 GMP 中的 P 绑定  </li>
<li>去除唤醒 goroutine: timerpro</li>
</ul>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><ul>
<li>检查 timer 到期在特殊函数 checkTimers 中进⾏  </li>
<li>检查 timer 操作移⾄调度循环中进⾏</li>
</ul>
<h3 id="⼯作窃取"><a href="#⼯作窃取" class="headerlink" title="⼯作窃取"></a>⼯作窃取</h3><ul>
<li>在 work-stealing 中，会从其它 P 那⾥偷 time</li>
</ul>
<h3 id="兜底"><a href="#兜底" class="headerlink" title="兜底"></a>兜底</h3><ul>
<li>runtime.sysmon 中会为 timer 未被触发(timeSleepUntil)兜底，启动新线程</li>
</ul>
<h2 id="偷-timer"><a href="#偷-timer" class="headerlink" title="偷 timer"></a>偷 timer</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/tou-timer.png">  </p>
<h2 id="runtime-sysmon-兜底"><a href="#runtime-sysmon-兜底" class="headerlink" title="runtime.sysmon 兜底"></a>runtime.sysmon 兜底</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/runtime_sysmon.png">  </p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="特权语法"><a href="#特权语法" class="headerlink" title="特权语法"></a>特权语法</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/map-grammer.png">  </p>
<h2 id="函数一览"><a href="#函数一览" class="headerlink" title="函数一览"></a>函数一览</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/map-func.png">  </p>
<p>map 中⼤量类似但⼜冗余的函数，原因之⼀便是没有泛型。  </p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/map-struct.png">  </p>
<h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><p>mapaccess<br>mapassign<br>mapdelete  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/map-ele-op.png">  </p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>• 触发：mapassign<br>• 时机：load factor 过⼤ || overflow bucket 过多<br>• 搬运过程是渐进进⾏的</p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/map-expansion.png">  </p>
<p><a href="https://www.figma.com/proto/vfhlrTqsKicCO5ZbQZXgD4/runtime-structs?page-id=30:3&node-id=111:371&viewport=210,399,0.18890097737312317&scaling=min-zoom">Grow animation</a>  </p>
<h3 id="元素操作-扩容中"><a href="#元素操作-扩容中" class="headerlink" title="元素操作-扩容中"></a>元素操作-扩容中</h3><p>• mapasssign：将命中的 bucket 从 oldbuckets 顺⼿搬运到<br>buckets 中，顺便再多搬运⼀个 bucket<br>• mapdelete：将命中的 bucket 从 oldbuckets 顺⼿搬运到<br>buckets 中，顺便再多搬运⼀个 bucket<br>• mapaccess: 优先在 oldbuckets 中找，如果命中，则说明这<br>个 bucket 没有被搬运</p>
<p>搬运 bucket x 时，会被该桶的 overflow 桶也⼀并搬完  </p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><a href="https://www.figma.com/proto/vfhlrTqsKicCO5ZbQZXgD4/runtime-structs?page-id=116:367&node-id=116:368&viewport=56,370,0.026418309658765793&scaling=min-zoom">map的遍历</a>  </p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>• 已经扩容的 map，⽆法收缩<br>• 保证并发安全时，要⼿动读写锁，易出错<br>• 多核⼼下表现差<br>• 难以使⽤ sync.Pool 进⾏重⽤</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/context2.png">  </p>
<p>• emptyCtx，所有 ctx 类型的根<br>• valueCtx，主要就是为了在 ctx 中嵌⼊上下⽂数据，⼀个简单的 k 和 v结构，同⼀个 ctx 内只⽀持⼀对 kv，需要更多的 kv 的话，会形成⼀棵树形结构。<br>• cancelCtx，⽤来取消程序的执⾏树<br>• timerCtx，在 cancelCtx 上包了⼀层，⽀持基于时间的 cancel  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/emptyCtx.png">  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/emptyCtx2.png">  </p>
<p>树形结构  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/ctx_tree.png">  </p>
<p>⽗节点取消时，可以传导到所有⼦节点  </p>
<p><img src="/2021/11/09/go-senior-engineer-3-amazing-built-in-data-structure/ectx.png">  </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/cch123/golang-notes/blob/master/context.md">Context</a><br><a href="https://github.com/cch123/golang-notes/blob/master/timer.md">⽼版本的 timer 实现</a><br><a href="http://xiaorui.cc/archives/6483">1.14 timer 性能提升分析</a><br><a href="https://speakerdeck.com/kavya719/understanding-channels">这位⼩姐姐的 PPT 还是做的不错的，有⼀些本节课未覆盖到的细节</a><br><a href="https://www.jianshu.com/p/f38cd8c99f70">DPVS 时间轮</a><br><a href="https://www.infoq.cn/article/erdajpj5epir65iczxzi">Kafka 时间轮</a>  </p>
<h1 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h1><h2 id="本节未涉及的内容："><a href="#本节未涉及的内容：" class="headerlink" title="本节未涉及的内容："></a>本节未涉及的内容：</h2><ul>
<li>Slice 的实现</li>
<li>String 的实现</li>
<li>Interface 的实现</li>
<li>select 的实现</li>
<li>Select 和多个 channel 结合时的代码执⾏逻辑</li>
<li>Map 在遍历时，正在扩容(growing)的 bucket 选择顺序，动画中省略掉了</li>
<li>Map 的 fat 后缀函数的编译器翻译过程</li>
<li>Timer 与 netpoll 的协作过程</li>
<li>Value Context 的查找过程(和链表查找过程类似)</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第4课_编程语言与操作系统的桥梁</title>
    <url>/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/</url>
    <content><![CDATA[<h1 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>操作系统是资源的管理器，其管理的资源均进⾏了抽象。  </p>
<p>磁盘抽象：⽂件夹<br>内存抽象：虚拟内存<br>CPU 抽象：时间⽚  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/os.png">  </p>
<h2 id="分级保护域-protection-ring"><a href="#分级保护域-protection-ring" class="headerlink" title="分级保护域-protection ring"></a>分级保护域-protection ring</h2><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/protecting-ring.png">  </p>
<p>CPU 为操作系统提供了特殊的安全⽀持<br>操作系统内核运⾏在特殊模式下，即图中的 ring-0<br>应⽤运⾏在 ring-3，权限被严格限制  </p>
<p>Intel 64 有四个特权级别，不过实际上只⽤到了其中的两个：ring-0 和 ring-3<br>ring-1 ring-2本来计划是为驱动程序和 OS 服务⽤，不过流⾏的 OS 们都没有接受这个⽅案。  </p>
<h2 id="什么是系统调⽤"><a href="#什么是系统调⽤" class="headerlink" title="什么是系统调⽤"></a>什么是系统调⽤</h2><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/osapp.png">  </p>
<p>系统调⽤是操作系统内核为应⽤提供的 API<br>是内核为应⽤提供的服务<br>操作系统为上层的应⽤程序提供了⼀个“标准库”<br>对于应⽤来说，系统调⽤可以实现超出⾃⼰能⼒以外的事情  </p>
<p>回忆⼀下之前讲的调⽤规约，Go 语⾔调⽤规约中<strong>未使⽤寄存器</strong>  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/callerBSP.png">  </p>
<p>寄存器：CPU内部的特殊存储单元：  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/ALU.png">  </p>
<p><a href="https://github.com/cch123/llp-trans/blob/master/part1/basic-computer-architecture/registers.md">registers</a>  </p>
<p>系统调⽤有⾃⼰的⼀套调⽤规约，需要使⽤寄存器和<code>C</code>语⾔的调⽤规约相似  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/arch.png">  </p>
<p><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit">syscalls.md#x86_64-64_bit</a>  </p>
<p>系统调⽤举例：  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/systemcall-example.png"><br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/systemcall-example2.png">  </p>
<h2 id="SYSCALL-之后发⽣了什么"><a href="#SYSCALL-之后发⽣了什么" class="headerlink" title="SYSCALL 之后发⽣了什么"></a>SYSCALL 之后发⽣了什么</h2><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/syscall-back.png">  </p>
<h2 id="怎么样找到内核⾥的代码"><a href="#怎么样找到内核⾥的代码" class="headerlink" title="怎么样找到内核⾥的代码"></a>怎么样找到内核⾥的代码</h2><p><a href="https://code.woboq.org/linux/linux/fs/eventpoll.c.html#do_epoll_create">do_epoll_create</a>  </p>
<p>应⽤层的开发同学不需要继续向下研究了，基础设施同学可以看看内核的内部实现。  </p>
<h1 id="常见的系统调用"><a href="#常见的系统调用" class="headerlink" title="常见的系统调用"></a>常见的系统调用</h1><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/getpid.png"><br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/pw.png"><br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/clone.png"><br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/tsc.png">  </p>
<h1 id="观察系统调用"><a href="#观察系统调用" class="headerlink" title="观察系统调用"></a>观察系统调用</h1><p>strace on linux<br>dtruss on macOS<br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/linux-macos.png">  </p>
<p>看看 nginx 这种软件阻塞的时候到底是阻塞在哪⾥:<br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/nginx.png"><br>docker 中使⽤ strace 时，要 <a href="https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/">https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/</a>  </p>
<p>查看⼀个 Go 语⾔的 hello world 程序⽣命周期内的系统调⽤统计:<br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/hw.png">  </p>
<p>strace 的实现依赖了 ptrace 这个 syscall<br>调试器(如 delve)也是⼤量使⽤了 ptrace<br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/ptrace.png">  </p>
<h1 id="Go语言中的系统调用"><a href="#Go语言中的系统调用" class="headerlink" title="Go语言中的系统调用"></a>Go语言中的系统调用</h1><h2 id="阻塞和⾮阻塞的系统调⽤"><a href="#阻塞和⾮阻塞的系统调⽤" class="headerlink" title="阻塞和⾮阻塞的系统调⽤"></a>阻塞和⾮阻塞的系统调⽤</h2><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/block.png">  </p>
<h2 id="Syscall-相关代码的基本结构"><a href="#Syscall-相关代码的基本结构" class="headerlink" title="Syscall 相关代码的基本结构"></a>Syscall 相关代码的基本结构</h2><p>OS 相关的基础⽂件，在 syscall package 中：<br><a href="https://golang.org/src/syscall/syscall_linux.go">https://golang.org/src/syscall/syscall_linux.go</a>  </p>
<p>使⽤脚本⽣成的⽂件，在 syscall package 中：<br><a href="https://golang.org/src/syscall/zsyscall_linux_386.go">https://golang.org/src/syscall/zsyscall_linux_386.go</a>  </p>
<p>不对⽤户暴露的特殊 syscall，不受调度影响，在 runtime 中：<br><a href="https://golang.org/src/runtime/sys_linux_amd64.s">https://golang.org/src/runtime/sys_linux_amd64.s</a>  </p>
<p>阻塞的系统调⽤需要修改 P 的状态：running -&gt; syscall。这样在 sysmon 中才能发现这个 P 已经在 syscall 状态阻塞了<br><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/sysmonP.png">  </p>
<p><a href="https://www.figma.com/proto/ounOboEYjlzBwcOhPgE2Z5/syscall?page-id=11:2&amp;node-id=11:3&amp;viewport=35,425,0.3724002540111542&amp;scaling=contain">https://www.figma.com/proto/ounOboEYjlzBwcOhPgE2Z5/syscall?page-id=11%3A2&amp;node-id=11%3A3&amp;viewport=35%2C425%2C0.3724002540111542&amp;scaling=contain</a>  </p>
<h2 id="VDSO-优化"><a href="#VDSO-优化" class="headerlink" title="VDSO 优化"></a>VDSO 优化</h2><p>内核负责，⾃动映射值到⽤户地址空间，⽆需⽤户&#x2F;内核态切换  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/vDSO.png">  </p>
<p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/VSDO.png">  </p>
<h1 id="系统调用发展历史"><a href="#系统调用发展历史" class="headerlink" title="系统调用发展历史"></a>系统调用发展历史</h1><p><img src="/2021/11/10/go-senior-engineer-4-bridge-between-pl-and-os/sysch.png">  </p>
<h1 id="学习系统调用"><a href="#学习系统调用" class="headerlink" title="学习系统调用"></a>学习系统调用</h1><p>这些知识到底有什么⽤？  </p>
<ul>
<li>了解操作系统与应⽤程序的边界  </li>
<li>了解内核升级导致应⽤程序⾏为变化的原因，如：madvdontneed 修改时，导致线上应⽤ RSS ⼤幅上升  </li>
<li>系统⽆响应时，观察系统是卡死在什么地⽅(也许根本没卡死，只是你的错觉)</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Ring 0 和 Ring 3:<br><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F</a><br><a href="https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-the-context-of-operating-systems">https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-the-context-of-operating-systems</a><br><a href="https://www.futurelearn.com/info/courses/computer-systems/0/steps/53514">https://www.futurelearn.com/info/courses/computer-systems/0/steps/53514</a>  </p>
<p><a href="https://github.com/cch123/llp-trans/blob/d6b7f46c72e83ac9145d5534c6bc4e690da8d815/part1/basic-computer-architecture/registers.md">寄存器的概念</a></p>
<p><a href="https://www.cs.montana.edu/courses/spring2005/518/Hypertextbook/jim/media/interrupts_on_linux.pdf">硬件中断、软件中断</a><br><a href="https://reverseengineering.stackexchange.com/questions/16702/difference-between-int-0x80-and-syscall">Int 80 和 syscall 有什么区别</a><br><a href="https://stackoverflow.com/questions/15168822/intel-x86-vs-x64-system-call">为什么 sysenter&#x2F;syscall ⽐ int 80 开销⼩</a><br><a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/">这⼀篇把内核中的代码返回位置都说清楚了，不需要⾃⼰去翻代码了</a><br><a href="https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/">Strace 在 docker ⾥做实验时，可能要做⼀点配置</a>  </p>
<p>Anatomy of a system cal:<br><a href="https://lwn.net/Articles/604287/">https://lwn.net/Articles/604287/</a><br><a href="https://lwn.net/Articles/604515/">https://lwn.net/Articles/604515/</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">VDSO</a><br><a href="https://mp.weixin.qq.com/s/06SDQLzDprJf2AEaDnX-QQ">time.Now 的性能衰退，其中有讲到 vdso</a><br><a href="http://arkanis.de/weblog/2017-01-05-measurements-of-system-call-performance-and-overhead">vdso 和普通 syscall 的性能对⽐</a>  </p>
<h1 id="源码分析⽐赛的⼀点提示"><a href="#源码分析⽐赛的⼀点提示" class="headerlink" title="源码分析⽐赛的⼀点提示"></a>源码分析⽐赛的⼀点提示</h1><ul>
<li>spec 可以搜到类型的所有⽤法</li>
<li>编译&#x2F;反编译⼯具可以找到语法的内部实现</li>
<li>调试⼯具&#x2F;IDE 可以跟踪具体流程</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第5课_Go语⾔的内存管理与垃圾回收</title>
    <url>/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="发问"><a href="#发问" class="headerlink" title="发问"></a>发问</h2><h3 id="内存从哪⾥来？到哪里去？"><a href="#内存从哪⾥来？到哪里去？" class="headerlink" title="内存从哪⾥来？到哪里去？"></a>内存从哪⾥来？到哪里去？</h3><h3 id="标记对象从哪⾥来？到哪里去？"><a href="#标记对象从哪⾥来？到哪里去？" class="headerlink" title="标记对象从哪⾥来？到哪里去？"></a>标记对象从哪⾥来？到哪里去？</h3><h3 id="垃圾从哪⾥来？到哪里去？"><a href="#垃圾从哪⾥来？到哪里去？" class="headerlink" title="垃圾从哪⾥来？到哪里去？"></a>垃圾从哪⾥来？到哪里去？</h3><h2 id="栈上内存分配"><a href="#栈上内存分配" class="headerlink" title="栈上内存分配"></a>栈上内存分配</h2><p>栈分配，函数调⽤返回后，函数栈帧⾃动销毁(SP 下移)  </p>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=101:2&node-id=117:113&viewport=227,187,0.2501279413700104&scaling=contain">栈分配</a>  </p>
<h2 id="堆分配"><a href="#堆分配" class="headerlink" title="堆分配"></a>堆分配</h2><p>在 C 语⾔中，返回函数的局部变量会怎么样？  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>悬垂指针：Dangling pointer<br>可能触发：Segmentation fault!!!!  </p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>堆分配，在 Go 语⾔⾥，为什么我们不⽤担⼼ dangling pointer?  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10240</span>)</span><br><span class="line">    <span class="built_in">println</span>(m[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/escape.png">  </p>
<h2 id="逃逸分析探究"><a href="#逃逸分析探究" class="headerlink" title="逃逸分析探究"></a>逃逸分析探究</h2><p>如何找到所有逃逸分析的可能性:  </p>
<h3 id="⾼难度模式"><a href="#⾼难度模式" class="headerlink" title="⾼难度模式"></a>⾼难度模式</h3><p><code>cmd/compile/internal/gc/escape.go</code>  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/egao.png">  </p>
<h3 id="低难度模式"><a href="#低难度模式" class="headerlink" title="低难度模式"></a>低难度模式</h3><p><code>https://github.com/golang/go/tree/master/test</code>  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/edi.png">  </p>
<h2 id="内存管理中的⻆⾊"><a href="#内存管理中的⻆⾊" class="headerlink" title="内存管理中的⻆⾊"></a>内存管理中的⻆⾊</h2><p>内存需要分配，谁来分配：⾃动 allocator，⼿⼯分配;<br>内存需要回收，谁来回收：⾃动 collector，⼿⼯回收。  </p>
<p><strong>⾃动内存回收技术&#x3D;垃圾回收技术</strong>  </p>
<h2 id="内存管理中的三个⻆⾊"><a href="#内存管理中的三个⻆⾊" class="headerlink" title="内存管理中的三个⻆⾊"></a>内存管理中的三个⻆⾊</h2><ul>
<li>Mutator：fancy(花哨的) word for application，其实就是你写的应⽤程序，它会不断地修改对象的引⽤关系，即对象图。  </li>
<li>Allocator：内存分配器，负责管理从操作系统中分配出的内存空间，malloc 其实底层就有⼀个内存分配器的实现(glibc 中)，tcmalloc 是malloc 多线程改进版。Go 中的实现类似 tcmalloc。  </li>
<li>Collector：垃圾收集器，负责清理死对象，释放内存空间。</li>
</ul>
<p>Mutator、Allocator、Collector 概览：  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/mactor.png">  </p>
<h2 id="内存管理抽象"><a href="#内存管理抽象" class="headerlink" title="内存管理抽象"></a>内存管理抽象</h2><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/rrpn.png">  </p>
<p>每个操作系统都有相应的实现，如：<code>mem_linux.go,mem_windows.go</code><br>相关的抽象描述在 <code>runtime/malloc.go</code> 注释中  </p>
<h1 id="进程虚拟内存布局"><a href="#进程虚拟内存布局" class="headerlink" title="进程虚拟内存布局"></a>进程虚拟内存布局</h1><h2 id="内存的分配类型"><a href="#内存的分配类型" class="headerlink" title="内存的分配类型"></a>内存的分配类型</h2><p>进程虚拟内存分布：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/pvm.png">  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/pvm2.png">  </p>
<p>进程虚拟内存分布，多线程的情况：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/npvm.png">  </p>
<h1 id="Allocator基础"><a href="#Allocator基础" class="headerlink" title="Allocator基础"></a>Allocator基础</h1><ul>
<li>Bump&#x2F;Sequential Allocator  </li>
<li>Free List Allocator</li>
</ul>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=175:118&node-id=175:119&viewport=-7626,499,0.4998303949832916&scaling=contain">memory-management-and-and-garbage-collection</a>  </p>
<p>Free List Allocator 详解：  </p>
<ul>
<li>First-Fi  </li>
<li>Next-Fi  </li>
<li>Best-Fi  </li>
<li>Segregated-Fi</li>
</ul>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=233:21&node-id=233:22&viewport=-650,182,0.059255365282297134&scaling=min-zoom">memory-management-and-and-garbage-collection</a></p>
<h1 id="malloc实现"><a href="#malloc实现" class="headerlink" title="malloc实现"></a>malloc实现</h1><h2 id="Go-语⾔的栈内存管理"><a href="#Go-语⾔的栈内存管理" class="headerlink" title="Go 语⾔的栈内存管理"></a>Go 语⾔的栈内存管理</h2><p>当你执⾏ malloc 时：  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/malloc.png">  </p>
<ul>
<li>brk 只能通过调整 programbreak位置推动堆增⻓  </li>
<li>mmap 可以从任意未分配位置映射内存</li>
</ul>
<h2 id="内存的分配类型-1"><a href="#内存的分配类型-1" class="headerlink" title="内存的分配类型"></a>内存的分配类型</h2><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/mmtype1.png"><br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/mmtype2.png">  </p>
<h2 id="Go-语⾔内存分配"><a href="#Go-语⾔内存分配" class="headerlink" title="Go 语⾔内存分配"></a>Go 语⾔内存分配</h2><p>为什么⼈⾁管理内存不靠谱，复杂对象图维护时的 danglingpointer：  </p>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=175:16&node-id=175:17&viewport=-603,359,0.22722375392913818&scaling=min-zoom">memory-management-and-and-garbage-collection</a>  </p>
<h1 id="Go-语⾔内存分配-1"><a href="#Go-语⾔内存分配-1" class="headerlink" title="Go 语⾔内存分配"></a>Go 语⾔内存分配</h1><p>⽼版本，连续堆：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/oldmm.png">  </p>
<p>新版本，稀疏堆：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/newmm.png">  </p>
<p>申请稀疏堆时，我们该⽤ brk 还是 mmap?  </p>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=151:36&node-id=151:38&viewport=241,543,0.2360718995332718&scaling=contain">Heap grow</a>  </p>
<p>分配⼤⼩分类：  </p>
<ul>
<li>Tiny : size &lt; 16 bytes &amp;&amp; has no pointer(noscan)  </li>
<li>Small ：has pointer(scan) || (size &gt;&#x3D; 16 bytes &amp;&amp; size &lt;&#x3D; 32 KB)  </li>
<li>Large : size &gt; 32 KB</li>
</ul>
<p>内存分配器在 Go 语⾔中维护了⼀个多级结构：mcache -&gt; mcentral -&gt; mheap  </p>
<p>mcache：与 P 绑定，本地内存分配操作，不需要加锁。<br>mcentral：中⼼分配缓存，分配时需要上锁，不同 spanClass 使⽤不同的锁。<br>mheap：全局唯⼀，从 OS 申请内存，并修改其内存定义结构时，需要加锁，是个全局锁。  </p>
<p>sizeClass 分类(sizeClass &#x3D; spanClass &gt;&gt; 1)<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/sizeclass.png"><br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/sizeclass2.png">  </p>
<p>Class 0&#x2F;1 预留给 large 了  </p>
<h2 id="堆内存管理-内存分配"><a href="#堆内存管理-内存分配" class="headerlink" title="堆内存管理-内存分配"></a>堆内存管理-内存分配</h2><h3 id="Small-alloc"><a href="#Small-alloc" class="headerlink" title="Small alloc"></a>Small alloc</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/smalloc.png">  </p>
<h3 id="Large-alloc"><a href="#Large-alloc" class="headerlink" title="Large alloc"></a>Large alloc</h3><p>⼤对象分配会直接越过 mcache、mcentral，直接从 mheap进⾏相应数量的 page 分配。  </p>
<p>pageAlloc 结构经过多个版本的变化，从：freelist -&gt; treap -&gt; radix tree，查找时间复杂度越来越低，结构越来越复杂。  </p>
<h3 id="Refill-流程"><a href="#Refill-流程" class="headerlink" title="Refill 流程"></a>Refill 流程</h3><ul>
<li>本地 mcache 没有时触发(mcache.refill  </li>
<li>从 mcentral ⾥的 non-empty 链表中找(mcentral.cacheSpan  </li>
<li>尝试 sweep mcentral 的 empty，insert sweeped -&gt; non-empty(mcentral.cacheSpan  </li>
<li>增⻓ mcentral，尝试从 arena 获取内存(mcentral.grow  </li>
<li>arena 如果还是没有，向操作系统申请(mheap.alloc</li>
</ul>
<p>最终还是会将申请到的 mspan 放在 mcache 中。  </p>
<h3 id="数据结构总览"><a href="#数据结构总览" class="headerlink" title="数据结构总览"></a>数据结构总览</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/ds.png">  </p>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=146:0&node-id=165:0&viewport=-457,167,0.1964392513036728&scaling=contain">数据结构总览</a>  </p>
<h3 id="Bitmap-与-allocCache"><a href="#Bitmap-与-allocCache" class="headerlink" title="Bitmap 与 allocCache"></a>Bitmap 与 allocCache</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/bitmap-allocache.png">  </p>
<h1 id="垃圾回收基础"><a href="#垃圾回收基础" class="headerlink" title="垃圾回收基础"></a>垃圾回收基础</h1><h2 id="垃圾分类"><a href="#垃圾分类" class="headerlink" title="垃圾分类"></a>垃圾分类</h2><h3 id="语义垃圾-semantic-garbage"><a href="#语义垃圾-semantic-garbage" class="headerlink" title="语义垃圾(semantic garbage)"></a>语义垃圾(semantic garbage)</h3><p>有的被称作内存泄露语义垃圾指的是从语法上可达(可以通过局部、全局变量引⽤得到)的对象，但从语义上来讲他们是垃圾，垃圾回收器对此⽆能为⼒。  </p>
<h3 id="语法垃圾-syntactic-garbage"><a href="#语法垃圾-syntactic-garbage" class="headerlink" title="语法垃圾(syntactic garbage)"></a>语法垃圾(syntactic garbage)</h3><p>语法垃圾是讲那些从语法上⽆法到达的对象，这些才是垃圾收集器主要的收集⽬标。  </p>
<h2 id="语义垃圾"><a href="#语义垃圾" class="headerlink" title="语义垃圾"></a>语义垃圾</h2><p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=185:2&node-id=185:13&viewport=-45,330,0.1481591761112213&scaling=contain">语义垃圾(semantic garbage)</a>  </p>
<h2 id="语法垃圾"><a href="#语法垃圾" class="headerlink" title="语法垃圾"></a>语法垃圾</h2><p>语法垃圾(syntactic garbage)<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/sg.png">  </p>
<p>在 allocOnHeap 返回后，堆上的 a ⽆法访问，便成为了语法垃圾。  </p>
<h2 id="常⻅垃圾回收算法"><a href="#常⻅垃圾回收算法" class="headerlink" title="常⻅垃圾回收算法"></a>常⻅垃圾回收算法</h2><ul>
<li>引⽤计数(Reference Counting)：某个对象的根引⽤计数变为 0 时，其所有⼦节点均需被回收。  </li>
<li>标记压缩(Mark-Compact)：将存活对象移动到⼀起，解决内存碎⽚问题。  </li>
<li>复制算法(Copying)：将所有正在使⽤的对象从 From 复制到 To 空间，堆利⽤率只有⼀半。  </li>
<li>标记清扫(Mark-Sweep)：解决不了内存碎⽚问题。需要与能尽量避免内存碎⽚的分配器使⽤，如 tcmalloc。(&lt;— Go 在这⾥)</li>
</ul>
<p><a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">Visualizing Garbage Collection Algorithms </a>  </p>
<h1 id="Go-语⾔垃圾回收"><a href="#Go-语⾔垃圾回收" class="headerlink" title="Go 语⾔垃圾回收"></a>Go 语⾔垃圾回收</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/gcap.png">  </p>
<p>1.8 后通过混合 write barrier 消除了第⼆个 stw 中的 stack re-scan，stw 时间⼤⼤减少。  </p>
<p>新流程：  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/newgcp.png">  </p>
<h2 id="程序⼊⼝-amp-amp-触发点"><a href="#程序⼊⼝-amp-amp-触发点" class="headerlink" title="程序⼊⼝ &amp;&amp; 触发点"></a>程序⼊⼝ &amp;&amp; 触发点</h2><p>垃圾回收⼊⼝：gcStart  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/gcstart.png">  </p>
<h1 id="GC-标记流程"><a href="#GC-标记流程" class="headerlink" title="GC 标记流程"></a>GC 标记流程</h1><p>标记对象从哪⾥来？  </p>
<ul>
<li>gcMarkWorker  </li>
<li>Mark assist  </li>
<li>mutator write&#x2F;delete heap pointers</li>
</ul>
<p>标记对象到哪⾥去？  </p>
<ul>
<li><p>Work buffer<br>本地 work buffer &#x3D;&gt; p.gc<br>全局 work buffer &#x3D;&gt; runtime.work.ful  </p>
</li>
<li><p>Write barrier buffe<br>本地 write barrier buffer &#x3D;&gt; p.wbBuf</p>
</li>
</ul>
<h2 id="三⾊抽象"><a href="#三⾊抽象" class="headerlink" title="三⾊抽象"></a>三⾊抽象</h2><p>⿊：已经扫描完毕，⼦节点扫描完毕。(gcmarkbits &#x3D; 1，且在队列外。)<br>灰：已经扫描完毕，⼦节点未扫描完毕。(gcmarkbits &#x3D; 1, 在队列内)<br>⽩：未扫描，collector 不知道任何相关信息。  </p>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=0:1&node-id=2:38&viewport=124,371,0.11918419599533081&scaling=contain">基本流程</a>  </p>
<h2 id="⼀些问题"><a href="#⼀些问题" class="headerlink" title="⼀些问题"></a>⼀些问题</h2><h3 id="GC-时要注意的问题："><a href="#GC-时要注意的问题：" class="headerlink" title="GC 时要注意的问题："></a>GC 时要注意的问题：</h3><ul>
<li><ol>
<li>对象在标记过程中不能丢失</li>
</ol>
</li>
<li><ol start="2">
<li>Mark 阶段 mutator 的指向堆的指针修改需要被记录下来</li>
</ol>
</li>
<li><ol start="3">
<li>GC Mark 的 CPU 控制要努⼒做到 25% 以内</li>
</ol>
</li>
</ul>
<h3 id="三⾊抽象的问题，标记过程中对象漏标，导致被意外回收："><a href="#三⾊抽象的问题，标记过程中对象漏标，导致被意外回收：" class="headerlink" title="三⾊抽象的问题，标记过程中对象漏标，导致被意外回收："></a>三⾊抽象的问题，标记过程中对象漏标，导致被意外回收：</h3><p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collection?page-id=16:150&node-id=16:151&viewport=373,377,0.3335455358028412&scaling=contain">memory-management-and-and-garbage-collection</a>  </p>
<h2 id="解决丢失问题的理论基础"><a href="#解决丢失问题的理论基础" class="headerlink" title="解决丢失问题的理论基础"></a>解决丢失问题的理论基础</h2><h3 id="强三⾊不变性-strong-tricolor-invariant"><a href="#强三⾊不变性-strong-tricolor-invariant" class="headerlink" title="强三⾊不变性(strong tricolor invariant)"></a>强三⾊不变性(strong tricolor invariant)</h3><p>禁⽌⿊⾊对象指向⽩⾊对象  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/sti.png">  </p>
<h3 id="弱三⾊不变性-weak-tricolor-invariant"><a href="#弱三⾊不变性-weak-tricolor-invariant" class="headerlink" title="弱三⾊不变性(weak tricolor invariant)"></a>弱三⾊不变性(weak tricolor invariant)</h3><p>⿊⾊对象指向的⽩⾊对象，如果有灰⾊对象到它的可达路径，那也可以  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/wti.png">  </p>
<h2 id="GC-标记流程-write-barrier"><a href="#GC-标记流程-write-barrier" class="headerlink" title="GC 标记流程-write barrier"></a>GC 标记流程-write barrier</h2><p>barrier 本质是 : snippet of code insert before pointer modify  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/barrier.png">  </p>
<p>这就是 writebarrier，是在指针修改前插⼊的⼀个函数调⽤。  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/barrier2.png">  </p>
<p>252行：指针修改。  </p>
<p>Dijkstra barrier：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/dib.png">  </p>
<p>Yuasa barrier：<br><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/yub.png">  </p>
<p>Slot 是 Go 代码⾥的被修改的指针对象<br>Ptr 是 Slot 要修改成的值  </p>
<p>问：如果我们在所有指针操作中都加上 Dijkstra barrier 或者 Yuasa barrier，就可以避免对象丢失了，为啥实际的实现没那么简单？<br>答:因为栈的操作频率极⾼，所以 Go 在栈上指针操作上是不加 barrier 的。  </p>
<p>因为 Go 的栈上的指针编辑不加 barrier，所以单独使⽤任意⼀种 barrier 都会有问题  </p>
<ul>
<li><p>Dijkstra 的问题<br>会出现栈上⿊指向堆上⽩的情况，该⽩⾊对象之前被堆上对象所指；  </p>
</li>
<li><p>Yuasa 的问题<br>会出现堆上⿊指向堆上⽩的情况，该⽩⾊对象之前被栈上某对象所指。</p>
</li>
</ul>
<h2 id="堆内存管理-write-barrier"><a href="#堆内存管理-write-barrier" class="headerlink" title="堆内存管理-write barrier"></a>堆内存管理-write barrier</h2><h3 id="Dijkstra-barrier"><a href="#Dijkstra-barrier" class="headerlink" title="Dijkstra barrier"></a>Dijkstra barrier</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/dib.png">  </p>
<p>优点：  </p>
<ul>
<li>能够保证堆上对象的强三⾊不变性(⽆栈对象参与时)  </li>
<li>能防⽌指针从栈被隐藏进堆(因为堆上新建的连接都会被着⾊)</li>
</ul>
<p>缺点：  </p>
<ul>
<li>不能防⽌栈上的⿊⾊对象指向堆上的⽩⾊对象(这个⽩⾊对象之前是被堆上的⿊&#x2F;灰指着的)</li>
<li>所以在 mark 结束后需要 stw重新扫描所有 goroutine 栈</li>
</ul>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collectionpage-id=201%3A0&node-id=201%3A1&viewport=250%2C361%2C0.06411547213792801&scaling=contain">memory-management-and-and-garbage-collection</a>  </p>
<h3 id="Yuasa-barrier"><a href="#Yuasa-barrier" class="headerlink" title="Yuasa barrier"></a>Yuasa barrier</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/yub.png">  </p>
<p>优点：</p>
<ul>
<li>能够保证堆上的弱三⾊不变性(⽆栈对象参与时)</li>
<li>能防⽌指针从堆被隐藏进栈(因为堆上断开的连接都会被着⾊)</li>
</ul>
<p>缺点：  </p>
<ul>
<li>不能防⽌堆上的⿊⾊对象指向堆上的⽩⾊对象(这个⽩⾊对象之前是由栈的⿊&#x2F;灰⾊对象指着的)  </li>
<li>所以需要 GC 开始时 STW 对栈做快照</li>
</ul>
<p><a href="https://www.figma.com/proto/tSl3CoSWKitJtvIhqLd8Ek/memory-management-and-and-garbage-collectionpage-id=201%3A293&node-id=201%3A294&viewport=347%2C468%2C0.4064616858959198&scaling=contain">memory-management-and-and-garbage-collectionpage</a>  </p>
<h3 id="Hybrid-barrier"><a href="#Hybrid-barrier" class="headerlink" title="Hybrid barrier"></a>Hybrid barrier</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/hyb.png">  </p>
<h3 id="Reality-in-Go"><a href="#Reality-in-Go" class="headerlink" title="Reality in Go"></a>Reality in Go</h3><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/redl-in-go.png">  </p>
<p>Go 实际的混合写屏障：代码在 gcWriteBarrier汇编函数中：  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/gcwb.png">  </p>
<p>混合屏障会将指针(指向堆的)修改前指向的位置和修改后指向的位置都标灰。  </p>
<h2 id="垃圾回收代码流程"><a href="#垃圾回收代码流程" class="headerlink" title="垃圾回收代码流程"></a>垃圾回收代码流程</h2><ul>
<li>gcStart -&gt; gcBgMarkWorker &amp;&amp; gcRootPrepare，这时 gcBgMarkWorker 在休眠中  </li>
<li>schedule -&gt; findRunnableGCWorker 唤醒适宜数量的 gcBgMarkWorke  </li>
<li>gcBgMarkWorker -&gt; gcDrain -&gt; scanobject -&gt; greyobject(set mark bit and put to gcw  </li>
<li>在 gcBgMarkWorker 中调⽤ gcMarkDone 排空各种 wbBuf 后，使⽤分布式 termination检查算法，进⼊ gcMarkTermination -&gt; gcSweep 唤醒后台沉睡的 sweepg 和 scvg -&gt; sweep -&gt; wake bgsweep &amp;&amp; bgscavenge</li>
</ul>
<h2 id="堆内存管理-垃圾回收"><a href="#堆内存管理-垃圾回收" class="headerlink" title="堆内存管理-垃圾回收"></a>堆内存管理-垃圾回收</h2><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/sgobj.png">  </p>
<h2 id="堆内存管理-垃圾回收-CPU-使⽤控制"><a href="#堆内存管理-垃圾回收-CPU-使⽤控制" class="headerlink" title="堆内存管理-垃圾回收-CPU 使⽤控制"></a>堆内存管理-垃圾回收-CPU 使⽤控制</h2><ul>
<li>GC 的 CPU 控制⽬标是整体 25%  </li>
<li>当 P &#x3D; 4 * N 时，只要启动 N 个 worker 就可以。  </li>
<li>但 P ⽆法被 4 整除时，需要兼职的 gcMarkWorker 来帮助做⼀部分⼯作<br>全职 GC 员⼯：Dedicated worker，需要⼀直⼲活，直到被抢占。<br>兼职 GC 员⼯：Fractional worker，达到业绩⽬标(fractionalUtilizationGoal)时可以主动让出。<br>还有⼀种 IDLE 模式，在调度循环中发现找不到可执⾏的 g，但此时有标记任务未完成，就⽤开启 IDLE 模式去帮忙。</li>
</ul>
<p>Worker 运⾏模式在：<em>p</em>.gcMarkWorkerMode  </p>
<p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/gcpu.png">  </p>
<h2 id="Go-语⾔的栈内存管理-1"><a href="#Go-语⾔的栈内存管理-1" class="headerlink" title="Go 语⾔的栈内存管理"></a>Go 语⾔的栈内存管理</h2><p><img src="/2021/11/11/go-senior-engineer-5-gopl-memory-management-and-garbage-collection/gostack.png">  </p>
<p>栈本身的内存：newstack,shrinkstack  </p>
<p>使⽤ allocManual 和 freeManual 相当于⼿动管理内存，不计⼊ heap_inuse 和 heap_sys；计⼊ stackinuse 和 stacksys  </p>
<p>栈上变量的内存：SP 移动销毁，简单快速  </p>
<h1 id="sweep-流程-待补充"><a href="#sweep-流程-待补充" class="headerlink" title="sweep 流程(待补充)"></a>sweep 流程(待补充)</h1><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>memorymanagement.org<br><a href="https://my.eng.utah.edu/~cs4400/malloc.pdf">https://my.eng.utah.edu/~cs4400/malloc.pdf</a><br><a href="https://cboard.cprogramming.com/linux-programming/101090-what-differences-between-brk-mmap.html">https://cboard.cprogramming.com/linux-programming/101090-what-differences-between-brk-mmap.html</a><br><a href="https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05">https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05</a><br><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44</a><br><a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/</a><br><a href="https://golangpiter.com/system/attachments/files/000/001/718/original/GP_2019_-_An_Insight_Into_Go_Garbage_Collection.pdf?1572419303">https://golangpiter.com/system/attachments/files/000/001/718/original/GP_2019_-_An_Insight_Into_Go_Garbage_Collection.pdf?1572419303</a><br><a href="https://www.cnblogs.com/zkweb/p/7880099.html?utm_source=tuicool&amp;utm_medium=referral">https://www.cnblogs.com/zkweb/p/7880099.html?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md">https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md</a><br><a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a><br><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html</a><br><a href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#">https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#</a><br><a href="https://zhuanlan.zhihu.com/p/95056679">https://zhuanlan.zhihu.com/p/95056679</a>  </p>
<h1 id="未涉及"><a href="#未涉及" class="headerlink" title="未涉及"></a>未涉及</h1><p>Runtime 中 Not in heap 类对象的内存管理<br>Page alloc &amp;&amp; Page cach<br>Stack alloc &amp;&amp; persistentAllo<br>Tiny 分配时的 offset 对⻬逻辑<br>为防⽌⻓时间标记导致应⽤请求阻塞，引⼊的 oblet 概念<br>对象被回收时的 finalizer 执⾏逻辑<br>Fd 类内置数据结构的引⽤计数逻辑<br>Sweep 和 Scvg 流程未涉及</p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第6课_Go并发编程最佳实践</title>
    <url>/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/</url>
    <content><![CDATA[<h1 id="并发内置数据结构"><a href="#并发内置数据结构" class="headerlink" title="并发内置数据结构"></a>并发内置数据结构</h1><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>sync.Once 只有⼀个⽅法，Do()  </p>
<p>但 o.Do 需要保证：  </p>
<ul>
<li>初始化⽅法必须且只能被调⽤⼀次  </li>
<li>Do 返回后，初始化⼀定已经执⾏完成</li>
</ul>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-once.png">  </p>
<h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p>主要在两种场景使⽤：  </p>
<ul>
<li>进程中的 inuse_objects 数过多，gc mark 消耗⼤量 CPU</li>
<li>进程中的 inuse_objects 数过多，进程 RSS 占⽤过⾼</li>
</ul>
<p>请求⽣命周期开始时，pool.Get，请求结束时，pool.Put。在 fasthttp 中有⼤量应⽤  </p>
<p><a href="https://github.com/valyala/fasthttp/blob/b433ecfcbda586cd6afb80f41ae45082959dfa91/server.go#L402">https://github.com/valyala/fasthttp/blob/b433ecfcbda586cd6afb80f41ae45082959dfa91/server.go#L402</a>  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-pool.png">  </p>
<p>sync.Pool 发⽣ GC 时：  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-pool-gc.png">  </p>
<h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><p>是锁的实现基础，所有同步原语的基础设施。  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/semaphore.png">  </p>
<h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-mutex.png">  </p>
<h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-rwmutex.png">  </p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p><a href="https://www.figma.com/proto/FMzUIdkjm4BEHSpwWFecew/concurrency?page-id=6:15&amp;node-">https://www.figma.com/proto/FMzUIdkjm4BEHSpwWFecew/concurrency?page-id=6%3A15&amp;node-</a><br>id&#x3D;6%3A16&amp;viewport&#x3D;-46%2C368%2C0.5078045725822449&amp;scaling&#x3D;min-zoom  </p>
<h2 id="sync-Waitgroup"><a href="#sync-Waitgroup" class="headerlink" title="sync.Waitgroup"></a>sync.Waitgroup</h2><p>Counter 减到 0 时，要唤醒所有 sema 上阻塞的 sudog  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/sync-wg.png">  </p>
<h1 id="并发编程模式举例"><a href="#并发编程模式举例" class="headerlink" title="并发编程模式举例"></a>并发编程模式举例</h1><h2 id="CSP-和传统并发模式"><a href="#CSP-和传统并发模式" class="headerlink" title="CSP 和传统并发模式"></a>CSP 和传统并发模式</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/csp.png">  </p>
<h2 id="Fan-in，合并多个-channel-操作"><a href="#Fan-in，合并多个-channel-操作" class="headerlink" title="Fan-in，合并多个 channel 操作"></a>Fan-in，合并多个 channel 操作</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/fanin1.png">  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/fanin2.png">  </p>
<h2 id="Or-channel"><a href="#Or-channel" class="headerlink" title="Or channel"></a>Or channel</h2><p>任意 channel 返回<br>全部返回  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/orchan.png">  </p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>串联在⼀起的 channel  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/pipeline.png">  </p>
<h2 id="并发同时保序"><a href="#并发同时保序" class="headerlink" title="并发同时保序"></a>并发同时保序</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/con-sort.png">  </p>
<h1 id="常⻅的并发-bug"><a href="#常⻅的并发-bug" class="headerlink" title="常⻅的并发 bug"></a>常⻅的并发 bug</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="RWR-死锁"><a href="#RWR-死锁" class="headerlink" title="RWR 死锁"></a>RWR 死锁</h3><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/rwr-dead-lock.png">  </p>
<h3 id="循环等待死锁"><a href="#循环等待死锁" class="headerlink" title="循环等待死锁"></a>循环等待死锁</h3><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/loop-wait-dead-lock.png">  </p>
<p>注意：<strong>死锁问题需要通过 pprof 进⼊ goroutine ⻚⾯查看</strong>  </p>
<h2 id="Map-concurrent-writes-x2F-reads"><a href="#Map-concurrent-writes-x2F-reads" class="headerlink" title="Map concurrent writes&#x2F;reads"></a>Map concurrent writes&#x2F;reads</h2><p>崩溃时输出 stderr，请注意重定向你的 stderr 到单独的⽂件中  </p>
<h2 id="Channel-关闭-panic"><a href="#Channel-关闭-panic" class="headerlink" title="Channel 关闭 panic"></a>Channel 关闭 panic</h2><p>Channel closing principle  </p>
<ul>
<li><ol>
<li>M receivers, one sender, the sender says “no more sends” by closing the data channel</li>
</ol>
</li>
<li><ol start="2">
<li>One receiver, N senders, the only receiver says “please stop sending more” by closing an additional signal channel</li>
</ol>
</li>
<li><ol start="3">
<li>M receivers, N senders, any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel</li>
</ol>
</li>
</ul>
<p><a href="https://go101.org/article/channel-closing.html">go101.channel-closing</a>  </p>
<h2 id="fn-超时后，ch-lt-result-阻塞"><a href="#fn-超时后，ch-lt-result-阻塞" class="headerlink" title="fn() 超时后，ch &lt;- result 阻塞"></a>fn() 超时后，ch &lt;- result 阻塞</h2><p><code>goroutine</code>永久泄露  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/ch-result-block.png">  </p>
<h2 id="wait-group-使⽤不当，永久阻塞"><a href="#wait-group-使⽤不当，永久阻塞" class="headerlink" title="wait group 使⽤不当，永久阻塞"></a>wait group 使⽤不当，永久阻塞</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/wg-block.png">  </p>
<h2 id="context-WithCancel"><a href="#context-WithCancel" class="headerlink" title="context.WithCancel"></a>context.WithCancel</h2><p>内部启动 goroutine，在 ctx 被覆盖后泄露  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/ctx-cancel.png">  </p>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/dead-lock2.png">  </p>
<h2 id="闭包捕获本地变量"><a href="#闭包捕获本地变量" class="headerlink" title="闭包捕获本地变量"></a>闭包捕获本地变量</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/block-pkg.png">  </p>
<h2 id="启动goroutine前要保证Add完成"><a href="#启动goroutine前要保证Add完成" class="headerlink" title="启动goroutine前要保证Add完成"></a>启动goroutine前要保证Add完成</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/gadd.png">  </p>
<h2 id="并发操作-channel-时，多次关闭同⼀个-channel"><a href="#并发操作-channel-时，多次关闭同⼀个-channel" class="headerlink" title="并发操作 channel 时，多次关闭同⼀个 channel"></a>并发操作 channel 时，多次关闭同⼀个 channel</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/n-close-chan.png">  </p>
<h2 id="Fn-耗时很久，但进⼊之前没有判断外部给的stopCh-中的通知浪费算⼒"><a href="#Fn-耗时很久，但进⼊之前没有判断外部给的stopCh-中的通知浪费算⼒" class="headerlink" title="Fn 耗时很久，但进⼊之前没有判断外部给的stopCh 中的通知浪费算⼒"></a>Fn 耗时很久，但进⼊之前没有判断外部给的stopCh 中的通知浪费算⼒</h2><p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/fn-stop-chan.png">  </p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>对于应⽤开发的同学来说，只要记住，使⽤<strong>显式同步</strong>就可以保证正确性。  </p>
<p>现代计算机的多级存储结构<br>L1D cache ⼜会被划分为多个cache line，每个 cache line &#x3D; 64 bytes<br><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/caches-reduce-length-of-stalls.png">  </p>
<p><a href="http://15418.courses.cs.cmu.edu/spring2015/lecture/basicarch/slide_042">http://15418.courses.cs.cmu.edu/spring2015/lecture/basicarch/slide_042</a>  </p>
<p>L1 cache ⼜被划分为更细粒度的 cacheline，下⾯是在服务器上获取 L1 cache line size 的命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ getconf LEVEL1_DCACHE_LINESIZE</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/l1-cache-work.png">  </p>
<p>Runtime 中的 cacheline pad  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/pad.png">  </p>
<p><a href="http://15418.courses.cs.cmu.edu/spring2015/lecture/basicarch/slide_042">http://15418.courses.cs.cmu.edu/spring2015/lecture/basicarch/slide_042</a>  </p>
<p>多核⼼给我们带来的问题：  </p>
<ul>
<li>单变量的并发操作也必须⽤同步⼿段，⽐如 atomic  </li>
<li>全局视⻆下观察到的多变量读写的顺序可能会乱序</li>
</ul>
<p>单变量的原⼦读&#x2F;写，多核⼼使⽤ mesi 协议保证正确性<br><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/mesi-state-transition-diagram.png">  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/p-reads-x.png">  </p>
<p>Mesi 协议是以整个 cache line 为单位进⾏的  </p>
<p><a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm">https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm</a>  </p>
<p>多核⼼执⾏时，CPU 和编译器可能对读写指令进⾏重排，使⽤ Litmus 测试观察内存重排：  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/litmus1.png">  </p>
<p>检查两个核⼼的 EAX 是不是都为 0  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/litmus2.png">  </p>
<p><a href="https://github.com/herd/herdtools7">https://github.com/herd/herdtools7</a>  </p>
<p>False sharing：因为 CPU 处理读写是以 cache line 为单位，所以在并发修改变量时，会⼀次性将其它 CPU core 中的cache line invalidate 掉，导致未修改的内存上相邻的变量也需要同步，带来额外的性能负担。  </p>
<p>True sharing：多线程确实在共享并更新同⼀个变量&#x2F;内存区域。  </p>
<h2 id="Happen-before-到底是什么？"><a href="#Happen-before-到底是什么？" class="headerlink" title="Happen-before 到底是什么？"></a>Happen-before 到底是什么？</h2><p>同⼀个 goroutine 内的逻辑有依赖的语句执⾏，满⾜顺序关系。<br>编译器&#x2F;CPU 可能对同⼀个 goroutine 中的语句执⾏进⾏打乱，以提⾼性能，但不能破坏其应⽤原有的逻辑。<br>不同的 goroutine 观察到的共享变量的修改顺序可能不⼀样。  </p>
<p>初始化：<br>A pkg import B pkg，那么 B pkg 的 init 函数⼀定在 A pkg 的 init 函数之前执⾏。<br>Init 函数⼀定在 main.main 之前执⾏  </p>
<p>Goroutine 创建：<br>Goroutine 的创建(creation)⼀定先于 goroutine 的执⾏(execution)  </p>
<p>Goroutine 结束：<br>在没有显式同步的情况下，goroutine 的结束没有任何保证，可能被执⾏，也可能不被执⾏  </p>
<p>Channel 收&#x2F;发：<br>A send on a channel happens before the corresponding receive from that channel completes.  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/chan-recv-send.png">  </p>
<p>这⾥ c &lt;- 0 ⼀定先于 &lt;- c 执⾏完，所以 print ⼀定能打印出 hello world  </p>
<p>The closing of a channel happens before a receive that returns a zero value because the channel is closed.  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/happ-chan-close.png">  </p>
<p>close(c) ⼀定先于 &lt;-c 执⾏完，所以这⾥也可以保证打印出 hello world。  </p>
<p>Channel 收&#x2F;发：<br>A receive from an unbuffered channel happens before the send on that channel completes.  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/happ-chan-close2.png">  </p>
<p>⽆ buffer 的 chan receive 先于 send 执⾏完，这⾥也可以保证打印出 hello world  </p>
<p>Lock：For any sync.Mutex or sync.RWMutex variable l and n &lt; m, call n of l.Unlock() happens before call m of l.Lock()returns  </p>
<p>Unlock ⼀定先于 Lock 函数返回前执⾏完  </p>
<p>Once：A single call of f() from once.Do(f) happens (returns) before any call of once.Do(f) returns.  </p>
<p>本质是在⽤户不知道 memory barrier 概念和具体实现的前提下，能够按照官⽅提供的 happen-before 正确进⾏并发编程。  </p>
<h2 id="Memory-barrier"><a href="#Memory-barrier" class="headerlink" title="Memory barrier"></a>Memory barrier</h2><p>在并发编程中的 memory barrier 和 GC 中的 barrier 不是⼀回事。<br>Memory barrier 是为了防⽌各种类型的读写重排：  </p>
<p><img src="/2021/11/12/go-senior-engineer-6-go-concurrent-programming-practice/con-mb.png">  </p>
<p>⽽ GC 中的 read&#x2F;write barrier 则是指堆上指针修改之前插⼊的⼀⼩段代码。  </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://wudaijun.com/2018/02/go-sync-map-implement/">https://wudaijun.com/2018/02/go-sync-map-implement/</a><br><a href="https://github.com/kat-co/concurrency-in-go-src">https://github.com/kat-co/concurrency-in-go-src</a><br><a href="https://speakerdeck.com/kavya719/understanding-channels">https://speakerdeck.com/kavya719/understanding-channels</a><br><a href="https://www.zenlife.tk/concurrency-with-keep-order.md?hmsr=joyk.com&amp;utm_source=joyk.com&amp;utm_medium=referral">https://www.zenlife.tk/concurrency-with-keep-order.md?hmsr=joyk.com&amp;utm_source=joyk.com&amp;utm_medium=referral</a><br><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br><a href="https://www.hardwaretimes.com/difference-between-l1-l2-and-l3-cache-what-is-cpu-cache/">https://www.hardwaretimes.com/difference-between-l1-l2-and-l3-cache-what-is-cpu-cache/</a><br><a href="https://github.com/lotusirous/go-concurrency-patterns">https://github.com/lotusirous/go-concurrency-patterns</a><br><a href="https://songlh.github.io/paper/go-study.pdf">https://songlh.github.io/paper/go-study.pdf</a><br><a href="https://github.com/cch123/golang-notes/blob/master/memory_barrier.md">https://github.com/cch123/golang-notes/blob/master/memory_barrier.md</a>  </p>
<h1 id="未涉及"><a href="#未涉及" class="headerlink" title="未涉及"></a>未涉及</h1><ul>
<li>内置并发结构：sync.Cond  </li>
<li>进阶话题：如 acquire、release、sequential consistency。  </li>
<li>Lock-Free，Wait-free 等等  </li>
<li>扩展并发原语：SingleFlight，ErrGroup 等</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>编程模式</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第7课_社区优秀框架对⽐</title>
    <url>/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/</url>
    <content><![CDATA[<h1 id="常⻅-web-框架"><a href="#常⻅-web-框架" class="headerlink" title="常⻅ web 框架"></a>常⻅ web 框架</h1><h2 id="httprouter"><a href="#httprouter" class="headerlink" title="httprouter"></a><a href="https://github.com/julienschmidt/httprouter">httprouter</a></h2><ul>
<li>⼏乎是所有 Go web 框架的 router 实现的爸爸  </li>
<li>⼀个简单的 radix tree 的实现</li>
</ul>
<h2 id="chi"><a href="#chi" class="headerlink" title="chi"></a><a href="https://github.com/go-chi/chi">chi</a></h2><p>最简单的框架：  </p>
<ul>
<li>核⼼代码 1200 ⾏  </li>
<li>适合作为 web 框架⼊⻔项⽬  </li>
<li>在其基础上整合其它组件，⽅便</li>
</ul>
<p>主要组件：  </p>
<ul>
<li>Router，⽀持分组  </li>
<li>Middleware&#x2F;Chai  </li>
<li>Context</li>
</ul>
<h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a><a href="https://github.com/gin-gonic/gin">Gin</a></h2><p>⽼牌框架  </p>
<ul>
<li>Star 最多  </li>
<li>核⼼代码 3000 ⾏  </li>
<li>⽤户很多很多</li>
</ul>
<p>主要组件：  </p>
<ul>
<li>Router，⽀持分组  </li>
<li>Middlewar  </li>
<li>binding，将 decoder 和 validator 合⼆为⼀，变成了 binding 组件  </li>
<li>Logger，功能⽐较弱  </li>
<li>Context</li>
</ul>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a><a href="https://github.com/labstack/echo">echo</a></h2><p>⽼牌框架  </p>
<ul>
<li>核⼼代码 1900  </li>
<li>中规中矩</li>
</ul>
<p>主要组件：  </p>
<ul>
<li>Router，⽀持分组</li>
<li>Middlewar</li>
<li>binding，没有 validato</li>
<li>Logger，实现在框架外部：<a href="https://github.com/labstack/gommon/blob/master/log/log.go">https://github.com/labstack/gommon/blob/master/log/log.go</a>  </li>
<li>Context</li>
</ul>
<h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a><a href="https://github.com/gofiber/fiber">fiber</a></h2><p>2020 年开始做的框架  </p>
<ul>
<li>基于 fasthtt  </li>
<li>参考了 Express.js 的设计</li>
</ul>
<p>主要组件：  </p>
<ul>
<li>Router，⽀持分组  </li>
<li>Middleware</li>
<li>Context</li>
</ul>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/fiber.png">  </p>
<h2 id="Beego"><a href="#Beego" class="headerlink" title="Beego"></a>Beego</h2><p>元⽼框架  </p>
<ul>
<li>与 martini，gin，beego 曾经是 Go 圈⼦三个最⽕的框架  </li>
<li>国⼈的第⼀个 Go 的世界级项⽬  </li>
<li>MVC 框架，适合 PHP 程序员上⼿</li>
</ul>
<p>主要组件：  </p>
<ul>
<li>Router，⽀持分组  </li>
<li>Filter(其实就是 middleware  </li>
<li>Contex  </li>
<li>Task(类似 spring 框架中的定时任务  </li>
<li>orm、httpclient、cache、validator、config、swagger、template 等</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>⼤多数流⾏的 Go 开源 web 框架本身功能并不是很多，最简单的框架，只需三个组件：  </p>
<ul>
<li>Router  </li>
<li>Middleware  </li>
<li>Context</li>
</ul>
<h1 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h1><p>相⽐ web 框架，微服务框架的组件更多：  </p>
<ul>
<li>Config：配置管理组件  </li>
<li>Logger：遵守第三⽅⽇志收集规范的⽇志组件  </li>
<li>Metrics：使框架能够与 Prometheus 等监控系统集成的 metrics 组件  </li>
<li>Tracing：遵守 OpenTelemetry 的 tracing 组件  </li>
<li>Registry：服务发现组件  </li>
<li>MQ：可以切换不同队列实现的 mq 组件  </li>
<li>依赖注⼊：wire，dig 等组件</li>
</ul>
<h2 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h2><p>主要组件：  </p>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/gm1.png">  </p>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/gm2.png">  </p>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/gm3.png">  </p>
<h2 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h2><p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/zero.png">  </p>
<h2 id="YoYoGo"><a href="#YoYoGo" class="headerlink" title="YoYoGo"></a>YoYoGo</h2><p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/yoyougo.png">  </p>
<h2 id="DubboGo"><a href="#DubboGo" class="headerlink" title="DubboGo"></a>DubboGo</h2><p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/dubbogo.png">  </p>
<h2 id="Kratos"><a href="#Kratos" class="headerlink" title="Kratos"></a>Kratos</h2><p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/kratos.png">  </p>
<h1 id="如何评判框架优劣"><a href="#如何评判框架优劣" class="headerlink" title="如何评判框架优劣"></a>如何评判框架优劣</h1><h2 id="框架设计需要考虑的问题"><a href="#框架设计需要考虑的问题" class="headerlink" title="框架设计需要考虑的问题"></a>框架设计需要考虑的问题</h2><ul>
<li>自动化  </li>
<li>平台化  </li>
<li>集成化  </li>
<li>组件化  </li>
<li>插件化  </li>
<li>通用化</li>
</ul>
<h2 id="如何评判框架优劣-1"><a href="#如何评判框架优劣-1" class="headerlink" title="如何评判框架优劣"></a>如何评判框架优劣</h2><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul>
<li>Layout 代码⾃动⽣成(DDD&#x2F;Clean Arch  </li>
<li>服务上线⾃动发布  </li>
<li>⾃动⽣成接⼝⽂档  </li>
<li>服务接⼊ SDK ⾃动⽣成  </li>
<li>常⻅ code snippet(boilerplate) 内置在 CLI ⼯具内  </li>
<li>不要让⽤户去复制粘贴，我们来帮他⾃动写好</li>
</ul>
<h3 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h3><ul>
<li>IDL 在平台中管理  </li>
<li>接⼝⽂档可检索  </li>
<li>服务上线&#x2F;部署流⽔线化</li>
</ul>
<p>举例  </p>
<ul>
<li>step 1，修改服务名，服务级别(p0, p1)  </li>
<li>step 2，选择依赖资源，db，redis，mq，外部服务  </li>
<li>step 3，选择服务部署集群，⾼可⽤要求  </li>
<li>step 4，部署</li>
</ul>
<h3 id="集成化"><a href="#集成化" class="headerlink" title="集成化"></a>集成化</h3><ul>
<li>框架提供所有基础设施 SDK(log, tracing, config center，orm&#x2F;sql builder，es sdk，clickhourse sdk, mq, etc..  </li>
<li>开箱即⽤，核⼼依赖⽆需外部站点寻找  </li>
<li>专⻔的 organization 下维护其它⾮核⼼依赖  </li>
<li>解决⽤户的选择困难症</li>
</ul>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ul>
<li>稳定性需求，沉淀为统⼀组件  </li>
<li>公司内历次故障经验都应尽量沉淀为避免&#x2F;解决问题的组件(可以是重试组件中的规则，也可以是静态扫描⼯具中的⼀个 linter)  </li>
<li>不要让每个⼈都必须读⼀遍 Google SRE 书才能做好稳定性</li>
</ul>
<h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><ul>
<li>⾯向接⼝编程  </li>
<li>组件以 plugin 形式提供(不是 Go 语⾔的那个 plugin)</li>
</ul>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/go-system.png">  </p>
<h3 id="通用化"><a href="#通用化" class="headerlink" title="通用化"></a>通用化</h3><ul>
<li>主要针对开源框架  </li>
<li>Leave options open by Uncle Bob  </li>
<li>让⽤户有选择权(我喜欢 etcd&#x2F;zk 做注册中⼼，我偏要⽤)，可以通过插件化来达成  </li>
<li>Go-micro 是⼀个很好的范例</li>
</ul>
<p>对于企业内部框架来说，通⽤<strong>并不是⼀定要追求的⽬标</strong>  </p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于企业场景来说，⼤⽽全就是好  </li>
<li>对于开源场景来说，给⽤户选择权才是好</li>
</ul>
<h1 id="如何看待社区观点"><a href="#如何看待社区观点" class="headerlink" title="如何看待社区观点"></a>如何看待社区观点</h1><h2 id="框架应该做薄"><a href="#框架应该做薄" class="headerlink" title="框架应该做薄"></a>框架应该做薄</h2><p>核⼼观点：  </p>
<ul>
<li>Less is more</li>
<li>框架的核⼼只保留通⽤接⼝和简单流程</li>
<li>复杂的选择问题交给⽤户</li>
<li>我们写 Go，就是因为不喜欢 Java 那样臃肿的框架！</li>
</ul>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/dt.png">  </p>
<p>如果框架不愿意帮业务解决依赖的坑，那每个业务都要被相似的问题坑⼀遍。  </p>
<h2 id="OLTP-到底该不该使⽤-ORM、sql-builder"><a href="#OLTP-到底该不该使⽤-ORM、sql-builder" class="headerlink" title="OLTP 到底该不该使⽤ ORM、sql builder"></a>OLTP 到底该不该使⽤ ORM、sql builder</h2><p>如果线上出现了慢 SQL，我想要⻢上定位到代码位置呢？  </p>
<p>使⽤规范的 SQL &lt;-&gt; struct 绑定⽅式，可以整合静态分析、部署⼯具直接定位到哪⼀次部署引⼊了慢 SQL  </p>
<p>但是：⽬前没有看到任何⼀家公司实现了上述诊断链。  </p>
<h2 id="框架内容多，升级负担极⼤，要推每个业务⽅去升级"><a href="#框架内容多，升级负担极⼤，要推每个业务⽅去升级" class="headerlink" title="框架内容多，升级负担极⼤，要推每个业务⽅去升级"></a>框架内容多，升级负担极⼤，要推每个业务⽅去升级</h2><ul>
<li>确实是这样，但这是框架组的责任  </li>
<li>基于 service mesh 和 dapr 的架构⼀定程度上解决了这个问题</li>
</ul>
<h2 id="框架不应该对业务⾃⼰选内部库造成的依赖冲突负责"><a href="#框架不应该对业务⾃⼰选内部库造成的依赖冲突负责" class="headerlink" title="框架不应该对业务⾃⼰选内部库造成的依赖冲突负责"></a>框架不应该对业务⾃⼰选内部库造成的依赖冲突负责</h2><ul>
<li>框架是稳定性&#x2F;⼯程效率交给业务研发的产品  </li>
<li>产品问题就应该让负责⼈来改进，甩锅怎么能⾏呢</li>
</ul>
<h1 id="⼀些可以借鉴的思路"><a href="#⼀些可以借鉴的思路" class="headerlink" title="⼀些可以借鉴的思路"></a>⼀些可以借鉴的思路</h1><ul>
<li>IDL 之间可以使⽤技术⼿段可以互相转换(第⼆节课有提到)  </li>
<li>要做平台化，可以适当屏蔽 IDL 的语法，可以参考 openapi  </li>
<li>业务代码⼊⼝不应与任何协议绑定，如图：</li>
</ul>
<p><img src="/2021/11/13/go-senior-engineer-7-community-excellent-framework-comparison/gn.png">  </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://zhuanlan.zhihu.com/p/32968829">why library?</a><br><a href="https://laravelacademy.org/post/21014">Go Micro 初探及其底层架构</a><br><a href="https://www.bilibili.com/video/av73488208/">Go-Micro 微服务框架设计</a><br><a href="https://gist.github.com/posener/330c2b08aaefdea6f900ff0543773b2e">Why I Recommend to Avoid Using the go-kit Library</a>  </p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第8课_深⼊ web 框架原理与实现</title>
    <url>/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/</url>
    <content><![CDATA[<h1 id="middleware-实现"><a href="#middleware-实现" class="headerlink" title="middleware 实现"></a>middleware 实现</h1><h2 id="middleware-x2F-filter-实现"><a href="#middleware-x2F-filter-实现" class="headerlink" title="middleware&#x2F;filter 实现"></a>middleware&#x2F;filter 实现</h2><p>我们有这样⼀个 hello world 的业务逻辑：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf1.png">  </p>
<p>如果想要统计每个请求花的时间：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf2.png">  </p>
<p>随着业务的迭代，接⼝会逐渐增加：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf3.png">  </p>
<p>公司发展壮⼤后，我们希望能把耗时可视化：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf4.png">  </p>
<p>基本思路是，把功能性(业务代码)和⾮功能性(⾮业务代码)分离  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf5.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf6.png">  </p>
<ul>
<li>和 HandlerFunc 有相同签名的函数可以强制转换为 HandlerFunc  </li>
<li>HandlerFunc 实现了 ServeHTTP ⽅法，所以 HandlerFunc 实现了 http.Handler 接⼝</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf7.png">  </p>
<p>多个中间件⼀般这么写就好了  </p>
<p>不过这样写很丑，一般这样写：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf7-1.png">  </p>
<p>实现也很简单：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/mf7-2.png">  </p>
<p>⼀个 http 的请求处理过程：  </p>
<p>![])(.&#x2F;go-senior-engineer-8-in-depth-web-framework-principle-and-realization&#x2F;http.png)  </p>
<h2 id="常⻅-middleware"><a href="#常⻅-middleware" class="headerlink" title="常⻅ middleware"></a>常⻅ middleware</h2><p><a href="https://github.com/gin-gonic/contrib">https://github.com/gin-gonic/contrib</a>  </p>
<h1 id="router-实现"><a href="#router-实现" class="headerlink" title="router 实现"></a>router 实现</h1><h2 id="Router-本质"><a href="#Router-本质" class="headerlink" title="Router 本质"></a>Router 本质</h2><p>![])(.&#x2F;go-senior-engineer-8-in-depth-web-framework-principle-and-realization&#x2F;rt.png)  </p>
<h2 id="字典树-trie"><a href="#字典树-trie" class="headerlink" title="字典树 trie"></a>字典树 trie</h2><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/trie.png">  </p>
<ul>
<li>单个节点代表⼀个字⺟  </li>
<li>如果需要对字符串进⾏匹配  </li>
<li>只要从根节点开始依次匹配即可</li>
</ul>
<h2 id="Radix-Tree"><a href="#Radix-Tree" class="headerlink" title="Radix Tree"></a>Radix Tree</h2><blockquote>
<p>In computer science, a radix tree (also radix trie or compact prefix tree) is a data structure that represents a space-optimized trie (prefix tree) in which each node that is the only child is merged with its parent. The result is that the number of children of every internal node is at most the radix r of the radix tree, where r is a positive integer and a power x of 2, having x ≥ 1. Unlike regular trees, edges can be labeled with sequences of elements as well as single elements. This makes radix trees much more efficient for small sets (especially if the strings are long) and for sets of strings that share long prefixes.  </p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Radix_tree">Radix tree</a>  </p>
<p>同⼀个 URI 在 HTTP 规范中会有多个⽅法  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/radix-uri.png">  </p>
<p>每⼀个 method 对应⼀棵 radix tree：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/radix-method.png">  </p>
<h2 id="httprouter-实现细节"><a href="#httprouter-实现细节" class="headerlink" title="httprouter 实现细节"></a>httprouter 实现细节</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>就是 httprouter 树中的节点。  </p>
<h3 id="nType"><a href="#nType" class="headerlink" title="nType"></a>nType</h3><p>就是 node type，有⼏种枚举值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">• static <span class="comment">// ⾮根节点的普通字符串节点</span></span><br><span class="line">• root <span class="comment">// 根节点</span></span><br><span class="line">• param(wildcard) <span class="comment">// 参数节点，例如 :id</span></span><br><span class="line">• catchAll <span class="comment">// 通配符节点，例如 *anyway</span></span><br></pre></td></tr></table></figure>

<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/hr-path.png"><br>到达节点时，所经过的字符串路径  </p>
<h3 id="indices"><a href="#indices" class="headerlink" title="indices"></a>indices</h3><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/indices1.png"><br>⼦节点索引，当⼦节点为⾮参数类型，即本节点的 wildChild 为 false时，会将每个⼦节点的⾸字⺟放在该索引数组。说是数组，实际上是个string。  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/indices2.png"><br>如果⼦节点为参数节点时，indices 应该是个空字符串。  </p>
<h3 id="wildChild"><a href="#wildChild" class="headerlink" title="wildChild"></a>wildChild</h3><p>如果⼀个节点的⼦节点中有 param(wildcard) 节点，那么该节点的 wildChild 字段即为 true。  </p>
<h3 id="catchAll"><a href="#catchAll" class="headerlink" title="catchAll"></a>catchAll</h3><p>以 * 结尾的路由，即为 catchAll。在静态⽂件服务上，catchAll ⽤的⽐较多。后⾯的部分⼀般⽤来描述⽂件路径。如：&#x2F;software&#x2F;downloads&#x2F;monodraw-latest.dmg。  </p>
<h2 id="Radix-Tree-的构造过程"><a href="#Radix-Tree-的构造过程" class="headerlink" title="Radix Tree 的构造过程"></a>Radix Tree 的构造过程</h2><h3 id="第⼀条路由"><a href="#第⼀条路由" class="headerlink" title="第⼀条路由"></a>第⼀条路由</h3><p>插⼊ &#x2F;marketplace_listing&#x2F;plans&#x2F;<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/rtcreate1.png">  </p>
<h3 id="第⼆条路由"><a href="#第⼆条路由" class="headerlink" title="第⼆条路由"></a>第⼆条路由</h3><p>插⼊ &#x2F;marketplace_listing&#x2F;plans&#x2F;:id&#x2F;acounts<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/rtcreate2.png">  </p>
<h3 id="第三条路由"><a href="#第三条路由" class="headerlink" title="第三条路由"></a>第三条路由</h3><p>插⼊ &#x2F;search<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/rtcreate3.png">  </p>
<h2 id="路由冲突"><a href="#路由冲突" class="headerlink" title="路由冲突"></a>路由冲突</h2><p>conflict:<br>GET &#x2F;user&#x2F;info&#x2F;:name<br>GET &#x2F;user&#x2F;:id  </p>
<p>no conflict:<br>GET &#x2F;user&#x2F;info&#x2F;:name<br>POST &#x2F;user&#x2F;:id  </p>
<h2 id="路由冲突细则"><a href="#路由冲突细则" class="headerlink" title="路由冲突细则"></a>路由冲突细则</h2><ul>
<li>在插⼊ wildcard 节点时，⽗节点的 children 数组⾮空且 wildChild 被设置为 false。<br>例如：GET &#x2F;user&#x2F;getAll 和 GET &#x2F;user&#x2F;:id&#x2F;getAddr，或者 GET &#x2F;user&#x2F;*aaa和 GET &#x2F;user&#x2F;:id。  </li>
<li>在插⼊ wildcard 节点时，⽗节点的 children 数组⾮空且 wildChild 被设置为 true，但该⽗节点的 wildcard ⼦节点要插⼊的 wildcard 名字不⼀样。<br>例如： GET &#x2F;user&#x2F;:id&#x2F;info 和 GET &#x2F;user&#x2F;:name&#x2F;info。  </li>
<li>在插⼊ catchAll 节点时，⽗节点的 children ⾮空。<br>例如： GET &#x2F;src&#x2F;abc和 GET &#x2F;src&#x2F;*filename，或者 GET &#x2F;src&#x2F;:id 和 GET &#x2F;src&#x2F;*filename。  </li>
<li>在插⼊ static 节点时，⽗节点的 wildChild 字段被设置为 true。 在插⼊static 节点时，⽗节点的 children ⾮空，且⼦节点 nType 为 catchAll。</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/routerconf2.png"><br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/routerconf.png">  </p>
<h1 id="validator-实现"><a href="#validator-实现" class="headerlink" title="validator 实现"></a>validator 实现</h1><h2 id="为什么需要-validator"><a href="#为什么需要-validator" class="headerlink" title="为什么需要 validator"></a>为什么需要 validator</h2><p>看看这坨代码：<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/validator1.png">  </p>
<p>使⽤ early return&#x2F;guard clause 重构之后，代码还是太丑：<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/validator2.png">  </p>
<p>validator 改造：<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/validator3.png">  </p>
<h2 id="validator-基本原理"><a href="#validator-基本原理" class="headerlink" title="validator 基本原理"></a>validator 基本原理</h2><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/valp1.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/valp2.png">  </p>
<p><a href="https://github.com/chai2010/advanced-go-programming-book/blob/master/ch5-web/ch5-04-validator.md#543-%E5%8E%9F%E7%90%86">深度优先遍历就可以了</a>  </p>
<h1 id="request-binder-实现"><a href="#request-binder-实现" class="headerlink" title="request binder 实现"></a>request binder 实现</h1><h2 id="Gin-的-binding"><a href="#Gin-的-binding" class="headerlink" title="Gin 的 binding"></a>Gin 的 binding</h2><p>HTTP header : Content-Type<br><img src="/./go-senior-engineer-8-in-depth-web-framework-principle-and-realization/http-header1.png"><br><img src="/./go-senior-engineer-8-in-depth-web-framework-principle-and-realization/http-header2.png">  </p>
<p><a href="https://github.com/gin-gonic/gin/blob/690aa2b1b9de7fe61dc15295210f64583dd3b90e/binding/binding.go#L90">简单工厂模式</a>  </p>
<p>不同的⼯⼚实现很简单，就是某种 codec 的 unmarshal<br><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/gin-binding.png">  </p>
<h1 id="sql-binder-实现"><a href="#sql-binder-实现" class="headerlink" title="sql binder 实现"></a>sql binder 实现</h1><h2 id="标准库的-API-难⽤"><a href="#标准库的-API-难⽤" class="headerlink" title="标准库的 API 难⽤"></a>标准库的 API 难⽤</h2><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/sql.png">  </p>
<ul>
<li>标准库的 API 难⽤且容易犯错  </li>
<li>有⽆数的新⼿ Gopher 倒在 sql.Rows 忘记关闭的坑下</li>
</ul>
<h2 id="SQL-binder-实现"><a href="#SQL-binder-实现" class="headerlink" title="SQL binder 实现"></a>SQL binder 实现</h2><p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/sql2.png">  </p>
<p>实现很简单，只要能把特殊开头的单词提取出来就可以了，⽐如:开头，@开头，$开头。  </p>
<h1 id="go-micro-实现"><a href="#go-micro-实现" class="headerlink" title="go-micro 实现"></a>go-micro 实现</h1><p>插件化原理：  </p>
<p><img src="/2021/11/14/go-senior-engineer-8-in-depth-web-framework-principle-and-realization/gom.png">  </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91">维基百科_基数树</a><br><a href="https://github.com/chai2010/advanced-go-programming-book/blob/master/ch5-web/readme.md">《Go ⾼级编程》的 web 部分</a><br>Go 夜读 go-micro 分享  </p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_第9课_框架之上的业务分层</title>
    <url>/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/</url>
    <content><![CDATA[<h1 id="传统分层"><a href="#传统分层" class="headerlink" title="传统分层"></a>传统分层</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC</a></h2><p>远古时代的 web 项⽬：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/mvc.png">  </p>
<p>当前后端分离成为主流共识：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/mvc2.png">  </p>
<h2 id="MVC-gt-DLC"><a href="#MVC-gt-DLC" class="headerlink" title="MVC -&gt; DLC"></a>MVC -&gt; DLC</h2><p>业务逻辑越来越复杂，拆成单独的 logic：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/mvc-dlc.png">  </p>
<h2 id="业务代码越来越多了，看不懂怎么办"><a href="#业务代码越来越多了，看不懂怎么办" class="headerlink" title="业务代码越来越多了，看不懂怎么办"></a>业务代码越来越多了，看不懂怎么办</h2><table>
<thead>
<tr>
<th>贫⾎模式</th>
<th>充⾎模式</th>
</tr>
</thead>
<tbody><tr>
<td>业务逻辑都在 logic 层内</td>
<td>要让 domain object 即 entity 有更多逻辑</td>
</tr>
<tr>
<td>Struct、Class 上没有任何逻辑，或只有少量逻辑</td>
<td>通过聚合来组合 entity 的逻辑</td>
</tr>
</tbody></table>
<h2 id="贫⾎模式代码示例"><a href="#贫⾎模式代码示例" class="headerlink" title="贫⾎模式代码示例"></a>贫⾎模式代码示例</h2><p>业务逻辑被埋没在存储业务中：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/pxex.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/pxex2.png">  </p>
<h2 id="使⽤充⾎模式改造后"><a href="#使⽤充⾎模式改造后" class="headerlink" title="使⽤充⾎模式改造后"></a>使⽤充⾎模式改造后</h2><p>定义 Customer Repo：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/cx.png">  </p>
<p>相关的 Repo 实现都较简单：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/cx2.png">  </p>
<p>主流程根据不同的⽤例选择执⾏不同的对象函数，⽽不是⽤数据建模，将所有处理集中在同⼀个函数⾥  </p>
<h2 id="SOLID-中的-DIP-Dependency-Inversion-Principle"><a href="#SOLID-中的-DIP-Dependency-Inversion-Principle" class="headerlink" title="SOLID 中的 DIP(Dependency Inversion Principle)"></a>SOLID 中的 DIP(Dependency Inversion Principle)</h2><p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/dip.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/dip2.png">  </p>
<p>通过 DIP，我们可以做到依赖⽅向与程序控制⽅向相反<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/dip2.png">  </p>
<h1 id="整洁架构-style"><a href="#整洁架构-style" class="headerlink" title="整洁架构 style"></a>整洁架构 style</h1><h2 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h2><p>Uncle Bob 提出的整洁架构：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/clean-arc.png">  </p>
<p>Uncle Bob 同时也是⾯向对象编程中的SOLID 原则的提出者  </p>
<h2 id="整洁架构的核⼼观点"><a href="#整洁架构的核⼼观点" class="headerlink" title="整洁架构的核⼼观点"></a>整洁架构的核⼼观点</h2><ul>
<li>不与框架绑定：业务不应该与某个 web 框架绑定，应该做到想换就换。  </li>
<li>可测试：业务逻辑应该在没有 UI、database 环境、web server 等所有外部环境的前提下做到可测试。  </li>
<li>不与 UI 绑定：不与具体的 UI 库绑定，项⽬应该做到随意切换外部 UI，⽐如可以将 web UI 替换为 console UI，同时⽆需业务逻辑做修改。  </li>
<li>不与数据库绑定：可以把 Oracle 换成 SQL Server，也可以换成Mongo，换成 BigTable，换成 CouchDB。业务不依赖具体存储⽅式。  </li>
<li>不依赖任何外部代理：你的业务应该对外部环境⼀⽆所知。</li>
</ul>
<h2 id="不与框架绑定"><a href="#不与框架绑定" class="headerlink" title="不与框架绑定"></a>不与框架绑定</h2><ul>
<li>业务代码⼊⼝不应与任何协议绑定  </li>
<li>框架代码(如 gin.Context)不要⼊侵到业务层</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/get-notes.png">  </p>
<h2 id="可测试"><a href="#可测试" class="headerlink" title="可测试"></a>可测试</h2><p>在没有 UI、database 环境、web server 等所有外部环境的前提下做到可测试。  </p>
<ul>
<li>Sql driver mock for Golang  </li>
<li>Go monkeypatching  </li>
<li>Redis client Mock  </li>
<li>httptest  </li>
<li>gomock  </li>
<li>Testify  </li>
<li><a href="https://github.com/etcd-io/etcd/issues/11849">How to get a mock Etcd for unit test?</a></li>
</ul>
<h2 id="不与-UI-绑定"><a href="#不与-UI-绑定" class="headerlink" title="不与 UI 绑定"></a>不与 UI 绑定</h2><p>我们做的基本上都是前后分离的系统，不太容易与 UI 发⽣绑定：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/fbend.png">  </p>
<h2 id="不与数据库绑定"><a href="#不与数据库绑定" class="headerlink" title="不与数据库绑定"></a>不与数据库绑定</h2><p>不与数据库绑定：可以把 Oracle 换成 SQL Server，也可以换成Mongo，换成 BigTable，换成 CouchDB。业务不依赖具体存储⽅式。  </p>
<p>需要借助 DDD 中的 Repo 设计⽅式：  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/repo-interface-implementations.png">  </p>
<h2 id="不依赖任何外部代理"><a href="#不依赖任何外部代理" class="headerlink" title="不依赖任何外部代理"></a>不依赖任何外部代理</h2><p>没有外部 agent 也能启动，做到⽐较难。  </p>
<p>⽐如你是不是经常会碰到：  </p>
<ul>
<li>没有配置下发的 agent 的环节，本系统跑不起来。  </li>
<li>没有 service mesh 模块，本系统跑不起来。  </li>
<li>没有 metrics 采集模块，本系统跑不起来。</li>
</ul>
<h1 id="DDD-style"><a href="#DDD-style" class="headerlink" title="DDD style"></a>DDD style</h1><h2 id="DDD-社区就是名词多"><a href="#DDD-社区就是名词多" class="headerlink" title="DDD 社区就是名词多"></a>DDD 社区就是名词多</h2><ul>
<li>Entity  </li>
<li>Value Object  </li>
<li>Repository  </li>
<li>Aggregate  </li>
<li>Aggregate Root</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/adm-ddd.png">  </p>
<h2 id="ports-amp-amp-adapters"><a href="#ports-amp-amp-adapters" class="headerlink" title="ports &amp;&amp; adapters"></a>ports &amp;&amp; adapters</h2><p>六边形架构，也被称为端⼝与适配器架构，所有外部类型都有适配器与之对应，外部通过 API 与内部交互。——《实现领域驱动设计-ch4》  </p>
<p>Ports &#x3D; interface<br>Adapters &#x3D; instances  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/ports-adapters.png">  </p>
<h2 id="DDD-中的战术设计-Value-Object-Value-Type"><a href="#DDD-中的战术设计-Value-Object-Value-Type" class="headerlink" title="DDD 中的战术设计-Value Object(Value Type)"></a>DDD 中的战术设计-Value Object(Value Type)</h2><p>Value Type 是不可变(immutable)，可⽐较(comparable)的值<br>例如：<br>数字： 1，2，3；<br>字符串：“⼈⺠⽇报”，“⽕星探测”<br>结构体：var addr &#x3D; address {“100010”, “xi er qi”, “33.133”,  “21.3243”}  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/vt.png">  </p>
<h2 id="DDD-中的战术设计-Entity"><a href="#DDD-中的战术设计-Entity" class="headerlink" title="DDD 中的战术设计-Entity"></a>DDD 中的战术设计-Entity</h2><ul>
<li>Entity 的关键是其有 ID 作为唯⼀标识  </li>
<li>Value type 则没有 ID  </li>
<li>有 ID 意味着 entity 是可变(mutable)的，会随着时间更新</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/entity.png">  </p>
<h2 id="DDD-中的战术设计-Aggregate"><a href="#DDD-中的战术设计-Aggregate" class="headerlink" title="DDD 中的战术设计-Aggregate"></a>DDD 中的战术设计-Aggregate</h2><p>• Aggregate 和 entity 设计上类似，也有 ID，也是可变(mutable)的<br>• 聚合可以⽤ entity + value object 构成，如右图<br>• 每⼀个聚合对应⼀个 Repo interfac<br>• 聚合需要<strong>对聚合内的数据⼀致性负责，可以认为聚合是数据⼀致性的边界</strong><br>• 聚合之外的⼀致性采⽤最终⼀致性保证</p>
<p>Aggregate:<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/collection.png"><br>|<br>Repo：<br><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/crepo.png">  </p>
<ul>
<li>⼀个聚合可以只有⼀个 entity  </li>
<li>也可以有多个 entity 和 value object</li>
</ul>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/aggregate-pattern.png">  </p>
<h2 id="DDD-中的战术设计-Aggregate-Root"><a href="#DDD-中的战术设计-Aggregate-Root" class="headerlink" title="DDD 中的战术设计-Aggregate Root"></a>DDD 中的战术设计-Aggregate Root</h2><p>• 聚合根也是聚合<br>• 与普通聚合唯⼀差别：聚合根对外暴露，要关联某个领域内的对象，⼀定是通过聚合根的 id 来进⾏关联的。<br>• 在聚合内的⼀些 entity ⼀般不对外暴露，但随着时间的推移也可能变成聚合根。  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/aggregate-root.png">  </p>
<h2 id="DDD-中的战术设计-Repo-Pattern"><a href="#DDD-中的战术设计-Repo-Pattern" class="headerlink" title="DDD 中的战术设计-Repo Pattern"></a>DDD 中的战术设计-Repo Pattern</h2><p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/repo-pattern.png">  </p>
<h2 id="DDD-中的战术设计"><a href="#DDD-中的战术设计" class="headerlink" title="DDD 中的战术设计"></a>DDD 中的战术设计</h2><p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/layers.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/depend.png">  </p>
<h1 id="插件化架构"><a href="#插件化架构" class="headerlink" title="插件化架构"></a>插件化架构</h1><p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/core-system.png">  </p>
<h1 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h1><h2 id="依赖注⼊⼯具"><a href="#依赖注⼊⼯具" class="headerlink" title="依赖注⼊⼯具"></a>依赖注⼊⼯具</h2><p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/main-module.png">  </p>
<p>main 模块是上帝模块，需要负责初始化所有内部类  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/wire.png">  </p>
<p><img src="/2021/11/14/go-senior-engineer-9-business-layering-above-the-framework/wire2.png">  </p>
<h2 id="⼀些可以参考的-API-设计指南"><a href="#⼀些可以参考的-API-设计指南" class="headerlink" title="⼀些可以参考的 API 设计指南"></a>⼀些可以参考的 API 设计指南</h2><p><a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#sub-resource-collection">Paypal 的 API 设计指南</a><br><a href="https://segmentfault.com/a/1190000005924733">Paypal 的 API 设计指南(中⽂)</a><br><a href="https://github.com/RestCheatSheet/api-cheat-sheet/blob/master/README-zh-Hans.md">⽹友的 API 设计指南</a><br><a href="https://github.com/microsoft/api-guidelines">微软的 API 设计指南</a><br><a href="https://github.com/xin-lai/api-guidelines">微软的 API 设计指南(中⽂)</a><br><a href="https://cloud.google.com/apis/design/design_patterns">Google 的 API 设计指南</a>  </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a><br><a href="https://eltonminetto.dev/en/post/2020-07-06-clean-architecture-2years-later/">使⽤ Go 实践 clean architecture</a><br><a href="https://github.com/eminetto/clean-architecture-go-v2">整洁架构相关的代码</a><br><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice">Design a DDD-oriented microservice</a><br><a href="https://blog.csdn.net/lengyue1084/article/details/116271065">wire简介</a><br><a href="https://eltonminetto.dev/en/post/2020-07-06-clean-architecture-2years-later/">整洁架构重新思考</a><br><a href="https://vladikk.com/2018/01/21/bounded-contexts-vs-microservices/">Bounded-context 和 microservice 怎么对应</a><br><a href="https://link-intersystems.com/blog/2011/10/01/anemic-vs-rich-domain-models/">贫⾎模式还是充⾎模式</a><br><a href="https://www.damianopetrungaro.com/posts/ddd-using-golang-tactical-design/">Go 与 DDD 中的战术设计</a><br><a href="https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example">DDD 代码模板</a><br><a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2248811&seqNum=3">DDD 代码模板</a><br><a href="http://gorodinski.com/blog/2013/04/29/sub-domains-and-bounded-contexts-in-domain-driven-design-ddd/">⼦领域和 bounded context 的关系</a><br><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model">设计微服务的 domain mode</a><br><a href="https://www.infoq.cn/article/pjekymkzhmkafgi6ycri">Netflix 的六边形架构实践</a><br><a href="https://blog.pragmatists.com/refactoring-from-anemic-model-to-ddd-880d3dd3d45f">将贫⾎项⽬重构为 DDD 模式</a><br><a href="https://laiyuanyuan-sg.medium.com/mock-solutions-for-golang-unit-test-a2b60bd3e157">将贫⾎项⽬重构为 DDD 模式</a>  </p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>业务</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_作业1_使用调试工具查看Go语言函数执行流程</title>
    <url>/2021/09/19/go-senior-engineer-test-1-debug-tools/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul>
<li><p>部署好本机的 docker 环境，使⽤ ppt 中的 dockerfile build ⾃⼰的环境  </p>
</li>
<li><p>使⽤ readelf ⼯具，查看编译后的进程⼊⼝地址  </p>
</li>
<li><p>在 dlv 调试⼯具中，使⽤断点功能找到代码位置  </p>
</li>
<li><p>使⽤断点调试功能，查看 Go 的 runtime 的下列函数执⾏流程，使⽤ IDE 查看函数的调⽤⽅：<br>(1).必做：runqput，runqget，globrunqput，globrunqget<br>(2).选做：schedule，findrunnable，sysmon  </p>
</li>
<li><p>课外作业：跟踪进程启动流程中的关键函数，rt0_go，需要汇编知识</p>
</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>调试</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_作业4_并发请求baidu和bing，谁先获取到完整html就中止另一个流程</title>
    <url>/2021/09/19/go-senior-engineer-test-4-get-web-html/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul>
<li><p>必做：使⽤任意并发⼯具，完成这样⼀个程序，并发请求 <a href="https://baidu.com/">https://baidu.com</a> 和 <a href="https://bing.com,任意一个站点先获取到了完整的/">https://bing.com，任意⼀个站点先获取到了完整的</a> html，即中⽌另⼀个流程，并把结果输出⾄⽂件：{sitename}.html，例如百度先获取到了结果，即输出baidu.html，若 bing 先获取到了结果，就输出 bing.html。  </p>
</li>
<li><p>选做，难度+：安装 herdtools(<a href="https://github.com/herd/herdtools7)%EF%BC%8C%E5%9C%A8%E6%9C%AC%E6%9C%BA%E4%B8%8A%E4%BD%BF%E2%BD%A4">https://github.com/herd/herdtools7)，在本机上使⽤</a> litmus7 执⾏下列脚本：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">X86 OOO </span><br><span class="line">&#123; x=0; y=0; &#125; </span><br><span class="line"> P0 | P1 ; </span><br><span class="line"> MOV [x],<span class="variable">$1</span> | MOV [y],<span class="variable">$1</span> ; </span><br><span class="line"> MOV EAX,[y] | MOV EAX,[x] ; </span><br><span class="line">locations [x;y;] </span><br><span class="line">exists (0:EAX=0 /\ 1:EAX=0)</span><br></pre></td></tr></table></figure>

<p>并阅读明⽩输出结果。  </p>
<ul>
<li>选做，难度+++：为什么使⽤<code>atomic.cas</code>可以实现⼀个互斥锁，为什么临界区内的内存读写操作不会被重排到 cas 操作之外？</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_作业3_封装⼀个数据结构MyMap，实现它所需要的API</title>
    <url>/2021/09/19/go-senior-engineer-test-3-mymap/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul>
<li>必做：封装⼀个数据结构 MyMap，实现并发安全的<code>Load，Store，Delete，LoadAndDelete，LoadOrStore</code>⼏个API(禁⽌使⽤ sync.Map)，不⽤考虑性能  </li>
<li>选做：编写 benchmark，⽐较 MyMap 与 sync.Map 的同名函数性能差异，输出相应的性能报告(注意，你应该使⽤ RunParallel)，将性能⽐较结果输出为 markdown ⽂件  </li>
<li>选做：使⽤ channel 实现⼀个 trylock，模板 trylock.go  </li>
<li>选做：修复 deadlock.go 的死锁  </li>
<li>选做：在 context 学习过程中，我们知道，在⼦节点中 WithValue 的数据，⽗节点是查不到的。请实现⼀个 MyContext，其 WithValue ⽅法赋值的 k，v 在⽗节点中也可以查得到。模板：mycontext.go  </li>
<li>选做难度++：实现，或封装社区的 timewheel，使⽤ benchmark 或 pprof ⽐较⼤量 timer 存活时，内置 timer 和 timewheel 的性能差异。不要求提交代码，只需要性能对⽐报告 markdown。</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Map</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_作业2_channel⼀⻚中，找出所有红线报错在runtime中的位置</title>
    <url>/2021/09/19/go-senior-engineer-test-2-channel-red-line-on-runtime/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul>
<li>必做：channel ⼀⻚中，找出所有红线报错在 runtime 中的位置，使⽤ Go 1.14.12 版本  </li>
<li>选做1：修复 <a href="https://golearn.coding.net/p/gonggongbanji/files/all/DF12">https://golearn.coding.net/p/gonggongbanji/files/all/DF12</a> 中的 test case  </li>
<li>选做2：扩展其功能，增加更多的操作符号⽀持(随意发挥)  </li>
<li>难度++选做：分析 Go 语⾔新版本的函数调⽤规约，将分析过程总结为 markdown ⽂档</li>
</ul>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>channel</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高级工程师_作业5_实现⼀个⾃⼰的 validator和 restful ⻛格 API 框架</title>
    <url>/2021/09/19/go-senior-engineer-test-5-my-validator-and-restful-api-frame/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul>
<li>必做：实现⼀个⾃⼰的 validator，⽀持通过 tag 对结构体中的字段进⾏⾮空校验  </li>
<li>选做：完成⼀个属于⾃⼰的 restful ⻛格 API 框架</li>
</ul>
<p>整合 httprouter，sqlx<br>整合 validator，和 gin 的 binding 库<br>实现兼容 http.HandlerFunc 的 middleware  </p>
]]></content>
      <categories>
        <category>GoSEC</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Go</tag>
        <tag>RestFul</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/go-test-tips/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？  </p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：  </p>
<ul>
<li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li>
</ul>
<p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure>
<p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。  </p>
<p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>单元测试</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gin+Casbin实现权限管理</title>
    <url>/2022/01/06/go-use-gin-casbin-to-auth-management/</url>
    <content><![CDATA[<h1 id="关于Casbin"><a href="#关于Casbin" class="headerlink" title="关于Casbin"></a>关于Casbin</h1><p>Casbin是用于Golang项目的功能强大且高效的开源访问控制库。<br><a href="https://casbin.org/docs/zh-CN/overview">casbin中文官方文档</a>  </p>
<h2 id="Casbin的作用"><a href="#Casbin的作用" class="headerlink" title="Casbin的作用"></a>Casbin的作用</h2><ul>
<li>以经典{subject, object, action}形式或您定义的自定义形式实施策略，同时支持允许和拒绝授权。  </li>
<li>处理访问控制模型及其策略的存储。  </li>
<li>管理角色用户映射和角色角色映射（RBAC中的角色层次结构）。  </li>
<li>支持内置的超级用户，例如root或administrator。超级用户可以在没有显式权限的情况下执行任何操作。  </li>
<li>多个内置运算符支持规则匹配。例如，keyMatch可以将资源键映射&#x2F;foo&#x2F;bar到模式&#x2F;foo*。</li>
</ul>
<h2 id="Casbin不执行的操作"><a href="#Casbin不执行的操作" class="headerlink" title="Casbin不执行的操作"></a>Casbin不执行的操作</h2><ul>
<li>身份验证（又名验证username以及password用户登录时）  </li>
<li>管理用户或角色列表。我相信项目本身管理这些实体会更方便。用户通常具有其密码，而Casbin并非设计为密码容器。但是，Casbin存储RBAC方案的用户角色映射。</li>
</ul>
<h2 id="它是怎么运行的"><a href="#它是怎么运行的" class="headerlink" title="它是怎么运行的"></a>它是怎么运行的</h2><p>在Casbin中，基于PERM元模型（策略，效果，请求，匹配器）将访问控制模型抽象为CONF文件。因此，切换或升级项目的授权机制就像修改配置一样简单。您可以通过组合可用的模型来定制自己的访问控制模型。例如，您可以在一个模型中同时获得RBAC角色和ABAC属性，并共享一组策略规则。  </p>
<p>Casbin中最基本，最简单的模型是ACL。ACL的CONF模型为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＃请求定义</span><br><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[role_definition]</span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p>ACL模型的示例策略如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p, alice, data1, read</span><br><span class="line">p, bob, data2, write</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get github.com/casbin/casbin</span><br></pre></td></tr></table></figure>

<p>装完后go mod init和go mod tidy后，本机安装的默认版本是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github.com/casbin/casbin v1.9.1</span><br><span class="line">github.com/casbin/xorm-adapter v1.0.0</span><br></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/casbin/casbin&quot;</span></span><br><span class="line">	xormadapter <span class="string">&quot;github.com/casbin/xorm-adapter&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 要使用自己定义的数据库rbac_db,最后的true很重要.默认为false,使用缺省的数据库名casbin,不存在则创建</span></span><br><span class="line">	a := xormadapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:mysql123@tcp(127.0.0.1:3306)/goblog?charset=utf8&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// if err != nil &#123;</span></span><br><span class="line">	<span class="comment">// 	log.Printf(&quot;连接数据库错误: %v&quot;, err)</span></span><br><span class="line">	<span class="comment">// 	return</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	e := casbin.NewEnforcer(<span class="string">&quot;./rbac_models.conf&quot;</span>, a)</span><br><span class="line">	<span class="comment">// if err != nil &#123;</span></span><br><span class="line">	<span class="comment">// 	log.Printf(&quot;初始化casbin错误: %v&quot;, err)</span></span><br><span class="line">	<span class="comment">// 	return</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">//从DB加载策略</span></span><br><span class="line">	e.LoadPolicy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取router路由对象</span></span><br><span class="line">	r := gin.New()</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">&quot;/api/v1/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;增加Policy&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ok := e.AddPolicy(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;/api/v1/hello&quot;</span>, <span class="string">&quot;GET&quot;</span>); !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Policy已经存在&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;增加成功&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//删除policy</span></span><br><span class="line">	r.DELETE(<span class="string">&quot;/api/v1/delete&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;删除Policy&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ok := e.RemovePolicy(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;/api/v1/hello&quot;</span>, <span class="string">&quot;GET&quot;</span>); !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Policy不存在&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//获取policy</span></span><br><span class="line">	r.GET(<span class="string">&quot;/api/v1/get&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;查看policy&quot;</span>)</span><br><span class="line">		list := e.GetPolicy()</span><br><span class="line">		<span class="keyword">for</span> _, vlist := <span class="keyword">range</span> list &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> vlist &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;value: %s, &quot;</span>, v)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//使用自定义拦截器中间件</span></span><br><span class="line">	r.Use(Authorize(e))</span><br><span class="line">	<span class="comment">//创建请求</span></span><br><span class="line">	r.GET(<span class="string">&quot;/api/v1/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello 接收到GET请求..&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/api/v1/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello 接收到POST请求..&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9000&quot;</span>) <span class="comment">//参数为空 默认监听8080端口，非空，监听9000端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Authorize</span><span class="params">(e *casbin.Enforcer)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取请求的URI</span></span><br><span class="line">		obj := c.Request.URL.RequestURI()</span><br><span class="line">		<span class="comment">//获取请求方法</span></span><br><span class="line">		act := c.Request.Method</span><br><span class="line">		<span class="comment">//获取用户的角色</span></span><br><span class="line">		sub := <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断策略中是否存在</span></span><br><span class="line">		<span class="keyword">if</span> ok := e.Enforce(sub, obj, act); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;恭喜您,权限验证通过&quot;</span>)</span><br><span class="line">			c.Next()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;很遗憾,权限验证没有通过&quot;</span>)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rbac_models.conf里面的内容如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[role_definition]</span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>命令行输入<code>go run main.go</code>后，会自动在本地数据库<code>goblog</code>下创建一个名为<code>casbin_rule</code>的表  </p>
<p><img src="/2022/01/06/go-use-gin-casbin-to-auth-management/casbin_rule.png">  </p>
<p>使用postman发送Get请求到<code>http://localhost:9000/api/v1/hello</code>  </p>
<p>输出为：很遗憾,权限验证没有通过  </p>
<p>接着我们往<code>casbin_rule</code>表里添加以下内容：  </p>
<p><img src="/2022/01/06/go-use-gin-casbin-to-auth-management/admin.png">  </p>
<p>再次使用postman发送Get请求到<code>http://localhost:9000/api/v1/hello</code>  </p>
<p>输出为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">恭喜您,权限验证通过</span><br><span class="line">Hello 接收到GET请求..</span><br></pre></td></tr></table></figure>

<p>按照数据表里的逻辑，我们再试试用postman发送POST请求到<code>http://localhost:9000/api/v1/hello</code>  </p>
<p>输出为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">恭喜您,权限验证通过</span><br><span class="line">Hello 接收到POST请求..</span><br></pre></td></tr></table></figure>

<p>如果我们再试一下用postman发送DELETE请求到<code>http://localhost:9000/api/v1/hello</code>  </p>
<p>输出为：很遗憾,权限验证没有通过  </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过以上个人实验，我觉得使用Casbin的作用就是把用户对应请求接口的权限放在MySQL数据库中去记录，因此权限验证这个模块可以完全独立出来，使得给某用户添加某接口的某种(常用POST、GET、DELETE、GET)请求的权限都会一目了然。  </p>
<p><a href="https://github.com/OctopusLian/xcms/tree/master/cmd/casbint">以上代码github地址</a>  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>Gin框架</tag>
        <tag>Casbin框架</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Go vendor应用</title>
    <url>/2019/07/10/go-vendor-application/</url>
    <content><![CDATA[<h2 id="为什么要用它"><a href="#为什么要用它" class="headerlink" title="为什么要用它"></a>为什么要用它</h2><p>控制包的依赖，例如一个项目引用的是A包1.0版本后编译成功，结果几个月后A包tag号升到了2.3，而我们平时用<code>go get</code>命令是直接从<code>master</code>分支下引入的，因此可能会造成引入了同样的包，但编译不通过的问题。<br>而如果这个项目中存在<code>vendor</code>文件夹，<code>go</code>项目编译时就会优先编译<code>vendor</code>文件夹里的包。  </p>
<h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>今天编译一个用<code>Go</code>写的语音识别服务的项目，缺失的A包用<code>go get</code>命令获取了，但编译后显示<code>xxx function not defined</code>，而我查了这个<code>xxx</code>函数是A包声明好的，这是什么原因呢。<br>原因就在于<strong>版本不匹配</strong>。  </p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="简单直接的方法"><a href="#简单直接的方法" class="headerlink" title="简单直接的方法"></a>简单直接的方法</h3><p>在该项目下新建一个<code>vendor</code>文件夹，假如这个包是引入<code>github</code>上的，就在这下面建立基于<code>github</code>的路径，像这样  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 20hours</span><br><span class="line">│   ├── 20hours</span><br><span class="line">│   ├── demo.txt</span><br><span class="line">│   ├── file.png</span><br><span class="line">│   └── main.go</span><br><span class="line">├── testgo</span><br><span class="line">├── test.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── name</span><br><span class="line">            └── A</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取包的指定版本号仓库文件，可以用命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone v版本号 httpurl  </span><br><span class="line"></span><br><span class="line">举例:获取版本号为1.4.1的go-socket.io包  </span><br><span class="line">git clone v1.4.1 https://github.com/googollee/go-socket.io</span><br></pre></td></tr></table></figure>

<h3 id="推荐的方法，使用dep构建"><a href="#推荐的方法，使用dep构建" class="headerlink" title="推荐的方法，使用dep构建"></a>推荐的方法，使用dep构建</h3><p>网上教程很多，在此不做赘述  </p>
<ul>
<li><a href="https://golang.github.io/dep/docs/introduction.html">dep官方文档</a>  </li>
<li><a href="https://godoc.org/github.com/golang/dep/cmd/dep">dep_Godoc</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>vendor</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-微服务概览与治理</title>
    <url>/2021/03/03/goatc-1-microservice-overview-and-governance/</url>
    <content><![CDATA[<h2 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h2><h3 id="单体设计"><a href="#单体设计" class="headerlink" title="单体设计"></a>单体设计</h3><p>尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终敏捷性和部署变的无法完成。  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/simple.png">  </p>
<p>因此，我们应对的思路：<strong>化繁为简，分而治之</strong>  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-inter.png">  </p>
<h3 id="微服务起源"><a href="#微服务起源" class="headerlink" title="微服务起源"></a>微服务起源</h3><h4 id="Q：SOA-面向服务的架构模式-和微服务是什么关系？"><a href="#Q：SOA-面向服务的架构模式-和微服务是什么关系？" class="headerlink" title="Q：SOA(面向服务的架构模式)和微服务是什么关系？"></a>Q：SOA(面向服务的架构模式)和微服务是什么关系？</h4><p>A:可以把微服务想成是SOA的一种实践。  </p>
<ul>
<li>小即是美：  </li>
<li>单一职责：  </li>
<li>尽可能早地创造原型：  </li>
<li>可移植性比效率更重要：</li>
</ul>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ms-ma-database.png">  </p>
<h3 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h3><p>定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。  </p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>原子服务  </li>
<li>独立进程  </li>
<li>隔离部署  </li>
<li>去中心化服务治理</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>基础设施的建设、复杂度高</li>
</ul>
<h3 id="微服务不足"><a href="#微服务不足" class="headerlink" title="微服务不足"></a>微服务不足</h3><ul>
<li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用<code>RPC</code>或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。  </li>
<li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。  </li>
<li>测试一个基于微服务的应用也是很复杂的任务。  </li>
<li>服务模块间的依赖，应用的升级有可能波及多个服务模块的修改。  </li>
<li>对运维基础设施的挑战比较大。</li>
</ul>
<h3 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h3><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过微服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需要新部署对应的服务进程。我们用<code>Go</code>实施一个微服务：  </p>
<ul>
<li>kit：一个微服务的基础库(框架)。  </li>
<li>service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务  </li>
<li>rpc + message queue：轻量级通讯</li>
</ul>
<p><strong>本质上等同于多个服务组合(compose)完成了一个完整的用户场景(usecase)。</strong>  </p>
<h3 id="重要-按业务组织服务"><a href="#重要-按业务组织服务" class="headerlink" title="(重要)按业务组织服务"></a>(重要)按业务组织服务</h3><p>按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关服务，后者是一种技术抽象服务不反应真实的业务。所以按照微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law.png">  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law2.png">  </p>
<p>我们的模式：大前端(移动&#x2F;Web) &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施(PaaS&#x2F;Saas)<br><strong>开发团队对软件在生产环境的运行负全部责任。</strong>  </p>
<h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><ul>
<li>数据去中心化  </li>
<li>治理去中心化  </li>
<li>技术去中心化</li>
</ul>
<p><strong>每个服务独享自身的数据存储设施(缓存、数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，这样有利于服务的独立性，隔离相关干扰。</strong>  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/qu-zhong-xin.png">  </p>
<h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><ul>
<li>CICD：Gitlab + Gitlab Hooks + k8s  </li>
<li>Testing：测试环境、单元测试、API自动化测试  </li>
<li>在线运行时：k8s，以及一系列Prometheus、ELK、Conrtol Panle</li>
</ul>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ji-chu-she-shi-zi-dong-hua.png">  </p>
<h3 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h3><p>著名的<code>Design For Failure</code>思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略了其中任何一点都属于对“分布式计算的误解”。  </p>
<ul>
<li>隔离  </li>
<li>超时控制  </li>
<li>负载保护  </li>
<li>限流  </li>
<li>降级  </li>
<li>重试  </li>
<li>负载均衡</li>
</ul>
<p>特别注意：<strong>服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。</strong>  </p>
<p>Be conserative in what you send, be liberal in what you accept.  </p>
<p>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。  </p>
<h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p>按照垂直功能进行拆分，对外暴露了一批微服务，但是缺乏统一的出口面临了不少困难：  </p>
<ul>
<li>客户端到微服务直接通信，强耦合；  </li>
<li>需要多次请求，客户端聚合数据，工作量巨大，延迟高；  </li>
<li>协议不利于统一，各个部门有差异，需要端来兼容；  </li>
<li>面向“端”的<code>API</code>适配，耦合到了内部服务；  </li>
<li>多终端兼容逻辑复杂，每个服务都需要处理；  </li>
<li>统一逻辑无法收敛，比如安全认证、限流。</li>
</ul>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-server.png">  </p>
<p><strong>要内聚模式配合。</strong>  </p>
<p>新增了一个<code>app-interface</code>用于统一的协议出口，在服务进行大量的<code>dataset join</code>，按照业务场景设计粗粒度的<code>API</code>，给后续服务的演进带来很多优势：  </p>
<ul>
<li>轻量交互：协议精简、聚合。  </li>
<li>差异服务：数据裁剪以及聚合、针对终端定制化<code>API</code>。  </li>
<li>动态升级：原有系统兼容升级，更新服务而非协议。  </li>
<li>沟通效率提升，协作模式演进为移动业务+网管小组。</li>
</ul>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/BFF.png">  </p>
<p><code>BFF</code>可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的<code>API</code>，方便无线设备接入访问后端服务。  </p>
<h4 id="single-point-of-failure"><a href="#single-point-of-failure" class="headerlink" title="single point of failure"></a>single point of failure</h4><p>严重代码缺陷或者流量洪峰可能引发集群宕机。  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/aws2.png"><br><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api2.png">  </p>
<ul>
<li>单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线<code>BFF</code>和多团队之间就出现不匹配的问题，团队之间沟通协调成本高，交付效率低下。  </li>
<li>很多横跨切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</li>
</ul>
<h4 id="跨横切面（Cross-Cutting-Concerns）"><a href="#跨横切面（Cross-Cutting-Concerns）" class="headerlink" title="跨横切面（Cross-Cutting Concerns）"></a>跨横切面（Cross-Cutting Concerns）</h4><p>跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 <code>APIGateway</code> 进行了分层处理  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api-gateway.png">  </p>
<p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。  </p>
<p>我们业务流量实际为：移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice，在FE Web业务中，BFF 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4&#x2F;7层负载均衡(ELB)。  </p>
<p>注：4层负载均衡可能是——LVS&#x2F;F5&#x2F;NetScala，7层负载均衡——Nginx&#x2F;ELB、SLB&#x2F;API Gateway&#x2F;BFS。  </p>
<h3 id="Mircoservice-划分"><a href="#Mircoservice-划分" class="headerlink" title="Mircoservice 划分"></a>Mircoservice 划分</h3><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/bounded-context.png">  </p>
<p>微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(BusinessCapability)或是 DDD 的限界上下文(BoundedContext)。  </p>
<ul>
<li><p>Business Capability<br>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。  </p>
</li>
<li><p>Bounded Context<br>限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。这本质上也促进了组织结构的演进：Service perteam</p>
</li>
</ul>
<p>CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。  </p>
<p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog 以及订阅binlog 的中间件canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。  </p>
<p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/CRQS.png">  </p>
<p>我们架构也从 Polling publisher -&gt; Transaction logtailing 进行了演进(Pull vs Push)  </p>
<h2 id="gRPC-amp-服务实现"><a href="#gRPC-amp-服务实现" class="headerlink" title="gRPC &amp; 服务实现"></a>gRPC &amp; 服务实现</h2><h2 id="多集群-amp-多租户"><a href="#多集群-amp-多租户" class="headerlink" title="多集群 &amp; 多租户"></a>多集群 &amp; 多租户</h2>]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>微服务</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-日志&amp;指标&amp;链路追踪</title>
    <url>/2021/05/10/goatc-10-log-metrics-and-link-tracking/</url>
    <content><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p><a href="https://github.com/golang/glog">https://github.com/golang/glog</a> 是 google 提供的一个不维护的日志库，glog 有其他语言的一些版本，对我当时使用 log 库有很大的影响。它包含如下日志级别：  </p>
<ul>
<li>Info  </li>
<li>Warning  </li>
<li>Error  </li>
<li>Fatal(会中断程序执行)</li>
</ul>
<p>还有类似 log4go，loggo，zap 等其他第三方日志库，他们还提供了设置日志级别的可见行，一般提供日志级别：  </p>
<ul>
<li>Trace  </li>
<li>Debug  </li>
<li>Info  </li>
<li>Warning  </li>
<li>Error  </li>
<li>Critical</li>
</ul>
<h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>没人看警告，因为从定义上讲，没有什么出错。也许将来会出问题，但这听起来像是别人的问题。我们尽可能的消除警告级别，它要么是一条信息性消息，要么是一个错误。我们参考 Go 语言设计额哲学，所有警告都是错误，其他语言的 warning 都可以忽略，除非 IDE 或者在 CICD 流程中强制他们为 error，然后逼着程序员们尽可能去消除。同样的，如果想要最终消除 warning 可以记录为 error，让代码作者重视起来。  </p>
<h4 id="Fatal"><a href="#Fatal" class="headerlink" title="Fatal"></a>Fatal</h4><p>记录消息后，直接调用 os.Exit(1)，这意味着：  </p>
<ul>
<li>在其他 goroutine defer 语句不会被执行；  </li>
<li>各种 buffers 不会被 flush，包括日志的；  </li>
<li>临时文件或者目录不会被移除；</li>
</ul>
<p>不要使用 fatal 记录日志，而是向调用者返回错误。如果错误一直持续到 main.main。main.main 那就是在退出之前做处理任何清理操作的正确位置。  </p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>也有很多人，在错误发生的地方要立马记录日志，尤其要使用 error 级别记录。  </p>
<ul>
<li>处理 error；  </li>
<li>把 error 抛给调用者，在顶部打印日志；</li>
</ul>
<p>如果您选择通过日志记录来处理错误，那么根据定义，它不再是一个错误 — 您已经处理了它。记录错误的行为会处理错误，因此不再适合将其记录为错误。  </p>
<h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>相信只有两件事你应该记录：  </p>
<ul>
<li>开发人员在开发或调试软件时关心的事情。  </li>
<li>用户在使用软件时关心的事情。</li>
</ul>
<p>显然，它们分别是调试和信息级别。<br>log.Info 只需将该行写入日志输出。不应该有关闭它的选项，因为用户只应该被告知对他们有用的事情。如果发生了一个无法处理的错误，它就会抛出到 main.main。main.main 程序终止的地方。在最后的日志消息前面插入 fatal 前缀，或者直接写入 os.Stderr。<br>log.Debug，是完全不同的事情。它由开发人员或支持工程师控制。在开发过程中，调试语句应该是丰富的，而不必求助于 trace 或 debug2（您知道自己是谁）级别。日志包应该支持细粒度控制，以启用或禁用调试，并且只在包或更精细的范围内启用或禁用调试语句。  </p>
<p>我们如何设计和思考的：<a href="https://github.com/go-kratos/kratos/tree/v2.0.x/log">https://github.com/go-kratos/kratos/tree/v2.0.x/log</a>  </p>
<h3 id="日志选型"><a href="#日志选型" class="headerlink" title="日志选型"></a>日志选型</h3><p>一个完整的集中式日志系统，需要包含以下几个主要特点：  </p>
<ul>
<li>收集－能够采集多种来源的日志数据；  </li>
<li>传输－能够稳定的把日志数据传输到中央系统；  </li>
<li>存储－如何存储日志数据；  </li>
<li>分析－可以支持 UI 分析；  </li>
<li>警告－能够提供错误报告，监控机制；</li>
</ul>
<p>开源界鼎鼎大名 ELK stack，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。新增了一个 FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat 占用资源少，适合于在各个服务器上搜集日志后传输给 Logstash，官方也推荐此工具。  </p>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/elk.png">  </p>
<p>此架构由 Logstash 分布于各个节点上搜集相关日志、数据，并经过分析、过滤后发送给远端服务器上的 Elasticsearch 进行存储。  </p>
<p>Elasticsearch 将数据以分片的形式压缩存储并提供多种 API 供用户查询，操作。用户亦可以更直观的通过配置 Kibana Web方便的对日志查询，并根据数据生成报表。  </p>
<p>因为 logstash 属于 server 角色，必然出现流量集中式的热点问题，因此我们不建议使用这种部署方式，同时因为 还需要做大量 match 操作（格式化日志），消耗的 CPU 也很多，不利于 scale out。  </p>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/2.png">  </p>
<p>此种架构引入了消息队列机制，位于各个节点上的 Logstash Agent 先将数据&#x2F;日志传递给 Kafka，并将队列中消息或数据间接传递给 Logstash，Logstash 过滤、分析后将数据传递给Elasticsearch 存储。最后由 Kibana 将日志和数据呈现给用户。因为引入了 Kafka，所以即使远端 Logstash server 因故障停止运行，数据将会先被存储下来，从而避免数据丢失。  </p>
<p>更进一步的：将收集端 logstash 替换为 beats，更灵活，消耗资源更少，扩展性更强。  </p>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/3.png"><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/4.png">  </p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul>
<li>接入方式收敛；  </li>
<li>日志格式规范；  </li>
<li>日志解析对日志系统透明；  </li>
<li>系统高吞吐、低延迟；  </li>
<li>系统高可用、容量可扩展、高可运维性；</li>
</ul>
<h3 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h3><p>JSON作为日志的输出格式：  </p>
<ul>
<li>time: 日志产生时间，ISO8601格式；  </li>
<li>level: 日志等级，ERROR、WARN、 INFO、DEBUG；  </li>
<li>app_id: 应用id，用于标示日志来源；  </li>
<li>instance_id: 实例 id，用于区分同一应用不同实例，即 hostname；</li>
</ul>
<h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>日志从产生到可检索，经历几个阶段：  </p>
<ul>
<li>生产 &amp; 采集  </li>
<li>传输 &amp; 切分  </li>
<li>存储 &amp; 检索</li>
</ul>
<h4 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h4><p>logstash：  </p>
<ul>
<li>监听 tcp&#x2F;udp  </li>
<li>适用于通过网络上报日志的方式</li>
</ul>
<p>filebeat：  </p>
<ul>
<li>直接采集本地生成的日志文件  </li>
<li>适用于日志无法定制化输出的应用</li>
</ul>
<p>logagent：  </p>
<ul>
<li>物理机部署，监听 unixsocket  </li>
<li>日志系统提供各种语言 SDK  </li>
<li>直接读取本地日志文件</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/5.png">  </p>
<h4 id="logagent设计"><a href="#logagent设计" class="headerlink" title="logagent设计"></a>logagent设计</h4><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/6.png">  </p>
<h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>基于 flume + Kafka 统一传输平台<br>基于 LogID 做日志分流：  </p>
<ul>
<li>一般级别  </li>
<li>低级别  </li>
<li>高级别（ERROR）</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/7.png">  </p>
<h4 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h4><p>从kafka消费日志，解析日志，写入elasticsearch<br>bili-index: 自研，golang 开发，逻辑简单，性能 高, 可定制化方便。  </p>
<ul>
<li>日志规范产生的日志(log agent 收集)<br>logstash: es 官方组件，基于 jruby 开发，功能强大， 资源消耗高，性能低。  </li>
<li>处理未按照日志规范产生的日志(filebeat、logstash 收集)，需配置各种日志解析规则。</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/8.png">  </p>
<h4 id="存储和检索"><a href="#存储和检索" class="headerlink" title="存储和检索"></a>存储和检索</h4><p>elasticsearch多集群架构：日志分级、高可用<br>单数据集群内: master node + data node(hot&#x2F;stale) + client node  </p>
<ul>
<li>每日固定时间进行热-&gt;冷迁移  </li>
<li>Index 提前一天创建，基于 template 进行mapping 管理  </li>
<li>检索基于 kibana</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/9.png">  </p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>使用自定义协议，对 SDK 质量、版本升级都有比较高的要求，因此我们长期会使用“本地文件”的方案实现：<br>采集本地日志文件：位置不限，容器内 or 物理机<br>配置自描述：不做中心化配置，配置由 app&#x2F;paas 自身提供，agent 读取配置并生效<br>日志不重不丢：多级队列，能够稳定地处理日志收集过程中各种异常<br>可监控：实时监控运行状态<br>完善的自我保护机制：限制自身对于宿主机资源的消耗，限制发送速度  </p>
<h4 id="容器日志采集"><a href="#容器日志采集" class="headerlink" title="容器日志采集"></a>容器日志采集</h4><p>容器内应用日志采集：基于 overlay2，直接从物理机上查找对应日志文件。  </p>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/10.png">  </p>
<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><h3 id="设计目标-1"><a href="#设计目标-1" class="headerlink" title="设计目标"></a>设计目标</h3><ul>
<li>无处不在的部署  </li>
<li>持续的监控  </li>
<li>低消耗  </li>
<li>应用级的透明  </li>
<li>延展性  </li>
<li>低延迟</li>
</ul>
<h3 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h3><p>参考 Google Dapper 论文实现，为每个请求都生成一个全局唯一的 traceid，端到端透传到上下游所有节点，每一层生成一个 spanid，通过traceid 将不同系统孤立的调用日志和异常信息串联一起，通过 spanid 和 level 表达节点的父子关系。  </p>
<p>核心概念：  </p>
<ul>
<li>Tree  </li>
<li>Span  </li>
<li>Annotation</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/11.png">  </p>
<h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>在跟踪树结构中，树节点是整个架构的基本单元，而每一个节点又是对 span 的引用。虽然 span 在日志文件中只是简单的代表 span 的开始和结束时间，他们在整个树形结构中却是相对独立的。  </p>
<p>核心概念：  </p>
<ul>
<li>TraceID  </li>
<li>SpanID  </li>
<li>ParentID  </li>
<li>Family &amp; Title</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/12.png">  </p>
<h3 id="植入点"><a href="#植入点" class="headerlink" title="植入点"></a>植入点</h3><p>Dapper 可以以对应用开发者近乎零浸入的成本对分布式控制路径进行跟踪，几乎完全依赖于基于少量通用组件库的改造。如下：<br>当一个线程在处理跟踪控制路径的过程中，Dapper 把这次跟踪的上下文的在 ThreadLocal中进行存储，在 Go 语言中，约定每个方法首参数为 context（上下文）<br>覆盖通用的中间件&amp;通讯框架、不限于：redis、memcache、rpc、http、database、queue。  </p>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/13.png">  </p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/14.png">  </p>
<h3 id="跟踪消耗"><a href="#跟踪消耗" class="headerlink" title="跟踪消耗"></a>跟踪消耗</h3><p>处理跟踪消耗：  </p>
<ul>
<li>正在被监控的系统在生成追踪和收集追踪数据的消耗导致系统性能下降，  </li>
<li>需要使用一部分资源来存储和分析跟踪数据，是Dapper性能影响中最关键的部分：  <blockquote>
<p>因为收集和分析可以更容易在紧急情况下被关闭，ID生成耗时、创建Span等；<br>修改agent nice值，以防在一台高负载的服务器上发生cpu竞争；</p>
</blockquote>
</li>
</ul>
<p>采样：</p>
<ul>
<li>如果一个显着的操作在系统中出现一次，他就会出现上千次，基于这个事情我们不全量收集数据。</li>
</ul>
<p>有意思的论文：Uncertainty in Aggregate Estimates from Sampled Distributed Traces  </p>
<h3 id="跟踪采样"><a href="#跟踪采样" class="headerlink" title="跟踪采样"></a>跟踪采样</h3><p>固定采样，1&#x2F;1024：<br>这个简单的方案是对我们的高吞吐量的线上服务来说是非常有用，因为那些感兴趣的事件(在大吞吐量的情况下)仍然很有可能经常出现，并且通常足以被捕捉到。然而，在较低的采样率和较低的传输负载下可能会导致错过重要事件，而想用较高的采样率就需要能接受的性能损耗。对于这样的系统的解决方案就是覆盖默认的采样率，这需要手动干预的，这种情况是我们试图避免在 Dapper 中出现的。  </p>
<p>应对积极采样：<br>我们理解为单位时间期望采集样本的条目，在高 QPS 下，采样率自然下降，在低 QPS 下，采样率自然增加；比如1s内某个接口采集1条。  </p>
<p>二级采样：<br>容器节点数量多，即使使用积极采样仍然会导致采样样本非常多，所以需要控制写入中央仓库的数据的总规模，利用所有 span 都来自一个特定的跟踪并分享同一个 traceid 这个事实，虽然这些 span 有可能横跨了数千个主机。  </p>
<p>对于在收集系统中的每一个 span，我们用hash算法把 traceid 转成一个标量Z ，这里0&lt;&#x3D;Z&lt;&#x3D;1，我们选择了运行期采样率，这样就可以优雅的去掉我们无法写入到仓库中的多余数据，我们还可以通过调节收集系统中的二级采样率系数来调整这个运行期采样率，最终我们通过后端存储压力把策略下发给 agent采集系统，实现精准的二级采样。  </p>
<p>下游采样：<br>越被依赖多的服务，网关层使用积极采样以后，对于 downstream 的服务采样率仍然很高。  </p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>搜索：按照 Family（服务名）、Title（接口）、时间、调用者等维度进行搜索<br>详情：根据单个 traceid，查看整体链路信息，包含 span、level 统计，span 详情，依赖的服务、组件信息等；<br>全局依赖图：由于服务之间的依赖是动态改变的，所以不可能仅从配置信息上推断出所有这些服务之间的依赖关系，能够推算出任务各自之间的依赖，以及任务和其他软件组件之间的依赖。<br>依赖搜索：搜索单个服务的依赖情况，方便我们做“异地多活”时候来全局考虑资源的部署情况，以及区分服务是否属于多活范畴，也可以方便我们经常性的梳理依赖服务和层级来优化我们的整体架构可用性。<br>推断环依赖：一个复杂的业务架构，很难避免全部是层级关系的调用，但是我们要尽可能保证一点：调用栈永远向下，即：不产生环依赖。  </p>
<h3 id="经验-amp-优化"><a href="#经验-amp-优化" class="headerlink" title="经验&amp;优化"></a>经验&amp;优化</h3><p>性能优化：<br>1、不必要的串行调用；2、缓存读放大；3、数据库写放大；4、服务接口聚合调用；  </p>
<p>异常日志系统集成：<br>如果这些异常发生在 Dapper 跟踪采样的上下文中，那么相应的 traceid 和 spanid 也会作为元数据记录在异常日志中。异常监测服务的前端会提供一个链接，从特定的异常信息的报告直接导向到他们各自的分布式跟踪；  </p>
<p>用户日志集成：<br>在请求的头中返回 traceid，当用户遇到故障或者上报客服我们可以根据 traceid 作为整个请求链路的关键字，再根据接口级的服务依赖接口所涉及的服务并行搜索 ES Index，聚合排序数据，就比较直观的诊断问题了；  </p>
<p>容量预估：<br>根据入口网关服务，推断整体下游服务的调用扇出来精确预估流量再各个系统的占比；  </p>
<p>网络热点&amp;易故障点：<br>我们内部 RPC 框架还不够统一，以及基础库的组件部分还没解决拿到应用层协议大小，如果我们收集起来，可以很简单的实现流量热点、机房热点、异常流量等情况。同理容易失败的 span，很容易统计出来，方便我们辨识服务的易故障点；  </p>
<p>opentraceing：<br>标准化的推广，上面几个特性，都依赖 span TAG 来进行计算，因此我们会逐步完成标准化协议，也更方便我们开源，而不是一个内部“特殊系统”；  </p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Monitoring：  </p>
<ul>
<li>延迟、流量、错误、饱和度  </li>
<li>长尾问题  </li>
<li>依赖资源 (Client&#x2F;Server ‘s view)</li>
</ul>
<p>opentracing (Google Dapper)：  </p>
<ul>
<li>jaeger  </li>
<li>zipkin</li>
</ul>
<p>Logging：  </p>
<ul>
<li>traceid关联</li>
</ul>
<p>Metric：  </p>
<ul>
<li>Prometheus + Granfana</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/15.png">  </p>
<p>涉及到 net、cache、db、rpc 等资源类型的基础库，首先监控维度4个黄金指标：  </p>
<ul>
<li>延迟（耗时，需要区分正常还是异常）  </li>
<li>流量（需要覆盖来源，即：caller）  </li>
<li>错误（覆盖错误码或者 HTTP Status Code）  </li>
<li>饱和度（服务容量有多“满”）</li>
</ul>
<p>系统层面：  </p>
<ul>
<li>CPU，Memory，IO，Network，TCP&#x2F;IP 状态等，FD（等其他），Kernel：Context Switch  </li>
<li>Runtime：各类 GC、Mem 内部状态等</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/16.png">  </p>
<ul>
<li>线上打开 Profiling 的端口；  </li>
<li>使用服务发现找到节点信息，以及提供快捷的方式快速可以 WEB 化查看进程的 Profiling 信息（火焰图等）；  </li>
<li>watchdog，使用内存、CPU 等信号量触发自动采集；</li>
</ul>
<p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-1.png"><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-2.png">  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging">https://dave.cheney.net/2015/11/05/lets-talk-about-logging</a><br><a href="https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html">https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern">https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern</a><br><a href="https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe">https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe</a><br><a href="https://developer.aliyun.com/article/703229">https://developer.aliyun.com/article/703229</a><br><a href="https://developer.aliyun.com/article/204554">https://developer.aliyun.com/article/204554</a><br><a href="https://developer.aliyun.com/article/251629">https://developer.aliyun.com/article/251629</a><br><a href="https://www.elastic.co/cn/what-is/elk-stack">https://www.elastic.co/cn/what-is/elk-stack</a><br><a href="https://my.oschina.net/itblog/blog/547250">https://my.oschina.net/itblog/blog/547250</a><br><a href="https://www.cnblogs.com/aresxin/p/8035137.html">https://www.cnblogs.com/aresxin/p/8035137.html</a><br><a href="https://www.elastic.co/cn/products/beats/filebeat">https://www.elastic.co/cn/products/beats/filebeat</a><br><a href="https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html">https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/logstash">https://www.elastic.co/cn/products/logstash</a><br><a href="https://www.elastic.co/guide/en/logstash/5.6/index.html">https://www.elastic.co/guide/en/logstash/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/kibana">https://www.elastic.co/cn/products/kibana</a><br><a href="https://www.elastic.co/guide/en/kibana/5.5/index.html">https://www.elastic.co/guide/en/kibana/5.5/index.html</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html</a><br><a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a><br><a href="https://blog.aliasmee.com/post/graylog-log-system-architecture/">https://blog.aliasmee.com/post/graylog-log-system-architecture/</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-SRE</title>
    <url>/2021/09/19/goatc-11-sre/</url>
    <content><![CDATA[<h2 id="SRE方法论"><a href="#SRE方法论" class="headerlink" title="SRE方法论"></a>SRE方法论</h2><h3 id="确保长期关注研发工作"><a href="#确保长期关注研发工作" class="headerlink" title="确保长期关注研发工作"></a>确保长期关注研发工作</h3><p>所有的产品事故都应该有总结，无论有没有触发报警。  </p>
<h3 id="在保障服务SLO的前提下最大化迭代速度"><a href="#在保障服务SLO的前提下最大化迭代速度" class="headerlink" title="在保障服务SLO的前提下最大化迭代速度"></a>在保障服务SLO的前提下最大化迭代速度</h3><p>错误预算，发布策略。  </p>
<h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>alert、ticket、logging。  </p>
<h3 id="应急事件处理"><a href="#应急事件处理" class="headerlink" title="应急事件处理"></a>应急事件处理</h3><ul>
<li>MTTF + MTTR  </li>
<li>预案 playbook 最佳方法</li>
</ul>
<h3 id="变更管理：70-的生产事故来自变更而触发"><a href="#变更管理：70-的生产事故来自变更而触发" class="headerlink" title="变更管理：70%的生产事故来自变更而触发"></a>变更管理：70%的生产事故来自变更而触发</h3><ul>
<li>采用渐进式的发布机制  </li>
<li>迅速而准确地检测到问题的发生  </li>
<li>当发现问题时，安全迅速地回退变动</li>
</ul>
<h3 id="需求预测和容量规划：自然增长-非自然增长"><a href="#需求预测和容量规划：自然增长-非自然增长" class="headerlink" title="需求预测和容量规划：自然增长 + 非自然增长"></a>需求预测和容量规划：自然增长 + 非自然增长</h3><ul>
<li>必须有一个准确的自然增长需求预测模型，需求预测的时间应该超过资源获取的时间  </li>
<li>规划中必须有准备的非自然增长需求来源的统计  </li>
<li>必须有周期性的压力测试，以便准备地将系统原始资源与业务容量对应起来</li>
</ul>
<h3 id="资源部署"><a href="#资源部署" class="headerlink" title="资源部署"></a>资源部署</h3><p>变更管理与容量规划的结合物。  </p>
<h3 id="效率与性能"><a href="#效率与性能" class="headerlink" title="效率与性能"></a>效率与性能</h3><ul>
<li>持续的优化资源利用率，有效地降低系统的总成本  </li>
<li>根据一个预设的延迟目标部署和维护足够的容量</li>
</ul>
<p><strong>我是一名软件工程师，这是我如何来应付重复劳动的办法。</strong>  </p>
<h2 id="Oncall"><a href="#Oncall" class="headerlink" title="Oncall"></a>Oncall</h2><h3 id="面向终端用户的服务，时间为5分钟。而非敏感的业务通常来说是30分钟"><a href="#面向终端用户的服务，时间为5分钟。而非敏感的业务通常来说是30分钟" class="headerlink" title="面向终端用户的服务，时间为5分钟。而非敏感的业务通常来说是30分钟"></a>面向终端用户的服务，时间为5分钟。而非敏感的业务通常来说是30分钟</h3><h3 id="多个渠道可以收到报警（不限于邮件、短信、自动电话呼叫）"><a href="#多个渠道可以收到报警（不限于邮件、短信、自动电话呼叫）" class="headerlink" title="多个渠道可以收到报警（不限于邮件、短信、自动电话呼叫）"></a>多个渠道可以收到报警（不限于邮件、短信、自动电话呼叫）</h3><h3 id="响应时间和业务的可靠性有关，如果服务为99-99-，那么每个季度有13分钟的不可用时间，所以oncall工程师要分钟级响应生产事故"><a href="#响应时间和业务的可靠性有关，如果服务为99-99-，那么每个季度有13分钟的不可用时间，所以oncall工程师要分钟级响应生产事故" class="headerlink" title="响应时间和业务的可靠性有关，如果服务为99.99%，那么每个季度有13分钟的不可用时间，所以oncall工程师要分钟级响应生产事故"></a>响应时间和业务的可靠性有关，如果服务为99.99%，那么每个季度有13分钟的不可用时间，所以oncall工程师要分钟级响应生产事故</h3><h3 id="一旦收到报警信息，工程师必须确认（ack），要能够及时定位问题并且尝试解决问题，必要的话要升级（escalate）请求支援"><a href="#一旦收到报警信息，工程师必须确认（ack），要能够及时定位问题并且尝试解决问题，必要的话要升级（escalate）请求支援" class="headerlink" title="一旦收到报警信息，工程师必须确认（ack），要能够及时定位问题并且尝试解决问题，必要的话要升级（escalate）请求支援"></a>一旦收到报警信息，工程师必须确认（ack），要能够及时定位问题并且尝试解决问题，必要的话要升级（escalate）请求支援</h3><h3 id="一般主oncall人值班，副oncall作为辅助，通常团队也可以彼此作为副oncall，互相值班，共同分担工作压力"><a href="#一般主oncall人值班，副oncall作为辅助，通常团队也可以彼此作为副oncall，互相值班，共同分担工作压力" class="headerlink" title="一般主oncall人值班，副oncall作为辅助，通常团队也可以彼此作为副oncall，互相值班，共同分担工作压力"></a>一般主oncall人值班，副oncall作为辅助，通常团队也可以彼此作为副oncall，互相值班，共同分担工作压力</h3><h3 id="oncall值班过程中，轮值工程师必须有足够的时间处理紧急事件和后续跟进工作，例如写事故报告"><a href="#oncall值班过程中，轮值工程师必须有足够的时间处理紧急事件和后续跟进工作，例如写事故报告" class="headerlink" title="oncall值班过程中，轮值工程师必须有足够的时间处理紧急事件和后续跟进工作，例如写事故报告"></a>oncall值班过程中，轮值工程师必须有足够的时间处理紧急事件和后续跟进工作，例如写事故报告</h3><h3 id="在面临挑战时，一个人会主动或者非主动选择下联方式处理："><a href="#在面临挑战时，一个人会主动或者非主动选择下联方式处理：" class="headerlink" title="在面临挑战时，一个人会主动或者非主动选择下联方式处理："></a>在面临挑战时，一个人会主动或者非主动选择下联方式处理：</h3><ul>
<li>依赖直觉，自动化、快速行动  </li>
<li>理性、专注、有意识的进行认知类活动</li>
</ul>
<h3 id="当处理负载系统问题时，第二种行事方式是更好的，可能产生更好的处理结果，以及计划更周全的执行过程"><a href="#当处理负载系统问题时，第二种行事方式是更好的，可能产生更好的处理结果，以及计划更周全的执行过程" class="headerlink" title="当处理负载系统问题时，第二种行事方式是更好的，可能产生更好的处理结果，以及计划更周全的执行过程"></a>当处理负载系统问题时，第二种行事方式是更好的，可能产生更好的处理结果，以及计划更周全的执行过程</h3><h3 id="凭直觉操作和快速响应看起来都是很有用的方法，但是这些方法都有自己的缺点。在有足够数据支撑的时候按步骤解决问题，同时不停地审核和验证目前所有的假设"><a href="#凭直觉操作和快速响应看起来都是很有用的方法，但是这些方法都有自己的缺点。在有足够数据支撑的时候按步骤解决问题，同时不停地审核和验证目前所有的假设" class="headerlink" title="凭直觉操作和快速响应看起来都是很有用的方法，但是这些方法都有自己的缺点。在有足够数据支撑的时候按步骤解决问题，同时不停地审核和验证目前所有的假设"></a>凭直觉操作和快速响应看起来都是很有用的方法，但是这些方法都有自己的缺点。在有足够数据支撑的时候按步骤解决问题，同时不停地审核和验证目前所有的假设</h3><h3 id="Oncall可以寻求外部帮助"><a href="#Oncall可以寻求外部帮助" class="headerlink" title="Oncall可以寻求外部帮助"></a>Oncall可以寻求外部帮助</h3><ul>
<li>清晰的问题升级路线  </li>
<li>清晰定义应急事件处理步骤  </li>
<li>无指责，对事不对人的文化氛围</li>
</ul>
<h3 id="系统太稳定，容易松懈，定期轮值以及进行灾难恢复演习"><a href="#系统太稳定，容易松懈，定期轮值以及进行灾难恢复演习" class="headerlink" title="系统太稳定，容易松懈，定期轮值以及进行灾难恢复演习"></a>系统太稳定，容易松懈，定期轮值以及进行灾难恢复演习</h3><h2 id="有效的故障排查手段"><a href="#有效的故障排查手段" class="headerlink" title="有效的故障排查手段"></a>有效的故障排查手段</h2><h3 id="通用的故障排查过程-发生故障的系统足够了解"><a href="#通用的故障排查过程-发生故障的系统足够了解" class="headerlink" title="通用的故障排查过程 + 发生故障的系统足够了解"></a>通用的故障排查过程 + 发生故障的系统足够了解</h3><h3 id="排查过程反复采用“假设-排除”"><a href="#排查过程反复采用“假设-排除”" class="headerlink" title="排查过程反复采用“假设- 排除”"></a>排查过程反复采用“假设- 排除”</h3><h3 id="收到报警时，先搞清问题的严重程度"><a href="#收到报警时，先搞清问题的严重程度" class="headerlink" title="收到报警时，先搞清问题的严重程度"></a>收到报警时，先搞清问题的严重程度</h3><ul>
<li>对于大型问题，立即声明一个全员参与的会议  </li>
<li>大不多数的人第一反应是立即开始故障排除过程，试图尽快找到问题根源，正确做法是：尽最大可能让系统恢复服务，止损  </li>
<li>快速定位问题时：保存问题现场，比如日志、监控等</li>
</ul>
<h3 id="监控系统记录了整个系统的监控指标，良好的Dashboard可以方便快速定位问题，比如Moni"><a href="#监控系统记录了整个系统的监控指标，良好的Dashboard可以方便快速定位问题，比如Moni" class="headerlink" title="监控系统记录了整个系统的监控指标，良好的Dashboard可以方便快速定位问题，比如Moni"></a>监控系统记录了整个系统的监控指标，良好的Dashboard可以方便快速定位问题，比如Moni</h3><h3 id="日志是另外一个无价之宝，日志记录每个操作的信息和对应的系统状态可以让你了解在某一个时刻整个组件究竟在做什么，比如Billions"><a href="#日志是另外一个无价之宝，日志记录每个操作的信息和对应的系统状态可以让你了解在某一个时刻整个组件究竟在做什么，比如Billions" class="headerlink" title="日志是另外一个无价之宝，日志记录每个操作的信息和对应的系统状态可以让你了解在某一个时刻整个组件究竟在做什么，比如Billions"></a>日志是另外一个无价之宝，日志记录每个操作的信息和对应的系统状态可以让你了解在某一个时刻整个组件究竟在做什么，比如Billions</h3><h3 id="链路追踪工具，比如Dapper"><a href="#链路追踪工具，比如Dapper" class="headerlink" title="链路追踪工具，比如Dapper"></a>链路追踪工具，比如Dapper</h3><h3 id="Debug客户端，以便了解这个组件在收到请求后具体返回了什么信息"><a href="#Debug客户端，以便了解这个组件在收到请求后具体返回了什么信息" class="headerlink" title="Debug客户端，以便了解这个组件在收到请求后具体返回了什么信息"></a>Debug客户端，以便了解这个组件在收到请求后具体返回了什么信息</h3><h3 id="最后一个修改：一个正常工作的系统，直到某种外力因素出现。"><a href="#最后一个修改：一个正常工作的系统，直到某种外力因素出现。" class="headerlink" title="最后一个修改：一个正常工作的系统，直到某种外力因素出现。"></a>最后一个修改：一个正常工作的系统，直到某种外力因素出现。</h3><p>一个配置文件修改，用户流量的改变，检查最近对系统的修改可能对查找问题根源很有帮助。  </p>
<p><img src="/2021/09/19/goatc-11-sre/test.png">  </p>
<h2 id="紧急事件响应"><a href="#紧急事件响应" class="headerlink" title="紧急事件响应"></a>紧急事件响应</h2><h3 id="不要慌，你不是一个人在战斗！"><a href="#不要慌，你不是一个人在战斗！" class="headerlink" title="不要慌，你不是一个人在战斗！"></a>不要慌，你不是一个人在战斗！</h3><h3 id="如果你感到自己难以应付，就去找更多人参与"><a href="#如果你感到自己难以应付，就去找更多人参与" class="headerlink" title="如果你感到自己难以应付，就去找更多人参与"></a>如果你感到自己难以应付，就去找更多人参与</h3><p>通知公司内的其他部门目前情况  </p>
<h3 id="经常性的进行灾难处理和应急响应演习"><a href="#经常性的进行灾难处理和应急响应演习" class="headerlink" title="经常性的进行灾难处理和应急响应演习"></a>经常性的进行灾难处理和应急响应演习</h3><p>大型测试中一定先测试回滚机制  </p>
<h3 id="应急响应要让其他人得到清晰和及时的事态更新"><a href="#应急响应要让其他人得到清晰和及时的事态更新" class="headerlink" title="应急响应要让其他人得到清晰和及时的事态更新"></a>应急响应要让其他人得到清晰和及时的事态更新</h3><h3 id="如果你想不到解决办法，那么就再更大的范围内需求帮助。找到更多的团队成员，寻求更多的帮助，但是要快。"><a href="#如果你想不到解决办法，那么就再更大的范围内需求帮助。找到更多的团队成员，寻求更多的帮助，但是要快。" class="headerlink" title="如果你想不到解决办法，那么就再更大的范围内需求帮助。找到更多的团队成员，寻求更多的帮助，但是要快。"></a>如果你想不到解决办法，那么就再更大的范围内需求帮助。找到更多的团队成员，寻求更多的帮助，但是要快。</h3><h3 id="紧急事件过后，别忘了留出一些时间书写事故报告。"><a href="#紧急事件过后，别忘了留出一些时间书写事故报告。" class="headerlink" title="紧急事件过后，别忘了留出一些时间书写事故报告。"></a>紧急事件过后，别忘了留出一些时间书写事故报告。</h3><h3 id="向过去学习，而不是重复它"><a href="#向过去学习，而不是重复它" class="headerlink" title="向过去学习，而不是重复它"></a>向过去学习，而不是重复它</h3><ul>
<li>没有什么比过去的事故记录是更好的学习材料了，公布和维护时候报告  </li>
<li>在记录中请务必诚实，事务巨细，时刻寻找如何能在战术以及战略上避免这项事故的发生。  </li>
<li>确保自己和其他人切实完成事故中总结的代办事项。</li>
</ul>
<h2 id="紧急事故管理"><a href="#紧急事故管理" class="headerlink" title="紧急事故管理"></a>紧急事故管理</h2><h3 id="无流程管理的紧急事故"><a href="#无流程管理的紧急事故" class="headerlink" title="无流程管理的紧急事故"></a>无流程管理的紧急事故</h3><ul>
<li>过于关注技术问题  </li>
<li>沟通不畅  </li>
<li>不请自来</li>
</ul>
<h3 id="事故总控、事务处理团队、发言人"><a href="#事故总控、事务处理团队、发言人" class="headerlink" title="事故总控、事务处理团队、发言人"></a>事故总控、事务处理团队、发言人</h3><h3 id="什么时候对外宣布事故"><a href="#什么时候对外宣布事故" class="headerlink" title="什么时候对外宣布事故"></a>什么时候对外宣布事故</h3><ul>
<li>是否需要引入第二个团队来帮助处理问题？  </li>
<li>这次事故是否正在影响最终用户？  </li>
<li>在集中分析一小时后，这个问题是否依然没有得到解决？</li>
</ul>
<h3 id="划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场"><a href="#划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场" class="headerlink" title="划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场"></a>划分优先级：控制影响范围，恢复服务，同时为根源调查保存现场</h3><h3 id="事前准备：事先和所有事故处理参与者一起准备一套流程"><a href="#事前准备：事先和所有事故处理参与者一起准备一套流程" class="headerlink" title="事前准备：事先和所有事故处理参与者一起准备一套流程"></a>事前准备：事先和所有事故处理参与者一起准备一套流程</h3><h3 id="信任：充分相信每个事故处理参与者，分配职责后让他们主动行动"><a href="#信任：充分相信每个事故处理参与者，分配职责后让他们主动行动" class="headerlink" title="信任：充分相信每个事故处理参与者，分配职责后让他们主动行动"></a>信任：充分相信每个事故处理参与者，分配职责后让他们主动行动</h3><h3 id="反思：在事故处理过程中注意自己的情绪和精神状态。如果发现自己开始惊慌失措或者干到压力难以承受，应该需求更多的帮助"><a href="#反思：在事故处理过程中注意自己的情绪和精神状态。如果发现自己开始惊慌失措或者干到压力难以承受，应该需求更多的帮助" class="headerlink" title="反思：在事故处理过程中注意自己的情绪和精神状态。如果发现自己开始惊慌失措或者干到压力难以承受，应该需求更多的帮助"></a>反思：在事故处理过程中注意自己的情绪和精神状态。如果发现自己开始惊慌失措或者干到压力难以承受，应该需求更多的帮助</h3><h3 id="考虑替代方案：周期性地重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行其他更要要或者更紧急的事情"><a href="#考虑替代方案：周期性地重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行其他更要要或者更紧急的事情" class="headerlink" title="考虑替代方案：周期性地重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行其他更要要或者更紧急的事情"></a>考虑替代方案：周期性地重新审视目前的情况，重新评估目前的工作是否应该继续执行，还是需要执行其他更要要或者更紧急的事情</h3><h3 id="练习：平时不断地使用这项流程，知道习惯成自然"><a href="#练习：平时不断地使用这项流程，知道习惯成自然" class="headerlink" title="练习：平时不断地使用这项流程，知道习惯成自然"></a>练习：平时不断地使用这项流程，知道习惯成自然</h3><h3 id="换位思考：上次你是事故总控负责人吗？鼓励每个团队成员熟悉流程中的其他角色"><a href="#换位思考：上次你是事故总控负责人吗？鼓励每个团队成员熟悉流程中的其他角色" class="headerlink" title="换位思考：上次你是事故总控负责人吗？鼓励每个团队成员熟悉流程中的其他角色"></a>换位思考：上次你是事故总控负责人吗？鼓励每个团队成员熟悉流程中的其他角色</h3><h2 id="事后总结：从失败中学习"><a href="#事后总结：从失败中学习" class="headerlink" title="事后总结：从失败中学习"></a>事后总结：从失败中学习</h2><ul>
<li>避免指责，提供建设性意见  </li>
<li>用户可见的宕机时间或者服务质量降低程度达到一定标准  </li>
<li>任何类型的数据丢失  </li>
<li>on-call工程师需要人工介入的事故（包括回滚，切换用户流量等  </li>
<li>问题解决耗时超过一定时间  </li>
<li>监控问题（预示着问题是由人工发现的，而非报警系统）</li>
</ul>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-异常处理</title>
    <url>/2021/05/02/goatc-2-error/</url>
    <content><![CDATA[<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Golang的<code>error</code>就是普通的一个接口  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。  </p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>引入了 exception，但是无法知道被调用方会抛出什么异常。  </p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。  </p>
<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。  </p>
<p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。  </p>
<p>Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。  </p>
<p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。  </p>
<p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。<br>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。  </p>
<p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you only need to check the error value if you care about the result.  -- Dave  </span><br><span class="line">This blog post from Microsoft’s engineering blog in 2005 still holds true today, namely:  </span><br><span class="line">My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</span><br></pre></td></tr></table></figure>

<ul>
<li>简单。  </li>
<li>考虑失败，而不是成功(Plan for failure, not success)。  </li>
<li>没有隐藏的控制流。  </li>
<li>完全交给你来控制 error。  </li>
<li>Error are values。</li>
</ul>
<h2 id="Error-Type"><a href="#Error-Type" class="headerlink" title="Error Type"></a>Error Type</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>类似的 io.EOF，更底层的 syscall.ENOENT。  </p>
<p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 &#x3D;&#x3D; 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。  </p>
<p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 &#x3D;&#x3D; ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。  </p>
<ul>
<li><p>不依赖检查 error.Error 的输出。<br>不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。  </p>
</li>
<li><p>Sentinel errors 成为你 API 公共部分<br>如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。<br>如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。<br>比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。  </p>
</li>
<li><p>Sentinel errors 在两个包之间创建了依赖<br>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。  </p>
</li>
<li><p>结论: 尽可能避免 sentinel errors<br>我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p>
</li>
</ul>
<p><strong>Error type 是实现了 error 接口的自定义类型。</strong>  </p>
<h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。<br>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。<br>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。  </p>
<ul>
<li>Assert errors for behaviour, not type<br>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。</li>
</ul>
<h2 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h2><h3 id="Indented-flow-is-for-errors"><a href="#Indented-flow-is-for-errors" class="headerlink" title="Indented flow is for errors"></a>Indented flow is for errors</h3><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。  </p>
<h3 id="Eliminate-error-handling-by-eliminating-errors"><a href="#Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="Eliminate error handling by eliminating errors"></a>Eliminate error handling by eliminating errors</h3><p>(后面再细说)  </p>
<h3 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h3><p>在程序的顶部，程序的主体将把错误打印到屏幕或日志文件中，打印出来的只是：没有这样的文件或目录。  </p>
<p>没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。  </p>
<p>这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败。  </p>
<p>Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，它可能包含一个半写的 JSON 片段。  </p>
<p>由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。  </p>
<p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。  </p>
<ul>
<li>错误要被日志记录。  </li>
<li>应用程序处理错误，保证100%完整性。  </li>
<li>之后不再报告当前错误。</li>
</ul>
<h2 id="Go-1-13-errors"><a href="#Go-1-13-errors" class="headerlink" title="Go 1.13 errors"></a>Go 1.13 errors</h2><p>最简单的错误检查：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？  </p>
<h2 id="Go-2-Error-Inspection"><a href="#Go-2-Error-Inspection" class="headerlink" title="Go 2 Error Inspection"></a>Go 2 Error Inspection</h2><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a>  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>error</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-并行编程</title>
    <url>/2021/05/02/goatc-3-concurrency/</url>
    <content><![CDATA[<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。<br>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。  </p>
<p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。  </p>
<h2 id="Goroutines-and-Parallelism"><a href="#Goroutines-and-Parallelism" class="headerlink" title="Goroutines and Parallelism"></a>Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。  </p>
<p><strong>Concurrency is not Parallelism.（并行不意味着并发）</strong>  </p>
<p>并发(可以同时做)不是并行(不同的执行单元)。  </p>
<p>并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。  </p>
<h3 id="Keep-your-busy-or-do-the-work-yourself"><a href="#Keep-your-busy-or-do-the-work-yourself" class="headerlink" title="Keep your busy or do the work yourself"></a>Keep your busy or do the work yourself</h3><p>空的select语句将永远堵塞：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Sprintln(w, <span class="string">&quot;Hello，GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Incomplete-Work"><a href="#Incomplete-Work" class="headerlink" title="Incomplete Work"></a>Incomplete Work</h3><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a>  </p>
<p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync&#x2F;atomic 来保护数据。  </p>
<h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a &#x3D; 1;b &#x3D; 2;，另一个 goroutine 可能看到 b 在 a 之前更新。  </p>
<h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。  </p>
<h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。  </p>
<p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。  </p>
<p>Do not communicate by sharing memory; instead, share memory by communicating.  </p>
<h3 id="Detecting-Race-Conditions-With-Go"><a href="#Detecting-Race-Conditions-With-Go" class="headerlink" title="Detecting Race Conditions With Go"></a>Detecting Race Conditions With Go</h3><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。  </p>
<p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3/8.go</span><br><span class="line">go build -race</span><br><span class="line">go test -race</span><br></pre></td></tr></table></figure>

<h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h3><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。  </p>
<h3 id="Unbuffered-Channels"><a href="#Unbuffered-Channels" class="headerlink" title="Unbuffered Channels"></a>Unbuffered Channels</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。  </p>
<p>无缓冲信道的本质是保证同步。  </p>
<h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。  </p>
<h3 id="Latencies-due-to-under-sized-buffer"><a href="#Latencies-due-to-under-sized-buffer" class="headerlink" title="Latencies due to under-sized buffer"></a>Latencies due to under-sized buffer</h3><p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。  </p>
<h3 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h3><ul>
<li><p>Timing out  </p>
</li>
<li><p>Moving on</p>
</li>
<li><p>Pipeline</p>
</li>
<li><p>Fan-out, Fan-in</p>
</li>
<li><p>Cancellation<br>Close 先于 Receive 发生(类似 Buffered)。<br>不需要传递数据，或者传递 nil。<br>非常适合去掉和超时控制。  </p>
</li>
<li><p>Contex<br><a href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p>
</li>
</ul>
<h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><h3 id="Request-scoped-context"><a href="#Request-scoped-context" class="headerlink" title="Request-scoped context"></a>Request-scoped context</h3><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。  </p>
<p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。  </p>
<h3 id="Do-not-store-Contexts-inside-a-struct-type"><a href="#Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="Do not store Contexts inside a struct type"></a>Do not store Contexts inside a struct type</h3><h3 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue"></a>context.WithValue</h3><h3 id="Debugging-or-tracing-data-is-safe-to-pass-in-a-Context"><a href="#Debugging-or-tracing-data-is-safe-to-pass-in-a-Context" class="headerlink" title="Debugging or tracing data is safe to pass in a Context"></a>Debugging or tracing data is safe to pass in a Context</h3><h3 id="When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="When a Context is canceled, all Contexts derived from it are also canceled"></a>When a Context is canceled, all Contexts derived from it are also canceled</h3><h3 id="All-blocking-x2F-long-operations-should-be-cancelable"><a href="#All-blocking-x2F-long-operations-should-be-cancelable" class="headerlink" title="All blocking&#x2F;long operations should be cancelable"></a>All blocking&#x2F;long operations should be cancelable</h3><h2 id="Final-Notes"><a href="#Final-Notes" class="headerlink" title="Final Notes"></a>Final Notes</h2><ul>
<li>Incoming requests to a server should create a Context.  </li>
<li>Outgoing calls to servers should accept a Context.  </li>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.  </li>
<li>The chain of function calls between them must propagate the Context.  </li>
<li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.  </li>
<li>When a Context is canceled, all Contexts derived from it are also canceled.  </li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.  </li>
<li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.  </li>
<li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/">https://dave.cheney.net/2018/01/06/</a>  </p>
<p><code>if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</code>  </p>
<p><a href="http://blog.golang.org/race-detector">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/">https://medium.com/a-journey-with-go/</a>  </p>
<p><code>go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</code>  </p>
<p><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发</tag>
        <tag>goroutine</tag>
        <tag>channel</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-工程化实践</title>
    <url>/2021/05/04/goatc-4-go-engineering-practice/</url>
    <content><![CDATA[<h1 id="工程项目结构"><a href="#工程项目结构" class="headerlink" title="工程项目结构"></a>工程项目结构</h1><h2 id="Standard-Go-Project-Layout"><a href="#Standard-Go-Project-Layout" class="headerlink" title="Standard Go Project Layout"></a>Standard Go Project Layout</h2><h3 id="x2F-cmd"><a href="#x2F-cmd" class="headerlink" title="&#x2F;cmd"></a>&#x2F;cmd</h3><p>本项目的主干。<br>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，&#x2F;cmd&#x2F;myapp)。<br>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 &#x2F;pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 &#x2F;internal 目录中。  </p>
<h3 id="x2F-internal"><a href="#x2F-internal" class="headerlink" title="&#x2F;internal"></a>&#x2F;internal</h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 release notes。  </p>
<p>注意，你并不局限于顶级 internal 目录。在项目树的任何级别上都可以有多个内部目录。  </p>
<p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 &#x2F;internal&#x2F;app 目录下(例如 &#x2F;internal&#x2F;app&#x2F;myapp)，这些应用程序共享的代码可以放在 &#x2F;internal&#x2F;pkg 目录下(例如 &#x2F;internal&#x2F;pkg&#x2F;myprivlib)。</p>
<h3 id="x2F-pkg"><a href="#x2F-pkg" class="headerlink" title="&#x2F;pkg"></a>&#x2F;pkg</h3><p>外部应用程序可以使用的库代码(例如 &#x2F;pkg&#x2F;mypubliclib)。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。&#x2F;pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。  </p>
<p>&#x2F;pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。&#x2F;internla&#x2F;pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p>
<p><strong>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。</strong>  </p>
<h2 id="Kit-Project-Layout"><a href="#Kit-Project-Layout" class="headerlink" title="Kit Project Layout"></a>Kit Project Layout</h2><p>基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。  </p>
<p>by [Package Oriented Design]  </p>
<blockquote>
<p>“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”  </p>
</blockquote>
<p>kit 项目必须具备的特点:  </p>
<ul>
<li>统一</li>
<li>标准库方式布局</li>
<li>高度抽象</li>
<li>支持插件</li>
</ul>
<h2 id="Service-Application-Project-Layout"><a href="#Service-Application-Project-Layout" class="headerlink" title="Service Application Project Layout"></a>Service Application Project Layout</h2><h3 id="x2F-api"><a href="#x2F-api" class="headerlink" title="&#x2F;api"></a>&#x2F;api</h3><p>API 协议定义目录，xxapi.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。  </p>
<h3 id="x2F-configs"><a href="#x2F-configs" class="headerlink" title="&#x2F;configs"></a>&#x2F;configs</h3><p>配置文件模板或默认配置。  </p>
<h3 id="x2F-test"><a href="#x2F-test" class="headerlink" title="&#x2F;test"></a>&#x2F;test</h3><p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 &#x2F;test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 &#x2F;test&#x2F;data 或 &#x2F;test&#x2F;testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。<br>不应该包含：&#x2F;src  </p>
<p>有些 Go 项目确实有一个 src 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。不要将项目级别 src 目录与 Go 用于其工作空间的 src 目录。  </p>
<p>一个 gitlab 的 project 里可以放置多个微服务的app(类似 monorepo)。也可以按照 gitlab 的 group 里建立多个 project，每个 project 对应一个 app。<br>多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account&#x2F;vip&#x2F;*。<br>和 app 平级的目录 pkg 存放业务有关的公共库（非基础框架库）。如果应用不希望导出这些目录，可以放置到 myapp&#x2F;internal&#x2F;pkg 中。</p>
<h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>“A high-performance, open-source universal RPC framework”  </p>
<ul>
<li>多语言：语言中立，支持多种语言。</li>
<li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。<br>可插拔</li>
<li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li>
</ul>
<p>设计理念</p>
<ul>
<li><p>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这-些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。  </p>
</li>
<li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p>
</li>
<li><p>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML和Thrift。</p>
</li>
<li><p>流: Streaming API。</p>
</li>
<li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p>
</li>
<li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p>
</li>
<li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p>
</li>
</ul>
<p><strong>不要过早关注性能问题，先标准化。</strong>  </p>
<p>为了统一检索和规范 API，我们内部建立了一个统一的 bapis 仓库，整合所有对内对外 API。  </p>
<p>API 仓库，方便跨部门协作。<br>版本管理，基于 git 控制。<br>规范化检查，API lint。<br>API design review，变更 diff。<br>权限管理，目录 OWNERS。</p>
<h2 id="API-Compatibility"><a href="#API-Compatibility" class="headerlink" title="API Compatibility"></a>API Compatibility</h2><p>向后兼容(非破坏性)的修改<br>给 API 服务定义添加 API 接口<br>    从协议的角度来看，这始终是安全的。</p>
<p>给请求消息添加字段<br>    只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。</p>
<p>给响应消息添加字段<br>    在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</p>
<p>向后不兼容(破坏性)的修改<br>删除或重命名服务，字段，方法或枚举值<br>    从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改major 版本号。<br>修改字段的类型<br>    即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加major版本号。 对于编译型静态语言来说，会容易引入编译错误。<br>修改现有请求的可见行为<br>    客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。<br>给资源消息添加 读取&#x2F;写入 字段</p>
<h2 id="API-Naming-Conventions"><a href="#API-Naming-Conventions" class="headerlink" title="API Naming Conventions"></a>API Naming Conventions</h2><p>包名为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。<br>my.package.v1，为 API 目录，定义service相关接口，用于提供业务使用。</p>
<p>&#x2F;&#x2F; RequestURL: &#x2F;<package_name>.<version>.<service_name>&#x2F;{method}<br>package <package_name>.<version>;</version></package_name></service_name></version></package_name></p>
<h2 id="API-Primitive-Fields"><a href="#API-Primitive-Fields" class="headerlink" title="API Primitive Fields"></a>API Primitive Fields</h2><p>gRPC 默认使用 Protobuf v3 格式，因为去除了 required 和 optional 关键字，默认全部都是 optional 字段。如果没有赋值的字段，默认会基础类型字段的默认值，比如 0 或者 “”。<br>Protobuf v3 中，建议使用：<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br>Warpper 类型的字段，即包装一个 message，使用时变为指针。</p>
<p>Protobuf 作为强 schema 的描述文件，也可以方便扩展，是不是用于配置文件定义也可？</p>
<h2 id="API-Errors"><a href="#API-Errors" class="headerlink" title="API Errors"></a>API Errors</h2><p>使用一小组标准错误配合大量资源<br>例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 google.rpc.Code.NOT_FOUND 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息(&#x2F;google&#x2F;rpc&#x2F;error_details)。<br>错误传播<br>如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：<br>隐藏实现详细信息和机密信息。<br>调整负责该错误的一方。例如，从另一个服务接收 INVALID_ARGUMENT 错误的服务器应该将 INTERNAL 传播给它自己的调用者。</p>
<p>全局错误码<br>全局错误码，是松散、易被破坏契约的，基于我们上述讨论的，在每个服务传播错误的时候，做一次翻译，这样保证每个服务 + 错误枚举，应该是唯一的，而且在 proto 定义中是可以写出来文档的。</p>
<h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/gomods/athens</span><br><span class="line">https://goproxy.cn</span><br><span class="line"></span><br><span class="line">https://blog.golang.org/modules2019</span><br><span class="line">https://blog.golang.org/using-go-modules</span><br><span class="line">https://blog.golang.org/migrating-to-go-modules</span><br><span class="line">https://blog.golang.org/module-mirror-launch</span><br><span class="line">https://blog.golang.org/publishing-go-modules</span><br><span class="line">https://blog.golang.org/v2-go-modules</span><br><span class="line">https://blog.golang.org/module-compatibility</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="Unittest"><a href="#Unittest" class="headerlink" title="Unittest"></a>Unittest</h2><p>小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试会带来整体产品质量和数据验证。<br>不同类型的项目，对测试的需求不同，总体上有一个经验法则，即70&#x2F;20&#x2F;10原则：70%是小型测试，20%是中型测试，10%是大型测试。<br>如果一个项目是面向用户的，拥有较高的集成度，或者用户接口比较复杂，他们就应该有更多的中型和大型测试；如果是基础平台或者面向数据的项目，例如索引或网络爬虫，则最好有大量的小型测试，中型测试和大型测试的数量要求会少很多。</p>
<p>“自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误（译注：大小差一(off-by-one)错误是一类常见的程序设计错误）等方面的验证”<br>                                    - 《Google软件测试之道》</p>
<p>单元测试的基本要求：<br>快速<br>环境一致<br>任意顺序<br>并行</p>
<p>基于 docker-compose 实现跨平台跨语言环境的容器依赖管理方案，以解决运行 unittest 场景下的(mysql, redis, mc)容器依赖问题:<br>本地安装 Docker。<br>无侵入式的环境初始化。<br>快速重置环境。<br>随时随地运行(不依赖外部服务)。<br>语义式 API 声明资源。</p>
<p>真实外部依赖，而非 in-process 模拟。<br>正确的对容器内服务进行健康检测，避免unittest 启动时候资源还未 ready。<br>应该交由 app 自己来初始化数据，比如 db 的scheme，初始的 sql 数据等，为了满足测试的一致性，在每次结束后，都会销毁容器。<br>在单元测试开始前，导入封装好的 testing 库，方便启动和销毁容器。<br>对于 service 的单元测试，使用 gomock 等库把 dao mock 掉，所以在设计包的时候，应该面向抽象编程。<br>在本地执行依赖 Docker，在 CI 环境里执行Unittest，需要考虑在物理机里的 Docker 网络，或者在 Docker 里再次启动一个 Docker。</p>
<p>利用 go 官方提供的: Subtests  + Gomock 完成整个单元测试。<br>&#x2F;api<br>    比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。<br>&#x2F;data<br>    docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。<br>&#x2F;biz<br>    依赖  repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。<br>&#x2F;service<br>    依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。<br>基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a><br><a href="https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html">https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html</a><br><a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a><br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html">https://www.cnblogs.com/zxf330301/p/6534643.html</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641">https://blog.csdn.net/taobaojishu/article/details/106152641</a><br><a href="https://cloud.google.com/apis/design/errors">https://cloud.google.com/apis/design/errors</a><br><a href="https://kb.cnblogs.com/page/520743/">https://kb.cnblogs.com/page/520743/</a><br><a href="https://zhuanlan.zhihu.com/p/105466656">https://zhuanlan.zhihu.com/p/105466656</a><br><a href="https://zhuanlan.zhihu.com/p/105648986">https://zhuanlan.zhihu.com/p/105648986</a><br><a href="https://zhuanlan.zhihu.com/p/106634373">https://zhuanlan.zhihu.com/p/106634373</a><br><a href="https://zhuanlan.zhihu.com/p/107347593">https://zhuanlan.zhihu.com/p/107347593</a><br><a href="https://zhuanlan.zhihu.com/p/109048532">https://zhuanlan.zhihu.com/p/109048532</a><br><a href="https://zhuanlan.zhihu.com/p/110252394">https://zhuanlan.zhihu.com/p/110252394</a><br><a href="https://www.jianshu.com/p/dfa427762975">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.citerus.se/go-ddd/">https://www.citerus.se/go-ddd/</a><br><a href="https://www.citerus.se/part-2-domain-driven-design-in-go/">https://www.citerus.se/part-2-domain-driven-design-in-go/</a><br><a href="https://www.citerus.se/part-3-domain-driven-design-in-go/">https://www.citerus.se/part-3-domain-driven-design-in-go/</a><br><a href="https://www.jianshu.com/p/dfa427762975">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.jianshu.com/p/5732b69bd1a1">https://www.jianshu.com/p/5732b69bd1a1</a></p>
<p><a href="https://www.cnblogs.com/qixuejia/p/10789612.html">https://www.cnblogs.com/qixuejia/p/10789612.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/4390086.html">https://www.cnblogs.com/qixuejia/p/4390086.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/10789621.html">https://www.cnblogs.com/qixuejia/p/10789621.html</a><br><a href="https://zhuanlan.zhihu.com/p/46603988">https://zhuanlan.zhihu.com/p/46603988</a><br><a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a><br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641">https://blog.csdn.net/taobaojishu/article/details/106152641</a></p>
<p><a href="https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc">https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc</a><br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a><br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">https://www.youtube.com/watch?v=oL6JBUk6tj0</a><br><a href="https://github.com/zitryss/go-sample">https://github.com/zitryss/go-sample</a><br><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md">https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md</a><br><a href="https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f">https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a><br><a href="https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182">https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf">https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf</a><br><a href="https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/">https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a><br><a href="https://github.com/katzien/go-structure-examples">https://github.com/katzien/go-structure-examples</a><br><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0">https://www.youtube.com/watch?v=MzTcsI6tn-0</a><br><a href="https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/">https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/</a><br><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/</a><br><a href="https://github.com/google/wire/blob/master/docs/best-practices.md">https://github.com/google/wire/blob/master/docs/best-practices.md</a><br><a href="https://github.com/google/wire/blob/master/docs/guide.md">https://github.com/google/wire/blob/master/docs/guide.md</a><br><a href="https://blog.golang.org/wire">https://blog.golang.org/wire</a><br><a href="https://github.com/google/wire">https://github.com/google/wire</a><br><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html">https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html</a><br><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html">https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html</a><br><a href="https://blog.golang.org/examples">https://blog.golang.org/examples</a><br><a href="https://blog.golang.org/subtests">https://blog.golang.org/subtests</a><br><a href="https://blog.golang.org/cover">https://blog.golang.org/cover</a><br><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a><br><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a><br><a href="https://blog.golang.org/modules2019">https://blog.golang.org/modules2019</a><br><a href="https://blog.codecentric.de/en/2017/08/gomock-tutorial/">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a><br><a href="https://pkg.go.dev/github.com/golang/mock/gomock">https://pkg.go.dev/github.com/golang/mock/gomock</a><br><a href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1">https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1</a></p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>golang</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-微服务可用性设计</title>
    <url>/2021/05/05/goatc-5-microservice-availability-design/</url>
    <content><![CDATA[<h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。  </p>
<p>服务隔离：动静分离、读写分离<br>轻重隔离：核心、快慢、热点<br>物理隔离:线程、进程、集群、机房  </p>
<h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><h4 id="动静隔离"><a href="#动静隔离" class="headerlink" title="动静隔离:"></a>动静隔离:</h4><p>小到 CPU 的 cacheline false sharing、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速&#x2F;缓存访问变换频次小的。比如 CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:  </p>
<ul>
<li>降低应用服务器负载，静态文件访问负载全部通过CDN。  </li>
<li>对象存储存储费用最低。  </li>
<li>海量存储空间，无需考虑存储架构升级。  </li>
<li>静态CDN带宽加速，延迟低。</li>
</ul>
<h4 id="读写分离：主从、Replicaset、CQRS。"><a href="#读写分离：主从、Replicaset、CQRS。" class="headerlink" title="读写分离：主从、Replicaset、CQRS。"></a>读写分离：主从、Replicaset、CQRS。</h4><h3 id="轻重隔离"><a href="#轻重隔离" class="headerlink" title="轻重隔离"></a>轻重隔离</h3><h4 id="核心隔离"><a href="#核心隔离" class="headerlink" title="核心隔离"></a>核心隔离</h4><p>业务按照 Level 进行资源池划分(L0&#x2F;L1&#x2F;L2)。  </p>
<ul>
<li>核心&#x2F;非核心的故障域的差异隔离(机器资源、依赖资源)。  </li>
<li>多集群，通过冗余资源来提升吞吐和容灾能力。</li>
</ul>
<h4 id="快慢隔离"><a href="#快慢隔离" class="headerlink" title="快慢隔离"></a>快慢隔离</h4><p>我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。  </p>
<p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中(早期设计目的: 更好的顺序IO)，流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。  </p>
<ul>
<li>按照各种纬度隔离：sink、部门、业务、logid、重要性(S&#x2F;A&#x2F;B&#x2F;C)。</li>
</ul>
<p>业务日志也属于某个 logid，日志等级就可以作为隔离通道。  </p>
<h4 id="热点隔离"><a href="#热点隔离" class="headerlink" title="热点隔离"></a>热点隔离</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：  </p>
<ul>
<li>小表广播: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。  </li>
<li>主动预热: 比如直播房间页高在线情况下bypass 监控主动防御。</li>
</ul>
<h3 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h3><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。  </p>
<p>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。  </p>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>容器化(docker)，容器编排引擎(k8s)。  </p>
<h4 id="集群隔离"><a href="#集群隔离" class="headerlink" title="集群隔离"></a>集群隔离</h4><p>逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。  </p>
<h3 id="Case-Stduy"><a href="#Case-Stduy" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul>
<li>早期转码集群被超大视频攻击，导致转码大量延迟。  </li>
<li>入口Nginx(SLB)故障，影响全机房流量入口故障。  </li>
<li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。  </li>
<li>数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。  </li>
<li>INFO 日志量过大，导致异常 ERROR 日志采集延迟。</li>
</ul>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制，我们的组件能够快速失效(fail fast)，因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。  </p>
<ul>
<li>网路传递具有不确定性。  </li>
<li>客户端和服务端不一致的超时策略导致资源浪费。  </li>
<li>“默认值”策略。  </li>
<li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li>
</ul>
<h3 id="Case-Stduy-1"><a href="#Case-Stduy-1" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul>
<li>SLB 入口 Nginx 没配置超时导致连锁故障。  </li>
<li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。  </li>
<li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li>
</ul>
<h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：  </p>
<ul>
<li>假设限制2r&#x2F;s，则按照500毫秒的固定速率往桶中添加令牌。  </li>
<li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。  </li>
<li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。  </li>
<li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：  </p>
<ul>
<li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li>
<li>如果桶是空的，则不需流出水滴。</li>
<li>可以以任意速率流入水滴到漏桶。</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li>
</ul>
<h3 id="如何计算接近峰值时的系统吞吐？"><a href="#如何计算接近峰值时的系统吞吐？" class="headerlink" title="如何计算接近峰值时的系统吞吐？"></a>如何计算接近峰值时的系统吞吐？</h3><ul>
<li>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。  </li>
<li>Inflight: 当前服务中正在进行的请求的数量。  </li>
<li>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展(Auto Scaling)失效前都不会出现过载的情况。  </p>
<ul>
<li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li>
<li>QPS 限流</li>
<li>不同的请求可能需要数量迥异的资源来处理。</li>
<li>某种静态 QPS 限流不是特别准。</li>
</ul>
<p>给每个用户设置限制  </p>
<ul>
<li>全局过载发生时候，针对某些“异常”进行控制。  </li>
<li>一定程度的“超卖”配额。  </li>
<li>按照优先级丢弃。  </li>
<li>拒绝请求也需要成本。</li>
</ul>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。  </p>
<ul>
<li>单个大流量的接口，使用 redis 容易产生热点。  </li>
<li>pre-request 模式对性能有一定影响，高频的网络往返。</li>
</ul>
<p>Q：如何来分配资源？<br>A：“最大最小公平分享”(Max-Min Fairness)。  </p>
<p>最大最小公平分配算法的形式化定义如下：  </p>
<ul>
<li>资源按照需求递增的顺序进行分配。  </li>
<li>不存在用户得到的资源超过自己的需求。  </li>
<li>未得到满足的用户等价的分享资源。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><a href="./goatc-5-microservice-availability-design/fen-bu-shi-xian-liu.png"></a>  </p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性(criticality):  </p>
<ul>
<li>最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。  </li>
<li>重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。  </li>
<li>可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。  </li>
<li>可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</li>
</ul>
<p>gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。  </p>
<ul>
<li>全局配额不足时，优先拒绝低优先级的。  </li>
<li>全局配额，可以按照重要性分别设置。  </li>
<li>过载保护时，低优先级的请求先被拒绝。</li>
</ul>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。  </p>
<ul>
<li>服务依赖的资源出现大量错误。  </li>
<li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li>
</ul>
<h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。  </p>
<p>我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。  </p>
<h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。  </p>
<ul>
<li>客户端需要限制请求频次，retry backoff 做一定的请求退让。  </li>
<li>可以通过接口级别的error_details，挂载到每个 API 返回的响应里。</li>
</ul>
<h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><ul>
<li><p>二层缓存穿透、大量回源导致的核心服务故障。  </p>
</li>
<li><p>异常客户端引起的服务故障(query of death)<br>(1)请求放大。<br>(2)资源数放大。  </p>
</li>
<li><p>用户重试导致的大面积故障。</p>
</li>
</ul>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：  </p>
<ul>
<li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。  </li>
<li>当服务进入降级模式时，需要执行什么动作？  </li>
<li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li>
</ul>
<p>同时我们要考虑一下几点：  </p>
<ul>
<li>优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。  </li>
<li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。  </li>
<li>应该足够简单。</li>
</ul>
<p>降级本质为: <strong>提供有损服务。</strong>  </p>
<ul>
<li><p>UI 模块化，非核心模块降级。<br>BFF 层聚合 API，模块降级。  </p>
</li>
<li><p>页面上一次缓存副本。</p>
</li>
<li><p>默认值、热门推荐等。</p>
</li>
<li><p>流量拦截 + 定期数据缓存(过期副本策略)。  </p>
</li>
<li><p>处理策略<br>页面降级、延迟服务、写&#x2F;读降级、缓存降级<br>抛异常、返回约定协议、Mock 数据、Fallback 处理</p>
</li>
</ul>
<h3 id="Case-Study-1"><a href="#Case-Study-1" class="headerlink" title="Case Study"></a>Case Study</h3><ul>
<li>客户端解析协议失败，app 奔溃。  </li>
<li>客户端部分协议不兼容，导致页面失败。  </li>
<li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。  </li>
<li>没有 playbook，导致的 MTTR 上升。</li>
</ul>
<h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:  </p>
<ul>
<li>限制重试次数和基于重试分布的策略(重试比率: 10%)。  </li>
<li>随机化、指数型递增的重试周期: exponential ackoff + jitter。  </li>
<li>client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。  </li>
<li>只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</li>
</ul>
<h3 id="Case-Study-2"><a href="#Case-Study-2" class="headerlink" title="Case Study"></a>Case Study</h3><ul>
<li><p>Nginx upstream retry 过大，导致服务雪崩。  </p>
</li>
<li><p>业务不幂等，导致的重试，数据重复。<br>(1)全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>(2)去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>(3)多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。  </p>
</li>
<li><p>多层级重试传递，放大流量引起雪崩。</p>
</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>数据中心内部的负载均衡  </p>
<p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。  </p>
<p>目标：  </p>
<ul>
<li>均衡的流量分发。  </li>
<li>可靠的识别异常节点。  </li>
<li>scale-out，增加同质节点扩容。  </li>
<li>减少错误，提高可用性。</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>变更管理:<br>70％的问题是由变更引起的，恢复可用代码并不总是坏事。  </li>
<li>避免过载:<br>过载保护、流量调度等。  </li>
<li>依赖管理:<br>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。  </li>
<li>优雅降级:<br>有损服务，避免核心链路依赖故障。  </li>
<li>重试退避:<br>退让算法，冻结时间，API retry detail 控制策略。  </li>
<li>超时控制:<br>进程内 + 服务间 超时控制。  </li>
<li>极限压测 + 故障演练。  </li>
<li>扩容 + 重启 + 消除有害流量。</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml">http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml</a><br><a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/">http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/</a><br><a href="http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year">http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year</a><br><a href="https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c">https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd">https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect</a><br><a href="https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/">https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/</a><br><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf">https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf</a><br><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E4%BF%9D%E6%8A%A4">https://github.com/alibaba/Sentinel/wiki/系统负载保护</a><br><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782">https://blog.csdn.net/okiwilldoit/article/details/81738782</a><br><a href="http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html">http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><br><a href="https://blog.csdn.net/m0_38106113/article/details/81542863">https://blog.csdn.net/m0_38106113/article/details/81542863</a></p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>架构设计</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-评论系统架构设计</title>
    <url>/2021/05/04/goatc-6-comment-system-architecture-design/</url>
    <content><![CDATA[<p><strong>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</strong>  </p>
<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。  </p>
<ul>
<li>发布评论: 支持回复楼层、楼中楼。  </li>
<li>读取评论: 按照时间、热度排序。  </li>
<li>删除评论: 用户删除、作者删除。  </li>
<li>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</li>
</ul>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li><p>BFF: comment<br>复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端&#x2F;WEB场景来设计 API，这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上。  </p>
</li>
<li><p>Service: comment-service<br>服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，关注在稳定性、可用性上，这样让上游可以灵活组织逻辑把基础能力和业务能力剥离。  </p>
</li>
<li><p>Job: comment-job<br>消息队列的最大用途是消峰处理。</p>
</li>
</ul>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/gai-lan.png">  </p>
<h3 id="comment-service"><a href="#comment-service" class="headerlink" title="comment service"></a>comment service</h3><p>专注在评论数据处理。  </p>
<p>读的核心逻辑:<br>Cache-Aside 模式，先读取缓存，再读取存储。早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即预读，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动是否，特别容易引起集群 hundering herd 现象，大量的请求会触发 cache rebuild，因为使用了预加载，容易导致服务 OOM。所以我们开到回源的逻辑里，我们使用了消息队列来进行逻辑异步化，对于当前请求只返回 mysql 中部分数据即止。  </p>
<p>写的核心逻辑:<br>我们担心类似“明星出轨”等热点事件的发生，而且写和读相比较，写可以认为是透穿到存储层的，系统的瓶颈往往就来自于存储层，或者有状态层。对于写的设计上，我们认为刚发布的评论有极短的延迟(通常小于几 ms)对用户可见是可接受的，把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储 latency 升高，消费能力就下降，自然消息容易堆积，系统始终以最大化方式消费。  </p>
<p>Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 全局并行，局部串行的生产消费方式。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。那么某个 partition 中的 评论主题的数据一定都在一起，这样方便我们串行消费。<br>同样的，我们处理回源消息也是类似的思路。  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-service.png">  </p>
<h3 id="comment-admin"><a href="#comment-admin" class="headerlink" title="comment admin"></a>comment admin</h3><p>mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后倒入到 es 中。<br>一般来说，运营后台的检索条件都是组合的，使用 es 的好处是避免依赖 mysql 来做多条件组合检索，同时 mysql 毕竟是 oltp 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。<br>es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-admin.png">  </p>
<h3 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h3><p>comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。  </p>
<ul>
<li>依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。  </li>
<li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。  </li>
<li>需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。</li>
</ul>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment.png">  </p>
<h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>数据写入: 事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。  </p>
<p>数据读取: 基于 obj_id + obj_type 在 comment_index 表找到评论列表，WHERE root &#x3D; 0 ORDER BY floor。之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。对于二级的子楼层，WHERE parent&#x2F;root IN (id…)。  </p>
<p>因为产品形态上只存在二级列表，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/database-design.png">  </p>
<h3 id="索引内容分离"><a href="#索引内容分离" class="headerlink" title="索引内容分离"></a>索引内容分离</h3><p>comment_index: 评论楼层的索引组织表，实际并不包含内容。comment_content: 评论内容的表，包含评论的具体内容。其中 comment_index 的 id 字段和 comment_content 是1对1的关系，这里面包含几种设计思想。  </p>
<ul>
<li>表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次 二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。  </li>
<li>索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 context 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。</li>
</ul>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/suo-yin-nei-rong-fen-li.png">  </p>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>comment_subject_cache: 对应主题的缓存，value 使用 protobuf 序列化的方式存入。我们早期使用 memcache 来进行缓存，因为 redis 早期单线程模型，吞吐能力不高。  </p>
<p>comment_index_cache: 使用 redis sortedset 进行索引的缓存，索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。  </p>
<p>sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。  </p>
<p>comment_content_cache: 对应评论内容数据，使用 protobuf 序列化的方式存入。类似的我们早期使用 memcache 进行缓存。  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/cache-design.png">  </p>
<h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Singleflight"><a href="#Singleflight" class="headerlink" title="Singleflight"></a>Singleflight</h3><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?  </p>
<p>使用归并回源的思路:<br><a href="https://pkg.go.dev/golang.org/x/sync/singleflight">https://pkg.go.dev/golang.org/x/sync/singleflight</a>  </p>
<p>同进程只交给一个人去获取 mysql 数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题。  </p>
<p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。  </p>
<p>Q：为什么我们不用分布式锁之类的思路？  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/singleflight.png">  </p>
<h3 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h3><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。<br>在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过去的 bucket，汇总所有 key 的数据。<br>之后使用小堆计算 TopK 的数据，自动进行热点识别。  </p>
<p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/hot.png">  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>golang</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-播放历史架构设计</title>
    <url>/2021/05/05/goatc-7-play-history-architecture-design/</url>
    <content><![CDATA[<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>为了大部分用户的基本功能体验，满足用户需求，例如播放历史查看、播放进度同步等。离线型用户，app 本地保留历史记录数据。<br>同样的，也要考虑平台化，视频、文章、漫画等业务扩展接入。  </p>
<ul>
<li>变更功能：添加记录、删除记录、清空历史。  </li>
<li>读取功能：按照 timeline 返回 top N，点查获取进度信息。  </li>
<li>其他功能：暂停&#x2F;恢复记录，首次观察增加经验等。</li>
</ul>
<p><strong>历史记录类型的业务，是一个极高 tps 写入，高 qps 读取的业务服务。分析清楚系统的 hot path，投入优化，而不是哪哪都去优化。</strong>  </p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li><p>BFF: app-interface、history<br>历史 BFF 层接受来自外部用户的读请求，依赖其他例如稿件、漫画服务来组装完整的面向历史业务（页面）需要的数据的组合。同时接受来自内部其他业务线的写请求，通常都是业务方自己进行业务 ID 的判定，然后投递到历史服务的 BFF 写接口中。最终 BFF 是打包在 app-interface 大杂烩 BFF 中，考虑到隔离性，读写流量很大，独立成 history BFF 服务。  </p>
</li>
<li><p>Service: history-service<br>服务层，去平台业务的逻辑，专注在历史数据的持久化上(因为对于播放类业务，BFF 专注平台业务数据组织，service 负责数据的读、写、删、清理等操作。播放进度是非常高频同步的，需要考虑性能优化)。</p>
</li>
</ul>
<p><strong>使用 write-back 的思路，把状态数据先入分布式缓存，再回写数据库。</strong>  </p>
<ul>
<li><p>Job: history-job<br>job 消费上游 kafka 的数据，利用消息队列的堆积能力，对于存储层的差速(消费能力跟不上生产速度时)，可以进行一定的数据反压。配合上游 service 批量打包过来的数据持久化。  </p>
</li>
<li><p>Upstream: some-app，some-api<br>整个历史服务还会被一些外部 gRPC 服务所依赖，所以 history 还充当了内网的 gRPC Provider，这些上游服务，使用历史服务的写接口，把自己业务的数据进行持久化。</p>
</li>
</ul>
<p><strong>历史服务最重要的设计，就是批量打包(pipeline)聚合数据。将高频、密集的写请求先入缓存(write-back)，批量消费减少对存储的直接压力，类似的设计随处可见。</strong>  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/gai-lan.png">  </p>
<h3 id="history-service"><a href="#history-service" class="headerlink" title="history service"></a>history service</h3><p>专注在历史数据处理。  </p>
<p>写的核心逻辑:<br>用户观看的稿件、漫画等，带有进度信息的数据，同一个 id 最后一次的数据即可，即 last-write win，高频的用户端同步逻辑，只需要最后一次数据持久化即可。我们可以在 in-process 内存中，定时定量来聚合不同用户的“同一个对象的最后一次进度”，使用 kafka 消息队列来消除写入峰值。但同时我们需要保证用户数据可以实时被观察到，不能出现上报进度后，需要一阵子才能体现进度变化。所以我们即在内存中打包数据，同时实时写入到 redis 中，这样即保证了实时，又避免海量写入冲击存储。  </p>
<p>kafka 是为高吞吐设计，超高频的写入并不是最优，所以内存聚合和分片算法比较重要，按照 uid 来sharding 数据，写放大仍然很大，这里我们使用 region sharding，打包一组数据当作一个 kafka message(比如 uid % 100数据打包)。  </p>
<p>写逻辑的数据流向: 实时写 redis -&gt; 内存维护用户数据 -&gt; 定时&#x2F;定量写入到 kafka。  </p>
<p>读的核心逻辑:<br>历史数据，实时写入 redis 后，不会无限制的存储，会按量截断，所以分布式缓存中数据不是完整数据，历史数据从 redis sortedset 中读取后，如果发现尾部数据不足，会触发 cache-aside 模式，从存储中回捞数据，但是不会重新回填缓存，因为拉取过去更久远的数据，属于用户纬度的低频度行为。历史数据通常是按照 timeline 来组织，游标的 key 可以使用时间戳进行翻页或者下拉。  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-service.png">  </p>
<h3 id="history-job"><a href="#history-job" class="headerlink" title="history job"></a>history job</h3><p>获取打包好的用户数据，进行批量持久化。  </p>
<p>上游 history-service 按照 uid region sharding 聚合好的数据，在 job 中消费取出，为了节约传输过程，以及 history-service 的 in-process cache 的内存使用，我们只维护了用户的 uid 以及 id 列表，最小化存储和传输。因为数据是不完整的，我们额外需要从 redis 中按照 id 对应的数据内容，再持久化。从原来的 N 条记录变为一个用户一条记录。  </p>
<p>对于存储的选型，我们认为 HBase 非常合适高密度写入。后续我们会单独讨论我们经历过的几次存储迭代和选型。  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-job.png">  </p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 作为 BFF，对用户端提供统一的用户记录记录入口接口，同时也对内提供 gRPC 写入历史接口。如果业务场景中不存在统一的用户入口访问历史记录，可以去掉 BFF 层，直接使用 history-service 提供读接口，这样需要每个业务方自己实现自己的数据组装。  </p>
<p>我们也有类似用户首次播放、观看等加经验或者奖励积分类似的操作，所以我们这里依赖 redis，进行判定用户当天是否是首次访问，我们比较容易想到使用 bitmap 或者 bloom filter 来进行判断，然后往下游 kafka 投递消息，而不直接依赖业务的某个服务。  </p>
<p>Q：因为我们有关闭历史记录的功能，这样每次写入操作都需要前置读取一次，是否打开了开关，同样的每次首次发送奖励也是一样，你有更好的办法吗？  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history.png">  </p>
<h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>我们最早的主力存储选型是: HBase。  </p>
<p>数据写入: PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写&#x2F;读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)  </p>
<p>数据读取: 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/database-design.png">  </p>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>数据写入: 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。<br>数据读取: 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取history_content 内容。<br>另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低。  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design.png">  </p>
<p>首次触发某行为，增加经验的，我们在缓存设计中，经常使用 bitmap(roaring bitmap)、bloom filter 缓存加速访问，但是在使用缓存时，需要注意规避热点问题，某个key sharding 命中 node 是固定的，因此我们可以利用构建多组 bitmap 或 bloom filter，来进行打散。  </p>
<p>prefix_key &#x3D; hash(mid) % 1000  </p>
<p>根据 prefix_key 找到对应的 cache 再进行操作，这样 1000 个 key 尽可能均匀的分布到更小集合的 node，而不会产生数据热点。  </p>
<p>Q：但是仍然每次触发行为，都为前置判定，有更好的优化方案吗？  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design2.png">  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design3.png">  </p>
<h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>在 history-service 中实时写入 redis 数据，因此只需要重点优化缓存架构中，扛住峰值的流量写入。之后在服务内存中，使用 map[int]map[int]struct{} 聚合数据，之后利用 chan 在内部发送每个小消息，再聚合成一个大map，在 sendproc 中，使用 timer 和 定量判定逻辑，发送到下游 kafka 中。  </p>
<p>在 history-job 中，获取消息后，重新去 redis 中回捞数据即: history-content，然后构建完整的数据批量写入到 HBase 中。  </p>
<p>这里存在两个风险:<br>1、history-service 重启过程中，预聚合的消息丢失；<br>2、history-job 读取 redis 构建数据，但 redis 丢失；  </p>
<p><strong>我们在这里进行了 trade-off，高收敛比的设计，意味着存在数据丢失的风险，对于历史场景，非 L0 的业务服务&#x2F;数据，我们认为极端情况下可接受。</strong>  </p>
<p><img src="/2021/05/05/goatc-7-play-history-architecture-design/wb.png">  </p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。  </p>
<p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。  </p>
<p>我们内网使用 boardcast(goim) 服务维护长连接，长连接一次验证，不断使用。  </p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？  </p>
<p>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。  </p>
<p>越源头解决架构问题，通常越简单，效率越高。  </p>
<p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。  </p>
<p>实现成本在于，你认为的代价高低。  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://en.wikipedia.org/wiki/Cache#Writing_Policies">https://en.wikipedia.org/wiki/Cache#Writing_Policies</a><br><a href="https://blog.csdn.net/jiaomeng/article/details/1495500">https://blog.csdn.net/jiaomeng/article/details/1495500</a><br><a href="https://blog.csdn.net/yizishou/article/details/78342499">https://blog.csdn.net/yizishou/article/details/78342499</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78783749">https://blog.csdn.net/caoshangpa/article/details/78783749</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-网络编程</title>
    <url>/2021/05/05/goatc-9-network-programming-practice/</url>
    <content><![CDATA[<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。  </p>
<p>主要协议分为：  </p>
<ul>
<li>Socket：接口抽象层  </li>
<li>TCP &#x2F; UDP：面向连接(可靠) &#x2F; 无连接(不可靠)  </li>
<li>HTTP1.1 &#x2F; HTTP2 &#x2F; QUIC（HTTP3）：超文本传输协议</li>
</ul>
<h3 id="Socket-抽象层"><a href="#Socket-抽象层" class="headerlink" title="Socket 抽象层"></a>Socket 抽象层</h3><p>应用程序通常通过“套接字”向网络发出请求或者应答网络请求。  </p>
<p>一种通用的面向流的网络接口  </p>
<p>主要操作：  </p>
<ul>
<li>建立、接受连接  </li>
<li>读写、关闭、超时  </li>
<li>获取地址、端口</li>
</ul>
<h3 id="TCP-可靠连接，面向连接的协议"><a href="#TCP-可靠连接，面向连接的协议" class="headerlink" title="TCP 可靠连接，面向连接的协议"></a>TCP 可靠连接，面向连接的协议</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）即传输控制协议&#x2F;网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议。  </p>
<p>服务端流程：  </p>
<ul>
<li>监听端口  </li>
<li>接收客户端请求建立连接  </li>
<li>创建 goroutine 处理连接</li>
</ul>
<p>客户端流程：  </p>
<ul>
<li>建立与服务端的连接  </li>
<li>进行数据收发  </li>
<li>关闭连接</li>
</ul>
<h3 id="UDP-不可靠连接，允许广播或多播"><a href="#UDP-不可靠连接，允许广播或多播" class="headerlink" title="UDP 不可靠连接，允许广播或多播"></a>UDP 不可靠连接，允许广播或多播</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议。  </p>
<p>一个简单的传输层协议：  </p>
<ul>
<li>不需要建立连接  </li>
<li>不可靠的、没有时序的通信  </li>
<li>数据报是有长度（65535-20&#x3D;65515）  </li>
<li>支持多播和广播  </li>
<li>低延迟，实时性比较好  </li>
<li>应用于用于视频直播、游戏同步</li>
</ul>
<h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h3><p>HTTP(HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。  </p>
<p>请求报文：  </p>
<ul>
<li>Method: HEAD&#x2F;GET&#x2F;POST&#x2F;PUT&#x2F;DELETE  </li>
<li>Accept：text&#x2F;html、application&#x2F;json  </li>
<li>Content-Type:  </li>
<li>application&#x2F;json  </li>
<li>application&#x2F;x-www-form-urlencoded  </li>
<li>请求正文</li>
</ul>
<p>响应报文：  </p>
<ul>
<li>状态行(200&#x2F;400&#x2F;500)  </li>
<li>响应头(Response Header)  </li>
<li>响应正文</li>
</ul>
<h3 id="HTTP-超文本传输协议-演进"><a href="#HTTP-超文本传输协议-演进" class="headerlink" title="HTTP 超文本传输协议-演进"></a>HTTP 超文本传输协议-演进</h3><p>HTTP 发展史：  </p>
<ul>
<li>1991 年发布初代 HTTP&#x2F;0.9 版  </li>
<li>1996 年发布 HTTP&#x2F;1.0 版  </li>
<li>1997 年是 HTTP&#x2F;1.1 版，是到今天为止传输最广泛的版本  </li>
<li>2015 年发布了 HTTP&#x2F;2.0 版，优化了 HTTP&#x2F;1.1 的性能和安全性  </li>
<li>2018 年发布的 HTTP&#x2F;3.0 版，使用 UDP 取代 TCP 协议</li>
</ul>
<p>HTTP2：<br>二进制分帧，按帧方式传输<br>多路复用，代替原来的序列和阻塞机制<br>头部压缩，通过 HPACK 压缩格式<br>服务器推送，服务端可以主动推送资源  </p>
<p>HTTP3：<br>连接建立延时低，一次往返可建立HTTPS连接<br>改进的拥塞控制，高效的重传确认机制<br>切换网络保持连接，从4G切换到WIFI不用重建连接  </p>
<h2 id="Go-网络编程基础"><a href="#Go-网络编程基础" class="headerlink" title="Go 网络编程基础"></a>Go 网络编程基础</h2><p>基础概念：  </p>
<ul>
<li>Socket：数据传输  </li>
<li>Encoding：内容编码  </li>
<li>Session：连接会话状态  </li>
<li>C&#x2F;S模式：通过客户端实现双端通信  </li>
<li>B&#x2F;S模式：通过浏览器即可完成数据的传输</li>
</ul>
<p>简单例子<br>• 通过TCP&#x2F;UDP实现网络通信  </p>
<p>网络轮询器  </p>
<ul>
<li>多路复用模型</li>
<li>多路复用模块</li>
<li>文件描述符</li>
<li>Goroutine 唤醒</li>
</ul>
<h3 id="TCP简单例子"><a href="#TCP简单例子" class="headerlink" title="TCP简单例子"></a>TCP简单例子</h3><h3 id="UDP简单例子"><a href="#UDP简单例子" class="headerlink" title="UDP简单例子"></a>UDP简单例子</h3><h3 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h3><p>Linux下主要的IO模型分为:  </p>
<ul>
<li>Blocking IO - 阻塞IO  </li>
<li>Nonblocking IO - 非阻塞IO  </li>
<li>IO multiplexing - IO 多路复用  </li>
<li>Signal-driven IO - 信号驱动式IO（异步阻塞）  </li>
<li>Asynchronous IO - 异步IO</li>
</ul>
<p>同步：调用端会一直等待服务端响应，直到返回结果<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被 CPU 调度，线程暂停运行<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回  </p>
<p><img src="/2021/05/05/goatc-9-network-programming-practice/io.png">  </p>
<h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>Go 语言在采用  I&#x2F;O 多路复用 模型处理 I&#x2F;O 操作，但是他没有选择最常见的系统调用 select。虽然 select 也可以提供 I&#x2F;O 多路复用的能力，但是使用它有比较多的限制：  </p>
<ul>
<li>监听能力有限 — 最多只能监听 1024 个文件描述符；  </li>
<li>内存拷贝开销大 — 需要维护一个较大的数据结构存储文件描述符，该结构需要拷贝到内核中；  </li>
<li>时间复杂度 𝑂(𝑛) — 返回准备就绪的事件个数后，需要遍历所有的文件描述符；</li>
</ul>
<p>I&#x2F;O多路复用：进程阻塞于 select，等待多个 IO 中的任一个变为可读，select调 用返回，通知相应 IO 可以读。 它可以支持单线程响应多个请求这种模式。  </p>
<p><img src="/2021/05/05/goatc-9-network-programming-practice/iomm.png">  </p>
<h3 id="多路复用模块"><a href="#多路复用模块" class="headerlink" title="多路复用模块"></a>多路复用模块</h3><p>为了提高 I&#x2F;O 多路复用的性能<br>不同的操作系统也都实现了自己的 I&#x2F;O 多路复用函数，例如：epoll、kqueue 和 evport 等<br>Go 语言为了提高在不同操作系统上的 I&#x2F;O 操作性能，使用平台特定的函数实现了多个版本的网络轮询模块：  </p>
<p>src&#x2F;runtime&#x2F;netpoll_epoll.go<br>src&#x2F;runtime&#x2F;netpoll_kqueue.go<br>src&#x2F;runtime&#x2F;netpoll_solaris.go<br>src&#x2F;runtime&#x2F;netpoll_windows.go<br>src&#x2F;runtime&#x2F;netpoll_aix.go<br>src&#x2F;runtime&#x2F;netpoll_fake.go  </p>
<h2 id="Goim-长连接-TCP-编程"><a href="#Goim-长连接-TCP-编程" class="headerlink" title="Goim 长连接 TCP 编程"></a>Goim 长连接 TCP 编程</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li><p>Comet<br>长连接管理层，主要是监控外网 TCP&#x2F;Websocket端口，并且通过设备 ID 进行绑定 Channel实 现，以及实现了 Room 合适直播等大房间消息广播。  </p>
</li>
<li><p>Logic<br>逻辑层，监控连接 Connect、Disconnect 事件，可自定义鉴权，进行记录 Session 信息（设备 ID、ServerID、用户 ID），业务可通过设备 ID、用户 ID、RoomID、全局广播进行消息推送。  </p>
</li>
<li><p>Job<br>通过消息队列的进行推送消峰处理，并把消息推送到对应 Comet 节点。</p>
</li>
</ul>
<p><strong>各个模块之间通过 gRPC 进行通信。</strong>  </p>
<p><img src="/2021/05/05/goatc-9-network-programming-practice/long-tcp-gai-lan.png">  </p>
<h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p>主要以包&#x2F;针方式：<br>Package Length，包长度<br>Header Length，头长度<br>Protocol Version，协议版本<br>Operation，操作码<br>Sequence 请求序号 ID<br>Body，包内容  </p>
<p>Operation:  </p>
<ul>
<li>Auth  </li>
<li>Heartbeat  </li>
<li>Message</li>
</ul>
<p>Sequence  </p>
<ul>
<li>按请求、响应对应递增 ID</li>
</ul>
<h3 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a>边缘节点</h3><p>Comet 长连接连续节点，通常部署在距离用户比较近，通过 TCP 或者 Websocket 建立连接，并且通过应用层 Heartbeat 进行保活检测，保证连接可用性。  </p>
<p>节点之间通过云 VPC 专线通信，按地区部署分布。  </p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>长连接负载均衡比较特殊，需要按一定的负载算法进行分配节点，可以通过 HTTPDNS 方式，请求获致到对应的节点 IP 列表，例如，返回固定数量 IP，按一定的权重或者最少连接数进行排序，客户端通过 IP 逐个重试连接；  </p>
<ul>
<li>Comet 注册 IP 地址，以及节点权重，定时 Renew当前节点连接数量；  </li>
<li>Balancer 按地区经纬度计算，按最近地区（经纬度）提供 Comet 节点 IP 列表，以及权重计算排序；  </li>
<li>BFF 返回对应的长连接节点 IP，客户端可以通过 IP直接连；  </li>
<li>客户端 按返回IP列表顺序，逐个连接尝试建立长连接</li>
</ul>
<h3 id="心跳保活机制"><a href="#心跳保活机制" class="headerlink" title="心跳保活机制"></a>心跳保活机制</h3><p>长连接断开的原因：<br>长连接所在进程被杀死<br>NAT 超时<br>网络状态发生变化，如移动网络 &amp; Wifi 切换、断开、重连<br>其他不可抗因素（网络状态差、DHCP 的租期等等 ）  </p>
<p>高效维持长连接方案：<br>进程保活（防止进程被杀死）<br>心跳保活（阻止 NAT 超时）<br>断线重连（断网以后重新连接网络）  </p>
<p>自适应心跳时间：<br>心跳可选区间，[min&#x3D;60s，max&#x3D;300s]<br>心跳增加步长，step&#x3D;30s<br>心跳周期探测，success&#x3D;current + step、fail&#x3D;current - step  </p>
<h3 id="用户鉴权和-Session-信息"><a href="#用户鉴权和-Session-信息" class="headerlink" title="用户鉴权和 Session 信息"></a>用户鉴权和 Session 信息</h3><p>用户鉴权，在长连接建立成功后，需要先进行连接鉴权，并且绑定对应的会话信息；  </p>
<p>Connect，建立连接进行鉴权，保存Session信息：  </p>
<ul>
<li>DeviceID，设备唯一 ID  </li>
<li>Token，用户鉴权 Token，认证得到用户 ID  </li>
<li>CometID，连接所在 comet 节点</li>
</ul>
<p>Disconnect，断开连接，删除对应Session信息：  </p>
<ul>
<li>DeviceID，设备唯一 ID  </li>
<li>CometID，连接所在 Comet 节点  </li>
<li>UserID，用户 ID</li>
</ul>
<p>Session，会话信息通过Redis保存连接路由信息：  </p>
<ul>
<li>连接维度，通过 设备 ID 找到所在 Comet 节点  </li>
<li>用户维度，通过 用户 ID 找到对应的连接和 Comet所在节点</li>
</ul>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet 长连接层，实现连接管理和消息推送：  </p>
<p>Protocol，TCP&#x2F;Websocket 协议监听；  </p>
<ul>
<li>Packet，长连接消息包，每个包都有固定长度；  </li>
<li>Channel，消息管道相当于每个连接抽象，最终TCP&#x2F;Websocket 中的封装，进行消息包的读写分发；  </li>
<li>Bucket，连接通过 DeviceID 进行管理，用于读写锁拆散，并且实现房间消息推送，类似 Nginx Worker；  </li>
<li>Room，房间管理通过 RoomID 进行管理，通过链表进行Channel遍历推送消息；</li>
</ul>
<p>每个 Bucket 都有独立的 Goroutine 和读写锁优化：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Buckets &#123;  channels <span class="keyword">map</span>[<span class="type">string</span>]*Channel</span><br><span class="line">  rooms <span class="keyword">map</span>[<span class="type">string</span>]*Room&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><p>Logic 业务逻辑层，处理连接鉴权、消息路由，用户会话管理；  </p>
<p>主要分为三层：  </p>
<ul>
<li>sdk，通过 TCP&#x2F;Websocket 建立长连接，进行重连、心跳保活；  </li>
<li>goim，主要负责连接管理，提供消息长连能力；  </li>
<li>backend，处理业务逻辑，对推送消息过虑，以及持久化相关等；</li>
</ul>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>业务通过对应的推送方式，可以对连接设备、房间、用户ID进行推送，通过Session信息定位到所在的Comet连接节点，并通过Job推送消息；  </p>
<p>通过Kafka进行推送消峰，保证消息逐步推送成功；  </p>
<p>支持的多种推送方式：  </p>
<ul>
<li>Push(DeviceID, Message)</li>
<li>Push(UserID, Message)</li>
<li>Push(RoomID, Message)</li>
<li>Push(Message)</li>
</ul>
<h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><p>在长连接中，如果想把消息通知所有人，主要有两种模式：一种是自己拿广播通知所有人，这叫“推”模式；一种是有人主动来找你要，这叫“拉”模式。；  </p>
<p>在业务系统中，通常会有三种可能的做法：  </p>
<ul>
<li>推模式，有新消息时服务器主动推给客户端；  </li>
<li>拉模式，由前端主动发起拉取消息的请求；  </li>
<li>推拉结合模式，有新消息实时通知，客户端再进行新的消息摘取；</li>
</ul>
<h3 id="读写扩散"><a href="#读写扩散" class="headerlink" title="读写扩散"></a>读写扩散</h3><p>一般消息系统中，通常会比较关注消息存储；<br>主要进行考虑“读”、“写”扩散，也就是性能问题；<br>在不同场景，可能选择不同的方式：</p>
<p>读扩散，在IM系统里的读扩散通常是每两个相关联的人就有一个信箱，或者每个群一个信箱。<br>优点：写操作（发消息）很轻量，只用写自己信箱<br>缺点：读操作（读消息）很重，需要读所有人信箱<br>写扩散，每个人都只从自己的信箱里读取消息，但写（发消息）的时候需要所有人写一份<br>优点：读操作很轻量<br>缺点：写操作很重，尤其是对于群聊来说  </p>
<h3 id="唯一-ID-设计"><a href="#唯一-ID-设计" class="headerlink" title="唯一 ID 设计"></a>唯一 ID 设计</h3><p>唯一 ID，需要保证全局唯一，绝对不会出现重复的 ID，且 ID 整体趋势递增。<br>通常情况下，ID 的设计主要有以下几大类：  </p>
<ul>
<li>UUID  </li>
<li>基于 Snowflake 的 ID 生成方式  </li>
<li>基于申请 DB 步长的生成方式  </li>
<li>基于 Redis 或者 DB 的自增 ID生成方式  </li>
<li>特殊的规则生成唯一 ID</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</a><br><a href="https://www.liwenzhou.com/posts/Go/15_socket/">https://www.liwenzhou.com/posts/Go/15_socket/</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="https://cloud.tencent.com/developer/article/1030660">https://cloud.tencent.com/developer/article/1030660</a><br><a href="https://juejin.cn/post/6844903827536117774">https://juejin.cn/post/6844903827536117774</a><br><a href="https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c">https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c</a><br><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html</a><br><a href="https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg">https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg</a><br><a href="https://www.imooc.com/article/265871">https://www.imooc.com/article/265871</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的CPU占满100%及解决方案</title>
    <url>/2019/05/26/golang-cpu-100-solution/</url>
    <content><![CDATA[<p>有一个流媒体适配服务，出现了<code>CPU</code>开销很大的问题，一个服务把<code>CPU</code>资源占满了，导致其他服务无法正常工作。<br>下面来详细记录发现<code>bug</code>和解决的流程。  </p>
<h1 id="发现CPU开销很大"><a href="#发现CPU开销很大" class="headerlink" title="发现CPU开销很大"></a>发现CPU开销很大</h1><p>扫描发现，是垃圾回收导致 <code>CPU</code> 使用上升 ： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time: Mar 22, 2019 at 5:52pm (CST)</span><br><span class="line">Duration: 1mins, Total samples = 1.43mins (142.57%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) tree </span><br><span class="line">Showing nodes accounting for 83.13s, 97.11% of 85.60s total</span><br><span class="line">Dropped 256 nodes (cum &lt;= 0.43s)</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context 	 	 </span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            71.36s 99.86% |   runtime.gcDrain</span><br><span class="line">                                             0.10s  0.14% |   runtime.systemstack</span><br><span class="line">    48.56s 56.73% 56.73%     71.46s 83.48%                | runtime.scanobject</span><br><span class="line">                                            11.86s 16.60% |   runtime.heapBitsForObject</span><br><span class="line">                                            11.04s 15.45% |   runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.86s 99.92% |   runtime.scanobject</span><br><span class="line">    11.87s 13.87% 70.60%     11.87s 13.87%                | runtime.heapBitsForObject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.04s   100% |   runtime.scanobject</span><br><span class="line">    11.02s 12.87% 83.47%     11.04s 12.90%                | runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                             6.53s 95.05% |   runtime.gosweepone.func1</span><br><span class="line">                                             0.34s  4.95% |   runtime.(*mheap).alloc</span><br><span class="line">     4.34s  5.07% 88.54%      6.87s  8.03%                | runtime.sweepone</span><br><span class="line">                                             2.53s 36.83% |   runtime.(*mspan).sweep</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            74.42s   100% |   runtime.gcBgMarkWorker.func2</span><br><span class="line">     1.97s  2.30% 90.84%     74.42s 86.94%                | runtime.gcDrain</span><br><span class="line">                                            71.36s 95.89% |   runtime.scanobject</span><br><span class="line">                                             0.52s   0.7% |   runtime.pollWork</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>之后考虑使用 <code>buffer pool</code>,  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 这里不再分配新的内存，而是从 buffer pool 里面 GET </span></span><br><span class="line">databuf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure>

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>参考<a href="https://github.com/libp2p/go-buffer-pool">go buffer pool</a>  </p>
<ul>
<li><p>先创建一个<code>buffer pool</code>  </p>
</li>
<li><p>在<code>Get</code>它  </p>
</li>
<li><p>用完再<code>Put</code>回去  </p>
</li>
<li><p>注意，最好在<code>Get</code>和<code>Put</code>时加锁。</p>
</li>
</ul>
<h1 id="是什么原因导致了CPU开销很大（重点）"><a href="#是什么原因导致了CPU开销很大（重点）" class="headerlink" title="是什么原因导致了CPU开销很大（重点）"></a>是什么原因导致了CPU开销很大（重点）</h1><p>当我们新建了一个有长度变量时，例如100<code>byte</code>的数组，那么它在操作系统内存中是这样展现的  </p>
<p><img src="/2019/05/26/golang-cpu-100-solution/memory.png">  </p>
<p>因此，当我们新建一个变量时，操作系统会在自己的运行内存里开辟一块内存给这个变量存数据用。当我们不需要这个数据时，或者说要删除这个变量时，<code>Golang</code>会执行垃圾回收机制。  </p>
<p>然而当<code>Golang</code>在执行垃圾回收时，操作系统会不断对这些有或者没有被引用的变量进行扫描，这中间涉及操作系统的算法，我们不用深究，但是，在执行这种算法时，会占用<code>CPU</code>的资源，如果新开辟的变量和内存过多，就会导致系统不停的检查是否有不需要引用的变量了，从而造成占用<code>CPU</code>资源过多。  </p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创建一个<code>buffer pool</code>  </p>
<p>创建一个大的<code>buffer pool</code>，你需要内存时，向<code>buffer pool</code>获取一下<code>Get</code>，用完不需要时再还回去<code>Put</code>。  </p>
<p><img src="/2019/05/26/golang-cpu-100-solution/bufferpool.png">  </p>
<p>这样做的好处是，操作系统每次检查内存时，都只有一个<code>buffer pool</code>在引用，不增不减，于是也就减少<code>CPU</code>资源的消耗了。  </p>
<h2 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h2><p>比如说操作系统就是一个土豪，借东西再换回来不收利息。它有一个很大的内存，周围许多人都想找它去借(新声明的变量并初始化)，刚开始借的人只有十几个，后面有上万个，于是它要每天记录谁借了多少内存出去，谁还没有归还，归还的直接从记录上把名字划掉(垃圾回收)。后来操作系统烦了，于是就建了一个很大的内存池，够所有人分批次借，只要借完及时归还就行，而它每次去看这个内存池有没有变小即可，省了不少精力。</p>
<p>而这个内存池就是<code>go buffer pool</code>的作用。  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建议给<code>Get</code>和<code>Put</code>加锁，防止多个协程同时借阅，造成竞争冒险。<br>这个<code>CPU</code>占满问题涉及<code>Golang</code>的垃圾回收机制，这块是要点，一定要搞明白。  </p>
<h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul>
<li><a href="https://github.com/libp2p/go-buffer-pool">go buffer pool</a>  </li>
<li><a href="http://legendtkl.com/2017/04/28/golang-gc/">Golang 垃圾回收剖析</a></li>
</ul>
]]></content>
      <categories>
        <category>Solution-notes</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>CPU占满</tag>
      </tags>
  </entry>
  <entry>
    <title>Go进阶-分布式缓存和分布式事务</title>
    <url>/2021/05/06/goatc-8-distributed-cache-and-affair/</url>
    <content><![CDATA[<h2 id="缓存选型"><a href="#缓存选型" class="headerlink" title="缓存选型"></a>缓存选型</h2><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h3><p>memcache 提供简单的 kv cache 存储，value 大小不超过1mb。  </p>
<p>我使用 memcache 作为大文本或者简单的 kv结构使用。  </p>
<p>memcache 使用了slab 方式做内存管理，存在一定的浪费，如果大量接近的 item，建议调整 memcache 参数来优化每一个 slab 增长的 ratio、可以通过设置 slab_automove &amp; slab_reassign 开启memcache 的动态&#x2F;手动 move slab，防止某些 slab 热点导致内存足够的情况下引发 LRU。  </p>
<p>大部分情况下，简单 KV 推荐使用 Memcache，吞吐和相应都足够好。  </p>
<p>每个 slab 包含若干大小为1M的内存页，这些内存又被分割成多个 chunk，每个 chunk存储一个 item；<br>在 memcache 启动初始化时，每个 slab 都预分配一个 1M 的内存页，由slabs_preallocate 完成(也可将相应代码注释掉关闭预分配功能)。  </p>
<p>chunk 的增长因子由 -f 指定，默认1.25，起始大小为48字节。<br>内存池有很多种设计，可以参考下: nginx ngx_pool_t，tcmalloc 的设计等等。  </p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis 有丰富的数据类型，支持增量方式的修改部分数据，比如排行榜，集合，数组等。  </p>
<p>比较常用的方式是使用 redis 作为数据索引，比如评论的列表 ID，播放历史的列表 ID 集合，我们的关系链列表 ID。  </p>
<p>redis 因为没有使用内存池，所以是存在一定的内存碎片的，一般会使用 jemalloc 来优化内存分配，需要编译时候使用 jemalloc 库代替 glib 的 malloc 使用。  </p>
<h3 id="redis-vs-memcache"><a href="#redis-vs-memcache" class="headerlink" title="redis vs memcache"></a>redis vs memcache</h3><p>Redis 和 Memcache 最大的区别其实是 redis 单线程(新版本双线程)，memcache 多线程，所以 QPS 可能两者差异不大，但是吞吐会有很大的差别，比如大数据 value 返回的时候，redis qps 会抖动下降的的很厉害，因为单线程工作，其他查询进不来(新版本有不少的改善)。  </p>
<p>所以建议纯 kv 都走 memcache，比如我们的关系链服务中用了 hashs 存储双向关系，但是我们也会使用 memcache 档一层来避免hgetall 导致的吞吐下降问题。  </p>
<p>我们系统中多次使用 memcache + redis 双缓存设计。  </p>
<p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/memcache-vs-redis.png">  </p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>早期使用 twemproxy 作为缓存代理，但是在使用上有如下一些痛点：  </p>
<ul>
<li>单进程单线程模型和 redis 类似，在处理一些大 key 的时候可能出现 io 瓶颈；  </li>
<li>二次开发成本难度高，难以于公司运维平台进行深度集成；  </li>
<li>不支持自动伸缩，不支持 autorebalance 增删节点需要重启才能生效；  </li>
<li>运维不友好，没有控制面板；</li>
</ul>
<p>业界开源的的其他代理工具：  </p>
<ul>
<li>codis: 只支持 redis 协议，且需要使用 patch版本的 redis；  </li>
<li>mcrouter: 只支持 memcache 协议，C 开发，与运维集成开发难度高；</li>
</ul>
<p>从集中式访问缓存到 Sidecar 访问缓存：  </p>
<ul>
<li>微服务强调去中心化；  </li>
<li>LVS 运维困难，容易流量热点，随下游扩容而扩容，连接不均衡等问题；  </li>
<li>Sidecar 伴生容器随 App 容器启动而启动，配置简化；</li>
</ul>
<h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。  </p>
<p>对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。  </p>
<p>余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。  </p>
<ul>
<li>平衡性(Balance)：尽可能分布到所有的缓冲中去  </li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。  </li>
<li>分散性(Spread)：相同内容被存储到不同缓冲中去，降低了系统存储的效率，需要尽量降低分散性。  </li>
<li>负载(Load)：哈希算法应能够尽量降低缓冲的负荷。  </li>
<li>平滑性(Smoothness)：缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li>
</ul>
<p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。  </p>
<p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。  </p>
<p>具体做法可以在服务器 ip 或主机名的后面增加编号来实现。  </p>
<p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/yi-zhi-hash.png">  </p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算<br>“Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点。<br>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到<br>“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。  </p>
<p>参考微信红包的写合并优化：<br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a>  </p>
<p>在网关层，使用一致性 hash，对红包 id 进行分片，命中到某一个逻辑服务器处理，在进程内做写操作的合并，减少存储层的单行锁争用。<br>我认为更好的做法是 有界负载一致性 hash。  </p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>数据分片的 hash 方式也是这个思想，即按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系,从而将哈希值不同的数据分布到不同的节点上。  </p>
<p>按照 hash 方式做数据分片，映射关系非常简单；需要管理的元数据也非常之少，只需要记录节点的数目以及 hash 方式就行了。  </p>
<p>当加入或者删除一个节点的时候，大量的数据需要移动。比如在这里增加一个节点 N3，因此 hash 方式变为了 mod 4。  </p>
<p>均衡问题：原始数据的特征值分布不均匀，导致大量的数据集中到一个物理节点上；第二，对于可修改的记录数据，单条记录的数据变大。<br>高级玩法是抽象 slot，基于 Hash 的 Slot Sharding，例如 Redis-Cluster。  </p>
<h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>redis-cluster 把16384 槽按照节点数量进行平均分配，由节点进行管理。  </p>
<p>对每个 key 按照 CRC16 规则进行 hash 运算，把 hash 结果对16383进行取余，把余数发送给 Redis 节点。  </p>
<p>需要注意的是：Redis Cluster 的节点之间会共享消息，每个节点都会知道是哪个节点负责哪个范围内的数据槽  </p>
<h2 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h2><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>Storage 和 Cache 同步更新容易出现数据不一致。  </p>
<p>模拟 MySQL Slave 做数据复制，再把消息投递到 Kafka，保证至少一次消费：  </p>
<ul>
<li>同步操作DB；  </li>
<li>同步操作Cache；  </li>
<li>利用Job消费消息，重新补偿一次缓存操作</li>
</ul>
<p>保证时效性和一致性。  </p>
<p>读&#x2F;写同时操作：<br>读操作，读缓存，缓存 MISS<br>读操作，读 DB，读取到数据<br>写操作，更新 DB 数据<br>写操作 SET&#x2F;DELETE Cache（可 Job 异步操作）<br>读操作，SET操作数据回写缓存（可 Job 异步操作）  </p>
<p>这种交互下，由于4和5操作步骤都是设置缓存，导致写入的值互相覆盖；并且操作的顺序性不确定，从而导致 cache 存在脏缓存的情况。  </p>
<p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/shu-ju-yi-zhi.png">  </p>
<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>微服务拆分细粒度原子业务下的整合服务（聚合服务），用于提供粗粒度的接口，以及二级缓存加速，减少扇出的 rpc 网络请求，减少延迟。<br>最重要是保证多级缓存的一致性：  </p>
<ul>
<li>清理的优先级是有要求的，先优先清理下游再上游；  </li>
<li>下游的缓存expire要大于上游，里面穿透回源；</li>
</ul>
<p>天下大势分久必合，适当的微服务合并也是不错的做法，再使用 DDD 思路以及我们介绍的目录结构组织方式，区分不同的 Usecase。  </p>
<h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><p>对于热点缓存 Key，按照如下思路解决：  </p>
<ul>
<li>小表广播，从 RemoteCache 提升为LocalCache，App 定时更新，甚至可以让运营平台支持广播刷新 LocalCache；  </li>
<li>主动监控防御预热，比如直播房间页高在线情况下直接外挂服务主动防御；  </li>
<li>基础库框架支持热点发现，自动短时的 short-live cache；  </li>
<li>多 Cluster 支持；<br>多 Key 设计: 使用多副本，减小节点热点的问题<br>使用多副本 ms_1,ms_2,ms_3 每个节点保存一份数据，使得请求分散到多个节点，避免单点热点问题。</li>
</ul>
<h3 id="穿透缓存"><a href="#穿透缓存" class="headerlink" title="穿透缓存"></a>穿透缓存</h3><ul>
<li><p>singlefly<br>对关键字进行一致性 hash，使其某一个维度的 key 一定命中某个节点，然后在节点内使用互斥锁，保证归并回源，但是对于批量查询无解；  </p>
</li>
<li><p>分布式锁<br>设置一个 lock key，有且只有一个人成功，并且返回，交由这个人来执行回源操作，其他候选者轮训 cache 这个 lock key，如果不存在去读数据缓存，hit 就返回，miss 继续抢锁；  </p>
</li>
<li><p>队列<br>如果 cache miss，交由队列聚合一个key，来 load 数据回写缓存，对于 miss 当前请求可以使用 singlefly 保证回源，如评论架构实现。适合回源加载数据重的任务，比如评论 miss 只返回第一页，但是需要构建完成评论数据索引。  </p>
</li>
<li><p>lease<br>通过加入 lease 机制，可以很好避免这两个问题，lease 是 64-bit 的 token，与客户端请求的 key 绑定，对于过时设置，在写入时验证 lease，可以解决这个问题；对于 thundering herd，每个key 10s 分配一次，当 client 在没有获取到 lease 时，可以稍微等一下再访问 cache，这时往往cache 中已有数据。（基础库支持 &amp; 修改 cache 源码）；</p>
</li>
</ul>
<h2 id="缓存技巧"><a href="#缓存技巧" class="headerlink" title="缓存技巧"></a>缓存技巧</h2><h3 id="Incast-Congestion"><a href="#Incast-Congestion" class="headerlink" title="Incast Congestion"></a>Incast Congestion</h3><p>如果在网路中的包太多，就会发生 Incast Congestion 的问题（可以理解为，network 有很多switch，router 啥的，一旦一次性发一堆包，这些包同时到达 switch，这些 switch 就会忙不过来）。  </p>
<p>应对这个问题就是不要让大量包在同一时间发送出去，在客户端限制每次发出去的包的数量（具体实现就是客户端弄个队列）。  </p>
<p>每次发送的包的数量称为“Window size”。这个值太小的话，发送太慢，自然延迟会变高；这个值太大，发送的包太多把 network switch 搞崩溃了，就可能发生比如丢包之类的情况，可能被当作 cache miss，这样延迟也会变高。所以这个值需要调，一般会在 proxy 层面实现。  </p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul>
<li>易读性的前提下，key 设置尽可能小，减少资源的占用，redis value 可以用 int 就不要用string，对于小于 N 的 value，redis 内部有 shared_object 缓存。  </li>
<li>拆分 key。主要是用在 redis 使用 hashes 情况下。同一个 hashes key 会落到同一个 redis 节点，hashes 过大的情况下会导致内存及请求分布的不均匀。考虑对 hash 进行拆分为小的hash，使得节点内存均匀及避免单节点请求热点。  </li>
<li>空缓存设置。对于部分数据，可能数据库始终为空，这时应该设置空缓存，避免每次请求都缓存 miss 直接打到 DB。  </li>
<li>空缓存保护策略。  </li>
<li>读失败后的写缓存策略（降级后一般读失败不触发回写缓存）。  </li>
<li>序列化使用 protobuf，尽可能减少 size。  </li>
<li>工具化浇水代码</li>
</ul>
<h3 id="memcache-小技巧"><a href="#memcache-小技巧" class="headerlink" title="memcache 小技巧"></a>memcache 小技巧</h3><ul>
<li>flag 使用：标识 compress、encoding、large value 等；  </li>
<li>memcache 支持 gets，尽量读取，尽可能的 pipeline，减少网络往返；  </li>
<li>使用二进制协议，支持 pipeline delete，UDP 读取、TCP 更新；</li>
</ul>
<h3 id="redis-小技巧"><a href="#redis-小技巧" class="headerlink" title="redis 小技巧"></a>redis 小技巧</h3><ul>
<li>增量更新一致性：EXPIRE、ZADD&#x2F;HSET 等，保证索引结构体务必存在的情况下去操作新增数据；  </li>
<li>BITSET: 存储每日登陆用户，单个标记位置（boolean），为了避免单个 BITSET 过大或者热点，需要使用 region sharding，比如按照mid求余 %和&#x2F; 10000，商为 KEY、余数作为offset；  </li>
<li>List:抽奖的奖池、顶弹幕，用于类似 Stack PUSH&#x2F;POP操作；  </li>
<li>Sortedset: 翻页、排序、有序的集合，杜绝 zrange 或者 zrevrange 返回的集合过大；  </li>
<li>Hashs: 过小的时候会使用压缩列表、过大的情况容易导致 rehash 内存浪费，也杜绝返回hgetall，对于小结构体，建议直接使用 memcache KV；  </li>
<li>String: SET 的 EX&#x2F;NX 等 KV 扩展指令，SETNX 可以用于分布式锁、SETEX 聚合了SET + EXPIRE；  </li>
<li>Sets: 类似 Hashs，无 Value，去重等；  </li>
<li>尽可能的 PIPELINE 指令，但是避免集合过大；  </li>
<li>避免超大 Value；</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>讲到事务，又得搬出经典的转账问题了：<br>支付宝账户表：A (id, user_id, amount)<br>余额宝账户表：B (id, user_id, amount)<br>用户的 user_id &#x3D; 1，从支付宝转帐1万快到余额宝分为两个步骤：<br>支付宝表扣除1万：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount <span class="operator">=</span> amount <span class="operator">-</span> <span class="number">10000</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;  </span><br></pre></td></tr></table></figure>
<p>余额宝表增加1万：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> B <span class="keyword">SET</span> amount <span class="operator">=</span> amount <span class="operator">+</span> <span class="number">10000</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;  </span><br></pre></td></tr></table></figure>
<p>如何保证数据一致性呢？<br>单个数据库，我们保证 ACID 使用 数据库事务。  </p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>如何可靠的保存消息凭证？<br>要解决消息可靠存储，我们实际上需要解决的问题是，本地的 mysql 存储和 message 存储的一致性问题。  </p>
<ul>
<li>Transactional outbox  </li>
<li>Polling publisher  </li>
<li>Transaction log tailing  </li>
<li>2PC Message Queue</li>
</ul>
<p>事务消息一旦被可靠的持久化，我们整个分布式事务，变为了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，称为：Best Effort。只有消息被消费，整个交易才能算是完整完结。  </p>
<h3 id="Best-Effort"><a href="#Best-Effort" class="headerlink" title="Best Effort"></a>Best Effort</h3><p>即尽最大努力交付，主要用于在这样一种场景：不同的服务平台之间的事务性保证。<br>比如我们在电商购物，使用支付宝支付；又比如玩网游的时候，通过 App Store 充值。<br>拿购物为例，电商平台与支付平台是相互独立的，隶属于不同的公司，即使是同一个公司也很可能是独立的部门。<br>“ 做过支付宝交易接口的同学都知道，我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。<br>同时，只有当我们回调页面中输出了success 字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。”  </p>
<h3 id="Transactional-outbox"><a href="#Transactional-outbox" class="headerlink" title="Transactional outbox"></a>Transactional outbox</h3><p>Transactional outbox，支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为 msg）。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EGIN TRANSACTION</span><br><span class="line">    <span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount <span class="operator">=</span> amount <span class="operator">-</span> <span class="number">10000</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> msg(user_id, amount, status) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">END</span> TRANSACTION</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。当上述事务提交成功后，我们想办法将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。  </p>
<h3 id="Polling-publisher"><a href="#Polling-publisher" class="headerlink" title="Polling publisher"></a>Polling publisher</h3><p>Polling publisher，我们定时的轮训 msg 表，把 status &#x3D; 1 的消息统统拿出来消费，可以按照自增 id 排序，保证顺序消费。在这里我们独立了一个  pay_task 服务，把拖出来的消息 publish 给我们消息队列，balance 服务自己来消费队列，或者直接 rpc 发送给 balance 服务。  </p>
<p>实际我们第一个版本的 archive-service 在使用 CQRS 时，就用的这个模型，Pull 的模型，从延迟来说不够好，Pull 太猛对 Database 有一定压力，Pull 频次低了，延迟比较高。  </p>
<h3 id="Transaction-log-tailing"><a href="#Transaction-log-tailing" class="headerlink" title="Transaction log tailing"></a>Transaction log tailing</h3><p>Transaction log tailing，上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。<br>有一些业务场景，可以直接使用主表被 canal 订阅使用，有一些业务场景自带这类 message 表，比如订单或者交易流水，可以直接使用这类流水表作为 message 表使用。  </p>
<p>使用 canal 订阅以后，是实时流式消费数据，在消费者 balance 或者 balance-job 必须努力送达到。  </p>
<p>我们发现，所有努力送达的模型，必须是先预扣（预占资源）的做法。  </p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>还有一个很严重的问题就是消息重复投递，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了。  </p>
<p>为什么相同的消息会被重复投递？比如余额宝处理完消息 msg 后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息 msg 还在，就会继续发送消息 msg。  </p>
<ul>
<li><p>全局唯一 ID+ 去重表<br>在余额宝这边增加消息应用状态表 msg_apply，通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。  </p>
</li>
<li><p>版本号</p>
</li>
</ul>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交协议(Two Phase Commitment Protocol)中，涉及到两种角色  </p>
<ul>
<li>一个事务协调者（coordinator）：负责协调多个参与者进行事务投票及提交(回滚)  </li>
<li>多个事务参与者（participants）：即本地事务执行者</li>
</ul>
<p>总共处理步骤有两个<br>（1）投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）；<br>（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；  </p>
<h3 id="2PC-Message-Queue"><a href="#2PC-Message-Queue" class="headerlink" title="2PC Message Queue"></a>2PC Message Queue</h3><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/affair.png">  </p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。<br>Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。<br>TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm&#x2F;Cancel 操作若执行失败，TM 会进行重试。  </p>
<p>需要注意：  </p>
<ul>
<li>空回滚  </li>
<li>防悬挂</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://blog.csdn.net/chen_kkw/article/details/82724330">https://blog.csdn.net/chen_kkw/article/details/82724330</a><br><a href="https://zhuanlan.zhihu.com/p/328728595">https://zhuanlan.zhihu.com/p/328728595</a><br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a><br><a href="https://medium.com/vimeo-engineering-blog/">https://medium.com/vimeo-engineering-blog/</a>   improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed<br><a href="https://www.jianshu.com/p/5fa447c60327">https://www.jianshu.com/p/5fa447c60327</a><br><a href="https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept">https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept</a><br><a href="https://www.cnblogs.com/williamjie/p/11132211.html">https://www.cnblogs.com/williamjie/p/11132211.html</a>  </p>
<p><a href="https://blog.csdn.net/hosaos/article/details/89136666">https://blog.csdn.net/hosaos/article/details/89136666</a><br><a href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a><br><a href="https://www.cnblogs.com/dyzcs/p/13780668.html">https://www.cnblogs.com/dyzcs/p/13780668.html</a><br><a href="https://blog.csdn.net/bjweimengshu/article/details/79607522">https://blog.csdn.net/bjweimengshu/article/details/79607522</a><br><a href="https://microservices.io/patterns/data/event-sourcing.html">https://microservices.io/patterns/data/event-sourcing.html</a><br><a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/transaction-log-tailing.html">https://microservices.io/patterns/data/transaction-log-tailing.html</a>  </p>
]]></content>
      <categories>
        <category>GoATC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>分布式</tag>
        <tag>缓存</tag>
        <tag>事务</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>对Go语言interface的理解</title>
    <url>/2019/03/03/golang-interface-understand/</url>
    <content><![CDATA[<h1 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h1><p>interface是一组method（方法）的组合，我们通过interface来定义对象的一组行为。  </p>
<h1 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h1><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。<br>（如果给鸭子模型定义划水的方法，当我再新建立一个鸟的对象，让它实现划水的方法，这时我可以认为鸟也是鸭子）  </p>
<p>一个例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以知道  </p>
<ul>
<li>interface可以被任意对象调用和实现。  </li>
<li>一个对象可以实现任意多个interface。</li>
</ul>
<p>形象的比喻：每个物种都是一个类，我们给这个类定义一系列的行为，例如给鸟类定义可以飞行的行为，给狗定义可以“汪汪”的声音，给人类定义可以说话可以跑步的行为，那么当你和我都实现了说话和跑步的行为，你我都属于人类，你和我都实现了飞行的行为，你我都属于鸟类，以此类推。这么做的意义在于，实现代码的高度使用。  </p>
<h1 id="思考：errors-这个-package-里面的-errors-New-到底是做什么的？"><a href="#思考：errors-这个-package-里面的-errors-New-到底是做什么的？" class="headerlink" title="思考：errors 这个 package 里面的 errors.New 到底是做什么的？"></a>思考：errors 这个 package 里面的 errors.New 到底是做什么的？</h1><p><code>errors</code>包实现了创建错误值的函数。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>使用字符串创建一个错误,可以类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(…))。  </p>
<p>例子  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(request <span class="type">string</span>)</span></span> (response <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> request == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">//调用errors.New函数时传入一个由字符串代表的错误信息，它会返回</span></span><br><span class="line">		<span class="comment">//给我们一个包含了这个错误信息的error类型值。该值的静态类型是error</span></span><br><span class="line">		err = errors.New(<span class="string">&quot;empty content&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	response = fmt.Sprintf(<span class="string">&quot;echo: %s&quot;</span>, request)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是返回一个自己定义的错误。  </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://golang.org/pkg/errors/">gopkg-errors</a>  </p>
<p><a href="https://golang.org/src/errors/errors.go?s=293:320#L1">New的实现</a></p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang踩坑集中整理</title>
    <url>/2019/05/14/golang-hit-pit-finish/</url>
    <content><![CDATA[<h1 id="append-x-1-与x-x3D-append-x-1-的区别"><a href="#append-x-1-与x-x3D-append-x-1-的区别" class="headerlink" title="append(x,1)与x &#x3D; append(x,1)的区别"></a>append(x,1)与x &#x3D; append(x,1)的区别</h1><p>今天有同事问我  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//append(x,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两者有什么区别</span></span><br></pre></td></tr></table></figure>

<p>我瞬间懵了，这不很明显吗？  </p>
<p><code>x = append(x,1)</code>是在<code>x</code>的原先基础上增加了一个元素，所以<code>x</code>中元素为5，而<code>append(x,1)</code>没有赋返回值，所以会报错!  </p>
<p>同事说，这不是重点，我是问你<code>append(x,1)</code>后<code>x</code>中的元素有几个。  </p>
<p>于是，我想了下，同时也请教了他人，最终得出答案，<code>x</code>为4。  </p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>append(x,1)之后相当于扩容，所以&#96;append 的结果，底层会分配一个新的数组。</p>
<p>如果我不接收返回值，相当于还是append前，长度没变。<br>那么为什么要这样呢</p>
<p>此处引用polaris的解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append 是 内置函数，必须要接收它的值。</span><br><span class="line">由此看来 go安全性做的确实好</span><br><span class="line">避免出现失误，没有将错误的append的结果保存</span><br></pre></td></tr></table></figure>

<p>因此</p>
<p>在<code>x := make([]int,4,4)</code>后，执行<code>x = append(x,1)</code>，长度为5；执行<code>append(x,1)</code>，长度为4.</p>
<p>注：可参考GO圣经中的Slice章节下的append用法介绍。 </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang插件-golangci-lint 基本介绍</title>
    <url>/2021/07/16/golang-extension-golangci-lint-introduce/</url>
    <content><![CDATA[<h2 id="golangci-lint-基本介绍"><a href="#golangci-lint-基本介绍" class="headerlink" title="golangci-lint 基本介绍"></a>golangci-lint 基本介绍</h2><p>golangci-lint 是一个 Go linters 聚合器。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>⚡ 非常快：并行运行 linter，重用 Go 构建缓存并缓存分析结果。<br>⚙️ 基于 Yaml 的配置。<br>🖥 与 VS Code、Sublime Text、GoLand、GNU Emacs、Vim、Atom、GitHub Actions 的集成。<br>🥇 包含 48 个linters，无需安装。<br>📈 由于调整了默认设置，误报的最小数量。<br>🔥带有颜色、源代码行和标记标识符的漂亮输出。  </p>
<h2 id="golangci-lint-各配置项介绍"><a href="#golangci-lint-各配置项介绍" class="headerlink" title="golangci-lint 各配置项介绍"></a>golangci-lint 各配置项介绍</h2><table>
<thead>
<tr>
<th align="center">名字</th>
<th align="left">描述</th>
<th align="center">预设</th>
</tr>
</thead>
<tbody><tr>
<td align="center">deadcode</td>
<td align="left">找到未使用的代码</td>
<td align="center">没用过</td>
</tr>
<tr>
<td align="center">errcheck</td>
<td align="left">errcheck是用于在Go程序中检查未选中错误的程序。在某些情况下，这些未选中的错误可能是关键错误</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">gosimple</td>
<td align="left">Linter for Go 源代码，专门用于简化代码</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">govet</td>
<td align="left">Vet 检查 Go 源代码并报告可疑结构，例如参数与格式字符串不一致的 Printf 调用</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">ineffassign</td>
<td align="left">检测何时不使用对现有变量的赋值</td>
<td align="center">没用过</td>
</tr>
<tr>
<td align="center">staticheck</td>
<td align="left">查找未使用的结构字段</td>
<td align="center">没用过</td>
</tr>
<tr>
<td align="center">typecheck</td>
<td align="left">就像 Go 编译器的前端一样，解析和类型检查 Go 代码</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">unused</td>
<td align="left">检查未使用常量，变量，函数和类型的Go代码</td>
<td align="center">没用过</td>
</tr>
<tr>
<td align="center">varcheck</td>
<td align="left">查找未使用的全局变量和常量</td>
<td align="center">没用过</td>
</tr>
<tr>
<td align="center">asciicheck</td>
<td align="left">简单的 linter 检查您的代码是否不包含非 ASCII 标识符</td>
<td align="center">错误、样式</td>
</tr>
<tr>
<td align="center">bodyclose</td>
<td align="left">检查 HTTP 响应体是否成功关闭</td>
<td align="center">性能、错误</td>
</tr>
<tr>
<td align="center">cyclop</td>
<td align="left">检查函数和包的圈复杂度</td>
<td align="center">复杂性</td>
</tr>
<tr>
<td align="center">depguard</td>
<td align="left">Go linter 检查包导入是否在可接受的包列表中</td>
<td align="center">样式、导入、模块</td>
</tr>
<tr>
<td align="center">dogsled</td>
<td align="left">检查具有太多空白标识符的分配（例如 x, , , _, :&#x3D; f()）</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">dupl</td>
<td align="left">代码克隆检测工具</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">durationcheck</td>
<td align="left">检查两个持续时间相乘</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">errorlint</td>
<td align="left">errorlint 是一个 linter，可用于查找会导致 Go 1.13 中引入的错误包装方案出现问题的代码。</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">exhaustive</td>
<td align="left">检查枚举 switch 语句的详尽程度</td>
<td align="center">错误、样式</td>
</tr>
<tr>
<td align="center">exhaustivestruct</td>
<td align="left">检查所有结构的字段是否已初始化</td>
<td align="center">样式、测试</td>
</tr>
<tr>
<td align="center">exportloopref</td>
<td align="left">检查指向封闭循环变量的指针</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">forbidigo</td>
<td align="left">禁止标识符</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">forcetypeassert</td>
<td align="left">查找强制类型断言</td>
<td align="center">错误、样式</td>
</tr>
<tr>
<td align="center">funlen</td>
<td align="left">用于检测长功能的工具</td>
<td align="center">复杂性</td>
</tr>
<tr>
<td align="center">gci</td>
<td align="left">gci 控制 golang 包导入顺序并使其始终具有确定性；检查是否存在全局变量；该分析器检查任何发现的全局变量和错误。</td>
<td align="center">格式、导入</td>
</tr>
<tr>
<td align="center">gochecknoglobals</td>
<td align="left">全局变量是在包作用域中声明并且可以读取的变量，并由包内的任何函数写入。 全局变量可能导致难以跟踪的副作用。 一个函数中的代码可能改变变量状态，而另一个不相关的代码块可能是受其影响。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">gocognit</td>
<td align="left">检查 Go 代码中是否不存在 init 函数</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">asciicheck</td>
<td align="left">计算和检查功能的认知复杂性</td>
<td align="center">复杂性</td>
</tr>
<tr>
<td align="center">goconst</td>
<td align="left">查找可以被常量替换的重复字符串</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">gocritic</td>
<td align="left">提供许多诊断程序来检查错误、性能和样式问题。无需通过动态规则重新编译即可扩展。动态规则是使用 AST 模式、过滤器、报告消息和可选建议以声明方式编写的。</td>
<td align="center">样式、性能</td>
</tr>
<tr>
<td align="center">gocyclo</td>
<td align="left">计算并检查功能的循环复杂性</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">godot</td>
<td align="left">检查评论是否在一段时间内结束</td>
<td align="center">样式、评论</td>
</tr>
<tr>
<td align="center">godox</td>
<td align="left">用于检测FIXME，TODO和其他注释关键词的工具</td>
<td align="center">样式、评论</td>
</tr>
<tr>
<td align="center">goerr113</td>
<td align="left">Golang Linter检查错误处理表达式</td>
<td align="center">样式、错误</td>
</tr>
<tr>
<td align="center">gofmt</td>
<td align="left">GOFMT检查代码是否是GOFMT-ed。默认情况下，此工具将使用-s选项运行以检查代码简化</td>
<td align="center">格式</td>
</tr>
<tr>
<td align="center">gofumpt</td>
<td align="left">gofumpt检查代码是否是gofumpt-ed</td>
<td align="center">格式</td>
</tr>
<tr>
<td align="center">goheader</td>
<td align="left">Checks是文件标题与模式匹配</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">goimports</td>
<td align="left">Goimports 完成了 gofmt 所做的一切。 此外，它还检查未使用的导入</td>
<td align="center">格式、引入</td>
</tr>
<tr>
<td align="center">golint ⚠</td>
<td align="left">linter 的存储库已由所有者存档。 被revive取代。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">gomnd</td>
<td align="left">检测幻数的分析器。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">gomoddirectives</td>
<td align="left">管理 go.mod 中“replace”、“retract”和“excludes”指令的使用。</td>
<td align="center">样式、模块</td>
</tr>
<tr>
<td align="center">gomodguard</td>
<td align="left">允许和阻止list linter 用于直接 Go 模块依赖项。 这与 depguard 不同，depguard 有不同的块类型，例如版本约束和模块推荐。</td>
<td align="center">样式、引入、模块</td>
</tr>
<tr>
<td align="center">goprintffuncname</td>
<td align="left">检查打印类函数是否以结尾命名为f</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">gosec</td>
<td align="left">检查安全问题的源代码</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">ifshort</td>
<td align="left">尽可能检查您的代码是否对 if 语句使用了简短的语法</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">importas</td>
<td align="left">强制使用一致的导入别名</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">interfacer ⚠</td>
<td align="left">LINTER的存储库已被所有者存档</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">lll</td>
<td align="left">报告排长队</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">makezero</td>
<td align="left">使用非零初始长度查找切片声明</td>
<td align="center">样式、错误</td>
</tr>
<tr>
<td align="center">maligned ⚠</td>
<td align="left">linter 的存储库已由所有者存档。 替换为 govet ‘fieldalignment’。</td>
<td align="center">性能</td>
</tr>
<tr>
<td align="center">misspell</td>
<td align="left">在评论中查找常见拼写错误的英语单词</td>
<td align="center">样式、评论</td>
</tr>
<tr>
<td align="center">nakedret</td>
<td align="left">在大于指定函数长度的函数中查找裸返回</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">nestif</td>
<td align="left">报告深度嵌套的 if 语句</td>
<td align="center">复杂性</td>
</tr>
<tr>
<td align="center">nilerr</td>
<td align="left">找到即使检查错误不是nil，也可以找到返回nil的代码。</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">nlreturn</td>
<td align="left">nlreturn在返回和分支机构语句之前检查新行以增加代码清晰度</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">noctx</td>
<td align="left">noctx发现没有context.context的发送HTTP请求</td>
<td align="center">性能、错误</td>
</tr>
<tr>
<td align="center">nolintlint</td>
<td align="left">报告不良或不足的Nolint指令</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">paralleltest</td>
<td align="left">paralleltest 在你的 Go 测试中检测到 t.Parallel() 方法的缺失使用</td>
<td align="center">样式、测试</td>
</tr>
<tr>
<td align="center">prealloc</td>
<td align="left">查找可能预先分配的切片声明</td>
<td align="center">性能</td>
</tr>
<tr>
<td align="center">predeclared</td>
<td align="left">找到隐藏 Go 预先声明的标识符之一的代码</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">promlinter</td>
<td align="left">通过 promlint 检查 Prometheus 指标命名</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">revive</td>
<td align="left">用于 Go 的快速、可配置、可扩展、灵活且美观的 linter。 直接替换 golint。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">rowserrcheck</td>
<td align="left">检查是否已成功检查行的错误</td>
<td align="center">错误、SQL</td>
</tr>
<tr>
<td align="center">scopelint ⚠</td>
<td align="left">所有者已弃用了Linter的存储库。由exportloopref替换。</td>
<td align="center">错误</td>
</tr>
<tr>
<td align="center">sqlclosecheck</td>
<td align="left">检查sql.rows和sql.stmt是否已关闭。</td>
<td align="center">错误、SQL</td>
</tr>
<tr>
<td align="center">stylecheck</td>
<td align="left">STYLECHECK是GOLINT的替代品</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">tagliatelle</td>
<td align="left">检查struct标签。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">testpackage</td>
<td align="left">LINTE让您使用单独的_test包</td>
<td align="center">样式、测试</td>
</tr>
<tr>
<td align="center">thelper</td>
<td align="left">T Helper检测Golang测试助手没有T.helper（）单元格，并检查测试助手的一致性</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">tparallel</td>
<td align="left">parallel 检测 Go 测试代码中 t.Parallel() 方法的不当使用</td>
<td align="center">样式、测试</td>
</tr>
<tr>
<td align="center">unconvert</td>
<td align="left">删除不必要的类型转换</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">unparam</td>
<td align="left">报告未使用的功能参数</td>
<td align="center">未使用</td>
</tr>
<tr>
<td align="center">wastedassign</td>
<td align="left">WastedAssign找到浪费的分配声明。</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">whitespace</td>
<td align="left">检测前导和尾随空格的工具</td>
<td align="center">样式</td>
</tr>
<tr>
<td align="center">wrapcheck</td>
<td align="left">检查从外部包返回的错误是否已包装</td>
<td align="center">样式、错误</td>
</tr>
<tr>
<td align="center">wsl</td>
<td align="left">强制您使用空行</td>
<td align="center">样式</td>
</tr>
</tbody></table>
<p>例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;--skip-dirs=vendor&quot;</span>,</span><br><span class="line"><span class="string">&quot;--fast&quot;</span>,</span><br><span class="line"><span class="string">&quot;--enable-all&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gochecknoglobals&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=lll&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gofmt&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=depguard&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=misspell&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gocritic&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gochecknoinits&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=funlen&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=wsl&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gomnd&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gosec&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=nestif&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=exhaustivestruct&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=godot&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=nlreturn&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=makezero&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=tagliatelle&quot;</span>,</span><br><span class="line"><span class="string">&quot;--disable=gocognit&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>插件</tag>
        <tag>golangci-lint</tag>
      </tags>
  </entry>
  <entry>
    <title>由FFmpeg合成视频静帧引发的协程未关闭的解决方案</title>
    <url>/2020/08/04/golang-merge-video-still-frame/</url>
    <content><![CDATA[<h2 id="产生静帧的原因"><a href="#产生静帧的原因" class="headerlink" title="产生静帧的原因"></a>产生静帧的原因</h2><p>视频的长度比音频短 ——&gt; 为什么视频短？ ——&gt; 1，外部给的数据就少；2，内部合成的问题。  </p>
<p>本文主要对7月底出现的一次静帧bug做详细的分析和给出的解决方案。  </p>
<h2 id="回顾整个任务流程"><a href="#回顾整个任务流程" class="headerlink" title="回顾整个任务流程"></a>回顾整个任务流程</h2><ul>
<li>开始任务：上层服务通知开始做任务时，我根据数据合成最终视频后，通过<code>Redis</code>数据库告知上层服务我已经做完任务了。</li>
<li>结束任务：上层服务发送结束任务时，我立刻停掉所有正在进行的协程。</li>
</ul>
<h2 id="问题溯源"><a href="#问题溯源" class="headerlink" title="问题溯源"></a>问题溯源</h2><p>首先，我通过看日志发现：上层服务只调用了一次开始任务的请求，但我这里却<strong>重复做了任务</strong>，也就是一个人做了两次任务。  </p>
<p>为什么呢？于是我根据日志查到源头，发现是这个循环检测<code>redis key</code>出了问题。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> redis_value <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">	redis_value, _ = redis.String(c.Do(<span class="string">&quot;GET&quot;</span>, redis_key))</span><br><span class="line"></span><br><span class="line">	Log.Info(GoID+<span class="string">&quot;: get redis value is: &quot;</span>, redis_value)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(redis_value) == <span class="number">0</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">15</span>) * time.Second)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">var</span> filelist FileList</span><br><span class="line">		Unerr := json.Unmarshal([]<span class="type">byte</span>(redis_value), &amp;filelist)</span><br><span class="line">		<span class="keyword">if</span> Unerr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">           Log.Info(GoID+<span class="string">&quot;: unmarshal filelist: &quot;</span>, filelist)</span><br><span class="line">           </span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而本地测试后发现没问题，那么问题出在哪里呢？  </p>
<p>后来我又看了日志，发现两个任务发的时间间隔很短，会不会是任务重了，导致同一个人开了两个协程，协程1在检测协程2已经生成的视频文件，结果视频还没有生成完，就送去做转场合成，导致最终的视频过短，从而产生静帧？  </p>
<p>经过和上层服务的负责人沟通，确认他当时发第一次任务后忘记停止任务了，导致发第二次任务时，第一次任务还在循环检测<code>redis key</code>，最终两个任务一起做了。  </p>
<p>于是他改了下代码，重新测试，但是问题还存在，这次主要集中在我这里，因为我发现<strong>即使上层服务发送了停止任务的请求，但我这里还是有协程在做检测redis key的活</strong>，所以最终问题确认为————发送了停止任务后，我这里没有及时关闭掉协程。  </p>
<p>修改代码，使用<code>sync.WaitGroup</code>控制协程的数量：  </p>
<p>person.go  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wg := sync.WaitGroup&#123;&#125;  <span class="comment">//很重要</span></span><br><span class="line"></span><br><span class="line">stopdone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">   StopTaskChannelMapOp(taskid, <span class="string">&quot;set&quot;</span>, stopdone)</span><br><span class="line">   <span class="keyword">for</span> _, person := <span class="keyword">range</span> personredis &#123;</span><br><span class="line">   <span class="keyword">go</span> Task(stopdone,wg)  </span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> &lt;-stopdone:</span><br><span class="line">				Log.Info(<span class="string">&quot;Stop Task&quot;</span>, taskid)</span><br><span class="line">				StopTaskChannelMapOp(taskid, <span class="string">&quot;delete&quot;</span>, stopdone)</span><br><span class="line"></span><br><span class="line">				wg.Done()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">           &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>task.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task</span><span class="params">(stop <span class="keyword">chan</span> <span class="type">bool</span>,wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)  <span class="comment">//很重要</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()  <span class="comment">//很重要</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> redis_value <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    t := time.NewTicker(<span class="number">15</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		redis_value, _ = redis.String(c.Do(<span class="string">&quot;GET&quot;</span>, redis_key))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(redis_value) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">            <span class="comment">//收到停止任务的请求后，直接结束这个协程</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            <span class="comment">//睡15s后继续检测redis key</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//unmarshal redis value</span></span><br><span class="line">			<span class="keyword">var</span> filelist FileList</span><br><span class="line">			Unerr := json.Unmarshal([]<span class="type">byte</span>(redis_value), &amp;filelist)</span><br><span class="line">			<span class="keyword">if</span> Unerr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Log.Info(GoID+<span class="string">&quot;: unmarshal filelist: &quot;</span>, filelist)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，收到停止任务后即可结束正在做任务的协程。  </p>
<h2 id="个人理解的sync-WaitGroup的用法"><a href="#个人理解的sync-WaitGroup的用法" class="headerlink" title="个人理解的sync.WaitGroup的用法"></a>个人理解的sync.WaitGroup的用法</h2><p>专业解释可以看官方文档或文章底部的参考资料，在此仅仅对我目前所用的<code>WaitGroup</code>做简单的理解，如有误差请及时提出来我好补充，感谢。  </p>
<p><code>WaitGroup</code>就像是一个计数器，开一个协程，<code>Add</code>就会让计数器加1，当协程运行完或中间退出时，<code>Done</code>就会减1，但当你开了很多协程，但又不知道什么时候协程会全部结束时，就需要<code>Wait</code>等待所有协程结束。  </p>
<p>而对于一些必须要及时退出协程的情况（比如我上述锁描述的情况），就需要用<code>channel</code>通知协程关闭，所以一定要在所有协程可能会退出的情况记得<code>Done</code>，或者使用<code>defer wg.Done</code>，否则<code>WaitGroup</code>这个“计数器”不为1，它就会一直卡住。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>遇到问题多想，多测试，多看日志，多分析；  </li>
<li>实在找不到问题，可以和相关的负责人员沟通，一起寻找突破口；  </li>
<li>一定要找到问题的本质，从根源解决，不要想着用一个应急方案先凑活，不然你会发现你的职业生涯就一直在和这类业务问题做斗争；  </li>
<li><code>sync.WaitGroup</code>是让协程优雅退出的一种解决方式，那么是否还有其他让协程退出的方法呢？  </li>
<li>所有看似匪夷所思的<code>Bug</code>，背后一定绕不开它的基础原理；  </li>
<li>最后感谢部门同事@yangfengyu和@chenhan的帮助，让我有<code>get</code>了一个新技能。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/79d27f200bcf">简书_Golang并发：并发协程的优雅退出</a><br><a href="https://zhuanlan.zhihu.com/p/75441551">你真的会用sync.WaitGroup吗</a><br><a href="https://www.dyxmq.cn/program/code/golang/waitgroup-in-golang.html">起风了_Golang等待组sync.WaitGroup的用法</a></p>
]]></content>
      <categories>
        <category>Solution-notes</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发</tag>
        <tag>协程</tag>
        <tag>WaitGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作常用函数介绍</title>
    <url>/2019/04/07/golang-string-operation-function/</url>
    <content><![CDATA[<ul>
<li>操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&quot;helloogo&quot;中是否包含&quot;hello&quot;</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;helloogo&quot;</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;helloogo&quot;</span>, <span class="string">&quot;goe&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Join组合</span></span><br><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">buf := strings.Join(s, <span class="string">&quot;_&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf = &quot;</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Index 查找子串所在位置</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;abcdhello&quot;</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;abcdhello&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Repeat 重复打印</span></span><br><span class="line">buf = strings.Repeat(<span class="string">&quot;go&quot;</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf = &quot;</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Split 以指定的分隔符对字符串进行拆分</span></span><br><span class="line">buf = <span class="string">&quot;hello&amp;abc&amp;go&amp;mike&amp;you&quot;</span></span><br><span class="line">s2 := strings.Split(buf, <span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim 去掉两头的字符</span></span><br><span class="line">buf = strings.Trim(<span class="string">&quot;      are you ok    &quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf = &quot;</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fields 去掉空格，把元素放入切片中</span></span><br><span class="line">s3 := strings.Fields(<span class="string">&quot;    are you ok?    &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> s3 &#123;</span><br><span class="line">	fmt.Println(i, <span class="string">&quot;, &quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">buf =  abc_hello_mike_go</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">buf =  gogogo</span><br><span class="line">s2 =  [hello abc go mike you]</span><br><span class="line">buf =  are you ok</span><br><span class="line">0 ,  are</span><br><span class="line">1 ,  you</span><br><span class="line">2 ,  ok?</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang操作Redis数据库小结</title>
    <url>/2019/11/03/golang-redis-op/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>十月中旬要做出一个和<code>Redis</code>相关的服务，在此记录<code>Golang</code>操作<code>Redis</code>的笔记。  </p>
<h2 id="Golang操作Redis"><a href="#Golang操作Redis" class="headerlink" title="Golang操作Redis"></a>Golang操作Redis</h2><p>(内容还在更新中…)  </p>
<h3 id="使用redisgo包"><a href="#使用redisgo包" class="headerlink" title="使用redisgo包"></a>使用redisgo包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/garyburd/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Connect to redis error&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入值</span></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;SET&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;nick&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis set failed:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取key对应的value值</span></span><br><span class="line">	username, err := redis.String(c.Do(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;username&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis get failed:&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Get username %v \n&quot;</span>, username)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从右往左，存一个名字为mylist的列表</span></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;lpush&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;ofo&quot;</span>, <span class="string">&quot;mobike&quot;</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis lpush failed&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从左往右，给一个名字为mylist的列表存值</span></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;rpush&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;bluegogo&quot;</span>, <span class="string">&quot;xiaolan&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis rpush failed&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取这个列表的长度</span></span><br><span class="line">	num, err := c.Do(<span class="string">&quot;llen&quot;</span>, <span class="string">&quot;mylist&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;mylist get len err&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;mylist&#x27;s len is &quot;</span>, num)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取mylist列表下表从0到10的值</span></span><br><span class="line">	values, err := redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lrange err&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;mylist is:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; %s &quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;ltrim&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;ltrim error&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;ltrim failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ltrim mylist is:&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s &quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val, err := c.Do(<span class="string">&quot;lindex&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lindex error:&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;lindex get result :%s\n&quot;</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;rpoplpush&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;mybike&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;rpoplpush failed:&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;lrange failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;rpoplpush %s\n&quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mybike&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;lrange failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;rpoplpush %s\n&quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;lset&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">2</span>, <span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lset error:&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	val, err = c.Do(<span class="string">&quot;lindex&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lset error:&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;lset get result:%s\n&quot;</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;lrem&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">1</span>, <span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lrem error&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;ltrim failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;lrem mylist: %s&quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;lpop&quot;</span>, <span class="string">&quot;mylist&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lpop failed:&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;lpop failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;lpop mylist :&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;lpop mylist %s&quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">&quot;rpop&quot;</span>, <span class="string">&quot;mylist&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;rpop failed&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">&quot;lrange&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;rpop failed:&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;rpop mylist :&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;lpop mylist %s&quot;</span>, v.([]<span class="type">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err := c.Do(<span class="string">&quot;blpop&quot;</span>, <span class="string">&quot;mylist&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;blpop error&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;blpop from mylist get:%s\n&quot;</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">&quot;blpop&quot;</span>, <span class="string">&quot;tmpbike&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;blpop time out&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;blpop from tmpbike get:&quot;</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">&quot;brpop&quot;</span>, <span class="string">&quot;tmpbike&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;brpop error&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;brpop from tmpbike get :%s\n&quot;</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">&quot;brpop&quot;</span>, <span class="string">&quot;mybike&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;brpop time out&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;brpop from mybike get:%s &quot;</span>, res)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程_Redis教程</a>  </li>
<li><a href="https://www.jianshu.com/p/89ca34b84101">Golang操作redis指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/golang-test-tips/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？  </p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：  </p>
<ul>
<li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li>
</ul>
<p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure>
<p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。  </p>
<p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>单元测试</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode下Golang的配置以及Git分支合并注意事项</title>
    <url>/2021/07/16/golang-vscode-setting-and-git-feature/</url>
    <content><![CDATA[<h2 id="Golang环境配置"><a href="#Golang环境配置" class="headerlink" title="Golang环境配置"></a>Golang环境配置</h2><h3 id="1-Golang-编译环境安装"><a href="#1-Golang-编译环境安装" class="headerlink" title="1. Golang 编译环境安装"></a>1. Golang 编译环境安装</h3><ul>
<li><a href="https://golang.google.cn/dl/">点击下载Golang编译环境安装文件</a>  </li>
<li>或者<a href="https://studygolang.com/dl">https://studygolang.com/dl</a></li>
</ul>
<p>完成后，安装文件</p>
<p>安装完成后，配置windows的系统环境变量，增加<code>golang\bin</code>目录</p>
<p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/go1.png"><br><img src="/2021/07/16/golang-vscode-setting-and-git-feature/go2.png">  </p>
<h3 id="2-Windows下安装MinGW，Linux下可以忽略此步骤"><a href="#2-Windows下安装MinGW，Linux下可以忽略此步骤" class="headerlink" title="2.Windows下安装MinGW，Linux下可以忽略此步骤"></a>2.Windows下安装MinGW，Linux下可以忽略此步骤</h3><ul>
<li><a href="http://mingw-w64.org/doku.php/download">点击下载Mingw</a></li>
</ul>
<p>完成后，解压文件，生成一个全新文件夹<code>mingw64</code>，将此放到任意位置  </p>
<p>进入<code>mingw64\bin</code>文件夹，拷贝<code>mingw32-make.exe</code>文件，并重命名为<code>make.exe</code>  </p>
<p>配置windows的系统环境变量，增加<code>mingw64\bin</code>目录  </p>
<p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/mg1.png"></p>
<ul>
<li><p><a href="https://code.visualstudio.com/Download/">点击下载VSCode</a>  </p>
</li>
<li><p>打开<code>VSCode</code>，进入Extensions，下载其他插件</p>
</li>
</ul>
<p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/cha-jian.png">  </p>
<h3 id="3-检验插件是否运作的方法"><a href="#3-检验插件是否运作的方法" class="headerlink" title="3. 检验插件是否运作的方法"></a>3. 检验插件是否运作的方法</h3><h4 id="检查插件goimport是否运作"><a href="#检查插件goimport是否运作" class="headerlink" title="检查插件goimport是否运作"></a>检查插件goimport是否运作</h4><p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/1.png">  </p>
<h4 id="检查插件golangci-lint是否运作"><a href="#检查插件golangci-lint是否运作" class="headerlink" title="检查插件golangci-lint是否运作"></a>检查插件golangci-lint是否运作</h4><p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/2.png">  </p>
<p><code>golangci-lint</code>会自动帮助开发者检查代码有明显语法错误的地方  </p>
<h3 id="4-批量安装Go相关插件"><a href="#4-批量安装Go相关插件" class="headerlink" title="4. 批量安装Go相关插件"></a>4. 批量安装Go相关插件</h3><p>首先，记得开启<code>go module</code>：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>其次，修改<code>GOPROXY</code>，将其改为<code>GOPROXY=https://goproxy.cn</code>，命令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn/       // Windows 或 Linux</span><br><span class="line">export GOPROXY=https://goproxy.cn/          // macOS 或 Linux</span><br></pre></td></tr></table></figure>

<p>在VSCode下同时按下<code>Ctrl + Shift + P</code>，选择<code>Go:Install/Update Tools</code>，然后点击全选，点OK，下载即可  </p>
<p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/go-tools.png">  </p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq2942713658/article/details/112915326">Go语言GOPROXY设置</a>  </p>
<h2 id="代码合并注意事项"><a href="#代码合并注意事项" class="headerlink" title="代码合并注意事项"></a>代码合并注意事项</h2><h3 id="Git分支构成"><a href="#Git分支构成" class="headerlink" title="Git分支构成"></a>Git分支构成</h3><p>分支划分如下：</p>
<ul>
<li>master：与线上版本保持绝对一致；  </li>
<li>develop：开发分支，由下文提到的release、feature、hotfix分支合并过后的代码；  </li>
<li>feature：实际功能点开发分支，建议每个功能新建一个feature， 具有关联关系的功能公用一个feature分支；  </li>
<li>release：每一次开发完成之后，从develop创建出来的分支，以此分支为基准，进行测试；  </li>
<li>hotfix：该分支主要用于修复线上bug；</li>
</ul>
<p>命名规范约定如下：  </p>
<ul>
<li>feature分支命名：feature-name  </li>
<li>release分支命名：release-name  </li>
<li>hotfix分支命名：hotfix-name</li>
</ul>
<p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature-optimize_distributed_session进行开发，开发完成后合并到develop分支。  </p>
<h3 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h3><p><strong>master分支</strong><br>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。  </p>
<p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。  </p>
<p><strong>develop分支</strong><br>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。  </p>
<p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。  </p>
<p><strong>feature分支</strong><br>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。  </p>
<p><strong>release分支</strong><br>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。  </p>
<p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。  </p>
<p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。  </p>
<p><strong>hotfix分支</strong><br>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。  </p>
<p><strong>特殊情况处理和注意点</strong>  </p>
<p>Q:develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理？  </p>
<ul>
<li>以master为基线创建feature， 在完成之后，代码合并到master分支；  </li>
<li>为了保证develop是最新代码，需要从master合并到develop分支；</li>
</ul>
<p>Q:以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办？  </p>
<ul>
<li>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;  </li>
<li>如果已经创建，则需要合并到一个分支；</li>
</ul>
<p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;<br>使用rebase注意，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；  </p>
<p><strong>提交说明规范：</strong>  </p>
<ul>
<li>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；  </li>
<li>如果关联jira，写上jira地址；</li>
</ul>
<h3 id="不同业务代码的管理需求差异"><a href="#不同业务代码的管理需求差异" class="headerlink" title="不同业务代码的管理需求差异"></a>不同业务代码的管理需求差异</h3><p><img src="/2021/07/16/golang-vscode-setting-and-git-feature/3.png">  </p>
<h3 id="工作中常见的场景"><a href="#工作中常见的场景" class="headerlink" title="工作中常见的场景"></a>工作中常见的场景</h3><p><strong>开发周期中，所有的功能在当前周期都能完成，需求评审确认通过且开发任务符合预期：</strong><br>时间线：D1→D2→D3→D4→S3→M2 。因为经过评估在下一个发布时间前开发人员能够将D1到D4的4个功能完成开发，所以在次期间我们只需要保证这个分支的功能能正常演进即可，尽量不要引进太多的分支。  </p>
<p><strong>开发周期中，所有功能在当前周期完成，需求评审确认通过，少部分功能上线时间待定，任务进度符合预期：</strong><br>这个时候可能存在2条线，大部分人参与当前版本的功能开发（develop分支的演进），少部分人进行未来版本上线的需求开发（F1，F2，F3）。F3→S2 这个合并尽量等到需求拍定上线版本后合并到stage给测试人员测试。  </p>
<p><strong>线上BUG的修复：</strong><br>确认BUG后，如果是测试人员反馈回来的一般会是在JIRA 上提单，我们可以根据jira的issue Id，在master 上 创建一个bugfix-jira-xx，接下来在这个分支上完成补丁的开发（B1→B2），之后合并补丁到stage分支进行测试环境的部署（B2→S4），等待测试人员的验证，验证完成后将补丁合并到master和develop分支（B2→M3，B2→D5），并打一个小版本号的tag。  </p>
<p><strong>有个新功能，老板想立马上线，但是发版的时间还没到：</strong><br>这种情况，把这个功能当成一个超前的feature处理，我们上面说的feature是一个未来版本的功能，可以走未来版本的测试上线流程，这里的feature 是一个超前的功能，我们需要走类似bugfix的流程，进行一个快速的开发上线。  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Git</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>再见乌鲁木齐，再见新疆</title>
    <url>/2019/05/11/goodbye-urumqi-goodbye-xinjiang/</url>
    <content><![CDATA[<p><a href="./plane"></a>  </p>
<p>(本文有感于五一，完稿于母亲节)  </p>
<p>5月6号晚，在乌鲁木齐的地窝堡国际机场，坐在飞机上，广播里说着飞机即将起飞，请关闭手机或调整为飞行模式，我知道，我又要和这座城市告别了。  </p>
<p>父亲开车送我去机场的路上，在穿过蜘蛛山隧道时，落日的余晖洒向了这座城市，我看到了这里林立的高楼，和四通八达的街道，以及刚刚亮起来的路灯。  </p>
<p>是的，这是我生活了二十二年的城市。  </p>
<p>它完整的记录了我从孩童成长为工作者的心路历程。  </p>
<p>就让我再穿越回过去，回忆这些转瞬即逝又弥足珍贵的记忆。  </p>
<h1 id="与杨搭城堡"><a href="#与杨搭城堡" class="headerlink" title="与杨搭城堡"></a>与杨搭城堡</h1><p>时间：小学四年级。  </p>
<p>地点：小巷子。  </p>
<p>人物：童年玩伴杨  </p>
<p>结束了一天在学校的学习，作业太少了，提前做完了，就算不会第二天去早点抄，玩耍才是最重要的！  </p>
<p>我约了杨和我一起去沙堆上搭城堡（其实现在看来像是在打洞），我和他挖的正兴奋时，父亲怒气冲冲的过来把我像提小鸡一样提起来，告诫我不要玩沙子，把手弄脏了。</p>
<p>我给杨递了个眼色，于是给父亲保证再不会碰这个了。  </p>
<p>等父亲走后，我又跑过去和他动工了。忙活到了晚上十点多，终于把城堡搭完了，筷子用断了好几根，脸也脏了，不过还是很开心呢。  </p>
<p>虽然这些艺术品在大人看来一文不值，明天估计就要被毁了，但我知道那时的我看到自己辛苦搭建出来的东西后，充满了成就感。  </p>
<h1 id="新华书店窃读记"><a href="#新华书店窃读记" class="headerlink" title="新华书店窃读记"></a>新华书店窃读记</h1><p>时间：小学五年级  </p>
<p>地点：乌鲁木齐市南门新华书店  </p>
<p>人物：童年玩伴杨  </p>
<p>因为非常喜欢看冒险小虎队系列的侦探书，无奈杨用零花钱买的几本书已经被我看了两遍了，于是我和他计划，周末去书店看。  </p>
<p>于是和父母说了一声后，周末吃过早饭和杨坐着61路公交车去书店，心里默念：今天我要看十本书！  </p>
<p>抵达书店，上二楼后厅，拿书，找空地坐下来，动作一气呵成。  </p>
<p>那一天，我记得是我生命中最充实最开心的时光，因为我把我的意识完全沉浸在侦探的世界里。  </p>
<h1 id="街边小巷你追我打的欢快"><a href="#街边小巷你追我打的欢快" class="headerlink" title="街边小巷你追我打的欢快"></a>街边小巷你追我打的欢快</h1><p>时间：小学六年级  </p>
<p>地点：街头小巷  </p>
<p>人物：一群小屁孩  </p>
<p>作业写完，叫上好朋友，一起去玩捉迷藏，真假孙悟空…反正就是各种跑。  </p>
<p>有时候玩得过头了，十几个小娃娃追着我，我就东躲西藏，他们说抓住我有重赏。  </p>
<p>就这样，间接锻炼了我奔跑的耐力和随机应变的决断力，也收获了一下午的喜悦。  </p>
<h1 id="插卡游戏机街头霸王车轮战"><a href="#插卡游戏机街头霸王车轮战" class="headerlink" title="插卡游戏机街头霸王车轮战"></a>插卡游戏机街头霸王车轮战</h1><p>时间：初一、二年级  </p>
<p>地点：韩家蛋糕盒厂  </p>
<p>人物：韩，杨等游戏高手  </p>
<p>初一认识了韩，因为他家有插卡游戏机，所以我经常跑他家里打游戏。  </p>
<p>还记得当时我最爱玩街头霸王，最喜欢用一个黄头发发冲击波的格斗家和会放电的野兽。为了发出绝招，我把游戏手柄的方向键搓掉了，又把自己的大拇指搓肿了。经常玩到父母上门来找才肯结束。  </p>
<p>除了街头霸王，还有四代魂斗罗，超级赛亚人等。  </p>
<h1 id="地下游戏厅称霸记"><a href="#地下游戏厅称霸记" class="headerlink" title="地下游戏厅称霸记"></a>地下游戏厅称霸记</h1><p>时间：初一  </p>
<p>地点：家对面的地下游戏厅  </p>
<p>人物：游戏爱好者  </p>
<p>家对面开了家游戏厅，里面有台球桌，还有两台PS2，在一个小隔间里还有四五台电脑，于是这里成了我放学和周末的天堂。  </p>
<p>我充分发挥了自己善于钻研和学习的天分，不到两个月，没花一分钱，成了这家游戏厅里的游戏专家，没事给打三国无双的玩家指点一二，或者去和其他人联机CS1.6场场爆头。  </p>
<p>后来因为白玩的次数太多了，被游戏厅老板拉入了黑名单。  </p>
<h1 id="懵懂无知的好感"><a href="#懵懂无知的好感" class="headerlink" title="懵懂无知的好感"></a>懵懂无知的好感</h1><p>时间：初二  </p>
<p>地点：某初中  </p>
<p>人物：a gril  </p>
<p>第一次对一个女孩产生好感应该就是这个时候吧。  </p>
<p>想想也真是奇葩，产生好感那就表现的好一点就是，然而偏偏把自己最坏的一面表现了出来。  </p>
<p>那种抑制不住的脸红和怦怦的心跳声，大概就是初恋的滋味吧，也是我再也回不去的青春。  </p>
<p>虽然我已经记不清她的模样，但也是因为她的出现和离开，让我学会如何去用心喜欢上一个人。  </p>
<h1 id="与赵的原始书信"><a href="#与赵的原始书信" class="headerlink" title="与赵的原始书信"></a>与赵的原始书信</h1><p>时间：初三  </p>
<p>地点：无  </p>
<p>人物：学习的榜样老赵  </p>
<p>面临中考，每当这时候会与相互打气，还记得那时候没有手机，不能登QQ，于是就以最原始的方式保持通信—写信。  </p>
<p>将信写好，装入那种放自动笔芯的圆筒内，然后交给顺路的人帮忙捎带给他，想想也是够机智的。  </p>
<p>这种方式一直持续到高考结束，然后就戛然而止。  </p>
<h1 id="影响我一生的良师益友"><a href="#影响我一生的良师益友" class="headerlink" title="影响我一生的良师益友"></a>影响我一生的良师益友</h1><p>时间：高三  </p>
<p>地点：高中  </p>
<p>人物：张，沈，杨，赵  </p>
<p>高三，多么神圣的阶段，也许你的一分，就能干掉上千人，这是当时最流行的宣传语。  </p>
<p>然而我又何尝不想拼搏努力呢。  </p>
<p>只是，当我把自己想象成一台做题机器时，总会有人帮我找回本来的模样。  </p>
<p>我想起，每当吃午饭的时候，我都会给凡儿和魁拔，讲述我自编的喜剧小说《高考命题组专家的故事》；我会在补习班内和杨还有赵吐槽这该死的高考题；我会咨询张老师是不是我太笨了为什么我一天睡五个小时，做题十个小时还是年级还不进步呢…  </p>
<p>多年后当我再来看这些问题时，会觉得当时的我多么幼稚。  </p>
<h1 id="大学毕业之后才懂"><a href="#大学毕业之后才懂" class="headerlink" title="大学毕业之后才懂"></a>大学毕业之后才懂</h1><ul>
<li>原来挣钱真的不容易  </li>
<li>保持终生学习的观念，这是一个长跑  </li>
<li>有空常回家看看  </li>
<li>学习靠主动，工作靠自觉  </li>
<li>有些人走着走着就会散了，你可以沉默一时，但不能一直活在这个阴影里  </li>
<li>生命第一，生活第二，工作第三</li>
</ul>
<h1 id="再见乌鲁木齐，再见新疆"><a href="#再见乌鲁木齐，再见新疆" class="headerlink" title="再见乌鲁木齐，再见新疆"></a>再见乌鲁木齐，再见新疆</h1><p>这里有我忘不掉的人和景。  </p>
<p>我想起和家人一起去阜康天池坐船看瀑布；一起去吐鲁番欣赏交河故城的荒凉，维吾尔族村寨，坎儿井的避暑好去处，火焰山的金箍棒温度计，葡萄沟的葡萄；一起去天山野生动物园里看狮子老虎大象长颈鹿，去植物园看各种花花草草，去游乐场玩碰碰车、旋转椅子和疯狂老鼠；一起自驾游去昌吉的杜氏旅游村；一起去石人沟骑马，我在湖边行走时右脚踏入沼泽地硬是左腿发力挣脱了出来；  </p>
<p>我感谢家人给予我资金和精神上的鼓励，在我大二暑假时同意让我一个人走出去看看，这一走就是一个多月，走了十三座城市，路上遇到了许多社会上各个阶级的人，使我长了见识；感谢他们一如既往的支持我继续读研和深造，而不是逼着我赶紧就业，虽然最后没有成功考上。  </p>
<p>我会想起和大学同学一起骑行一百二十公里去阿克苏的惊险刺激；和朋友去库车旅行，在沙漠公路上遭遇沙尘暴，方圆能见度不足三米的时候一辆越野车及时出现化解了危机；百里徒步去沙漠路上的艰辛，以及看到屹立不倒的胡杨，放佛沙漠中守护的卫士；  </p>
<p>我会想起和女友夏天去的博斯腾湖，夜晚欣赏那静谧的孔雀河；冬天在公园里散步，差点把自己的耳朵冻掉；  </p>
<p>我会想起和学校同学夏天扔水球，泼水冲凉，冬天打雪仗的开心；和慎在学校内散步，讨论物理化学题；和涛咨询人生困惑；和杨推着购物车在七一酱园，好家乡，友好里面乱逛；和好朋友去火焰山吃自助火锅烧烤，去八音和里唱歌，去人民电影院和和平都会踩点找最合适的场次；高三毕业去南山牧场吃烧烤，骑马。  </p>
<p>仔细梳理，原来我留在这的回忆有这么多。  </p>
<p>五一回家，看着周围熟悉的街道已经拆的差不多了，想想自己以后也是要一年才回一次家，不知明年回来时，这些记忆是否还能记住一半？  </p>
<p>从我决定离开这座城市到一座新城市发展的时候，我知道我以后需要独自面临许多未知的阻碍。我要随机应变适应新的环境。  </p>
<ul>
<li>我要更加坚强，来应对突如其来的质疑和压力；  </li>
<li>我要更加机警，防止被套路；  </li>
<li>我要更加勇敢，接受新挑战；  </li>
<li>我要更加感恩，记住在这样一个陌生的城市里还愿意帮助我的人；  </li>
<li>我要更加珍惜学习的机会；  </li>
<li>我要学会接纳自己的不足。</li>
</ul>
<p>今天，我不认为一年前我放弃校招选择社招离开自己熟悉的环境而感到遗憾，并且我从没有如此神清气爽过，我放佛看到了重生，因为从此以后，我将不受束缚。  </p>
<p><img src="/2019/05/11/goodbye-urumqi-goodbye-xinjiang/bohu">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>新疆</tag>
        <tag>乌鲁木齐</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业18个月，我终于在这座城市活了下来</title>
    <url>/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年12月19日，星期四，我在成都，写下了这句话，距离的毕业后的第一天入职，已经过去了整整十八个月。现在，我终于敢说，我在这座城市活了下来。  </p>
<p>犹记得，大学还有半年就毕业时，经历了考研失败的我，在考虑去哪座城市发展时，高中好友涛说，来成都嘛，找工作可以先住我家，于是，我跟父母说明情况后，就来到了成都。  </p>
<p>在这里，我逐渐学会了如何独立成长，如何与自己独处，如何照顾自己，以及如何与他人协作。  </p>
<p>从大一到大四，可能唯一的遗憾就是没有去实习过。  </p>
<p>寒假时间短，冬天基本就是在家，或者出去看看那似曾相识的街道，在雪地里和妹妹打雪仗。  </p>
<p>犹记得，最快乐最有意义的时光都是在暑假度过————支教，远途旅行，以及在家准备考研。  </p>
<p>毕业后的18个月，失去父母庇护的我，学习着如何写简历，投简历，面试，以及签下了我的第一份劳务合同，第一个月拿到了试用期的薪资，那一刻我放佛觉得我长大了，不再需要问父母要生活费，可以自己自给自足。  </p>
<h2 id="亲爱的小孩，今天有没有哭"><a href="#亲爱的小孩，今天有没有哭" class="headerlink" title="亲爱的小孩，今天有没有哭"></a>亲爱的小孩，今天有没有哭</h2><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>毕业后最大的收获，就在于适应了职场生存的法则。  </p>
<p>犹记得，刚入职的时候，第一次用<code>Go</code>写一个定时删除服务，涉及了大量的文件处理，设计模式和并发等知识点，当我写完后，我感觉很有成就感，后来，当这个服务产品化后，出现了一个内存泄露的问题，我又用性能分析工具层层剖析，解决了它。  </p>
<p>但我知道这只是小试牛刀，接着我有接手了一个核心调度的项目，然而这个项目给我的打击太大，比如逻辑很复杂，导致和产品对需求的时候，都不敢保证这个需求什么时候能做出来；又比如当整个系统出来了问题时，会把所有的<code>Bug</code>都指派给我，然后我就挨个去打断点，看日志去排查；又比如有一次，因为需求太多，做不完，每天被<code>leader</code>和其他同事催着赶进度时，我只能偷偷跑到卫生间去哭上五分钟，然后擦干眼泪继续做。  </p>
<p>为什么我对这两件事这么记忆尤新呢，因为它让我看到了一个程序员工作的缩影：提需求——编码——测试——改<code>Bug</code>——新的需求…周而复始。  </p>
<p>在工作中，我也总结了一些研发和改<code>Bug</code>的经验  </p>
<ul>
<li>1，和产品经理沟通是双向的，当他&#x2F;她提出一个需求时，最好是根据自己的理解把他&#x2F;她的话再复述一遍，以确认是否信息一致，当然最好写在文档里，后面可以防止产品频繁变需求（虽然这个愿望有些微小）；  </li>
<li>2，编码时，最好理清逻辑，在脑海中画好逻辑时序图，接着写代码就会轻松许多；  </li>
<li>3，最好在容易出错，以及频繁赋值的地方打上日志，后期出现<code>Bug</code>时好及时有效地定位问题；  </li>
<li>4，如果出现<code>Bug</code>了，最好在已经出现<code>Bug</code>的机器上再复现一遍，当然也可以在本地搭一个完整的测试环境，这样最好；  </li>
<li>5，运用性能分析工具，解决完<code>Bug</code>后，最好详细将<code>Bug</code>出现的原因和解决过程个最终结果记录下来，方便以后自己查阅；  </li>
<li>6，将自己的研发时间定在25-35分钟一块，中间最好不要被别人打断；  </li>
<li>7，学会使用搜索引擎，尽量用<code>Google</code>和<code>Bing</code>，将问题切换成英文描述，搜出来的文章质量会高一些；  </li>
<li>8，是你的问题，及时承担，不是你的问题，找到证据后迅速甩锅。</li>
</ul>
<p>以上是我个人在写程序的经验小结。  </p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><ul>
<li>1，自己做的饭真好吃</li>
</ul>
<p>2019年最大的感受就是学会了做饭。  </p>
<p>自己买了电磁炉，照着网上的步骤开始学会炒素菜，炒荤菜。接着依葫芦画瓢，不断调整酱油、盐、鸡精的比例，味道和颜色也好了许多。  </p>
<p>我想今年过年家里又多了个做饭的帮手。  </p>
<ul>
<li>2，一觉睡到自然醒的感觉真爽</li>
</ul>
<p>项目不忙的时候，六点半下班，回去看看书，玩玩手机，十一点前关灯睡觉，早上一觉睡到自然醒，再看看表，八点多，没事，还来得及。  </p>
<p>这段<code>一觉睡到自然醒</code>的时光，让我又找回了睡觉的乐趣，同时对<code>996</code>的厌恶又加深了一些。  </p>
<ul>
<li>3，睡前水乳护肤很舒服</li>
</ul>
<p>从大学买的一套曼秀雷敦，到18年毕业时买的高夫男士全套，再到今年的百雀羚，我逐渐学会了护肤这一技能。  </p>
<p>先用清水洗一遍脸，再涂上洗面奶清一遍，再用爽肤水，护肤乳，后面还可以用面霜，眼霜除皱纹，上班时还可以抹一层隔离霜，每次护理完，感觉脸像生命一样在自由的呼吸，很清爽。  </p>
<h3 id="在这座城市，哭过，笑过"><a href="#在这座城市，哭过，笑过" class="headerlink" title="在这座城市，哭过，笑过"></a>在这座城市，哭过，笑过</h3><p>在一座陌生的城市，给我最大的感触就是，一切都只能靠自己。  </p>
<p>找房子，你需要现场去验房，签合同；找工作，需要自己投简历，面试，签劳动合同；工作完成不了，你需要自己加班赶进度。  </p>
<p>折磨你，也在成就你。  </p>
<p>谢谢你，让我变得更坚强。  </p>
<h2 id="要感谢的人"><a href="#要感谢的人" class="headerlink" title="要感谢的人"></a>要感谢的人</h2><ul>
<li>感谢我的父母对我只身前往陌生城市的支持；  </li>
<li>感谢我的女友，教会为如何护肤，告诫我不要一到周末就想着外面吃，要自己买菜做饭；  </li>
<li>感谢我在成都结识的好友，在知道我要面试时，分享了他宝贵的面试经验并整理成文档分享给我；  </li>
<li>感谢我在健身房结识的一位好友，一起健身，劳逸结合，在健身中释放一天的压力；  </li>
<li>感谢我在游戏公司时结识的一位前辈，他教会我把眼界放长远一些；  </li>
<li>感谢我在公司部门内刚入职时带我的导师，教会我如何设计程序，分享他的所见所闻和工作经验；</li>
</ul>
<p>谢谢你们的帮助，让我在这一年内学会了许多技能，它们是我在这黑暗森林中得以生存的资本。  </p>
<h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><ul>
<li><a href="https://octopuslian.github.io/2019/03/28/first-work-project-havest/">第一次做项目学到的技术之外的东西</a>  </li>
<li><a href="https://octopuslian.github.io/2019/05/31/a-project-deadline-note/">记一次项目演示前赶deadline的经历</a></li>
</ul>
<p><img src="/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/live.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>守的云开，见月明</title>
    <url>/2015/03/31/happy-19-birthday-keep-up-cloud-appear-see-the-moon/</url>
    <content><![CDATA[<p>那些曾经让你哭过的事，总有一天，你要笑着说出来。<br>                                                            ——题记  </p>
<p>只有走过一些路，<br>爱过一些人，<br>受过一些伤，<br>我才会明白：<br>人生的每一次成长都是痛苦的，<br>每一次痛苦都是一次蜕变，<br>生活总让我们遍体鳞伤，<br>但到后来，<br>那些受伤的地方会变得更坚强。  </p>
<p>还记得18岁时的那年今日吗？你自信满满地指着光荣榜上的那所向往的大学，眼里满是期待。可是，世事无常，上帝仿佛故意和你开了个玩笑，以测试你内心的抗打击程度。所以，你欲哭无泪过，心痛过，但最终，你还是咬牙接受了这突如其来的一切。  </p>
<p>但你不会想到：曾经那段深夜绞尽脑汁写程序，因为一道编程题不会做而被罚做一百个俯卧撑，甚至因为遗漏一个字符而被教练训斥的日子，竟然成为了你所学专业的资本；那些在高中时期结交的好兄弟们，成为了你遇到困难时最坚强的后盾；那些从老师学到了的除书本之外的人生哲理，让你在大学里收获颇丰……或许，一切就是最好的安排。  </p>
<p>梦想，有时候不能一蹴而就，而是要一步一步地向上攀爬，就像乌云背后的明月一样…。  </p>
<p>不甘心的你，一定会把内心的小宇宙逐渐释放出来的。于是，黑夜成为了你的伴侣，每当夜幕降临，一切归于平静，你的身影却还在灯光下跳跃着。校园里，一个人、一个包、一辆车、一场疾速行驶，一道最平常的风景线就这样构成了。我知道，你的背影时常是孤单的，但你的内心，是不寂寞的。  </p>
<p>谢谢那些曾经看轻过我的人，使我拥有着拼搏下去的目标与动力。  </p>
<p>有没有那么一首歌，能让你想起最初的自己？我已忘了每天睡到自然醒是什么样的感觉；我只能意识到我的时间被无聊的水课、会议等琐事占满时，是多么令我抓狂的一件事。所以我感悟到：能和家人通通话；与朋友来一次说走就走地骑行；与喜欢的女孩肩并肩地走在田间小路上；也不失一种幸福的事。请记得：鱼和熊掌不可兼得，勿忘初心，方得始终。  </p>
<p>当我5000米长跑跑到岔气时；当我拖着轮胎在跑道上艰难地加速时；当我心情不爽，你们可以陪我一起打球时；当我生病你们关心的问候时，当我们一起练习街舞时你们给予的鼓励……；谢谢你们，让我知道我并不是一个人在走。  </p>
<p>爸爸妈妈，你听到了吗这是我心里面的话：在你们身边长大我很幸福 ，现在有一群人对我很好代替你们关心我，请你们不要难过不要牵挂儿子总是要长大。是你们教会我坚强；教会我宽容；教会我感恩。  </p>
<p>我知道，我有一对隐形的翅膀，带我在黑夜中自由地飞翔，等待着夜尽天明的时刻。  </p>
<p>那些曾经令你哭过的事，总有一天，你会笑着说出来。  </p>
<p>所有错过的，错误的，<br>都会被时间原谅，<br>所有伤痛的，悔恨的，<br>终将被岁月抚平。<br>我们的人生<br>从来都不在前尘旧世中，<br>而在当下和未来。<br>愿你成为一个成熟又睿智，坚强且温暖的优秀男人，<br>与自己心爱的女孩：<br>一起，<br>在陌生的城市里，<br>面带微笑，温暖前行。  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>穿过生命散发的芬芳——写给即将奔二的你</title>
    <url>/2016/03/31/happy-20-birthday-fragrance-emanating-through-life-for-coming-twenty-you/</url>
    <content><![CDATA[<p>念，今天是你20岁的生日。你还很年轻，将来你会遇到很多人，经历很多事，得到很多，也会失去很多。但无论如何，有两样东西，你绝不能丢弃，一个叫良心，另一个叫理想。  </p>
<h2 id="穿过生命散发的亲情"><a href="#穿过生命散发的亲情" class="headerlink" title="穿过生命散发的亲情"></a>穿过生命散发的亲情</h2><p>如果你是一颗参天大树，我就是一粒种子，你宽大的树荫把我守护，我每天眺望你的高度。  </p>
<p>还记得在上大学的前一个晚上，我还在忙着收拾行李，你就在我的房间里，和我聊到了凌晨3点多，那是我和你有史以来心平气和地聊的最长最深的一次，那一次，让我大概体会到了男人的艰辛与付出。  </p>
<p>我心里有满满的爱，可是说不出，你是一个真正的男人，让我牵肠挂肚。  </p>
<p>有时看一个小孩从小慢慢长大再慢慢衰老的过程，心里就会有种莫名其妙的酸楚。是的，或许你们会慢慢衰老，但我会在你身旁把你搀扶，就像当初，你牵着我的小手，带我走出了人生的第一步一样。  </p>
<h2 id="穿过生命散发的爱情"><a href="#穿过生命散发的爱情" class="headerlink" title="穿过生命散发的爱情"></a>穿过生命散发的爱情</h2><p>还记得那时的我年少轻狂，不懂得一个好女孩对我的真情，而那时的我只知道一 味地调侃和忽视。天冷时，是她主动提醒我要加衣保暖；生病时，是她主动提醒我要按时吃药；课业压力重时，是她主动提醒我要多注意休息；待到进入了大学，才发现再遇到一位这样的女孩是多么的不容易！是的，有个爱你的人不容易，你为何不去好好珍惜，当错过了失去了开始忏悔的你，是否还能换回那颗善良的心？  </p>
<h2 id="穿过生命散发的友情"><a href="#穿过生命散发的友情" class="headerlink" title="穿过生命散发的友情"></a>穿过生命散发的友情</h2><p>2016年3月1号至3月19号，是我无法忘记的一段经历。那是一段熬夜敲代码的时光，那个深夜，我从机房出来，恍恍惚惚间回到了自己的宿舍，想起那满篇的错误警告，我想哭，可流不出眼泪。是的，基础太差，只能像狗一样趴在显示屏上不断看题，不断写代码…曾几何时，我被程序打击到精神快崩溃，只想把键盘砸在显示屏上，然后一走了之。可是现实告诉我，逃避是解决不了问题的。  </p>
<p>当你感到畏惧和痛苦，支撑不下去的时候，你应该同时意识到，决定你命运的时候到了。  </p>
<p>这段时间，谢谢你扯着嗓子给我讲算法，让我讲编程的方法， 虽然我总是不开窍，让你失望，但每当我AC一个水题后，我还是会开心好一阵。  </p>
<p>这段时间，我感到很幸运能遇到你们。有陪我刷题玩的；有深夜给我发暖心语录与安抚情绪的轻音乐；有给我拍风景图让我开心的；有当我抽不开身时二话不说帮我去顶替的；而更多的是每天给我鼓劲，提醒我注意休息的朋友们…有时我觉得我的实力配不上你们的期望，但我也相信：即使你的敌人无比强大，即使你没有好的应对方法，但只要你有敢于面对强敌的决心和勇气，你就会发现，奇迹是可以创造的。  </p>
<h2 id="穿过生命散发的痛苦"><a href="#穿过生命散发的痛苦" class="headerlink" title="穿过生命散发的痛苦"></a>穿过生命散发的痛苦</h2><p>天真的理想主义者纵使执著，纵使顽强，却依然是软弱的，他们并不明白，在这世上，很多事情你可以不理解，但必须接受；只有真正了解这个世界的丑陋与污浊，被现实打击，受痛苦折磨，遍体鳞伤，无路可退，却从未放弃对光明的追寻，依然微笑着，坚定前行的人，才是真正的勇者；而不经历黑暗的人，是无法懂得光明的。  </p>
<p>在你20岁来临之际，我很想含着泪水对那年18岁刚踏进大学校门的你说声“对不起”。是的，这里的大学教育并不是你想象中的精英化，而是最让你反感的批量化生产；这里的学生绝大部分并不真的喜欢学习，他们只求拿个毕业文凭，找份可以养家糊口的工作；这里的学术氛围充满着功利化的气息， 他们甚至在关心项目比在项目价值方面所产生的兴趣要多得多，所以他们也不会懂得和朋友一起查资料，画草图，研究原理后互相交流思想，并做出一件产品所带来的快乐。是的，这就是你要面对的现实，从你在志愿填报表上庄严地填上这所大学的代码时，就已经注定！  </p>
<p>亲爱的小孩，今天有没有哭，是否希望都已经离去，留下了带不走的孤独与无奈；漂亮的小孩，今天有没有哭，是否弄脏了美丽的衣服，却找不到别人倾诉；聪明的小孩，今天有没有哭，是否遗失了心爱的礼物，在风中寻找从清晨到日暮。  </p>
<p>对不起，我没能成为你18岁刚步入大学时你想成为的那个人。虽然，我已完成了你当时在大学定下的多个目标与梦想，但每当夜深人静，我独自站在操场上仰望星空，想起刚到大学的初衷时，我还是无法面对那个充满抱负的你。  </p>
<p>当我逐渐发现我在追梦的轨道上渐渐脱轨时，我曾想过放弃。我可以通宵打游戏，可以一觉睡到自然醒，可以在校园各处去勾搭小女生…可是，我的内心告诉我，这并不是它想要的生活！  </p>
<p>虽然，你时常会感到孤独，但你并不寂寞。因为你能感应到，全世界各地都有和你类似的人在承受着理想与现实的煎熬。你要明白：你是一个孤独的个体，要保证离开任何人都是优秀的！  </p>
<h2 id="穿过生命散发的遗憾"><a href="#穿过生命散发的遗憾" class="headerlink" title="穿过生命散发的遗憾"></a>穿过生命散发的遗憾</h2><p>遗憾是会呼吸的痛。  </p>
<p>每个追过的女孩都是我们人生的烛火，照亮了每段时期男孩为追求爱情的疯狂姿态。  </p>
<p>我的一生最美好的场景，就是遇见你，在人海茫茫中静静凝望着你，陌生又熟悉。尽管呼吸着同一天空下的气息，却无法拥抱到你，如果转换了时空身份和姓名，但愿我能认得你的眼睛。多年之后你会在哪里，身边会有怎样的风景，我们的故事并不算美丽，却又如此令我艰难忘记。  </p>
<p>如果当初勇敢的在一起，会不会有不同的结局，你会不会也有千言万语，埋在沉默的梦里。  </p>
<p>世界上最珍贵的东西，不是得不到和已失去，而是我手中握着的幸福。有个爱你的人不容易，你又怎能让她如此伤心？！谢谢你，使我懂得了如何去珍惜爱我的人。  </p>
<h2 id="穿过生命散发的芬芳"><a href="#穿过生命散发的芬芳" class="headerlink" title="穿过生命散发的芬芳"></a>穿过生命散发的芬芳</h2><p>夺走你的一切，只因为我要给你的更多。给你荣华富贵，锦衣玉食，只为让你知晓世间百态；使你穷困潦倒，身处险境，只为让你通明人生冷暖。只有夺走你所拥有的一切，你才能摆脱人世间一切的浮躁与诱惑，经受千锤百炼，心如止水，透悟天地。  </p>
<p>随心而动，随意而行，万法自然。 （王守仁-心学）  </p>
<p>以上这段话是王守仁心学思想的核心体现，虽然我的思想境界还没达到这么高的层次，但是我想：一切事物都有代价，无论是财富、事业还是自由，所以不必羡慕，生活不在别处，而在于你付出了多少，就会收获多少。不攀比，不抱怨，不计较，多包容，多理解，多付出，因为有一种努力叫做靠自己。  </p>
<p>置身于全然的黑暗中，跟随自己的感觉，不用试图去寻找光的来源，只有持续地行走，才是划破它的唯一可能。  </p>
<p>我想，真正的生存挑战才刚刚开始……  </p>
<p>加油！走在人生路上的我们。  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>十八岁的感触，十八岁的顿悟</title>
    <url>/2014/03/31/happy-18-birthday-eighteen-year-old-feelings-eighteen-year-old-epiphany/</url>
    <content><![CDATA[<h2 id="时间，都去哪了？！"><a href="#时间，都去哪了？！" class="headerlink" title="时间，都去哪了？！"></a>时间，都去哪了？！</h2><p>时光流逝，岁月如歌。转眼间我已在这个世界上存在了十八个年头。回首这些年，我失去了什么，又得到了什么？我这十八年的时间，又都流向了哪里？  </p>
<p>其实，它都流向了一个叫做天堂的地方……  </p>
<h2 id="爱，因为在心中。"><a href="#爱，因为在心中。" class="headerlink" title="爱，因为在心中。"></a>爱，因为在心中。</h2><p>当我睁开双眼每一天，都会记得大家的笑脸，明白心中勇敢又多了一点……  </p>
<p>当我年幼，不懂事时，你们用一颗宽容的心包容了我；当我高一、高二心情差时的无理取闹、乱发脾气时，你们在默默承受着，偶尔会责骂我，而我则会用更大的嗓门去指责，去和你们顶嘴…；当我瞟到父亲头上的微微白发，母亲脸上的点点皱纹，和他们那过会就容易遗忘的记忆力，我明白，你们老了。  </p>
<p>还记得那天我一个人坐客车去和田，前一天晚上我还在向父亲抱怨为什么不选择去坐飞机。然而，当我透过车窗，看到父亲单薄的背影，伫立在客运站门口前，微笑着向我招手道别。我的眼泪夺眶而出，所有的抱怨，都已烟消云散，化作无尽的不舍。  </p>
<p>我知道，终有一天，我会长大的，不会令你们费心。因为，我不勇敢，没人会替我坚强！（致父母）  </p>
<p>伤心时你会给我笑脸，让我感受友爱的原点，快乐地过有风有雨的岁月。这些年来，感谢有你们的陪伴，给我鼓励，给我教导，给我希望，使我不会停留在“红叉叉”的阴霾里，从而使我更好地把握人生，把握属于自己的方向。因为我明白：分数并不能决定一切，唯有优秀的人格素养和精神品质，才能在以后的社会中独霸一方！（致朋友）  </p>
<p>高中，因为遇到了你，才使我明白一位优秀的男人在以后应为自己心爱的女人所做的事情。真正爱一个女孩，不是想着现在如何去讨她的欢心；不是为她忙前忙后的像个保姆一样；更不是想着和她呆在一起总是有着说不完的废话！而是努力为她创造安全感的同时，每当想起她，都会想起自己还未实现的梦想和心里默默为她许下的承诺，然后为之更加努力地去奋斗。最后，在一个美丽的彩虹的照耀下的时间里，真诚而又自信地站在她的面前，伸出手，对她说：“嫁给我吧，我会给你只属于我们的幸福！”  （致初恋）  </p>
<p>有的时候，幸福很简单，它来自于人与人的内心之间，只要爱我的人和我爱的人都能健康、快乐地生活着，其实也不失为一种简单的小幸福。  </p>
<h2 id="念-恋"><a href="#念-恋" class="headerlink" title="念-恋"></a>念-恋</h2><p>小的时候，我很在乎我的名字，总是觉得它不如别人的名字好听。上高中后，我首先要感谢一个女生，因为她给我取了一个可爱的昵称，使我更加深刻的理解了这名字的含义。  </p>
<p>念。思念-怀念-想念。无论你走到了哪里，无论你以后是高官厚禄、亿万富翁还是平常百姓，无论你曾经是取得了胜利还是获得了失败，请记得心存感恩，感恩那些曾经帮助过你的人，无论他们是高低贵贱，都没有分界线。  </p>
<p>念-过去。过去犯下的错误固然不可改变，但要吸取教训，避免再犯。  </p>
<p>恋-未来。心有大未来，心有多远，梦就有多远。  </p>
<h2 id="心若在，梦就在"><a href="#心若在，梦就在" class="headerlink" title="心若在，梦就在"></a>心若在，梦就在</h2><p>我不能随波逐流，为了我至爱的亲人。再苦再累也要坚强，因为那些期待的眼神。  </p>
<p>高考临近，为了你心中理想的大学，再苦再累，也要咬牙坚持下去。在漫漫的长夜之中，不要去问光源在哪里，因为你自身就像一束光，只有持续地行走才是划破它的唯一可能！  </p>
<p>众里寻她千百度，蓦然回首，那人却在，灯火阑珊处。  </p>
<p>心若在，梦就在。待到山花烂漫时，我期待着你从考场中笑着走出来。因为，我相信：你比你想象中的自己还要强大！  </p>
<h2 id="沐浴在那阳光风雨之中"><a href="#沐浴在那阳光风雨之中" class="headerlink" title="沐浴在那阳光风雨之中"></a>沐浴在那阳光风雨之中</h2><p>信念是一种很奇妙的东西，当你从骨子里认定你是成功者的水平，行动上就会处处表现出准成功者的素质。  </p>
<p>无论你的前方充满了多少坎坷，多少荆棘，经历了多么残酷的暴风雨，请记得，这些都是阳光来临前的征兆。  </p>
<p>只有跌入从未有过的低谷，才能到达从未有过的高度；只有经历了沐浴风雨的过程，才能享受沐浴阳光时的惬意。  </p>
<p>今天，是属于你的成人礼。跃过“龙”门，父母期待着望子成龙；而我，期待着你奔向未知的前方，展翅欲飞，最终翱翔于蓝天之中，傲视群雄！  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>高考</tag>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>在白夜中彳亍-写给21岁的你</title>
    <url>/2017/03/31/happy-21-birthday-in-the-white-night-to-walk-slowly/</url>
    <content><![CDATA[<p><strong>冗长的黑暗中，你是我唯一的光。</strong><br>                                   ——题记</p>
<p>每个人都会死，但我总以为我不会。  </p>
<p>如果我有一台时光机，我愿意再回到高考前的那一天，我会告诉自己要认真对待每一道选择，每一道填空，认真考虑以后报考的院校和城市，而不会是像现在这样，孤单地无可奈何地苟活。  </p>
<p>三年前，萌新般的我们从母校走了出来奔赴全国各地，三年后，当我还在考研与工作中选择时，已经有人手持数个名企offer，或者在无忧虑的做着项目。而我有时候就问自己：毕业时，你拿什么与他们竞争？！  </p>
<p>天真的孩子总是会存在着一种侥幸心理，即使已经被长辈们告知这里是雷区，那里是泥坑，但还是要以身犯险，直到深陷其中，难以自拔，才悔不当初。  </p>
<p>这些天来， 我一直在自责中度过。用了将近两年的时间来试错，换来了这一时的觉悟。  </p>
<p>一天中，太阳会升起，同时也会落下。人生也一样，有白天和黑夜，只是不会像太阳那样有定时的日出和日落。有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。而我所害怕的，就是本来一直存在的太阳落下后不再升起，也就是非常害怕原本照在身上的光芒消失。  </p>
<p>是的，我害怕曾经的赞扬声离我远去；害怕那肯定的眼神不再青睐于我；害怕我不再是你们的榜样…但是这样的我过得并不开心，事实也是如此，因为我一直在排斥自己。  </p>
<p>前段时间我和一准备考研的女生晚上在校园内散步，她无意间感慨到，看你平时也挺辛苦的，何必把自己整的这么累，毕业了找份服务生的工作够吃够喝也不是挺好的嘛……我苦笑了下，可能原因在于我想做一个有价值的人吧。  </p>
<p>是的，做一个有价值的人，它就像一个信念，支撑着我熬过一个又一个的漫长黑夜。倘若我的生活里本来就没有太阳，是不是也就习惯了黑夜，所以就不怕失去；倘若当初我不是在那样的环境下成长，那么现在应该也不会有那么多的不愉快与深夜的创作了吧。  </p>
<p>有一次，我在操场上与刚进入大学的自己展开了一次对话，结果泪水打湿了我的脸庞，我彻底品尝到了痛苦与失败的滋味，我终究没能成为我想成为的那个人，带着遗憾，像一颗脱离了既定轨道的卫星，坠入了无边的深渊之中…  </p>
<p>我问：你们觉得我还来得及吗？  </p>
<p>老师：完全来得及，毕竟你还那么年轻，像个孩子似的，只要意识到错了，一切都可以从头开始。  </p>
<p>朋友：寄蜉蝣于天地，渺沧海之一粟。个人得失，一时的得失，在整个人生长河，乃至世界的历程看来，实在是一件微不足道的事情。  </p>
<p>学长：只要还没结婚，三十岁以前，那都不是事，重要的是要有一颗大心脏。我有时就会告诉自己，我要好好感受这份痛苦，因为以后我很难会像现在这样痛苦了。当你走过这段失落的人生后，你的生命会大放异彩，你的人生也更懂得珍惜。  </p>
<p>我突然想起上个寒假，我和老妈坐在公交车上，她无意间讲起她怀我的一件事，她说如果当时不是我老爸在仓惶中冷静分析了一下形势，然后当机立断把她转移到一家更正规，医疗条件更好的医院，主刀的医生说如果再晚送来半天，我就没了。记得那是个冬天，然而我竟然冒起了冷汗。原来我竟然是如此的“来之不易”，生命真是脆弱的可贵。  </p>
<p>深夜，本想早点休息，却想还是坚持把这篇文章写完吧。听着老爸老妈从千里之外发来的祝福语音，看着来自全国各地的朋友们发来的生日祝福，我想我已经在我21岁时收获了一份价值不菲的生日礼物。  </p>
<p>吾生也有涯，而知也无涯，以有涯随无涯，殆矣。已而为知者，殆而已矣（——《庄子》）。我想我会学着庄子的做法， 给我的任务做减法，舍弃一些看似重要的东西，将自己“杯子”里的水慢慢倒掉，然后重新开始，装入新的东西。  </p>
<p>深夜，我仰望天空，虽然没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着你给我的这份光，我便能把黑夜当成白天。  </p>
<p>如果命运要将我再次全部置身于这黑夜中，那我就在这黑夜中默默彳亍着，静静地反思自己，这样当我再次感到太阳带给我的光芒时，我才会觉得格外耀眼，同时也会倍加珍惜。  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
        <tag>挫折</tag>
        <tag>前行</tag>
      </tags>
  </entry>
  <entry>
    <title>左耳听风，右耳聆心</title>
    <url>/2020/03/31/happy-24-birthday-listening-wind-and-heart/</url>
    <content><![CDATA[<p>我步入丛林 因为我希望活得随意 我希望活得深刻 吸取生命所有的精华 把非生命的一切都击溃 以免我在弥留之际 发现自己从未真正活过。  </p>
<p>今天是我大学毕业之后过的第二个生日，是的，过了今天，我就24岁了。  </p>
<p>突然发现我坚持了七年写日记的习惯，在毕业后竟然断更了。  </p>
<p>每天得过且过，忘记了昨天，也看不清未来。  </p>
<h4 id="我的写作之路"><a href="#我的写作之路" class="headerlink" title="我的写作之路"></a>我的写作之路</h4><p>我记忆中记得最开始练习写作，是小时候的语文考试，每次考试要写超过300字的作文，这让我很苦恼，为什么是300字，100字也挺好的啊。  </p>
<p>于是不停的看书，积累好词好句，然后在考试的时候，数着格子，计算着我要写多少字就可以达到及格的要求，很苦恼。  </p>
<p>上了初中，喜欢上了写小说，尤其是科幻小说，只可惜这些不能为我的作文加分，于是开始到处抄作文，然后套用到模板中，只是当我写完了文章，我连我自己写的是什么都不知道。  </p>
<p>直到上了高三，上补习班的老师，一位幽默风趣的男老师，据说是自治区语文命题组成员，告诉我们要用八个自然段，准备了十几个材料模型，教我们如何套模板，并告知我们，应试作文可以造假，反正也查不出来，关键是你要往出题者的意图上去靠….哦，原来这就是“写作”啊。  </p>
<p>直到读了大学，没有了那么多条条框框的束缚，我才发觉，写作竟然是如此有趣，当你内心思绪紊乱，同时有多个想法冒出的时候，可以通过写作，将这些点串成线，线在汇聚成面，放佛在织一张很大的网。  </p>
<p>我仍记得，在我大二那年，我在学习了单片机C语言和汇编知识后，要做一个课程设计出来，于是我查资料，做测试，请教同学，写了十几页演算纸，最后我在想，把它记录下来吧，扔掉怪可惜的。于是在实验室里，从下午两点到晚上七点半，一直在捋逻辑，然后写在博客上，发布出去。多年之后，发现那篇文章用搜索引擎搜出来排名第一，令我感到意外的同时又感到惊喜。  </p>
<p>从那时开始，我将自己学习的收获，以及对生活的感悟记录下来，大学毕业时写下了三百多篇文章，只是没想到无心插柳的举动，竟为我后续面试求职和人脉拓展起到了关键作用。  </p>
<h4 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h4><p>有位好朋友说，好习惯一定不能断，不然再试着找回来就很困难了。  </p>
<p>我们面临的诱惑太多，如果说在学校面临的是学习和爱情，那么工作后除了学习、爱情，还有工作，人际沟通，经济，生存等，太多太多太多需要自己去注意的地方，在不经意间分散着自己的时间和精力。  </p>
<p>所以，请让自己的时间变得有价值起来，这句话也是我前两个月顿悟出来的。  </p>
<p>也许有人会说你变得冷漠无情了，那就让他说去吧，对你有影响吗？  </p>
<p>有一位朋友说，我有时太在意别人的看法，却忘记了最终的目的，太着急了，以至于乱的方寸，错误频出，实则是降低了效率，所以，请把步调放慢一些。  </p>
<p>很感谢他这么坦诚的说出我的问题，我曾反思过为什么会这样，而追根溯源就是和习惯有关，和曾经的环境有关。  </p>
<p>所以，试着放慢步伐，把每一步都踩扎实，才不会在风中摇摆不定，找不到出口。  </p>
<h4 id="象牙塔与现实的脱节"><a href="#象牙塔与现实的脱节" class="headerlink" title="象牙塔与现实的脱节"></a>象牙塔与现实的脱节</h4><p>曾经在学校读书的时候，遇到过3-5年的开发大佬，也有工作10年以上的架构师，他们都感慨一句“读书真好”，直到现在我才明白这四个字所蕴含的情感。  </p>
<p>在学校，老师教导我们要善良，要乐于助人，却没有告诉我们善良的后果是什么；<br>在学校，老师教导我们要诚实守信，但遇到现实你敢这样做吗；<br>在学校，有问题可以找老师，找同学，而现实中全靠自己解决；<br>…</p>
<p>今年一月初，晚上我行走在四川大学江安校区内，走在校园的林荫小道上，看着背着书包往返于图书馆的学生们，放佛也找到了自己曾经的身影。  </p>
<h4 id="曾经不代表现在"><a href="#曾经不代表现在" class="headerlink" title="曾经不代表现在"></a>曾经不代表现在</h4><p>工作最大的收获就在于，只要功夫下到位，潜力也是可以被激发出来的。  </p>
<p>那些曾经自认为不擅长的技能，在经过刻意练习和实践后也能够熟练掌握。  </p>
<p>曾经我最害怕在人多的地方骑自行车，现在已经成为一名骑行路程接近3000公里的老骑手；曾经我自认为没有写程序的天赋，然而我也通过看别人代码，自己动手刷了leetcode 200道以上的算法题；曾经我以为写<code>Linux Shell</code>脚本很难，然而我因为项目需要只用了一下午就可以掌握；曾经我遇到<code>Bug</code>心跳就会加速，然而经过两个重量级项目的历练，我熟练掌握了排查问题的流程；曾经我喜欢单干，然而我现在发现和大佬进行技术交流有时也会加深我的记忆和理解…  </p>
<h4 id="左耳听风，右耳聆心"><a href="#左耳听风，右耳聆心" class="headerlink" title="左耳听风，右耳聆心"></a>左耳听风，右耳聆心</h4><p>我的创作时间一般喜欢选定在晚上，尤其是接近零点的时候，这时放佛给我一种进入新的一天的仪式感，同时也是因为万籁俱寂，可以聆听自己内心深处，最真实的感受。  </p>
<p>写作，就是把我在这个世界上听到的，看到的，想到的，品到的，悟到的，记录下来，留给需要的人看，如果能对你们产生一些触动，那么对于我写作的价值也就达到了。  </p>
<p>人生的意义是什么？我到现在都无法下结论。但我至少能这么说：我知道，在我离世时闭上了双眼，却敞开了心灵。  </p>
<p>念，祝你24岁生日快乐！^_^  </p>
<p>念<br>2020年3月31日凌晨一点<br>于成都</p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>十年之约</title>
    <url>/2021/03/31/happy-25-birthday-ten-years-promise/</url>
    <content><![CDATA[<p>种一棵树最好的时间是十年前，其次是现在。  </p>
<h2 id="过去十年"><a href="#过去十年" class="headerlink" title="过去十年"></a>过去十年</h2><h3 id="心中的童话镇"><a href="#心中的童话镇" class="headerlink" title="心中的童话镇"></a>心中的童话镇</h3><p>心中至今还记得， 大三暑假那会，每天早晨去公园散步，然后吃一碗粥，再加几个馒头，过几天换成可口的豆腐脑，上午看会《新概念英语》，睡个午觉，下午在卧室看一会小说，打一小会游戏，然后抱着冰镇的西瓜边啃边看剧的欢乐时光，偶尔想起几个好友，约着去体育公园打球，亦或是去是自助餐和看电影。  </p>
<p>也许这就是我心中理想的幸福生活。  </p>
<p>只是，我知道，我终将是要离开父母，独自去生活。  </p>
<h3 id="高中三年"><a href="#高中三年" class="headerlink" title="高中三年"></a>高中三年</h3><p>收获最多的就是结识了几位良师益友，他们给予过我鼓励，安慰和期望，让我坚定自己的目标，不断向前。  </p>
<h3 id="大学四年"><a href="#大学四年" class="headerlink" title="大学四年"></a>大学四年</h3><p>感触最多的是从大学同班同学何和唐身上学到的，也是我毕业后一直保持联系的人。  </p>
<p>大一时我曾对何不以为然，觉得他只是个会考试会背题的机器罢了。直到大四机缘巧合搬进了何的宿舍，跟他做了一学期舍友，才发现我错了。  </p>
<p>曾经我通过打算法竞赛和写博客结识了很多北京上海的竞赛大佬，直到我将他们和何对比了一下，才发现都有共通点，这一点我在唐的身上也看到了。  </p>
<p>所以，我在大三的时候，抛弃了所有所谓的荣誉、职务，专心做自己觉得有价值的事情，因为那样我觉得才是踏实的。  </p>
<h3 id="工作接近三年"><a href="#工作接近三年" class="headerlink" title="工作接近三年"></a>工作接近三年</h3><p>上班三年，实现了自己小时候想当工程师的梦想，从游戏服务端开发工程师到图形图像算法工程师，再到<code>Golang</code>后端研发工程师以及兼职的音视频工程师，虽然<code>title</code>在变，但一直不变的就是加班以及研发在国内卑微的地位。嗯，这和我小时候的设想的貌似不太一样呢。  </p>
<h2 id="一些顿悟"><a href="#一些顿悟" class="headerlink" title="一些顿悟"></a>一些顿悟</h2><h3 id="对996以及加班的感悟"><a href="#对996以及加班的感悟" class="headerlink" title="对996以及加班的感悟"></a>对996以及加班的感悟</h3><ul>
<li>命是自己的，即使加班出事故了，企业也买了保险，大不了用废了再换一个，但自己的生命只有一次，这是大前提；  </li>
<li>结合三年加班的经验，以及吸收消化那些加班场景，无非就是项目上线出事故或者是老板想看你好不好使唤（阶级思想），这是国内私企大部分加班的根本原因；  </li>
<li>活是做不完的，即使做完了，老板也不会感慨你效率多高，而会开心的说自己花一个人的价钱省了三个人的成本。</li>
</ul>
<p>因此，结合以上三点，在保持不会没有存款的大前提之下，我会尽量边提升自己的技术，边找一些管理规范且<code>nice</code>的企业，小企业就不去浪费时间和精力了。  </p>
<h3 id="关于离职"><a href="#关于离职" class="headerlink" title="关于离职"></a>关于离职</h3><p>感到是一种解脱，是从封闭的办公室，嘈杂的喧闹声和咳嗽声后带来的一份宁静。  </p>
<h3 id="关于本科学历"><a href="#关于本科学历" class="headerlink" title="关于本科学历"></a>关于本科学历</h3><p>这是个沉重的话题，因为它会跟到你老。面试的时候会决定你和名校毕业生的起点，关系到升职加薪等等等。可能我刚毕业会担心，但经过这三年的洗礼，以及和一位南天信息的技术专家的沟通，我验证并得出了结论：<strong>只要你一直更新自己的知识储备，就永远不会被这个社会淘汰。</strong></p>
<h3 id="关于离别"><a href="#关于离别" class="headerlink" title="关于离别"></a>关于离别</h3><p>小学毕业时，我哭了，想着毕业后大家一定要常聚；初中毕业时，我悄悄地哭，想着以后还在一座城市，可以常聚；高中毕业时，我忍住没哭，即使高考结束后我依旧会突然从8点多惊醒，想着快迟到了；大学毕业时，我没有哭，平静的收拾好自己的行李，拿好毕业证学位证，定好火车票，就此离去；工作了，偶尔在机场碰到我的高中同班同学，惊喜、意外接踵而至，但这些过后呢，依旧平静，然后错过。  </p>
<p>曾经我比喻两个人的关系就像平行线，如果相交后，错过可能就再也见不到了，是这样的。  </p>
<p>在乌鲁木齐时失去了一个从幼儿园玩到大学的好朋友，那时我会失眠，会迷茫，像是生命中突然缺少了什么东西似的。直到大学毕业前，父母问起我和他还有联系没，我心中都会隐隐作痛后摇摇头，但我又无能为力。直到毕业后，我突然顿悟，有时候也许就是两个人缘分尽了就平静的看待吧，想想快乐的事情——两个人从小学相互打闹；初中因为没有手机就互传书信，就差买只鸽子做飞鸽传书了；相互请教理综和数学题；周末约着一起去打球或者看电影；老师看到我俩还以为是亲兄弟…哈哈。  </p>
<p>如果要离别，我会微笑，会真诚的对你说一声：<strong>谢谢你，曾出现在我的回忆里，感谢相遇，离别保重。</strong>。然后继续走好我自己的路。  </p>
<h2 id="未来十年"><a href="#未来十年" class="headerlink" title="未来十年"></a>未来十年</h2><ul>
<li>用一年时间沉淀自己的基础，深入后端开发；  </li>
<li>用两年时间搭建自己的副业体系的雏形并开始运作；  </li>
<li>用三年时间提升一下自己的核心竞争力，并尝试横向拓宽自己的技术面；  </li>
<li>用四年时间丰富自己工作履历和项目经验，争取达到专家级别；  </li>
<li>拥有自己的一套房；  </li>
<li>注：以上流程可以交替并发运作。</li>
</ul>
<h2 id="十年的约定"><a href="#十年的约定" class="headerlink" title="十年的约定"></a>十年的约定</h2><p>回想起，我在大三时在北邮遇见了<code>DemonGan</code>，他给自己在一定时间内定了个目标，然后好长时间没发朋友圈，突然在研三之际发布保博清华；我也在大二时受到一位北大毕业的天使投资人的影响，他说<strong>优秀的人相互都是吸引的</strong>，于是我明白了——需要先让自己变强，才有和大佬共同合作的资本，所以，做一个可以创造价值的人，是我未来十年的要实现的理想。  </p>
<p>因此，我也在25岁生日来临之际，给自己定个目标————十年之约。十年后，我35岁，即使不做技术，我也希望我的副业可以支撑着我的日常开销，我想到那时，我才是真正实现了财务自由以及真正在做着有意义的事情。  </p>
<p>GOOD LUCK:)  </p>
<p><img src="/2021/03/31/happy-25-birthday-ten-years-promise/dream.jpg">  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
        <tag>顿悟</tag>
        <tag>约定</tag>
        <tag>承诺</tag>
      </tags>
  </entry>
  <entry>
    <title>我想把我唱给这个世界听</title>
    <url>/2018/03/31/happy-22-birthday-i-want-to-sing-me-to-this-world/</url>
    <content><![CDATA[<p>种一棵树，最好的时间是十年前，其次是现在。</p>
<h2 id="【扎心的校园春招】"><a href="#【扎心的校园春招】" class="headerlink" title="【扎心的校园春招】"></a>【扎心的校园春招】</h2><p>有人说我比以前要沉稳了，我说有吗？也许是我对所谓的不公平抱着坦然接受的一种心态吧。既然生活给了我一个大嘴巴，我又不能像疯子一样上前拼命，而是要把所有的委屈和那个不堪入目的自己全都咽进肚子里，然后在深夜中不动声色的练拳头。  </p>
<p>考研的失利，让我不得不开始重新思考我未来的路，是继续二战还是先就业。经过考虑，我决定先就业再考研。  </p>
<p>于是我开始学着做简历，在各大招聘网站、互联网公司的官网上投递，期待能获得笔试和面试的机会。校园的春季现场招聘会也去看过，很可惜，扎心了！要么冲出去闯出一番天地，要么留在这里养老，我所面临的就是这样一种困境。  </p>
<p>三月，我在备战春招和学习新技能的过程中度过。在此期间，我看到了“该岗位只面向985 211应届毕业生”字眼；我看到了一个岗位有千人挤破头报名参加笔试而对某些学校毕业生开绿色通道；我看到了我填简历时额头渗出的汗水…是的，现实太残酷，我该如何生存？又该怎样才能寻找到适合自己的舞台？  </p>
<h2 id="【三次流泪的蜕变】"><a href="#【三次流泪的蜕变】" class="headerlink" title="【三次流泪的蜕变】"></a>【三次流泪的蜕变】</h2><p>第一次，高一入学军训时被拉到荒郊野外的炮兵营，没有温暖舒适的床，醒来就能看到严肃板着面孔的教官，第一天夜里我哭到了凌晨四点。预示着我该试着独立生活，因为父母总有不能陪伴在身边的时刻。  </p>
<p>第二次，高三第二学期独自坐24小时班车去和田，车上没有熟人，老爸本来说要陪我去，我说算了吧，你生意忙，我一个人可以的。结果上了班车，我突然开始慌张的不知所措，看着单色玻璃外老爸挥手向我告别，我再一次哭了出来。原来，每个生命在时间的长河面前，都会显得那么渺小。  </p>
<p>第三次，大三第二学期经历的最低谷最黑暗的时刻，彻底击碎了我曾一直保持着的优越感。我在跑道上边跑边哭，想通过无情的风吹散这伤痛的往事。原来，我这一生并不是一帆风顺的，有些事情也并不是我可以掌控的，要学会谦卑，学会敬畏。  </p>
<p>我就是在这血泪交织中逐渐完成了蜕变。  </p>
<h2 id="【蜗牛似的追光者】"><a href="#【蜗牛似的追光者】" class="headerlink" title="【蜗牛似的追光者】"></a>【蜗牛似的追光者】</h2><p>寒假有幸受朋友邀请去了趟成都。在那里品尝了美味的火锅、酸辣粉，也尝试着投递了几家游戏公司的技术岗位，然而回复给我的只有“不合适”。于是，我记录下我所欠缺的技能，利用最后在校的三个月时间弥补。  </p>
<p>坚持做一件事真的不简单。但是当你养成一种习惯，把它看成和洗脸刷牙必须要做的一件事，那么一切都会变得自然。比如你会每天早晨九点半左右看到一位背着灰色书包、戴着蓝牙耳机的小伙子坐在校园小市场的早餐店里吃包子喝粥，然后再去图书馆五楼东南角找处有插座的座位，打开笔记本电脑和书籍，开始沉浸于一个人的世界中。  </p>
<p>没错，那就是我。  </p>
<p>有梦的人就像一只背着壳的蜗牛，艰难缓慢的行走，背负着信念，去追逐那稍纵即逝的光。  </p>
<h2 id="【不再痛苦的无上密】"><a href="#【不再痛苦的无上密】" class="headerlink" title="【不再痛苦的无上密】"></a>【不再痛苦的无上密】</h2><p>人心这么黑暗，我想找到一种不再痛苦的秘密。  ——《妖猫传》  </p>
<p>涉世未深的应届大学毕业生，总是容易被当做欺负的对象，因为他们已经成年，可以为自己的选择承担后果；因为他们经验还不够丰富；因为他们还年轻，可以多榨取一些价值。以前总听人说社会是另外一所“终身大学”，它会教你如何做人，但是学费也很高，有时是要拿自己的前途做赌注。  </p>
<p>我感到如履薄冰，那些职业化笑容的背后总会让我看到一些若影若现的不安全因素。就业三方协议是看了又看，和用人单位沟通时总是尽可能把所有考虑到的细节都问清楚，笔试面试时总是会咨询多位前辈综合选择最优化方案。  </p>
<p>原来，我要学的东西还有很多呢。  </p>
<p>恍惚间看到曾经的我因为周围环境的问题而烦躁不安，其实是我把自己局限于此。我所能改变的，我会尽力去改变，如果改变不了，学会接纳残酷，拥抱美好。比如书包破了会有人乐意给我缝好；感冒了会有人给我送感冒药，嘱咐我多喝温水，多吃水果少吃辣；北京、上海、杭州等地从未相见的前辈会乐意给我内推和HR的联系方式、还会耐心给我讲笔试面试时的注意事项…。  </p>
<p>生活是不完美的，但我依然可以选择去拥抱生活的美好。  </p>
<h2 id="【幽谷中的空山鸟语】"><a href="#【幽谷中的空山鸟语】" class="headerlink" title="【幽谷中的空山鸟语】"></a>【幽谷中的空山鸟语】</h2><p>无论我身处何方，我的心永远都将是自由的，我想这也许就是另一种摆脱烦恼的方式。  </p>
<p>自由的心，那么所谱写的人生乐谱，我想应该会有所与众不同吧。我期待现在处在幽谷深处中的你，会有那么一天可以飞向自己向往的地方，那里有属于你的舞台和Show Time，到那时，全世界都将会听到你的声音。  </p>
<p>种一棵树，最好的时间是十年前，其次是现在。如果十年前忘了种，那就请现在就种下，耐心施肥浇水，静待它隐秘的成长。  </p>
<p>你还年轻，有时间有精力有资本去开拓自己的未来。  </p>
<p>亲爱的，祝22岁的你，生日快乐！  </p>
<p>-念<br>于2018年3月31日晚</p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
        <tag>种树</tag>
      </tags>
  </entry>
  <entry>
    <title>四季予你</title>
    <url>/2022/03/31/happy-26-birthday-four-seasons-for-you/</url>
    <content><![CDATA[<p>世间的本质，用眼睛是看不到的，那一刻我才明白这句话的真正含义。我是个盲人，但那又如何呢，世界不会因为我看不到而不再美丽；我不是侠岚，但那又怎样呢，我手中有属于我自己的侠岚印。 ——《风语咒》  </p>
<p>十年之约，已走过十分之一。  </p>
<p>这一年，你是否离自己的目标更近了一些，是否摆脱了内心的桎梏，重获新生？  </p>
<h1 id="三月的春风"><a href="#三月的春风" class="headerlink" title="三月的春风"></a>三月的春风</h1><p>三月，你意气风发，自信满满，觉得未来前途一切光明，朋友L交代给你的事情，你觉得百分百可以搞定。  </p>
<h1 id="六月的夏雨"><a href="#六月的夏雨" class="headerlink" title="六月的夏雨"></a>六月的夏雨</h1><p>六月，下了一夜的雨后，你自认为一切都没问题，结果尽在自己的掌握中，殊不知已经掉入了猎人的陷阱里，在不断的挑衅和怀疑中，你开始变得被动与内敛。  </p>
<h1 id="九月的秋景"><a href="#九月的秋景" class="headerlink" title="九月的秋景"></a>九月的秋景</h1><p>九月，遭遇了自大学毕业后的低谷期，你无助，甚至生活错乱，这时一个陌生的电话想起，聊着聊着竟然哭了起来，是的，这是你人生第一次当着一位陌生人的面哭泣，你不知道他长啥样，但只记得他说了一句话：没事，过了这个坎就好了。  </p>
<p>秋季，你如枯黄的落叶孤独的掉落在泥土中，等待着新生的枝芽长出。  </p>
<h1 id="十二月的冬雪"><a href="#十二月的冬雪" class="headerlink" title="十二月的冬雪"></a>十二月的冬雪</h1><p>十二月，成都没有下雪，但心经历过挫折的淬炼，变得坚韧如铁，你鼓起勇气，向他微信上说明情况，并且创造了一个新机会，虽然迟到了两个月，但还是在年底感受到了一丝暖意，那一刻，覆盖在精神上的冰雪仿佛融化。  </p>
<h1 id="三月的暖阳"><a href="#三月的暖阳" class="headerlink" title="三月的暖阳"></a>三月的暖阳</h1><p>你获得了认可，同时也终于找到了自己要为之要努力的方向，并且也有了定居的物质条件和打算，一切仿佛进行的刚刚好。  </p>
<h1 id="生日的祝福"><a href="#生日的祝福" class="headerlink" title="生日的祝福"></a>生日的祝福</h1><p>以上说的比较隐晦，主要还是记录一下这一年跌宕起伏最后趋之稳定的工作经历。  </p>
<p>我跟我的父亲提起这件事，他说这就是财富啊，有些事情你只有自己去经历，去感悟，才能做出真正的改变。  </p>
<p>是的，这一年我变化了许多，技术的广度，知识的涉猎，以及心理承压能力等…，最重要的还是对待挫折的看法。  </p>
<p>曾经视为枷锁的东西，说到底其实就是自己太当回事导致的，然而随着时间的推移，才发现自己才是本源，有色的外衣会随着时间的消逝而价值递减，因此，希望你自信且从容。  </p>
<p>我觉得趁年轻，去做一些自己没做过的事情，是非常兴奋的，因为你不知道未来会怎样。  </p>
<p>至今记得，读书时暑假当背包客逛遍了半个祖国，自驾行，骑行，搭车行，遇到了各种突如其来的阻碍，也收获过前所未有的喜悦。  </p>
<p>工作后玩的时间变少了，挑战与机遇也随之而来，但我认为这是精力和时间重心的转移，直到你步入垂暮之年回首往事时，不因虚度年华而悔恨，也不应碌碌无为而羞愧。  </p>
<p>今天是你26岁的生日，希望你在未来健康的成长，在四季的交替变换中，我永远是你的唯一。  </p>
<p>愿你风雨中像个大人，阳光下是个孩子。  </p>
<p><img src="/2022/03/31/happy-26-birthday-four-seasons-for-you/four-seasons.jpeg">  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
        <tag>挫折</tag>
        <tag>痛苦</tag>
      </tags>
  </entry>
  <entry>
    <title>去码头整点薯条</title>
    <url>/2025/06/23/happy-29-birthday-go-to-the-pier-and-get-some-fries/</url>
    <content><![CDATA[<p>致未来的念念，你好，好久不见，我是过去的你，当你看到这篇文章的时候，你应该是一个中年人了吧。你完成我们的梦想了吗？还记得我们的十年之约吗？还是，被生活打倒了呢？<br>我不知道。但是，念念，永远不要停止追逐，我知道这也许很艰难，无论如何努力，希望的火苗都始终无法点燃。但是，念念，假如有一天我放弃了，把梦想埋起来了，那么，无论多少次都好，请你一定要再鼓起勇气，重新拿起铲子，把梦想再挖出来！<br>我们的故事不应该深埋在地底，而是应该飞向蓝天之上！无论被打倒多少次，都不要忘记梦想的力量。去地球的尽头看看吧，但又不止地球的尽头，去看看一望无际的荒原，去看看连绵千里的高山，去看看飞流直下的瀑布，去看看清澈碧绿的湖面，<strong>不为什么，只因为想去就去了</strong>，那不就是最棒的人生吗？</p>
<p>那么，曾经的你，如何定义最棒的人生呢？  </p>
<p>小学五年级，你说你要成为像杨利伟一样的宇航员，飞向太空，万人瞩目；你说要成为一名老师，受人尊敬，同时像蜡烛一样，燃烧自己，照亮他人；你说要成为一名科学家，造福人类。你觉得只要成为对社会有用的事，这就是最棒的人生。  </p>
<p>初中一年级，你上课打闹，暗恋班里的某位女生，放学后打一局台球，再去游戏厅打一局PS2和反恐精英，学习无压力。你觉得每天开心，做自己想做的事，这应该就是向往的生活。  </p>
<p>高中一年级，你被你理想的市重点高中录取了，你觉得一只脚已经踏入了名校，你认为只要保持高考分数大于等于中考分数就没问题。于是，你在上课的同时，报名参加了全国的机器人竞赛，开始提前学习编程知识，同时你在乒乓球比赛中战胜了多个对手，100多人选8个，很幸运你是其中之一。你对自己的学业充满信心，同时有精力发展自己的爱好，且有所成就，你的眼里充满了追逐梦想的光。  </p>
<p>大学三年级，你拿了奖学金，可以报销自己这一学年的学费，图书馆可以一次借阅50本书籍，同时有一个独属于自己学习的空间，于是你白天在实验室里学习，学累了喊上女朋友一起去下馆子，在校园里散步，你微笑着给每个认识你的人打招呼，另外你给出版社兼职社群运营，可以让你掌握一手的技术信息。学业爱情两不误，这应该是你人生顶级的享受吧。</p>
<p>工作第一年，你的<code>offer</code>落在了一个陌生的城市，父亲说多带点钱在身上，你说我就带2000，1000租房子，1000吃饭，第一个月结束后就有收入啦！那时的你，自信阳光善良，过程如你所料，你的财富就像搭积木一样，缓慢增长中。有着一份不错的工作收入，不断结识领域大佬，累了就去短途旅行，看看风景，这或许是你理想的生活吧。  </p>
<p>今年的6月7号，你参加了一场重启人生的沙盘游戏，在游戏中，你依然在18岁高考报志愿的时候坚定了选择了IT行业，你说要深耕自己热爱的领域，于是你在30岁之前拿下了博士学历，顺利进入了国企，同时开启了创业之旅，你的运气很好，企业一直盈利到60岁退休，你的退休金也非常高，你赚了几千万的资产，错过了两个结婚的对象，因为你总觉得会遇到更适合自己的。然而直到退休你都是孑然一人，于是你放弃了，你开始花钱延缓衰老，全国旅游，做自己想做的事情，但是时间有限，你在最后的纠结中走向了生命的尽头。名校背景，创业成功，资产千万，最后却孤独终老，这是你想要的人生吗？（其实我现在回想起来，重启人生中的八大维度的成就，特别像是牛马前钓着的一个胡萝卜，你越是着急的想要达成某项成就，就越有可能落入既定规则下的陷阱）  </p>
<p>今年是你工作的第七年，你已经褪去了校园的稚气，一路从跑龙套打杂成长为高级研发，至少你已经实现了你小时候梦想的三分之二，你的职场技能树从刚毕业只会写<code>C</code>语言和简单的<code>Linux</code>命令，到现在从前端，移动端，后端，算法，人工智能，网络安全，云原生，爬虫，自动化脚本Devops遍地开花；你的存款超越了大多数的同龄人；你的爱人是跟你一起从大学认识走到了现在，没有经历奇葩的说媒和相亲，可是，为什么我从你的眼里看不到光，以及强颜欢笑时的痛苦与无奈呢。  </p>
<p>鲁迅说，真的勇士，敢于直面惨谈的人生。<br>罗曼罗兰说，世界上只有一种英雄主义，在认清生活真相之后依然热爱。<br>你说，我们的教育生产理想主义者，再由现实击碎他们的幻想，并将这种重塑称之为成长。每当我回顾我所接受的教育，我总感觉到被欺骗的愤怒，到现在还是无法释怀。  </p>
<p>这些年你确实经历了不少事情，因为善良，被欺骗，被算计，我想坚持走下去，但发觉这条路长夜难明，你知道的越多，才发觉理想与现实的巨大差距，像一道难以跨越的高墙，高墙内深不见底的黑暗不断蚕食着你眼中的光。  </p>
<p>我至今清晰的记得我追逐梦想时那份心中的悸动，但在长大后，那份悸动却越来越淡，甚至这份悸动替换为了加班和焦虑，我被生活压的喘不过气来，无形的牢笼和既定的规则让我变得越来越麻木，也许这样一直当木头人也挺好…但是我的心中却有着些许不甘。所以，我拼尽了全力，我渴望我所追逐的梦想能带给我一个永恒的意义，让我可以去更加勇敢的对抗生活，但是当我发觉能够为之心动的梦想在实现后便索然无味，高墙依旧存在，所有的追求到最后都化为了虚无，那继续坚持走下去的意义是什么呢？  </p>
<p>我尝试找寻答案，直到我看到了三个视频  </p>
<p>第一个是谭谈交通采访福贵大爷的一段话，就你这情况，放谁身上都觉得特别痛苦，但我刚才见你好像特别开心又是为什么？大爷回答：<strong>往前看，不要去想那些不开心的事情</strong>。  </p>
<p>第二个是<code>UC Berkeley</code>的<code>John DeNero</code>教授给学生的寄语：  </p>
<ul>
<li>1.做你擅长的事，做你喜欢做的事，做在某些方面对世界有用的事。</li>
<li>2.不要过分的看重测试和分数，你不必将每一件事都做到完美，但不要停下你前进的脚步，专注于学习、进步和毅力。你很快就能比过去多解决很多问题。  </li>
<li>3.<strong>Don’t compare with others</strong>。</li>
</ul>
<p>第三个是《三傻大闹宝莱坞》中法函和拉朱的一段话：  </p>
<ul>
<li>法汗：我要说服你，爸，但不是用自杀来威胁来说服，我做了摄影师会怎么样呢？赚少点的钱，住小点的房子，开小点的车，但是我会非常快乐，我为你做的事都非虚情假意，我一向听你话，就这一次，让我聆听自己的声音。</li>
<li>拉朱：恐惧是造成我成绩很差的原因。我从小就是个好学生，父母希望我能结束他们的贫穷，那让我感到害怕，在这里，我又看到疯狂的竞赛，如果你不是第一就什么都不是，我的恐惧就一直增长。恐惧真的对成绩不好，我就找了更多的神符和圣戒，乞讨神的厚爱。16根摔断的肋骨，让我这两个月里思考和反思，终于我明白了，今天我不请求神给我这份工作，只为这生命而感激，如果我被拒了，我也不后悔，我这一生仍会去做些有价值的事情。</li>
</ul>
<p>小时候，我以为我是《三傻大闹宝莱坞》里的兰彻，结果发现一直是朝着消音器的方向去努力，但最终活成了拉朱和消音器。  </p>
<p>焦虑和恐惧使我无法专注于做一件事，即使在做这件事的时候，我会思考做的意义是什么，ROI（投资回报率）是否会达到预期。  </p>
<p>分数使我等牛马分成了三六九等，导致有时为了所谓的等级之差而吵得不可开交，我的心情会随着分数和领导的评语而变幻莫测。  </p>
<p>还记得我大学读书的时候，因为太累了，第二天一觉睡到了中午，我为此懊悔不已，感觉虚度了光阴，并在潜意识里告知自己下次不能这样。本科毕业后，我在家里就呆了一天半，然后急匆匆的就去新公司报到，因为我想快点进入职场，积累工作经验。即使中间换工作，也不敢休息，因为我有五险一金的枷锁。在这个所谓的枷锁下，我加快步伐，不断对比，超越，但是却变得越来越不像自己。  </p>
<p>一位登山家，在登上珠穆朗玛峰后，经常被记者问一个问题：<br>你为什么要爬？他总不回答，于是记者总问，终于有一次，他答出了一个让所有人都无法再问的答案：<strong>Because it’s there.</strong></p>
<p>因为它就在那里。</p>
<p>其实这个世上很多事，本不需要理由，之所以需要理由，是因为很多人喜欢找抽，抽久了，就需要理由了。  </p>
<p>因此，我在经历了工作的大起大落后，也终于悟了：<br>一个问题的产生，没有对和错。每一个抉择，都必然会产生一个结果。我们要明白的是，在做出抉择后，将要面对的结果。如果是为了得到世人的认同而找寻的答案，那么世人，就会在你身边围起一道道高墙。如果你即使努力也无法逾越高墙，那么请记住，正因世界的现在、过去、将来都不存在意义，正因为生命本就无所意义，死后归于粪土，我们才得以从教育描绘的幻梦中解脱，得以真实的去面对这个世界，将意义抛下吧，那根本不重要，所谓意义只是给某件事强加的理由。在一切旧思想被打碎重组后，我们才会得以新生。所以，念念，回到一切的根源上去吧，为了做某件事情而去做，而生命的意义，就是去码头整点薯条！没有任何理由，也无需任何意义，只是为了整点薯条而整点薯条，活在每一个必将来到的当下，不受意义枷锁的控制与折磨，然后与这残酷的生活斗争到最后一秒，在每一个痛苦且没有意义的日子中起舞，最后勇敢地爱上生活，不才是这个世界最有勇气，最值得奋斗的事情吗？  </p>
<ul>
<li>享受当下生活，不要去想那些不开心的事情；  </li>
<li>不要对比，不要紧张，专注于学习，感受知识带给你的愉悦感；    </li>
<li>尝试打破枷锁，去做你喜欢且对世界有用的事吧。</li>
</ul>
<p>我期待在未来可以看到你眼里的那道光，那些曾经的遗憾和痛苦可以永远成为历史。  </p>
<p>我真的很期待那一天，真的真的真的很期待。  </p>
<p><img src="/2025/06/23/happy-29-birthday-go-to-the-pier-and-get-some-fries/1.png"></p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生日祝福</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>演示结束后的开心与喜悦</title>
    <url>/2019/11/10/happy-after-ai-demo-show/</url>
    <content><![CDATA[<h2 id="昆明大学演示"><a href="#昆明大学演示" class="headerlink" title="昆明大学演示"></a>昆明大学演示</h2><p>十月中下旬，突然被<code>leader</code>安排去做一个和<code>FFmpeg</code>相关的重组视音频片段的服务，说是项目演示用。  </p>
<p>于是我快速搭建好服务器的框架，接着开始不断的构造和测试<code>FFmpeg</code>命令(不得不说<code>FFmpeg</code>确实是视音频领域的”瑞士军刀”)，经过一番波折后(加了两天班)，服务跑了起来，和<code>python</code>程序联调一下午+一晚上后，10月底昆明大学演示上通过，很开心。  </p>
<h2 id="领导演示"><a href="#领导演示" class="headerlink" title="领导演示"></a>领导演示</h2><p>进入十一月后，又来了新的演示，印象最深的是有一天心情实在不好，下班时以为没什么问题了，于是就回家了，结果刚到家部门同事打电话通知我回公司改<code>bug</code>，虽然心里不太乐意，但还是回去了，然后发觉是配置文件出的问题，程序没问题。后面两天的演示也是一切顺利。  </p>
<h2 id="周末游天府芙蓉园"><a href="#周末游天府芙蓉园" class="headerlink" title="周末游天府芙蓉园"></a>周末游天府芙蓉园</h2><p>周末去天府芙蓉园逛了一圈，持续的输出，早出晚归，让我似乎忘记了沐浴在阳光中是一种什么样的感觉。  </p>
<p>犹记得我高一第一次接触编程时，将一堆字母输入在屏幕上，然后点击<code>run</code>后屏幕打出<code>hello world</code>的兴奋感，不知道现在从事研发后，兴趣和责任，哪个更重一些呢？  </p>
<p><a href="./sunshine.png"></a></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>项目</tag>
        <tag>人工智能</tag>
        <tag>收录</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>人生剧本</title>
    <url>/2023/12/31/happy-27-birthday-life-script/</url>
    <content><![CDATA[<p>我们登上并非我们所选择的舞台，演出并非我们所选择的剧本。    ——古希腊哲学家艾比克泰德</p>
<h2 id="坏小孩的剧本"><a href="#坏小孩的剧本" class="headerlink" title="坏小孩的剧本"></a>坏小孩的剧本</h2><p>上初一前，我想我拿到的都是一个叫做坏小孩的剧本，剧本上说，我很聪明，活泼好动，广交朋友，爱打游戏，<br>所以学校作业其实可以不用写的，第二天早上早点去抄就行了。于是，游戏厅和台球桌成了我放学后经常光顾的场所<br>因为我家对面就是游戏厅，所以进出很方便，但我知道我没有钱去消费，于是就开始了白嫖，只要脸皮厚一些，其他人<br>玩得还剩十几分钟到期时，我就会接上，同时也充当起了免费的CS1.6游戏和台球陪练，由于机动性强，服务态度好，<br>演技真实 ，广受玩家好评。  </p>
<p>在学校时，我记得语数英外加班主任的课是不敢轻举妄动的，其他课随意，所以我当时非常期待的课程就是<br>副课和体育课了。  </p>
<p>中午吃完饭，可以和班里同学打球打到午休结束，甚至第一节课上课前经常迟到，到时编造一个理由就行。<br>这样美好的一天就已经过半了，放学了还有游戏厅和台球桌在召唤我。  </p>
<p>当时我想，要是人生像上学一样轻松就好了。</p>
<h2 id="老实人的剧本"><a href="#老实人的剧本" class="headerlink" title="老实人的剧本"></a>老实人的剧本</h2><p>拿到老实人剧本的转机来自初二下学期，当时记得因为生物第一学期我考了60分刚及格，所以我想在第二学期一鸣惊人，于是就上课不打闹了，开始认真听生物老师讲课，下课了就把课后习题自己做一遍，不懂的就去问老师，甚至我自己会<br>买专门的水彩笔，把细胞核、DNA这些都画一遍加深印象，我记满了一本的笔记，最后考完我拿了全班第一。</p>
<p>哦~原来考试得高分的过程如此简单，于是逐渐将方法应用到其他科目上。</p>
<p>同时可能是因为我白嫖的太久，游戏厅关门了，我就再也没有放学去过游戏厅和台球桌，转而奔向成堆的教材和试卷， 成了老师眼中积极上进的学生。  </p>
<p>当时我想，要是人生像考试一样轻松就好了。  </p>
<h2 id="救世主的剧本"><a href="#救世主的剧本" class="headerlink" title="救世主的剧本"></a>救世主的剧本</h2><p>考入大学后，给我最大的感触就是接触了全国各地的人，我才知道原来一种食材在不同的地域有不同的吃法，同样的文字在不同的地域有不同的说法，俗称方言。  </p>
<p>同时，各种大学生优惠政策纷至沓来，又加上十二年义务教育的沉淀和励志片的渲染，我以为拿到了救世主的剧本。  </p>
<p>何为救世主，《黑客帝国》中的矩阵世界因为病毒感染都变成了史密斯，而你还是安德森，是尼奥的时候，那么你就是这个世界的救世主。  </p>
<p>哦~所以是不是只要逆流而上，做自己想做的事情就好了呢。  </p>
<p>于是，我利用大学里的资源，完成了很多人生第一次的经历，增长了见识，顺便赚回了四年的学费和住宿费。  </p>
<p>当时我想，要是社会也跟大学一样，那么等毕业了肯定要努力奋斗，实现人生理想，我会非常期待。  </p>
<h2 id="成年人的剧本"><a href="#成年人的剧本" class="headerlink" title="成年人的剧本"></a>成年人的剧本</h2><p>当我拿到了我的毕业证和学位证的那一刻，同时也签下了我的第一份劳动合同的时候，我终于拿到了属于我的成年人的剧本。  </p>
<p>这个剧本至今已经用了五年，它使我看到了从学生到打工人的蜕变过程，同时也击碎了我一些不切实际的幻想。  </p>
<p>在这五年中，我才发现曾经童年时期不屑一顾的某个午后时光，竟然是我木讷的脸对在电脑时无情地敲击键盘时，嘴角微微上扬的调味剂。只是我必须要演好现在的剧本：  </p>
<ul>
<li>生存是人的第一需要。  </li>
<li>人不断扩大自己的欲望，但人类社会中的物质总量保持不变。</li>
</ul>
<p>原来《三体》中的两条公理，放在成年人的剧本中也依旧适用。  </p>
<p>我们所有的努力，都是为了活下去，而活着的方式多种多样。你可以为了更好地活着，去努力得到某些东西，但这肯定是会失去某样东西，即使当时的你浑然不知。  </p>
<p>在这个剧本中，它使我明白不要狂妄自大，以及逃避解决不了任何问题。  </p>
<h2 id="演好你的剧本"><a href="#演好你的剧本" class="headerlink" title="演好你的剧本"></a>演好你的剧本</h2><p>演好你的剧本，即便它并非所愿。  </p>
<p>我们这一生中其实自己能决定的东西很少，我们可能只能决定5%的东西，但有95%的东西是我们决定不了的， 我们决定不了我们的出身，我们决定不了我们的智商，我们更决定不了我们这一生的贵人相助。很多时候我们经常会<br>羡慕别人的剧本，我自己有时候也非常羡慕别人的剧本，但是没有谁的剧本值得羡慕，你只能把你自己的剧本演好。  </p>
<h2 id="手里的幸福"><a href="#手里的幸福" class="headerlink" title="手里的幸福"></a>手里的幸福</h2><p>那天傍晚，我们三个人朝着山丘上的大树为终点赛跑，提出要赛跑的艾连一说完就冲了出去，米卡莎故意落后跑在了艾连后面，我果然又是最后一名。但是，那一天的风非常暖和，光是跑着就觉得很舒服，看着枯叶漫天飞舞，当时我不知为何突然觉得…我说不定是为了在这里跟他们一起赛跑，才出生在这世界上的。下雨天在家里看书的时候，看松鼠吃掉我给的松果的时候，和大家一起逛市场的时候，我都会这么想，这些平凡无奇的时刻。（——出自《进击的巨人》）</p>
<p>前两天，我跟一好友晚上约出来吃串串，他说人生是一个多维的几何体，不是一个平面，所以不需要太在意一时的得失。他现在就觉得跟自己的老婆孩子是最幸福的。  </p>
<p>是啊，原来，幸福一直握在了我的手心里。  </p>
<p>我的父母文化水平不高，但他们用实际行动告诉我勤劳可以改善现状，同时带给了我快乐的童年；我的妹妹古灵精怪，小时候我犯错误被父亲训斥，她会贴心的递来挨打工具（比如苍蝇拍）给父亲，但也是因为她的出现，让我多了一个牵挂的人；<br>我的爱人在大学 认识，我俩一起逛遍了校园，坐在湖边啃西瓜，研究新菜品让我品尝，充当一对一四川话口语听力教练，虽然偶尔发生了矛盾，但都因双向奔赴所化解；<br>我有几个信得过的朋友，为数不多，但是可以把后背交给对方的。  </p>
<p>我想，这就够了，剩下的就靠我自己来实现吧。   </p>
<p>今天是2023年的最后一天，也是你27岁迟到的生日祝福，虽然已过，但还是会延续这长达九年的习惯。  </p>
<p>虽然这还是一个普通人的剧本，但我认为他是最适合我的剧本。  </p>
<p>祝你27岁生日快乐 &amp; 2024新年快乐！  </p>
<p><img src="/2023/12/31/happy-27-birthday-life-script/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA.png">  </p>
]]></content>
      <categories>
        <category>Happy-Birthday</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生日祝福</tag>
        <tag>人生</tag>
        <tag>罗翔</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移Hexo博客的方案</title>
    <url>/2021/01/15/hexo-blog-move-new-res-solution/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为买了一台新电脑，所以需要将旧电脑上本地的<code>Hexo</code>文件夹迁移到新的电脑上来，写以此文记录迁移<code>Hexo</code>的过程。  </p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="第一步，在新电脑上搭建Hexo的环境"><a href="#第一步，在新电脑上搭建Hexo的环境" class="headerlink" title="第一步，在新电脑上搭建Hexo的环境"></a>第一步，在新电脑上搭建Hexo的环境</h3><p>安装<code>node</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y nodejs</span><br></pre></td></tr></table></figure>

<p>安装<code>npm</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y npm</span><br></pre></td></tr></table></figure>

<p>安装<code>hexo</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>然后试试<code>hexo -v</code>，看看是否安装成功，如果成功，应该有以下显示：  </p>
<p><img src="/2021/01/15/hexo-blog-move-new-res-solution/hexo-v.png">  </p>
<h3 id="第二步，复制旧电脑上的Hexo文件夹到新电脑上"><a href="#第二步，复制旧电脑上的Hexo文件夹到新电脑上" class="headerlink" title="第二步，复制旧电脑上的Hexo文件夹到新电脑上"></a>第二步，复制旧电脑上的<code>Hexo</code>文件夹到新电脑上</h3><h3 id="第三步，使用命令测试本地能否将博客页面渲染成功"><a href="#第三步，使用命令测试本地能否将博客页面渲染成功" class="headerlink" title="第三步，使用命令测试本地能否将博客页面渲染成功"></a>第三步，使用命令测试本地能否将博客页面渲染成功</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>如果渲染成功，应该可以在<code>http://localhost:4000</code>上看到自己的博客页面：  </p>
<p><img src="/2021/01/15/hexo-blog-move-new-res-solution/hexo-page.png">  </p>
<h3 id="第四步，推送到远程仓库"><a href="#第四步，推送到远程仓库" class="headerlink" title="第四步，推送到远程仓库"></a>第四步，推送到远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>至此，<code>Hexo</code>博客的迁移就做完了。</p>
]]></content>
      <categories>
        <category>Solution-notes</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>迁移</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>心就那么大，重了装不下</title>
    <url>/2021/10/11/heart-is-too-heavy-to-beat/</url>
    <content><![CDATA[<p>心就那么大，重了装不下，也跳不动，这是我最近悟出来的，也是道家的一种心法。（网上看的，是不是真的就不知道了…）  </p>
<p>这段时间经历了我从毕业以来的低谷期，和安恒的面试官闲聊的时候眼泪和鼻血控制不住地都流了出来，我知道，这只是我人生路上的一道坎，跨过去就好，是的，说起来容易，但考虑的事情很多很多…  </p>
<p>国庆回了趟家，彻底放松了一下，节后面试大厂，结束后闲聊了四十分钟，让我发觉大公司和中小公司面试的区别非常大。  </p>
<p>我一直想把我最好的一面展现出来，以至于简历写了很多自以为曾经拿过奖就是自己能力的奖项，殊不知人会老，技能不练就倒退这个道理。  </p>
<p>不过还好，一切都来得及。  </p>
<p>沉下心来，重新改写自己的简历，以及重构自己的知识框架，不断添砖加瓦，不断尝试，总结，提升。  </p>
<p>心就那么大，重了装不下，抛弃杂念，去决断出最有价值最值得去做的事情。</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题7.8.0新版本美化</title>
    <url>/2022/04/27/hexo-next-7-8-0-theme-beautify/</url>
    <content><![CDATA[<h1 id="崩溃的边缘"><a href="#崩溃的边缘" class="headerlink" title="崩溃的边缘"></a>崩溃的边缘</h1><p>前天晚上，我使用我的电脑准备更新一下博客内容，结果发现报错：<code>Ignoring local @import of &quot;font-embedded.css</code>，网上查了下，说是要更新<code>Next</code>版本到最新即可。  </p>
<p><img src="/2022/04/27/hexo-next-7-8-0-theme-beautify/bug.png">  </p>
<p>因此，痛定思痛，决定先整我的博客。  </p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>本文将省略<code>xxx.github.io</code>等<code>Github Pages</code>的配置，并且默认你已经安装完<code>Hexo</code>和<code>Node</code>，因此我们的关注点就是<code>Next</code>的配置和美化工作。  </p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo 初始化</span></span><br><span class="line">$ <span class="built_in">mkdir</span> myblog</span><br><span class="line">$ <span class="built_in">cd</span> myblog/</span><br><span class="line">$ hexo init</span><br><span class="line"><span class="comment"># 创建存放next源码的文件夹</span></span><br><span class="line">$ <span class="built_in">mkdir</span> themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注：此时运行以下命令的位置，应该在 myblog/下</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>创建完成后，目录结构应该为  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment">#博客站点配置文件</span></span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── public</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 该文件夹下会存放_data/next.yml配置文件</span></span><br><span class="line">└── themes</span><br><span class="line">    └── next</span><br><span class="line">        ├── _config.yml <span class="comment">#主题配置文件</span></span><br></pre></td></tr></table></figure>

<p>以前用<code>Next</code>主题写博客文章的时候，总会有一个疑惑，就是我直接在<code>themes/next</code>文件夹下修改了源码来适配，那<code>Next</code>更新了版本之后，我岂不是又要删了重新配置？<br>因此这一疑惑在<code>7.8.0</code>版本解决。  </p>
<h2 id="源码与配置文件分离"><a href="#源码与配置文件分离" class="headerlink" title="源码与配置文件分离"></a>源码与配置文件分离</h2><p>首先，在<code>source</code>文件夹下创建一个名为<code>_data/</code>的文件夹，在<code>_data/</code>文件夹下新建<code>next.yml</code>文件，将<code>themes/next/_config.yml</code>文件里的内容全部复制到<code>source/_data/next.yml</code>里，原因在<code>Next</code>源码里有说明：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If false, merge configs from `_data/next.yml` into default configuration (rewrite).</span></span><br><span class="line"><span class="comment"># If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings.</span></span><br><span class="line"><span class="comment"># And if true, all config from default NexT `_config.yml` have to be copied into `next.yml`. Use if you know what you are doing.</span></span><br><span class="line"><span class="comment"># Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config.</span></span><br><span class="line"><span class="attr">override:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>哦~~~我懂了，意思就是<code>_data/next.yml</code>和<code>themes/next/_config.yml</code>文件中，只要谁的<code>override</code>为<code>true</code>，就用哪一个当做配置文件，那我们当然是选择<code>_data/next.yml</code>。  </p>
<p>同时，在站点配置文件里设置<code>next</code>为博客的主题  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>主题配置文件  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>至此，准备工作已经完成，运行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:4000</code>，就可以看到初始效果了。  </p>
<h1 id="Next美化"><a href="#Next美化" class="headerlink" title="Next美化"></a>Next美化</h1><h2 id="设置博主文字描述和中文语言"><a href="#设置博主文字描述和中文语言" class="headerlink" title="设置博主文字描述和中文语言"></a>设置博主文字描述和中文语言</h2><p>站点配置文件修改<code>site</code>  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">不会飞的章鱼</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;熟能生巧，勤能补拙，静能生慧；念念不忘，必有回响。&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;All is Well.&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">···计算机，旅行，思考，网络，数据结构，操作系统，算法，数据库，服务器，图形，图像，黑客，OpenGL，Go，C，C++，Python···</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Neo</span> <span class="string">Zhang</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-hexo-中的-about、tag、categories、sitemap-菜单"><a href="#配置-hexo-中的-about、tag、categories、sitemap-菜单" class="headerlink" title="配置 hexo 中的 about、tag、categories、sitemap 菜单"></a>配置 hexo 中的 about、tag、categories、sitemap 菜单</h2><p>默认的主题配置文件<code>_config.yml</code>中，菜单只开启了首页和归档，我们根据需要，可以添加 <code>about、tag、categories、sitemap</code> 等菜单。  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">movies:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-film</span>  <span class="comment">#添加了 movies 页</span></span><br><span class="line">  <span class="attr">books:</span> <span class="string">/books/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-book</span></span><br><span class="line">  <span class="attr">games:</span> <span class="string">/games/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-gamepad</span></span><br><span class="line">  <span class="comment">#reward: /reward || fa fa-money</span></span><br><span class="line">  <span class="attr">wishlist:</span> <span class="string">/wishlist||</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<p>更多的图表可以到<a href="http://www.fontawesome.com.cn/faicons/">Font Awesome中文网</a>里面去找，其中 <code>||</code> 后面是你想要设置的图标的名字。  </p>
<h2 id="手动生成-hexo-菜单对应文件"><a href="#手动生成-hexo-菜单对应文件" class="headerlink" title="手动生成 hexo 菜单对应文件"></a>手动生成 hexo 菜单对应文件</h2><h3 id="新建-about-页面"><a href="#新建-about-页面" class="headerlink" title="新建 about 页面"></a>新建 about 页面</h3><p><code>about</code> 页面一般用来介绍站点信息和博主的个人介绍等。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>然后会发现多了个<code>source/about</code>文件夹，里面有一个<code>index.md</code>文件，可以使用<code>Markdown</code>写一写自己想写的内容。  </p>
<h3 id="新建一个-tags-页面"><a href="#新建一个-tags-页面" class="headerlink" title="新建一个 tags 页面"></a>新建一个 tags 页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在<code>tags</code>页面文件 <code>source/tags/index.md</code> 的头部修改为：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-04-26 18:12:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span>                <span class="comment"># 类型一定要为tags</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span>             <span class="comment"># 提示这个页面不需要加载评论</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="新建一个-categories-页面"><a href="#新建一个-categories-页面" class="headerlink" title="新建一个 categories 页面"></a>新建一个 categories 页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 <code>categories</code> 页面文件 <code>source/categories/index.md</code> 的头部修改为：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-04-26 18:12:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="新建一个-404-页面"><a href="#新建一个-404-页面" class="headerlink" title="新建一个 404 页面"></a>新建一个 404 页面</h3><p>首先在<code>source</code>目录下创建自己的 <code>404.html</code>：  </p>
<blockquote>
<p>注意：Hexo 博客的基本内容是一些 Markdown 文件，放在 source&#x2F;_post 文件夹下，每个文件对应一篇文章。除此之外，放在 source 文件夹下的所有开头不是下划线的文件，在 hexo generate 的时候，都会被拷贝到 public 文件夹下。但是，Hexo 默认会渲染所有的 HTML 和 Markdown 文件。  </p>
</blockquote>
<p>因此我们可以简单地在文件开头加上 <code>layout: false</code> 一行来避免渲染：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;返回&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-hexo-本地搜索"><a href="#配置-hexo-本地搜索" class="headerlink" title="配置 hexo 本地搜索"></a>配置 hexo 本地搜索</h2><p>本地搜索的原理：<br>对于动态网站来说，可以通过 <code>php</code> 实现。但是，<code>Hexo</code> 博客是静态网站，用不了 <code>php</code>。  <code>NexT</code>主题已经实现这个功能，它用了<code>Hexo</code>的拓展包 <code>hexo-generator-searchdb</code>，预先生成了一个文本库 <code>search.xml</code>，然后传到了网站里面。在本地搜索的时候，<code>NexT</code> 直接用 <code>javascript</code> 调用了这个文件，从而实现了静态网站的本地搜索。  </p>
<h3 id="设置过程"><a href="#设置过程" class="headerlink" title="设置过程"></a>设置过程</h3><p>安装插件:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>然后我们修改站点配置<code>_config.yml</code> 文件，添加如下内容：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>path：索引文件的路径，相对于站点根目录  </li>
<li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面  </li>
<li>limit：限制搜索的条目数</li>
</ul>
<p>然后修改主题配置文件<code>next.yml</code>：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="设置-hexo-中的-rss-订阅"><a href="#设置-hexo-中的-rss-订阅" class="headerlink" title="设置 hexo 中的 rss 订阅"></a>设置 hexo 中的 rss 订阅</h2><p>安装插件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>在站点配置文件_config.yml 中添加以下代码：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-hexo-站点的-footer-信息"><a href="#配置-hexo-站点的-footer-信息" class="headerlink" title="配置 hexo 站点的 footer 信息"></a>配置 hexo 站点的 footer 信息</h2><p>底部 footer 可以开关显示 hexo 信息、theme 信息、建站时间等个性化配置：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>        <span class="comment"># 建站开始时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span>       <span class="comment"># 设置 建站初始时间和至今时间中间的图标，默认是一个&#x27;小人像&#x27;，更改user为heart可以变成一个心</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 更改图标的颜色，红色为&#x27;#ff0000&#x27;</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启hexo驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启hexo版本号</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启主题驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启主题版本号</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hosted</span> <span class="string">by</span> <span class="string">&lt;a</span> <span class="string">target=&quot;_blank&quot;</span> <span class="string">rel=&quot;external</span> <span class="string">nofollow&quot;</span> <span class="string">href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding</span> <span class="string">Pages&lt;/b&gt;&lt;/a&gt;</span> <span class="comment"># 这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages</span></span><br></pre></td></tr></table></figure>

<h2 id="头像信息设置"><a href="#头像信息设置" class="headerlink" title="头像信息设置"></a>头像信息设置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/neozhang.png</span>  <span class="comment"># 设置头像资源的位置</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>            <span class="comment"># 开启圆形头像</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span>               <span class="comment"># 不透明的比例：0就是完全透明</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>           <span class="comment"># 不开启旋转</span></span><br></pre></td></tr></table></figure>

<h2 id="社交信息和友链配置"><a href="#社交信息和友链配置" class="headerlink" title="社交信息和友链配置"></a>社交信息和友链配置</h2><p>社交信息配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span> </span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">google</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>      <span class="comment"># 显示社交图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span> <span class="comment"># 只显示图标，不显示文字</span></span><br></pre></td></tr></table></figure>

<p>友链配置：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span>          <span class="comment"># 友链的图标 参考上文</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span>        <span class="comment"># 友链的title  比如你可以更改为 友情链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span>       <span class="comment"># 友链摆放的样式：按块（一行一个）</span></span><br><span class="line"><span class="comment">#links_layout: inline     # 友链摆放的样式：按线摆放（一行很多个），注意，同时只能一种样式</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">Title:</span> <span class="string">http://example.com/</span>  <span class="comment"># 友链的地址</span></span><br></pre></td></tr></table></figure>

<p>官方提供的友链放在侧边栏下面，视觉上比较臃肿。<br>推荐这篇文章<a href="https://tding.top/archives/73ce4e7.html">Hexo-NexT 新增友链</a>  </p>
<h2 id="首页文章不展示全文显示摘要"><a href="#首页文章不展示全文显示摘要" class="headerlink" title="首页文章不展示全文显示摘要"></a>首页文章不展示全文显示摘要</h2><p>接在文章中添加 <code>&lt;!-- more --&gt;</code> 来精确控制摘要内容。  </p>
<h2 id="首页文章属性"><a href="#首页文章属性" class="headerlink" title="首页文章属性"></a>首页文章属性</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span>    <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>    <span class="comment"># 显示创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>    <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>              <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>       <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>          <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>           <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h2><p>首先安装插件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>主题配置文件<code>next.yml</code> 修改如下：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                <span class="comment"># 计算字数的一个设置,没设置过</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>              <span class="comment"># 一分钟阅读的字数</span></span><br></pre></td></tr></table></figure>

<p>站点配置文件<code>_config.yml</code> 新增如下：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="内容页里的代码块新增复制按钮"><a href="#内容页里的代码块新增复制按钮" class="headerlink" title="内容页里的代码块新增复制按钮"></a>内容页里的代码块新增复制按钮</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>      <span class="comment"># 增加复制按钮的开关</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span> <span class="comment"># 点击复制完后是否显示 复制成功 结果提示</span></span><br></pre></td></tr></table></figure>

<h2 id="配置微信，支付宝打赏"><a href="#配置微信，支付宝打赏" class="headerlink" title="配置微信，支付宝打赏"></a>配置微信，支付宝打赏</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">金额随意，一元也是鼓励^_^</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.jpg</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<h2 id="文章原创申明"><a href="#文章原创申明" class="headerlink" title="文章原创申明"></a>文章原创申明</h2><p>主题配置文件：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>       <span class="comment"># 默认显示版权信息</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h2 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h2><p>安装推荐文章的插件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p>主题配置信息如下:  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">相关文章推荐</span>      <span class="comment"># 属性的命名</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span> <span class="comment"># false代表首页不显示</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span>          <span class="comment"># 最多5条</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0   # 相关度</span></span><br><span class="line">    <span class="comment">#isDate: true        # 是否显示日期</span></span><br><span class="line">    <span class="comment">#isImage: false      # 是否显示配图</span></span><br><span class="line">    <span class="attr">isExcerpt:</span> <span class="literal">false</span>     <span class="comment"># 是否显示摘要</span></span><br></pre></td></tr></table></figure>

<h2 id="代码块风格美化为mac样式"><a href="#代码块风格美化为mac样式" class="headerlink" title="代码块风格美化为mac样式"></a>代码块风格美化为mac样式</h2><p>主题<code>next.yml</code>配置文件修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">bright</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>


<h2 id="添加豆瓣个人主页"><a href="#添加豆瓣个人主页" class="headerlink" title="添加豆瓣个人主页"></a>添加豆瓣个人主页</h2><p><a href="https://github.com/mythsman/hexo-douban">hexo-douban</a>是可以在 <code>Hexo</code> 页面中嵌入豆瓣页面的插件。  </p>
<p>安装插件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure>

<p>在站点的配置文件<code>_config.yml</code>里写入以下内容  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">mythsman</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my book title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my book quote&#x27;</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my movie title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my movie quote&#x27;</span></span><br><span class="line">  <span class="attr">game:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my game title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my game quote&#x27;</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>user: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的URL大概是这样：”<a href="https://www.douban.com/people/xxxxxx/&quot;">https://www.douban.com/people/xxxxxx/&quot;</a> ，其中的”xxxxxx”就是你的个人ID了。  </li>
<li>builtin: 是否将生成页面的功能嵌入hexo s和hexo g中，默认是false,另一可选项为true(1.x.x版本新增配置项)。  </li>
<li>title: 该页面的标题.  </li>
<li>quote: 写在页面开头的一段话,支持html语法.  </li>
<li>timeout: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。</li>
</ul>
<p>如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可。  </p>
<p>需要注意的是，通常大家都喜欢用<code>hexo d</code>来作为<code>hexo deploy</code>命令的简化，但是当安装了<code>hexo douban</code>之后，就不能用<code>hexo d</code>了，因为<code>hexo douban</code>跟<code>hexo deploy</code>的前缀都是<code>hexo d</code>。  </p>
<p>如果配置了<code>builtin</code>参数为<code>true</code>，那么除了可以使用<code>hexo douban</code>命令之外，<code>hexo g</code>或<code>hexo s</code>也内嵌了生成页面的功能。  </p>
<p>本地呈现的效果<br>电影：<br><img src="/2022/04/27/hexo-next-7-8-0-theme-beautify/douban-movie.png">  </p>
<p>读书：<br><img src="/2022/04/27/hexo-next-7-8-0-theme-beautify/douban-book.png">  </p>
<p>游戏：<br><img src="/2022/04/27/hexo-next-7-8-0-theme-beautify/douban-game.png">  </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>用了大概两天左右的闲暇时间，完成了博客的美化和配置，非常感谢这次出故障的经历，使我翻找官方<code>issue</code>，解决了曾经博客上遗留的许多问题，也成功美化了我的博客，非常开心。  </p>
<p>正如《武庚纪》中大剑士子羽被十刑大神抓进牢中后所说的：<strong>虽然不想承认，但十刑的直觉是对的，修习已久的炼气术被废，那也只能面对现实，从头练起就是了。首先，必须耐心地去修复错乱受损的经脉，虽然很吃力，但曾经四散的炼气，仍一点一滴重新凝聚起来，化为古剑。我发现，把以往的一切推倒重来，对于剑道反而有新的领悟，如今炼成的剑，只会比以往更强大，更霸道。</strong>  </p>
<p>希望自己终将炼成属于自己的剑。  </p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://kalialbert.github.io/article/107153072.html">hexo 主题 next7.8 版本配置美化</a><br><a href="https://blog.csdn.net/tuckEnough/article/details/107383201">hexo theme next7.8 主题美化</a><br><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a>  </p>
]]></content>
      <categories>
        <category>Solution-notes</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose的使用</title>
    <url>/2023/09/15/how-docker-compose-use/</url>
    <content><![CDATA[<h1 id="什么是-docker-compose"><a href="#什么是-docker-compose" class="headerlink" title="什么是 docker-compose"></a>什么是 docker-compose</h1><p>在 Docker 把容器技术大众化之后，Docker 周边涌现出了数不胜数的扩展、增强产品，其中有一个名字叫“Fig”的小项目格外令人瞩目。<br>Fig 为 Docker 引入了“容器编排”的概念，使用 YAML 来定义容器的启动参数、先后顺序和依赖关系，让用户不再有 Docker 冗长命令行的烦恼，第一次见识到了“声明式”的威力。<br>Docker 公司也很快意识到了 Fig 这个小工具的价值，于是就在 2014 年 7 月把它买了下来，集成进 Docker 内部，然后改名成了<code>docker-compose</code>。</p>
<h1 id="如何使用-docker-compose"><a href="#如何使用-docker-compose" class="headerlink" title="如何使用 docker-compose"></a>如何使用 docker-compose</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">intel x86_64</span></span><br><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 \</span><br><span class="line">          -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apple m1</span></span><br><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-aarch64 \</span><br><span class="line">          -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="编写-YAML-文件"><a href="#编写-YAML-文件" class="headerlink" title="编写 YAML 文件"></a>编写 YAML 文件</h2><p>docker-compose 里管理容器的核心概念是<strong>service</strong>。<br>docker-compose 里的service就是一个容器化的应用程序，通常是一个后台服务，用 YAML 定义这些容器的参数和相互之间的关系。<br>下面来编写一个简单的<code>dc-nginx.yml</code>文件，用于启动一个<code>nginx</code>容器  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span> <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span> <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 容器的重启策略，no：容器退出时不重启，always：容器退出时总是重启，on-failure：只有当容器的退出状态码不为0时才重启，unless-stopped：除非手动停止容器，否则总是重启容器</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口号暴露</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span> </span><br></pre></td></tr></table></figure>

<p>执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加-f，默认是目录下的docker-compose.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose -f dc-nginx.yml up -d</span></span><br><span class="line">[+] Running 8/8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                                                      COMMAND                  CREATED         STATUS         PORTS                                                                      NAMES</span><br><span class="line">61584a254a15   nginx                                                      &quot;/docker-entrypoint.…&quot;   8 seconds ago   Up 5 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp                                          nginx</span><br></pre></td></tr></table></figure>

<h1 id="使用-docker-compose-搭建-WordPress-网站"><a href="#使用-docker-compose-搭建-WordPress-网站" class="headerlink" title="使用 docker-compose 搭建 WordPress 网站"></a>使用 docker-compose 搭建 WordPress 网站</h1><p>在空目录下新建<code>dc-wp.yml</code>  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">maria_data:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mariadb:</span> <span class="comment"># 定义数据库 MariaDB</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb:10</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 设置环境变量</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MARIADB_DATABASE:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">MARIADB_USER:</span> <span class="string">wp</span></span><br><span class="line">      <span class="attr">MARIADB_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">      <span class="attr">MARIADB_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">maria_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:5</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mariadb</span> <span class="comment"># 因为 docker-compose 会自动把 MariaDB 的名字用做网络标识，所以在连接数据库的时候（字段 WORDPRESS_DB_HOST）就不需要手动指定 IP 地址了，直接用“service”的名字 mariadb 就行了</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wp</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="comment"># 设置容器的依赖关系，指定容器启动的先后顺序</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mariadb</span> <span class="comment"># mariadb启动后</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./wp.conf:/etc/nginx/conf.d/default.conf</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress</span> <span class="comment"># wordpress启动后</span></span><br></pre></td></tr></table></figure>

<p>配置文件<code>wp.conf</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  default_type text/html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">      proxy_http_version 1.1;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">      #proxy_pass http://172.20.0.110;</span><br><span class="line">      proxy_pass http://wordpress;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker-compose -f dc-wp.yml up -d</span><br></pre></td></tr></table></figure>

<p>查看容器状态<br><img src="/2023/09/15/how-docker-compose-use/wp1.png">  </p>
<p>至此完成了<code>WordPress</code>的搭建。  </p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://docs.docker.com/compose/compose-file/">docker-compose字段定义</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnDocker</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>编排</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的使用</title>
    <url>/2023/09/15/how-docker-use/</url>
    <content><![CDATA[<h1 id="熟悉Docker的使用"><a href="#熟悉Docker的使用" class="headerlink" title="熟悉Docker的使用"></a>熟悉Docker的使用</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Cloud integration: v1.0.35</span><br><span class="line"> Version:           24.0.2</span><br><span class="line"> API version:       1.43</span><br><span class="line"> Go version:        go1.20.4</span><br><span class="line"> Git commit:        cb74dfc</span><br><span class="line"> Built:             Thu May 25 21:51:16 2023</span><br><span class="line"> OS/Arch:           darwin/arm64</span><br><span class="line"> Context:           desktop-linux</span><br><span class="line"></span><br><span class="line">Server: Docker Desktop 4.21.1 (114176)</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          24.0.2</span><br><span class="line">  API version:      1.43 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.20.4</span><br><span class="line">  Git commit:       659604f</span><br><span class="line">  Built:            Thu May 25 21:50:59 2023</span><br><span class="line">  OS/Arch:          linux/arm64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.6.21</span><br><span class="line">  GitCommit:        3dce8eb055cbb6872793272b4f20ed16117344f8</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.7</span><br><span class="line">  GitCommit:        v1.1.7-0-g860f061</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker engine</code>版本号 24.0.2  </li>
<li>系统是<code>linux</code>  </li>
<li>硬件架构是<code>arm64</code></li>
</ul>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure>

<p>显示的是当前系统相关的信息，例如 CPU、内存、容器数量、镜像数量、容器运行时、存储文件系统等。  </p>
<h1 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull alpineUsing default tag: latest</span><br><span class="line">latest: Pulling from library/alpine</span><br><span class="line">9fda8d8052c6: Pull complete </span><br><span class="line">Digest: sha256:7144f7bab3d4c2648d7e59409f15ec52a18006a128c733fcff20d3a4a54ba44a</span><br><span class="line">Status: Downloaded newer image for alpine:latest</span><br><span class="line">docker.io/library/alpine:latest</span><br></pre></td></tr></table></figure>

<h2 id="运行并进入容器"><a href="#运行并进入容器" class="headerlink" title="运行并进入容器"></a>运行并进入容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it alpine sh</span><br><span class="line">/ # cat /etc/os-release</span><br><span class="line">NAME=&quot;Alpine Linux&quot;</span><br><span class="line">ID=alpine</span><br><span class="line">VERSION_ID=3.18.3</span><br><span class="line">PRETTY_NAME=&quot;Alpine Linux v3.18&quot;</span><br><span class="line">HOME_URL=&quot;https://alpinelinux.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://gitlab.alpinelinux.org/alpine/aports/-/issues&quot;</span><br></pre></td></tr></table></figure>
<p>这样就暂时离开当前的操作系统，进入了容器内部的 Alpine 系统，可以在里面执行任意的命令，比如 cat &#x2F;etc&#x2F;os-release。<br>这个容器环境与外面是完全隔离的，进程、文件系统都独立，不过也有没有隔离的部分，比如时间和内核。<br>使用 <code>exit</code> 退出容器</p>
<p>再运行一个容器  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d --rm nginx:alpine</span><br></pre></td></tr></table></figure>

<p>在宿主机里用 <code>ps -ef|grep nginx</code> 可以看到有 3 个 Nginx 进程，它们其实就是容器里的 Nginx 进程，用 <code>docker stop</code> 停止后再用 ps，就能发现它们已经消失了。 </p>
<p>说明<strong>容器其实就是操作系统里的进程，只是被容器运行环境加上了 namespace、cgroup、chroot 的限制，所以容器和普通进程在资源的使用方面是没有什么区别的，也因为没有虚拟机的成本，启动更迅速，资源利用率也就更高。</strong></p>
<h1 id="构建自己的镜像"><a href="#构建自己的镜像" class="headerlink" title="构建自己的镜像"></a>构建自己的镜像</h1><p>构建镜像，需要编写<code>Dockerfile</code>。  </p>
<h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="keyword">ARG</span> IMAGE_BASE=<span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> IMAGE_TAG=<span class="string">&quot;1.21-alpine&quot;</span></span><br><span class="line"><span class="comment"># 指定构建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> $&#123;IMAGE_BASE&#125;:$&#123;IMAGE_TAG&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:/tmp</span><br><span class="line"><span class="keyword">ENV</span> DEBUG=OFF</span><br><span class="line"><span class="comment"># 把构建上下文里的./default.conf 拷贝到镜像的 /etc/nginx/conf.d/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./default.conf /etc/nginx/conf.d/</span></span><br><span class="line"><span class="comment"># 构建镜像时要执行的 shell 命令，可以是安装软件、创建目录、编译程序等</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;hello nginx&quot;</span> &gt; a.txt</span></span><br><span class="line"><span class="comment"># 声明容器对外服务的端口号</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span> <span class="number">8082</span> <span class="number">8083</span></span><br><span class="line"><span class="comment"># 容器的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /etc/nginx</span></span><br></pre></td></tr></table></figure>


<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t ngx-app:1.0 .</span><br></pre></td></tr></table></figure>



<h2 id="镜像文件导出"><a href="#镜像文件导出" class="headerlink" title="镜像文件导出"></a>镜像文件导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker save ngx-app:1.0 -o ngx.tar</span><br></pre></td></tr></table></figure>

<h2 id="镜像文件加载"><a href="#镜像文件加载" class="headerlink" title="镜像文件加载"></a>镜像文件加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker load -i ngx.tar</span><br></pre></td></tr></table></figure>

<h1 id="与外部系统互通的操作"><a href="#与外部系统互通的操作" class="headerlink" title="与外部系统互通的操作"></a>与外部系统互通的操作</h1><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝本地文件到容器里</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">cp</span> a.txt 容器ID:/tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝容器里的文件到本地</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">cp</span> 容器ID:/tmp/a.txt ./b.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="本地目录映射"><a href="#本地目录映射" class="headerlink" title="本地目录映射"></a>本地目录映射</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地目录，把文件直接映射到容器内部</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --<span class="built_in">rm</span> -v /tmp:/tmp redis</span></span><br></pre></td></tr></table></figure>

<h2 id="端口号映射"><a href="#端口号映射" class="headerlink" title="端口号映射"></a>端口号映射</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个 Nginx 容器，把本机的 80 端口映射到容器的 80 端口</span> </span><br><span class="line">docker run -d -p 80:80 --rm nginx:alpine</span><br></pre></td></tr></table></figure>

<h1 id="使用Docker搭建WordPress"><a href="#使用Docker搭建WordPress" class="headerlink" title="使用Docker搭建WordPress"></a>使用Docker搭建WordPress</h1><h2 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull wordpress:5</span><br><span class="line">$ docker pull mariadb:10</span><br><span class="line">$ docker pull nginx:alpine</span><br></pre></td></tr></table></figure>

<h2 id="启动-MariaDB"><a href="#启动-MariaDB" class="headerlink" title="启动 MariaDB"></a>启动 MariaDB</h2><p>设置数据库名、用户名、密码等环境变量  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d --rm \</span><br><span class="line">    --env MARIADB_DATABASE=db \</span><br><span class="line">    --env MARIADB_USER=wp \</span><br><span class="line">    --env MARIADB_PASSWORD=123 \</span><br><span class="line">    --env MARIADB_ROOT_PASSWORD=123 \</span><br><span class="line">    mariadb:10</span><br></pre></td></tr></table></figure>

<h2 id="启动-WordPress"><a href="#启动-WordPress" class="headerlink" title="启动 WordPress"></a>启动 WordPress</h2><p>使用刚才的 MariaDB 的用户名、密码  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d --rm \</span><br><span class="line">    --env WORDPRESS_DB_HOST=172.17.0.2 \</span><br><span class="line">    --env WORDPRESS_DB_USER=wp \</span><br><span class="line">    --env WORDPRESS_DB_PASSWORD=123 \</span><br><span class="line">    --env WORDPRESS_DB_NAME=db \</span><br><span class="line">    wordpress:5</span><br></pre></td></tr></table></figure>

<h2 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h2><p>在配置文件里指定 WordPress 的地址，然后用 -v 参数挂载进容器里  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d --rm \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -v `pwd`/wp.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<h2 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h2><p>打开浏览器，输入本机的<code>127.0.0.1</code>或者服务器的IP地址，就可以看到 WordPress 的界面。  </p>
]]></content>
      <categories>
        <category>LearnDocker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员如何阅读英语资料</title>
    <url>/2020/06/17/how-programmers-read-english-materials/</url>
    <content><![CDATA[<h2 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h2><p><strong>“三天打渔两天晒网”是学英语的大忌。Consistency 是最重要的。</strong>  </p>
<p><img src="/2020/06/17/how-programmers-read-english-materials/rule-of-five.jpg">  </p>
<p>每天你哪怕只认识一个单词，连着 365 天，你也可以有很大的成就，对吧？你每天哪怕只看两段文章，你一定要看；每天哪怕只听 5 分钟，你一定要听。这个才是练一项技能最重要的。一定要持久，而不是心血来潮去强调它的强度，要细水长流，水滴石穿。  </p>
<p>今天我突然发现自己太忙了，没有办法看 5 页，我只能看两段，可以的，没问题，这个不算违反规则。没有时间的话，你做少一点，都没有关系。这是一个基本的方法，这也是学习唯一的方法。  </p>
<h2 id="关于词汇"><a href="#关于词汇" class="headerlink" title="关于词汇"></a>关于词汇</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/cihui.jpg">  </p>
<p><strong>学词汇，不要背字典，我再跟你们强调，千万不要背字典。</strong>  </p>
<p><strong>首先，要找一本自己比较习惯使用的一个字典。</strong>我比较推荐用朗文词典。因为朗文词典上面有标准的真人朗读的音标和例句，还会告诉你美英怎么读音，英音怎么读。另外，它的解释也比较简单，用低级的词来解释高级的词。有的词典会用比较高级的词来解释一些低级的词，越查越糊涂。  </p>
<p><strong>我让大家不要背单词，另一个原因是，词组其实更重要，</strong>特别是动词。动词有千变万化的词组，它后面可能跟 20 个不同的介词，这样的话就出来 20 个不同的意思，还有一些搭配。  </p>
<p>在英语里，1 万个单词里有 2000 个单词是真正核心单词，你要把它学透。  </p>
<p>所有那些你看了好像能想起来，但平时不跟你说话的叫被动词汇。天天跟你说话、经常跟你联系的叫主动词汇，那是真正的好朋友。那么主动词汇怎么学呢？  </p>
<ul>
<li><p>第一，要知道它怎么读。  </p>
</li>
<li><p>第二，要读它的例句。除此之外，这些词你要自己学会造句。你可以在例句基础之上你来做一个 preference。你可以去改写一下例句，把它变成自己的话。造句之后还没有完，你还要有意识地去主动运用你今天学的词汇，比如说你要给自己创造一个条件，比如今天给别人要写个 Email，或者在论坛上面要发个 issue 等等。刻意地去用一下词汇，然后多用几次之后，这个就变成你的主动词汇了。  </p>
</li>
<li><p>定制一本自己的词汇手册。  </p>
</li>
<li><p>或者用卡片，把卡片分成三大堆。第一堆是你已经背熟的，你真正的好朋友。第二堆是你刚刚认识的还不太熟的。第三堆是你今天记下来的完全不熟的。慢慢地把第三堆变成第二堆、第 1 堆。当然，第一堆也要经常拿出来复习一下。长久不联系，这个人也就生疏了，对吧？跟交朋友一样的道理，质量永远比数量要来得重要。这些核心词汇，你一定要把它吃透，这些才是你最后才能够用得出来的词。</p>
</li>
</ul>
<h2 id="关于语法"><a href="#关于语法" class="headerlink" title="关于语法"></a>关于语法</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/yufa.jpg">  </p>
<p><strong>看语法书、刷语法题，不是掌握语法的最好的途径。大量的阅读才是掌握语法的最好的方法。</strong>  </p>
<p>语法就是我们认识一座新城市的地图。  </p>
<p>看地图也是有技巧的，切记不要夸大地图的作用。  </p>
<p>语法永远是为内容服务，你不是为了学语法而学语法。  </p>
<h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/yuedu.jpg">  </p>
<p><strong>你要养成一个习惯。每天坚持多读一点，多少没关系，设定一个小一点的目标。另外，读的时候，要把所有的干扰全部都关掉，不要一心多用。</strong>  </p>
<p>读的话一定要读自己感兴趣的内容，不要硬逼自己去读不感兴趣的内容。  </p>
<p>难易度一定要适中，不要去读自己完全看不懂的东西。  </p>
<p><strong>阅读，读的永远是它的思想。读完一篇文章，你知道他讲了什么，它的中心思想是什么，而不是读某一个单词或者读某一个句子。</strong>  </p>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="有必要背诵新概念吗？"><a href="#有必要背诵新概念吗？" class="headerlink" title="有必要背诵新概念吗？"></a>有必要背诵新概念吗？</h3><p>如果你觉得不是那么难的话，我建议你还是要背下来。不要把背诵英文的这个目的太局限化。我们不是为了背而背，而是为了模仿语音语调。你可以找到原版的英国人的录音，去模仿他的语音语调。然后，你自己找一支录音笔，把自己背诵的内容录下来自己听。听完了之后，你再去对照原来新概念的录音，比较一下，看看差别在哪里。  </p>
<p>练语音语调没有第二种方法，只能是模仿。新概念是一个比较好的模仿材料。它的难度相对来说比较适中，是从容易到难循序渐进的。如果你模仿得非常像，从第 1 册开始，一般背到第 3 册，你的语音语调基本上就没有什么太大的问题了。  </p>
<h3 id="怎样才能读懂长难句？"><a href="#怎样才能读懂长难句？" class="headerlink" title="怎样才能读懂长难句？"></a>怎样才能读懂长难句？</h3><p>首先，你要了解英文句式的特点。中文的句子像一列火车，它就是一个车厢接一个车厢，一句话你可以用逗号一直点下去。但是英文它是一棵树，你永远可以找出它的主干，然后你可以找出它的树枝，找到树枝上面的花或者果实。你可以剥洋葱一样把它剥开，之后你大概就知道它是什么意思了，然后你在脑子里面再给它组织在一起就可以了。  </p>
<p>再长的长句、难句，多么变态的句子，我们都可以找到主干。英语的长句怎么读？先从找主干开始。  </p>
<h3 id="看美剧有帮助吗？"><a href="#看美剧有帮助吗？" class="headerlink" title="看美剧有帮助吗？"></a>看美剧有帮助吗？</h3><p>看美剧当然是有帮助的，而且毫无疑问会有很大的益处。  </p>
<p>世界上所有的语言，我们可以粗粗地把它分成两类。一类我们叫 formal English，正式的英语，比如你做演讲的时候或者公司领导做报告的时候，那个时候都是讲很正式的英语。我们平时在课堂当中学的也都是这些 formal English。这些句子非常工整，主谓宾能够非常清楚地找出来的，用的词也都非常正式。  </p>
<p>而我们美剧中大部分都是生活领域的，我们有时候叫 casual English，有时候也叫 kitchen English。不是说它 informal，只是它是比较日常的用语。你看美剧里面，人家插科打诨或者讲一个 joke，你听不懂，因为这个是日常生活的用语，往往是我们学英语的短板，是课堂当中没学过的。  </p>
<h3 id="翻译文章是不是提高阅读能力比较自然的方法？"><a href="#翻译文章是不是提高阅读能力比较自然的方法？" class="headerlink" title="翻译文章是不是提高阅读能力比较自然的方法？"></a>翻译文章是不是提高阅读能力比较自然的方法？</h3><p>不是。除非你的工作跟翻译有关系，你需要把那篇文章翻成中文，或者把中文翻成英文，你有工作上面的需要，否则的话，没事不要去练翻译，浪费时间。阅读就是阅读，不要在阅读的过程当中，把每一篇文章都想着把它给它翻成中文，没有必要。你要 think in English，你要用英文学英文。阅读，你把它理解了就好了。  </p>
<p>但是反过来，当你要把中文翻成英文的时候，这个时候考查的其实并不是你的翻译，考查的是你的英文写作能力。大家老觉得，是我翻译技巧不好，或者是我翻译上面是不是什么东西没学？不是的。  </p>
<p>比如说，一篇 Email，你脑子里面想好中文了，你要把它用英文表达出来，你觉得有困难。你想用英文把一件事情讲清楚，但是你讲不清楚，或者你原本可以用 5 个字讲清楚，绕来绕去，现在你要用 50 个字才能讲清楚。这个不是你翻译技巧有问题，而是你英文不够好。所以，在整个学习的过程当中，只要打英语听说读写的基础就可以了。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>刻意的练习其实是一个 active training，是一个需要你主动投入一些精力，非常专注的、抱着一些特定的目的去寻求一些教练的反馈，然后通过不断接收反馈找到自己练习过程当中的问题，再进行下一轮有意识的练习的过程。  </p>
</li>
<li><p>练习，我们一直在强调，要重持久，而不是重你的练习强度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>英语阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>如何决断一家公司是否值得去为之工作</title>
    <url>/2020/09/09/how-to-decide-whether-a-company-is-worth-going-to-work/</url>
    <content><![CDATA[<p>昨天下午，我意外在朋友圈看到一位之前在上海EA做图形渲染的前辈，跳槽去了一家创业公司——鹰角网络，出于好奇，我询问其跳槽的原因，以下内容采取对话形式展开：  </p>
<p>————————————————————————————————————————————————————————————————————————————</p>
<p>Q：hello，老哥，您是从EA直接跳过去的吗？我有接到猎头邀请，问我是否考虑上海EA。<br>A：是的，EA挺好的，很正规。  </p>
<p>Q：是什么原因去跳槽呢？<br>A：待遇更好，鹰角的产品已经做起来了，并且在扩张阶段。相比上海EA，鹰角产品更挣钱，也更肯投钱在员工身上。  </p>
<p>Q：讲真我还没听过过这家公司，不过我看鹰角公司主页，说是大部分来自谷歌、无极黑的员工，所以我想看一家公司是否值得去，肯定有它的闪光点，耀眼到超过自己当前岗位的价值和意义。<br>A：《明日方舟》可以了解下，从趋利的角度讲，明日方舟首月5亿流水，现在差不多每月1亿，而之前在EA的项目每月1千万，并且腾讯拿大头。还有员工培训这点，今年的UWA开发者大会，鹰角买了20多张票给员工去参加，EA一般每年1-2张，今年1张，当然这也和EA主要用自研引擎有关。但其实EA也有的，比如买GDC各种视频，就是离用到生产还有点距离。  </p>
<p>Q：怎么判断公司是否值得去呢？<br>A：待遇、项目、技术力、宣发能力，大致这些。  </p>
<p>————————————————————————————————————————————————————————————————————————————</p>
<p>和他沟通完后，我陷入了沉思，突然想起我以前在一家上市游戏公司的时候，我旁边工位一位做客户端的同事，为了学习渲染，将一本厚厚的只有英文版的书籍打印下来看，领导看到后非但没有生气，反而对着全工作室人说谁能看完这本书奖励money，各种下午茶、比赛、讲座纷至沓来…。  </p>
<p>然而我目前在另外一家公司所做的事，就只是简单的维护已有的业务逻辑，增删改查，沟通&gt;技术，没有任何成就感，各种无聊的需求以及奇葩的规定，让我逐渐麻木。  </p>
<p>但是这位前辈提到的建议还是非常实用的，对我未来的职业规划起到一定的作用。    </p>
<p>待遇占第一位，毕竟这是生存之根本；项目+技术力，这是历练和提升实力的关键；员工培养机制，这是发展前景的保障；节日礼物和福利，这是人情温暖的一大体现。  </p>
<p><strong>我还年轻，还有更多的时间和机会找到自己喜欢做的事，希望那一天不会让我等太久。</strong>  </p>
<p><img src="/2020/09/09/how-to-decide-whether-a-company-is-worth-going-to-work/wait.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>上班</tag>
        <tag>选择</tag>
        <tag>价值</tag>
      </tags>
  </entry>
  <entry>
    <title>Sad Workers</title>
    <url>/2020/12/18/how-sad-workers/</url>
    <content><![CDATA[<p>打工人，越来越难了。  </p>
<p>曾以为打工只是出卖自己的劳动力换取报酬，然而没想到行业内卷的这么严重，停止等于倒退；没有今天的996，哪有明天的669；优化不能加班的员工；35岁被裁…现在要成立HR联盟，垄断员工肆意跳槽。  </p>
<p>我不知道未来将会怎样，今天意外刷到一部冷门电影<a href="https://movie.douban.com/subject/4116481/">《极乐空间》</a>，放佛看到了打工人的未来。  </p>
<p>社会缺什么，就会赞美什么————缺爱国情怀，就去拍各种抗日神剧；缺真善美，就去拍各种脑残傻白甜的电视剧…我一直很喜欢<a href="https://movie.douban.com/subject/5350027/">《妖猫转》</a>里的一段话：<strong>人心这么黑暗，我想找到一种不再痛苦的秘密。</strong>而最后杨玉环给了我一个答案：生活是不完美的，但我依然可以选择去拥抱生活的美好。  </p>
<p>什么是美好呢？也许是一次温暖的鼓励，也许是临行前父母的嘱托，也许是高考前妹妹大声喊着“哥哥高考必胜”，也许是大雪纷飞中公交车司机多等了我一分钟…可是，当我步入职场后，我却发现自己越来越难以坚守本心。  </p>
<p>最近忙着申请了成都市的失业补助金，也为极客时间又当了一回审稿人，看着这些忙忙碌碌我生活奔波的打工人，是的，也许我就是一滴水，多我少我都算不了什么，因为我迟早要融入这浩浩荡荡的打工人海中去随波逐流，为着这居高不下的房价当做我奋斗的目标，衡量工作的成功而是以工作作为评级。  </p>
<p>只是，如果允许我再任性一回，我想再回归本心，去找寻真正的出路。  </p>
<p>（最近备考压力有些大，看着杭州市成立了HR联盟，难免心里有些膈应，写一此文吐槽一番…）</p>
<p><a href="https://www.zhihu.com/question/357459810/answer/908791884">如何看待网传网易裁员，让保安把身患绝症的 5 年老员工赶出公司一事？</a><br><a href="https://www.zhihu.com/question/434158902">如何评价杭州阿里、海康、网易等组成 HR 联盟？</a><br><a href="https://www.zhihu.com/question/359047845/answer/921118877">「华为前员工李洪元被羁押 251 天」 事发过程是怎样的？还有哪些值得注意的疑点和信息？</a><br><a href="https://www.zhihu.com/question/308375308/answer/654108580">如何看待华为工程师 22 月无休后猝死的传闻，事件真相如何？</a><br><a href="https://www.zhihu.com/question/407009249">如何看待腾讯高级工程师因「每天在岗不足8小时」被辞退，反诉加班费等 500 余万两度败诉？</a>  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>打工人</tag>
        <tag>悲哀</tag>
        <tag>出路</tag>
      </tags>
  </entry>
  <entry>
    <title>如何释放压力</title>
    <url>/2019/11/11/how-to-reduce-pressure/</url>
    <content><![CDATA[<h2 id="压力来源"><a href="#压力来源" class="headerlink" title="压力来源"></a>压力来源</h2><p>我个人觉得压力的渠道主要有这些：  </p>
<ul>
<li><p>单调，日复一日的生活，没有新鲜感；  </p>
</li>
<li><p>对未来的迷茫  </p>
</li>
<li><p>焦虑(知识，未来)  </p>
</li>
<li><p>生理期</p>
</li>
</ul>
<h2 id="减压方式"><a href="#减压方式" class="headerlink" title="减压方式"></a>减压方式</h2><p>人是一种群体性动物，所以每天和周围人说说话也是释放压力的一种方式，然而有些时候节奏过快，而像类似程序员这种天天和机器打交道的职业，可能时间久了连一句语序正确的话都说不出了，或者说出的话都是间隔相同，带分号(;)隔开？亦或是进行并发同时阐述多种话语？hhh调皮一下。  </p>
<h3 id="写日记"><a href="#写日记" class="headerlink" title="写日记"></a>写日记</h3><p>这是我坚持了(3+4+1.5)八年半的习惯，不得不说这是我首选的宣泄方式，从高中对某个女孩的暗恋，到大学对这教育体制的不满又无能为力的心情，以及毕业顺利拿到<code>offer</code>的喜悦，记录着我心智成长的艰辛过程。  </p>
<h3 id="慢跑"><a href="#慢跑" class="headerlink" title="慢跑"></a>慢跑</h3><p>很怀念大学时期每晚在操场跑步的时光，从图书馆自习出来后，戴上无线耳机去操场慢跑3-5圈，然后回宿舍泡热水脚洗漱睡觉，第二天又精神饱满的去学习。  </p>
<h3 id="瑜伽"><a href="#瑜伽" class="headerlink" title="瑜伽"></a>瑜伽</h3><p>有段时间加班严重，回到家就想躺在床上，背部及其难受，无意间在<code>keep</code>上发现一个长达16分钟的睡前舒缓瑜伽课程，于是跟着视频练习起来，效果很满意。  </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打电话、看书、睡觉、打游戏？？？  </p>
<p>部门老哥推荐的一本<a href="ps://book.douban.com/subject/26590889/">《情绪急救》</a>  </p>
<h3 id="关于焦虑"><a href="#关于焦虑" class="headerlink" title="关于焦虑"></a>关于焦虑</h3><p>周末看完了阮一峰老师写的书《未来世界的幸存者》，让我不自在的又焦虑了起来，技术迭代太快，我怕我跟不上时代的节奏，称为了淘汰者。  </p>
<p>可是，这又有什么办法呢？人的生命如此渺小，如沧海一粟，实在难以想象一千年后的技术水平会是什么样子。  </p>
<p>最后以我很喜欢的一句话结尾  </p>
<p><strong>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年</strong></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>压力</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>如何完美干净的卸载Kubernetes集群</title>
    <url>/2022/09/06/how-to-perfect-uninstall-kubernetes-cluster/</url>
    <content><![CDATA[<p>因为某些原因，需要卸载<code>kubernetes</code>集群，本文将分享完整卸载<code>kubernetes</code>的方法。  </p>
<p>默认是<code>root</code>用户操作  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先清理运行到k8s群集中的pod</span></span><br><span class="line">kubectl delete node --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有k8s相关服务</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> kube-apiserver kube-controller-manager kubectl kubelet kube-proxy kube-scheduler;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">      systemctl stop <span class="variable">$service</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置集群</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除相关的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.kube/</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/kubernetes/</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/systemd/system/kubelet.service.d</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/systemd/system/kubelet.service</span><br><span class="line"><span class="comment"># 删除kubenetes有关的可执行文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf /usr/bin/kube*</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/cni</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /opt/cni</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/etcd</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /var/etcd</span><br><span class="line"></span><br><span class="line">apt clean all</span><br><span class="line"></span><br><span class="line">apt remove kube*</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>kubernetes</tag>
        <tag>卸载</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何更新fork后的repository</title>
    <url>/2019/06/10/how-to-update-git-fork-repository/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个仓库A，我经过<code>fork</code>后变成了仓库B，当仓库A已经有了新提交时，我需要更新仓库B，该怎么办呢？  </p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1,首先，检查一下当前的配置，看看当前有没有已经设置了上游，这要使用<code>git remote -v</code>命令。</p>
<p>2,将原repository设置为自己fork出的repository的上游（upstream）。运用如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure>

<p>3,运行<code>git fetch upstream</code>命令，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Enumerating objects: 122, done.</span><br><span class="line">remote: Counting objects: 100% (122/122), done.</span><br><span class="line">remote: Compressing objects: 100% (90/90), done.</span><br><span class="line">remote: Total 97 (delta 40), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (97/97), done.</span><br><span class="line">From https://gitea.com/zsxq/jobs_crawler</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4,<code>git checkout master</code>，这是保证切换到本地的repository的master上，如果本来就在，那么这一步不是必须的。</p>
<p>5,运行<code>git merge upstream/master</code>命令，将upstream&#x2F;master上的更新合并到本地的master上，其实就是将第三步中download到.git文件夹下的那些change合并到本地的master中。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Updating e9540a6..c31fadf</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md                      |   8 +-</span><br><span class="line"> cmd/crawler/background.go      |  42 ++++++++</span><br><span class="line"> cmd/crawler/main.go            |  32 +++---</span><br><span class="line"> config/config.yaml             |  18 +++-</span><br><span class="line"> dao/auto_crawl_rule.go         |  79 +++++++++++++++</span><br><span class="line"> dao/auto_crawl_rule_test.go    |  38 +++++++</span><br><span class="line"> dao/crawl_rule.go              |  44 ++++++++</span><br><span class="line"> dao/db.go                      |  19 ++--</span><br><span class="line"> dao/job.go                     | 101 ++++++++++++++++++-</span><br><span class="line"> docs/db.sql                    |  19 ++--</span><br><span class="line"> global/app.go                  |  77 ++++++++++++++</span><br><span class="line"> global/init.go                 |  35 +++++++</span><br><span class="line"> go.mod                         |   5 +-</span><br><span class="line"> go.sum                         |   3 +</span><br><span class="line"> http/controller/job_handler.go |  79 ++++++++++++++-</span><br><span class="line"> http/middleware/logger.go      |  35 +++++++</span><br><span class="line"> logic/crawler/colly.go         |  46 +++++++++</span><br><span class="line"> logic/crawler/goquery.go       | 221 +++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> logic/crawler/parser.go        |  68 +++++++++++++</span><br><span class="line"> logic/crawler/work.go          |  55 ++++++++++</span><br><span class="line"> logic/job.go                   |  14 ++-</span><br><span class="line"> model/auto_crawl_rule.go       |  31 ++++++</span><br><span class="line"> model/crawl_rule.go            |  26 +++++</span><br><span class="line"> model/job_info.go              |   2 +-</span><br><span class="line"> template/detail.html           |  49 +++++++++</span><br><span class="line"> template/index.html            |  70 +++++++++++++</span><br><span class="line"> util/file.go                   |  18 ++++</span><br><span class="line"> util/http.go                   |  21 ++++</span><br><span class="line"> util/int.go                    |   8 ++</span><br><span class="line"> util/ip.go                     |  37 +++++++</span><br><span class="line"> 30 files changed, 1253 insertions(+), 47 deletions(-)</span><br></pre></td></tr></table></figure>
<p>这时我在用<code>gitk</code>命令查看<br><img src="/2019/06/10/how-to-update-git-fork-repository/git-fork.png" alt="git-fork">  </p>
<p>6,如果本地没有什么自己独立的更新的话，那么将执行”Fast-forward”的合并。如果本地有自己独立的更新，而又会引起冲突的话，则要解决冲突，再commit.</p>
<p>关于解决冲突，如果明确所有冲突都是使用upstream&#x2F;master上的来override自己的，那么可以直接运行如下命令，则无需解决冲突了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge -X theirs upstream/master</span><br></pre></td></tr></table></figure>

<p>注意，以上步骤结束后，仅仅是本地的fork出的repository和原repository取得了同步，如果想让远程的fork出的repository也同样取得同步，必须再git push上去。 </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://help.github.com/en/articles/syncing-a-fork">Syncing a fork</a>  </li>
<li><a href="https://help.github.com/en/articles/configuring-a-remote-for-a-fork">Configuring a remote for a fork</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad上改变百度网盘播放速度的方法</title>
    <url>/2020/06/06/how-to-use-ipad-baiduyundisk-control-video-play-speed/</url>
    <content><![CDATA[<p>百度网盘上的视频无法变速，我将分享一种我自认为最快解决的办法。  </p>
<h2 id="步骤一：添加快捷指令"><a href="#步骤一：添加快捷指令" class="headerlink" title="步骤一：添加快捷指令"></a>步骤一：添加快捷指令</h2><p>打开<code>iPad</code>上的快捷指令；<br>选中<code>共享表单快捷指令</code>；<br>点击<code>更改视频速度</code>；<br>拉到最下面点击<code>添加快捷指令</code>。  </p>
<h2 id="步骤二：Safari浏览器"><a href="#步骤二：Safari浏览器" class="headerlink" title="步骤二：Safari浏览器"></a>步骤二：Safari浏览器</h2><p>打开Safari浏览器，登录百度网盘，选中一个视频播放；<br>点击右上角有一个<strong>向上箭头</strong>的图标；<br>拉到下面有一个<code>更改视频速度</code>的选项；<br>选择可以接受的视频播放速度，完成。  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.zhihu.com/question/65320947/answer/649400591">iPad 百度网盘视频如何加速播放？</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7S3?from=search&seid=16526850915632720540">你的ipad还在用百度网盘和Alook看视频吗，教你免费的自定义倍速播放！</a></p>
]]></content>
      <categories>
        <category>Play-iPad</category>
      </categories>
      <tags>
        <tag>iPad</tag>
        <tag>百度</tag>
        <tag>网盘</tag>
        <tag>速度</tag>
      </tags>
  </entry>
  <entry>
    <title>不想长大</title>
    <url>/2017/02/24/i-do-not-want-to-grow-up/</url>
    <content><![CDATA[<p>总有一条蜿蜒在童话镇里七彩的河，沾染魔法的乖张气息却又在爱里曲折，川流不息扬起水花又卷入一帘时光入水，让所有很久很久以前，都走到幸福结局的时刻。  ——《童话镇》  </p>
<p>时光还与造物，来路末予光年。毫素与书囊的故事讲不到尽头，街灯与星辰联翩，银河回声隐隐，影子在脚下蜷缩又伸展。日光目送，夜色复又遗忘，我仿佛回到了那些年。  </p>
<p>记得那是个清晨，我迷迷糊糊从梦中醒来，照常洗漱，看着镜中自己的面容，熟悉又感到陌生。这是20岁时的我，和小时候的自己已经判若两人。变化的不光是外表，还有心。  </p>
<p>寒假里最快乐的时光，就是两位路痴在大雪纷飞的日子里，畅聊着大学期间的酸甜苦辣，走过那些似曾相识的街道，看看是否还残留着幸福的味道，又或者开始漫无边际的吹牛皮。  </p>
<p>我问：你说，人为什么会成长？  </p>
<p>回答1：所谓的成长就是获得经验，而获得经验的方法就是记忆。  </p>
<p>回答2：成长就是人需要经历痛苦和磨难后的改变。  </p>
<p>回答3：一个人小时候会优先选择做自己喜欢而且擅长的事情，成长后会选择放弃自己的兴趣，承担起责任和义务，去做自己应该做的事情。  </p>
<p>回答4：分为主动成长和被动成长。前者是受兴趣、梦想所驱使的主动改变；后者是因周围环境的变化所不得不做出的适应性改变。  </p>
<p>回答5：基因的程序员结果所致。  </p>
<p>当我思考这个问题的时候，我在基因和环境这两个因素前徘徊了许久。有时候会想到“三十而立，四十不惑”，但有时候又会想到“近朱者赤，近墨者黑”这句话。  </p>
<p>其实是我自己把问题想复杂了。所谓的成长，不过是从遭遇现实时不再选择逃避，而是坦然接受。就像生活给了你一个嘴巴，这个时候你既不能像个娘炮一样把右脸伸过去给它打，也不能像个懦夫一样冲上去玩命，不能哭，不能讲话，不能像傻逼一样抱着头。你唯一能做的是，擦干净嘴角滴落的粘稠的血，把它抹在地板上，然后牙咬碎，嘴闭紧，把所有委屈和不甘，以及那个不堪入目的自己，全他妈的咽下去。像一个真正的平淡的猛男一样，不动声色的练拳头。  </p>
<p>一个人的成长，就如同一个健壮代码的形成过程。从最开始生下来说了一声hello world（创建项目工程文件），到后来学会了判断对错（if-else），每天重复做一件事（循环），自己尝试控制自己（递归），然后知道了对知识进行思维导图记忆（数据结构），学会了敌进我退，敌退我追的经典战术（迭代算法）。当然这样做的弊端就在于规模越大，BUG也就越多。  </p>
<p>我不想长大，不想做那些违背自己内心的事情，不想变得复杂得令人难以捉摸。可是当我直面现实时，就要开始享受那无法回避的痛苦。真叫人心痛，全身没有一处受伤，却感到呼吸困难，仿佛时刻有人会扼住自己的咽喉。我不知道这样的感觉还要持续多久，只知道现在早已习以为常，就像上了一条时光传送带，在不知不觉中就已经习惯了这样的转速，这样的压力，这样的生存环境。  </p>
<p>只有在家，才能卸下这满身的负担。  </p>
<p>这个寒假，或许是我过得最后一个最充实，最幸福的的假期了。没有压力，没有负担，一日三餐定时供应，我可以起早去公园跑步，吹口琴；我可以喝一口下午茶，捧着自己喜欢的书籍细细品味；我可以和朋友们在外玩的很开心而忘记了回家的路…但是，美好的时光总是短暂的，不然上帝也会嫉妒的。  </p>
<p>我不想长大，我真的不想不想长大。  </p>
<p>再看望一遍我的母校和恩师；再和我的朋友们道一声别，愿你们过着自己想要的生活；再走一回曾经和她一起走过的街角，当我回眸时，是否会看到她的身影，直到看着我消失；再次站在红山顶上，眺望这笼罩在雾霾中的城市，曾经的蓝天白云都去哪了呢？  </p>
<p>终于，一直单曲循环的《童话镇》接近了尾声，听：总有一条蜿蜒在童话镇里梦幻的河，分隔了理想分隔现实又在前方的山口汇合。川流不息扬起水花又卷入一帘时光入水，让所有很久很久以前都走到幸福结局的时刻，又陌生。  </p>
<p>我不想长大，却无法改变这正在长大的事实，只能接受。或许这将是标志着我逐渐成长的开始。  </p>
<p><img src="/2017/02/24/i-do-not-want-to-grow-up/chinldhood.jpeg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>童话镇</tag>
        <tag>幸福</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Swagger生成API文档</title>
    <url>/2022/01/16/how-to-use-swagger-make-api-doc/</url>
    <content><![CDATA[<h1 id="Swagger-介绍"><a href="#Swagger-介绍" class="headerlink" title="Swagger 介绍"></a>Swagger 介绍</h1><p>Swagger 是一套围绕 OpenAPI 规范构建的开源工具，可以设计、构建、编写和使用REST API。Swagger 包含很多工具，其中主要的 Swagger 工具包括：  </p>
<ul>
<li>Swagger 编辑器：基于浏览器的编辑器，可以在其中编写 OpenAPI 规范，并实时预览API 文档。<a href="https://editor.swagger.io/">https://editor.swagger.io</a> 就是一个 Swagger 编辑器，你可以尝试在其中编辑和预览 API 文档。  </li>
<li>Swagger UI：将 OpenAPI 规范呈现为交互式 API 文档，并可以在浏览器中尝试 API调用。  </li>
<li>Swagger Codegen：根据 OpenAPI 规范，生成服务器存根和客户端代码库，目前已涵盖了 40 多种语言。</li>
</ul>
<h1 id="Swagger-和-OpenAPI-的区别"><a href="#Swagger-和-OpenAPI-的区别" class="headerlink" title="Swagger 和 OpenAPI 的区别"></a>Swagger 和 OpenAPI 的区别</h1><p>OpenAPI 是一个 API 规范，它的前身叫 Swagger 规范，通过定义一种用来描述 API 格式或 API 定义的语言，来规范 RESTful 服务开发过程，目前最新的 OpenAPI 规范是OpenAPI 3.0（也就是 Swagger 2.0 规范）。  </p>
<p>OpenAPI 规范规定了一个 API 必须包含的基本信息，这些信息包括：  </p>
<ul>
<li>对 API 的描述，介绍 API 可以实现的功能。  </li>
<li>每个 API 上可用的路径（&#x2F;users）和操作（GET &#x2F;users，POST &#x2F;users）。  </li>
<li>每个 API 的输入 &#x2F; 返回的参数。  </li>
<li>验证方法。  </li>
<li>联系信息、许可证、使用条款和其他信息。</li>
</ul>
<p>所以可以简单理解为：<strong>OpenAPI 是一个 API 规范，Swagger 则是实现规范的工具。</strong>  </p>
<h1 id="用go-swagger来生成Swagger-API文档"><a href="#用go-swagger来生成Swagger-API文档" class="headerlink" title="用go-swagger来生成Swagger API文档"></a>用go-swagger来生成Swagger API文档</h1><h2 id="安装-Swagger-工具"><a href="#安装-Swagger-工具" class="headerlink" title="安装 Swagger 工具"></a>安装 Swagger 工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/go-swagger/go-swagger/cmd/swagger</span><br><span class="line">$ swagger version</span><br><span class="line">version: v0.28.0</span><br><span class="line">$ swagger -h</span><br><span class="line">Usage:</span><br><span class="line">  swagger [OPTIONS] &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Swagger tries to support you as best as possible when building APIs.</span><br><span class="line"></span><br><span class="line">It aims to represent the contract of your API with a language agnostic description of your application in json or yaml.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -q, --quiet                  silence logs</span><br><span class="line">      --log-output=LOG-FILE    redirect logs to file</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --help                   Show this help message</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  diff      diff swagger documents</span><br><span class="line">  expand    expand $ref fields in a swagger spec</span><br><span class="line">  flatten   flattens a swagger document</span><br><span class="line">  generate  generate go code</span><br><span class="line">  init      initialize a spec document</span><br><span class="line">  mixin     merge swagger documents</span><br><span class="line">  serve     serve spec and docs</span><br><span class="line">  validate  validate the swagger document</span><br><span class="line">  version   print the version</span><br></pre></td></tr></table></figure>
<h2 id="swagger-命令行工具介绍"><a href="#swagger-命令行工具介绍" class="headerlink" title="swagger 命令行工具介绍"></a>swagger 命令行工具介绍</h2><table>
<thead>
<tr>
<th>子命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>diff</td>
<td>对比两个swagger文档的差异</td>
</tr>
<tr>
<td>expand</td>
<td>展开swagger定义文档中的@ref</td>
</tr>
<tr>
<td>flatten</td>
<td>展开swagger文档</td>
</tr>
<tr>
<td>generate</td>
<td>生成swagger文档、客户端代码、服务端代码等</td>
</tr>
<tr>
<td>ini</td>
<td>初始化一个swagger定义文档，初始化时可以指定一些配置</td>
</tr>
<tr>
<td>mix</td>
<td>合并swagger文档</td>
</tr>
<tr>
<td>serv</td>
<td>启动http服务，以查看swagger文档</td>
</tr>
<tr>
<td>validate</td>
<td>验证Swagger定义文件是否正确</td>
</tr>
<tr>
<td>version</td>
<td>打开swagger命令版本</td>
</tr>
</tbody></table>
<h2 id="如何使用-swagger-命令生成-Swagger-文档？"><a href="#如何使用-swagger-命令生成-Swagger-文档？" class="headerlink" title="如何使用 swagger 命令生成 Swagger 文档？"></a>如何使用 swagger 命令生成 Swagger 文档？</h2><p>go-swagger 通过解析源码中的注释来生成 Swagger 文档，go-swagger 的详细注释语法可参考<a href="https://goswagger.io/">官方文档</a>。常用的有如下几类注释语法：  </p>
<table>
<thead>
<tr>
<th>注释语法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>swagger:meta</td>
<td>定义API接口全局基本信息</td>
</tr>
<tr>
<td>swagger:route</td>
<td>定义路由信息</td>
</tr>
<tr>
<td>swagger:parameters</td>
<td>定义API请求参数</td>
</tr>
<tr>
<td>swagger:operation</td>
<td></td>
</tr>
<tr>
<td>swagger:response</td>
<td>定义API响应参数</td>
</tr>
<tr>
<td>swagger:model</td>
<td>定义可以复用的Go数据结构</td>
</tr>
<tr>
<td>swagger:allOf</td>
<td>嵌入其他的Go结构体</td>
</tr>
<tr>
<td>swagger:strfmt</td>
<td>定义格式化的字符串</td>
</tr>
<tr>
<td>swagger:discriminated</td>
<td></td>
</tr>
<tr>
<td>swagger:ignore</td>
<td>定义需要忽略的结构体</td>
</tr>
</tbody></table>
<h2 id="解析注释生成-Swagger-文档"><a href="#解析注释生成-Swagger-文档" class="headerlink" title="解析注释生成 Swagger 文档"></a>解析注释生成 Swagger 文档</h2><p>swagger generate 命令会找到 main 函数，然后遍历所有源码文件，解析源码中与Swagger 相关的注释，然后自动生成 swagger.json&#x2F;swagger.yaml 文件。  </p>
<p>这一过程的示例代码为<a href="https://github.com/OctopusLian/swagger-demo">swagger</a>。目录下有一个 main.go 文件，定义了如下 API 接口：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;swagger-demo/api&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This line is necessary for go-swagger to find your docs!</span></span><br><span class="line">	_ <span class="string">&quot;swagger-demo/docs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users []*api.User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.POST(<span class="string">&quot;/users&quot;</span>, Create)</span><br><span class="line">	r.GET(<span class="string">&quot;/users/:name&quot;</span>, Get)</span><br><span class="line">	log.Fatal(r.Run(<span class="string">&quot;:5555&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create create a user in memory.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user api.User</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBindJSON(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;message&quot;</span>: err.Error(), <span class="string">&quot;code&quot;</span>: <span class="number">10001</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">		<span class="keyword">if</span> u.Name == user.Name &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;user %s already exist&quot;</span>, user.Name), <span class="string">&quot;code&quot;</span>: <span class="number">10001</span>&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	users = <span class="built_in">append</span>(users, &amp;user)</span><br><span class="line">	c.JSON(http.StatusOK, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get return the detail information for a user.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	username := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">		<span class="keyword">if</span> u.Name == username &#123;</span><br><span class="line">			c.JSON(http.StatusOK, u)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;user %s not exist&quot;</span>, username), <span class="string">&quot;code&quot;</span>: <span class="number">10002</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 包中引入的 User struct 位于 swagger-demo&#x2F;api 目录下的user.go文件：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package api defines the user model.</span></span><br><span class="line"><span class="keyword">package</span> api</span><br><span class="line"></span><br><span class="line"><span class="comment">// User represents body of User request and response.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// User&#x27;s name.</span></span><br><span class="line">	<span class="comment">// Required: true</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// User&#x27;s nickname.</span></span><br><span class="line">	<span class="comment">// Required: true</span></span><br><span class="line">	Nickname <span class="type">string</span> <span class="string">`json:&quot;nickname&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// User&#x27;s address.</span></span><br><span class="line">	Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// User&#x27;s email.</span></span><br><span class="line">	Email <span class="type">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>// Required: true</code>说明字段是必须的，生成 Swagger 文档时，也会在文档中声明该字段是必须字段。  </p>
<p>为了使代码保持简洁，我们在另外一个 Go 包中编写带 go-swagger 注释的 API 文档。假设该 Go 包名字为 docs，在开始编写 Go API 注释之前，需要在 main.go 文件中导入 docs 包：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ <span class="string">&quot;swagger-demo/docs&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 swagger-demo 目录下，创建 docs 文件夹：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> docs</span><br><span class="line">$ <span class="built_in">cd</span> docs</span><br></pre></td></tr></table></figure>

<p>在 docs 目录下，创建一个 doc.go 文件，在该文件中提供 API 接口的基本信息：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Package docs awesome.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Documentation of our awesome API.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Schemes: http, https</span></span><br><span class="line"><span class="comment">//     BasePath: /</span></span><br><span class="line"><span class="comment">//     Version: 0.1.0</span></span><br><span class="line"><span class="comment">//     Host: some-url.com</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Consumes:</span></span><br><span class="line"><span class="comment">//     - application/json</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Produces:</span></span><br><span class="line"><span class="comment">//     - application/json</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     Security:</span></span><br><span class="line"><span class="comment">//     - basic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    SecurityDefinitions:</span></span><br><span class="line"><span class="comment">//    basic:</span></span><br><span class="line"><span class="comment">//      type: basic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// swagger:meta</span></span><br><span class="line"><span class="keyword">package</span> docs</span><br></pre></td></tr></table></figure>

<p>Package docs 后面的字符串 awesome 代表我们的 HTTP 服务名。Documentation of our awesome API是我们 API 的描述。其他都是 go-swagger 可识别的注释，代表一定的意义。最后以swagger:meta注释结束。  </p>
<p>编写完 doc.go 文件后，进入 swagger-demo 目录，执行如下命令，生成 Swagger API 文档，并启动 HTTP 服务，在浏览器查看 Swagger：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger generate spec -o swagger.yaml</span><br><span class="line">$ swagger serve --no-open -F=swagger --port 36666 swagger.yaml</span><br><span class="line"></span><br><span class="line">2022/1/16 23:16:47 serving docs at http://localhost:36666/docs</span><br></pre></td></tr></table></figure>

<ul>
<li>o：指定要输出的文件名。swagger 会根据文件名后缀.yaml 或者.json，决定生成的文件格式为 YAML 或 JSON。  </li>
<li>–no-open：因为是在 Linux 服务器下执行命令，没有安装浏览器，所以使–no-open 禁止调用浏览器打开 URL。  </li>
<li>-F：指定文档的风格，可选 swagger 和 redoc。我选用了 redoc，因为觉得 redoc 格式更加易读和清晰。  </li>
<li>–port：指定启动的 HTTP 服务监听端口。</li>
</ul>
<p>打开浏览器，访问<a href="http://localhost:36666/docs">http://localhost:36666/docs</a> ，就可以看到效果了。  </p>
<p>接下来，我们就可以编写 API 接口的定义文件，位于<a href></a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> docs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/marmotedu/gopractise-demo/swagger/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// swagger:route POST /users user createUserRequest</span></span><br><span class="line"><span class="comment">// Create a user in memory.</span></span><br><span class="line"><span class="comment">// responses:</span></span><br><span class="line"><span class="comment">//   200: createUserResponse</span></span><br><span class="line"><span class="comment">//   default: errResponse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swagger:route GET /users/&#123;name&#125; user getUserRequest</span></span><br><span class="line"><span class="comment">// Get a user from memory.</span></span><br><span class="line"><span class="comment">// responses:</span></span><br><span class="line"><span class="comment">//   200: getUserResponse</span></span><br><span class="line"><span class="comment">//   default: errResponse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swagger:parameters createUserRequest</span></span><br><span class="line"><span class="keyword">type</span> userParamsWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// This text will appear as description of your request body.</span></span><br><span class="line">    <span class="comment">// in:body</span></span><br><span class="line">    Body api.User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This text will appear as description of your request url path.</span></span><br><span class="line"><span class="comment">// swagger:parameters getUserRequest</span></span><br><span class="line"><span class="keyword">type</span> getUserParamsWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// in:path</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This text will appear as description of your response body.</span></span><br><span class="line"><span class="comment">// swagger:response createUserResponse</span></span><br><span class="line"><span class="keyword">type</span> createUserResponseWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// in:body</span></span><br><span class="line">    Body api.User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This text will appear as description of your response body.</span></span><br><span class="line"><span class="comment">// swagger:response getUserResponse</span></span><br><span class="line"><span class="keyword">type</span> getUserResponseWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// in:body</span></span><br><span class="line">    Body api.User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This text will appear as description of your error response body.</span></span><br><span class="line"><span class="comment">// swagger:response errResponse</span></span><br><span class="line"><span class="keyword">type</span> errResponseWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Error code.</span></span><br><span class="line">    Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error message.</span></span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>user.go 文件说明：  </p>
<ul>
<li>swagger:route：swagger:route代表 API 接口描述的开始，后面的字符串格式为HTTP方法 URL Tag ID。可以填写多个 tag，相同 tag 的 API 接口在 Swagger 文档中会被分为一组。ID 是一个标识符，swagger:parameters是具有相同 ID 的swagger:route的请求参数。swagger:route下面的一行是该 API 接口的描述，需要以英文点号为结尾。responses:定义了 API 接口的返回参数，例如当 HTTP 状态码是 200 时，返回 createUserResponse，createUserResponse 会跟swagger:response进行匹配，匹配成功的swagger:response就是该 API 接口返回 200 状态码时的返回。  </li>
<li>swagger:response：swagger:response定义了 API 接口的返回，例如 getUserResponseWrapper，关于名字，我们可以根据需要自由命名，并不会带来任何不同。getUserResponseWrapper 中有一个 Body 字段，其注释为&#x2F;&#x2F; in:body，说明该参数是在 HTTP Body 中返回。swagger:response之上的注释会被解析为返回参数的描述。api.User 自动被 go-swagger 解析为Example Value和Model。我们不用再去编写重复的返回字段，只需要引用已有的 Go 结构体即可，这也是通过工具生成 Swagger 文档的魅力所在。  </li>
<li>swagger:parameters：swagger:parameters定义了 API 接口的请求参数，例如 userParamsWrapper。userParamsWrapper 之上的注释会被解析为请求参数的描述，&#x2F;&#x2F; in:body代表该参数是位于 HTTP Body 中。同样，userParamsWrapper 结构体名我们也可以随意命名，不会带来任何不同。swagger:parameters之后的 createUserRequest 会跟swagger:route的 ID 进行匹配，匹配成功则说明是该 ID 所在 API 接口的请求参数。</li>
</ul>
<p>进入 swagger-demo 目录，执行如下命令，生成 Swagger API 文档，并启动 HTTP 服务，在浏览器查看 Swagger：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger generate spec -o swagger.yaml</span><br><span class="line">$ swagger serve --no-open -F=swagger --port 36666 swagger.yaml</span><br><span class="line">2021/1/27 23:50:30 serving docs at http://localhost:36666/docs</span><br></pre></td></tr></table></figure>

<p>打开浏览器，访问 <a href="http://localhost:36666/docs">http://localhost:36666/docs</a> ，如下图所示：  </p>
<p><img src="/2022/01/16/how-to-use-swagger-make-api-doc/%E6%95%88%E6%9E%9C1.png">  </p>
<p><img src="/2022/01/16/how-to-use-swagger-make-api-doc/%E6%95%88%E6%9E%9C2.png">  </p>
<h1 id="go-swagger-其他常用功能介绍"><a href="#go-swagger-其他常用功能介绍" class="headerlink" title="go-swagger 其他常用功能介绍"></a>go-swagger 其他常用功能介绍</h1><h2 id="对比-Swagger-文档"><a href="#对比-Swagger-文档" class="headerlink" title="对比 Swagger 文档"></a>对比 Swagger 文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger diff -d change.log swagger.new.yaml swagger.old.yaml</span><br><span class="line">$ cat change.log</span><br><span class="line"></span><br><span class="line">BREAKING CHANGES:</span><br><span class="line">=================</span><br><span class="line">/users:post Request - Body.Body.nickname.address.email.name.Body : User - Deleted property</span><br><span class="line">compatibility test FAILED: 1 breaking changes detected</span><br></pre></td></tr></table></figure>

<h2 id="生成服务端代码"><a href="#生成服务端代码" class="headerlink" title="生成服务端代码"></a>生成服务端代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir go-user</span><br><span class="line">$ cd go-user</span><br><span class="line">$ swagger generate server -f ../swagger.yaml -A go-user</span><br></pre></td></tr></table></figure>

<h2 id="生成客户端代码"><a href="#生成客户端代码" class="headerlink" title="生成客户端代码"></a>生成客户端代码</h2><p>在 go-user 目录下执行如下命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger generate client -f ../swagger.yaml -A go-user</span><br></pre></td></tr></table></figure>

<h2 id="验证-Swagger-文档是否合法"><a href="#验证-Swagger-文档是否合法" class="headerlink" title="验证 Swagger 文档是否合法"></a>验证 Swagger 文档是否合法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger validate swagger.yaml</span><br><span class="line">2020/10/21 09:53:18</span><br><span class="line">The swagger spec at &quot;swagger.yaml&quot; is valid against swagger specification 2.0</span><br></pre></td></tr></table></figure>

<h2 id="合并-Swagger-文档"><a href="#合并-Swagger-文档" class="headerlink" title="合并 Swagger 文档"></a>合并 Swagger 文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ swagger mixin swagger_part1.yaml swagger_part2.yaml</span><br></pre></td></tr></table></figure>

<p>注：以上所有代码的<a href="https://github.com/OctopusLian/swagger-demo">Github地址</a>  </p>
]]></content>
      <categories>
        <category>LearnSwagger</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>文档</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>今天我换了一台新电脑</title>
    <url>/2021/01/13/i-get-a-new-computer-today/</url>
    <content><![CDATA[<p>今天换了一台新电脑，替代我那用了六年之久的Dell灵越笔记本电脑。  </p>
<p>最新的intel CPU+512G固态硬盘+16G内存+4G独显，外加价位合适，所以立马入手。  </p>
<p>另外宏碁的标志acer，让我想起大学参加竞赛时候ac一道道题目的感觉，ac+er也更好合适，工程师的工作不就是ac一个接一个的问题吗？  </p>
<p>所以后期打算如何规划呢？  </p>
<ul>
<li><p>安装Visual Studio，把图形学搞一下，正好有个关于DirectX的项目顺便做了；  </p>
</li>
<li><p>务实基础，算法、数据结构、网络和操作系统；  </p>
</li>
<li><p>每周尝试在Medium上翻译一篇技术文章；  </p>
</li>
<li><p>准备软考中级网络工程师；  </p>
</li>
<li><p>学习理财，边学习理论边在蚂蚁财富上进行实践；  </p>
</li>
<li><p>开始整理LeetCode、LintCode、牛客网和面试书籍上的题解；  </p>
</li>
<li><p>整理常考面试题；  </p>
</li>
<li><p>坚持锻炼，早睡早起。</p>
</li>
</ul>
<p>GOOD LUCK ^_^  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>电脑</tag>
        <tag>换新</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA配置Maven</title>
    <url>/2024/01/15/idea-setting-maven/</url>
    <content><![CDATA[<h1 id="Maven设置"><a href="#Maven设置" class="headerlink" title="Maven设置"></a>Maven设置</h1><p><a href="https://maven.apache.org/download.cgi?.">官方下载Maven</a>  </p>
<p>IDEA配置Maven<br><img src="/2024/01/15/idea-setting-maven/maven%E9%85%8D%E7%BD%AE.png">  </p>
<p><code>setting.xml</code>中配置阿里云公共仓库镜像<br><img src="/2024/01/15/idea-setting-maven/aliyun.png">  </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/361418923">Maven：超详细的mac下环境配置以及优化（安装、配置、更新mirrors为阿里云镜像、新建本地仓库，IDEA使用Maven）</a>  </li>
<li><a href="https://help.aliyun.com/document_detail/102512.html?spm=a2c40.aliyun_maven_repo.0.0.36183054eGk3vS">阿里云公共代理库</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnIDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>吊车尾</title>
    <url>/2019/05/23/in-the-end/</url>
    <content><![CDATA[<p>这一周感觉过得好慢，也许是我太压抑了的缘故吧。  </p>
<p>周一，让我做一个新需求，周二，又增加了一个新需求，让我抓紧时间，五月底要上线，然而我周二下午发现这个需求有问题，周三又讨论了一上午定下来要修改的部分。然而就在今天，又说这些不重要了，先把另外一个新需求做了。  </p>
<p>好吧，我认了，毕竟是拿人钱财，替人干活。你说干嘛我干嘛。  </p>
<p>然而，新需求是在老项目的一个逻辑上做的，而我对这块业务不熟悉，于是请教，接着受打击，这已经成为我工作的家常便饭了。  </p>
<p>晚上回家，突然想看火影，看李使用八门遁甲开了五门虐我爱罗最终获得凯老师的认可，看鸣人中忍考试最终用实力证明给宁次看我不是吊车尾，看迈特凯开了死门虐拥有六道能力的斑。  </p>
<p>他们都在坚持不懈的贯彻自己的忍道。  </p>
<p>那我在编程上的忍道又是什么呢？  </p>
<p>我喜欢钻研新东西，喜欢用自己的方式去创新，然而我现在经验不足，只能通过大佬的源代码窥探其中工程设计的奥妙。  </p>
<p>我能力不足，但又不肯认输；我进步缓慢，原来，突然发现自己真的是一无是处，放佛成了部门的吊车尾。  </p>
<p>今天我不知道在内心深处有多少次想过放弃，但我实在不甘心，不跨过这个坎，我怎么成长？！  </p>
<p>只能在深夜再给自己打气，让自己挺住，毕竟，在那些大佬看来，这真的是一件微不足道的挫折罢了。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年，我们一起追逐的时光</title>
    <url>/2014/09/02/in-those-years-the-time-we-chased-together/</url>
    <content><![CDATA[<p>在高考的那两天中，我是怀着兴奋的心情度过的，因为，我终于可以从缺氧的书堆与卷子堆中挣脱出来，我以为只要离开了高三这个地狱时期，我就可以没日没夜地狂玩电脑，或是精神抖擞地到处旅游，亦或是和朋友出来疯玩……可是，直到有一天早上醒来一看表是10点了，我瞬间从梦中惊醒，然后暗叫一声“糟了，要迟到了”。但又一想我已经毕业了，顿时，一种迷茫的失落感油然而生。  </p>
<p>是啊！我已经毕业了。动能定理已经与我无缘，圆锥曲线我早已甩的远远的，看着成堆的卷子进入垃圾箱，就像我亲手把它们葬送在坟墓中一样痛快！可是，我很想念那些时光，那些我们一起追逐的时光……  </p>
<p>那些年，我们在学校过着看老师唾沫横飞的讲课，做做笔记，写写作业的生活。没有所谓的经济负担，于是总是挑着食堂饭菜的毛病，比较着哪家饭馆的拌面和盖饭比较好吃。有时候我还会给周围的人讲我自创的幻想+搞笑的短篇小说《我与高考命题组专家的故事》。常常令我的听众们差一点把嘴里的饭喷到了饭桌上；又或者在回学校的路上思考着加面与创业的外在联系与内在本质……  </p>
<p>总之，感谢在我的高中生涯中能遇到虽然不是高考状元，但又个性十足的你们。使我能用这黑白双色的眼睛，去欣赏这五彩斑斓的世界。  </p>
<p>我曾经堕入无边黑暗想挣扎无法自拔；我曾经拥有者一切转眼都飘散如烟；我曾经失落失望失掉所有的方向……  </p>
<p>谢谢你们，爱过我的每一个人。在我的梦想遭受接二连三的打击时，是你们，一起陪我挣脱束缚。有时候，我会绝望地躲开，是你们，让我坚强地直面惨淡的结果，因为，当我置身于无边的黑暗的林荫小道时，只有勇敢并持续地行走，才能在拐角处见到阳光。  </p>
<p>谢谢你们，让我的每一小步越跨越大，我会不停地向前走，离幸福越来越近。  </p>
<p>人生就像一场轮回，在你不断遭受打击即将灭亡之际，也是你的生命即将涅槃之时。  </p>
<p>今天，我的老茧将化为尘埃，我在人群中昂首阔步，不会有人认出我来，因为我不再是过去的自己，我已拥有新的生命！  </p>
<p>（写以此文，纪念那段时光，那段帮助我、鼓励我的人，毕业在即，遥望明月，真心祝愿你们：平安、幸福）</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>高考</tag>
        <tag>毕业</tag>
        <tag>再见</tag>
        <tag>快乐</tag>
        <tag>时光</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入www.baidu.com为什么能渲染出百度页面</title>
    <url>/2020/04/17/interview-enter-www-baidu-com-why-can-render-baidu-page/</url>
    <content><![CDATA[<p>注：此问题涉及计算机网络的深度和广度，内容较多，本文将陆续将相关信息整理出来。  </p>
<p>有好的资源或回答欢迎留言。  </p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>主要分两部分，网络通信和页面渲染。  </p>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><h4 id="1，在浏览器中输入www-baidu-com"><a href="#1，在浏览器中输入www-baidu-com" class="headerlink" title="1，在浏览器中输入www.baidu.com"></a>1，在浏览器中输入<a href="http://www.baidu.com/">www.baidu.com</a></h4><h4 id="2，应用层DNS解析域名"><a href="#2，应用层DNS解析域名" class="headerlink" title="2，应用层DNS解析域名"></a>2，应用层DNS解析域名</h4><h4 id="3，应用层客户端发送HTTP请求"><a href="#3，应用层客户端发送HTTP请求" class="headerlink" title="3，应用层客户端发送HTTP请求"></a>3，应用层客户端发送HTTP请求</h4><h4 id="4，传输层TCP传输报文"><a href="#4，传输层TCP传输报文" class="headerlink" title="4，传输层TCP传输报文"></a>4，传输层TCP传输报文</h4><h4 id="5，网络层IP协议查询MAC地址"><a href="#5，网络层IP协议查询MAC地址" class="headerlink" title="5，网络层IP协议查询MAC地址"></a>5，网络层IP协议查询MAC地址</h4><h4 id="6，数据到达数据链路层"><a href="#6，数据到达数据链路层" class="headerlink" title="6，数据到达数据链路层"></a>6，数据到达数据链路层</h4><h4 id="7，服务器接收数据"><a href="#7，服务器接收数据" class="headerlink" title="7，服务器接收数据"></a>7，服务器接收数据</h4><h4 id="8，服务器响应请求"><a href="#8，服务器响应请求" class="headerlink" title="8，服务器响应请求"></a>8，服务器响应请求</h4><h4 id="9，服务器返回相应文件"><a href="#9，服务器返回相应文件" class="headerlink" title="9，服务器返回相应文件"></a>9，服务器返回相应文件</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/jeffleo/article/details/77151646">从输入URL到浏览器显示页面发生了什么</a>  </li>
<li><a href="https://blog.csdn.net/qq_16681169/article/details/50866290">在浏览器中输入www.baidu.com后执行的全部过程</a>  </li>
<li><a href="https://blog.csdn.net/yaotengjian/article/details/80457774">【网络】 输入www.baidu.com后的过程详解</a>  </li>
<li>《网络是怎样连接的》  </li>
<li><a href="https://segmentfault.com/a/1190000002611809">从输入 URL 到页面加载完成发生了什么事</a>  </li>
<li><a href="https://div.io/topic/457">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a>  </li>
<li><a href="https://www.cnblogs.com/xianyulaodi/p/6547807.html">【原】老生常谈-从输入url到页面展示到底发生了什么</a></li>
</ul>
]]></content>
      <categories>
        <category>Interview-QA</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中Slice和Array有何不同</title>
    <url>/2020/04/17/interview-golang-slice-and-array-difference/</url>
    <content><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="《Go-Program-Language》定义"><a href="#《Go-Program-Language》定义" class="headerlink" title="《Go Program Language》定义"></a>《Go Program Language》定义</h3><p>数组是一个由固定长度的特定类型元素组成的序列， 一个数组可以由零个或多个元素组成。<br>因为数组的长度是固定的， 因此在Go语言中<strong>很少直接使用数组</strong>。  </p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul>
<li>默认情况下， 数组的每个元素都被初始化为元素类型对应的零值， 对于数字类型来说就是0。</li>
</ul>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><h3 id="《Go-program-language》定义"><a href="#《Go-program-language》定义" class="headerlink" title="《Go program language》定义"></a>《Go program language》定义</h3><p>Slice（ 切片） 代表变长的序列， 序列中每个元素都有相同的类型。 一个slice类型一般写作[]T， 其中T代表slice中元素的类型； slice的语法和数组很像， 只是没有固定长度而已。  </p>
<h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ul>
<li>内置的append函数用于向slice追加元素。<br>（注意：append函数对于理解slice底层是如何工作的非常重要，此问题后面再详细阐述。）</li>
</ul>
<h2 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h2><h3 id="Go-program-language》"><a href="#Go-program-language》" class="headerlink" title="Go program language》"></a>Go program language》</h3><p>数组和slice之间有着紧密的联系。<br>一个slice是一个轻量级的数据结构， 提供了访问数组子序列（ 或者全部） 元素的功能， 而且slice的底层确实引用一个数组对象。 一个slice由三个部分构成： <strong>指针、 长度和容量</strong>。 指针指向第一个slice元素对应的底层数组元素的地址， 要注意的是slice的第一个元素并不一定就是数组的第一个元素。 长度对应slice中元素的数目； 长度不能超过容量， 容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。  </p>
<h2 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h2><ul>
<li>平时开发中对<code>Slice</code>用的较多，因为<code>Slice</code>可以自动扩容；  </li>
<li>slice由三个部分构成： <strong>指针、 长度和容量</strong>。  </li>
<li>array由两个部分构成： <strong>指针、长度</strong>。  </li>
<li>内置的append函数是针对<code>slice</code>操作的。  </li>
<li><code>slice</code>需要用内置的<code>make</code>函数创建。</li>
</ul>
]]></content>
      <categories>
        <category>Interview-QA</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>切片</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个秒杀系统</title>
    <url>/2021/07/18/interview-seckill-system-design/</url>
    <content><![CDATA[<h1 id="秒杀系统架构设计都有哪些关键点"><a href="#秒杀系统架构设计都有哪些关键点" class="headerlink" title="秒杀系统架构设计都有哪些关键点"></a>秒杀系统架构设计都有哪些关键点</h1><p><strong>秒杀其实主要解决两个问题，一个是并发读，一个是并发写。</strong>  </p>
<p>秒杀的整体架构可以概括为“稳、准、快”几个关键字。  </p>
<p>所谓“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。  </p>
<p>所谓“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。  </p>
<p>所谓“快”，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。  </p>
<h1 id="设计秒杀系统时应该注意的5个架构原则"><a href="#设计秒杀系统时应该注意的5个架构原则" class="headerlink" title="设计秒杀系统时应该注意的5个架构原则"></a>设计秒杀系统时应该注意的5个架构原则</h1><p><strong>秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统。</strong>  </p>
<h2 id="架构原则1-数据要尽量少"><a href="#架构原则1-数据要尽量少" class="headerlink" title="架构原则1. 数据要尽量少"></a>架构原则1. 数据要尽量少</h2><p>所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。  </p>
<h3 id="为什么“数据要尽量少”呢？"><a href="#为什么“数据要尽量少”呢？" class="headerlink" title="为什么“数据要尽量少”呢？"></a>为什么“数据要尽量少”呢？</h3><p>因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。  </p>
<p>其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是 CPU 的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单、越小则越好。  </p>
<h2 id="架构原则2-请求数要尽量少"><a href="#架构原则2-请求数要尽量少" class="headerlink" title="架构原则2. 请求数要尽量少"></a>架构原则2. 请求数要尽量少</h2><p>用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS&#x2F;JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。  </p>
<h2 id="架构原则3-路径要尽量短"><a href="#架构原则3-路径要尽量短" class="headerlink" title="架构原则3. 路径要尽量短"></a>架构原则3. 路径要尽量短</h2><p>所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。  </p>
<p>通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。  </p>
<p>然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，假如一次请求经过 5个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。  </p>
<p>所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时)。  </p>
<h2 id="架构原则4-依赖要尽量少"><a href="#架构原则4-依赖要尽量少" class="headerlink" title="架构原则4. 依赖要尽量少"></a>架构原则4. 依赖要尽量少</h2><p>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。  </p>
<p>举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。  </p>
<p>要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。  </p>
<h2 id="架构原则5-不要有单点"><a href="#架构原则5-不要有单点" class="headerlink" title="架构原则5. 不要有单点"></a>架构原则5. 不要有单点</h2><p>系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。  </p>
<p>那如何避免单点呢？我认为关键点是避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。  </p>
<p>如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。  </p>
<p>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。  </p>
<h1 id="如何才能做好动静分离？有哪些方案可选？"><a href="#如何才能做好动静分离？有哪些方案可选？" class="headerlink" title="如何才能做好动静分离？有哪些方案可选？"></a>如何才能做好动静分离？有哪些方案可选？</h1><h2 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h2><p><strong>动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据。</strong>  </p>
<h3 id="怎样对静态数据做缓存"><a href="#怎样对静态数据做缓存" class="headerlink" title="怎样对静态数据做缓存"></a>怎样对静态数据做缓存</h3><ul>
<li>第一，你应该把静态数据缓存到离用户最近的地方。  </li>
<li>第二，静态化改造就是要直接缓存 HTTP 连接。  </li>
<li>第三，让谁来缓存静态数据也很重要。</li>
</ul>
<h2 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h2><ul>
<li><ol>
<li>URL 唯一化。</li>
</ol>
</li>
<li><ol start="2">
<li>分离浏览者相关的因素。</li>
</ol>
</li>
<li><ol start="3">
<li>分离时间因素。</li>
</ol>
</li>
<li><ol start="4">
<li>异步化地域因素。</li>
</ol>
</li>
<li><ol start="5">
<li>去掉 Cookie。</li>
</ol>
</li>
</ul>
<h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><h3 id="方案-1：实体机单机部署"><a href="#方案-1：实体机单机部署" class="headerlink" title="方案 1：实体机单机部署"></a>方案 1：实体机单机部署</h3><h3 id="方案-2：统一-Cache-层"><a href="#方案-2：统一-Cache-层" class="headerlink" title="方案 2：统一 Cache 层"></a>方案 2：统一 Cache 层</h3><h3 id="方案-3：上-CDN"><a href="#方案-3：上-CDN" class="headerlink" title="方案 3：上 CDN"></a>方案 3：上 CDN</h3><h1 id="二八原则：有针对性地处理好系统的“热点数据”"><a href="#二八原则：有针对性地处理好系统的“热点数据”" class="headerlink" title="二八原则：有针对性地处理好系统的“热点数据”"></a>二八原则：有针对性地处理好系统的“热点数据”</h1><h2 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h2><p>首先，热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占 90% 的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费。  </p>
<p>其次，即使这些热点是有效的请求，我们也要识别出来做针对性的优化，从而用更低的代价来支撑这些热点请求。  </p>
<h2 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h2><p>热点分为热点操作和热点数据。  </p>
<p>所谓“热点操作”，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单等都属于此类操作。对系统来说，这些操作可以抽象为“读请求”和“写请求”，这两种热点请求的处理方式大相径庭，读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化的思路就是根据 CAP 理论做平衡。  </p>
<p>而“热点数据”就是用户的热点请求对应的数据。而热点数据又分为“静态热点数据”和“动态热点数据”。  </p>
<ul>
<li><p>所谓“静态热点数据”，就是能够提前预测的热点数据。例如，我们可以通过卖家报名的方式提前筛选出来，通过报名系统对这些热点商品进行打标。另外，我们还可以通过大数据分析来提前发现热点商品，比如我们分析历史成交记录、用户的购物车记录，来发现哪些商品可能更热门、更好卖，这些都是可以提前分析出来的热点。  </p>
</li>
<li><p>所谓“动态热点数据”，就是不能被提前预测到的，系统在运行过程中临时产生的热点。例如，卖家在抖音上做了广告，然后商品一下就火了，导致它在短时间内被大量购买。</p>
</li>
</ul>
<h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><p>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离。  </p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化热点数据最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用LRU 淘汰算法替换。  </p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。  </p>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让 1%的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化。  </p>
<p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离。  </p>
<ul>
<li><ol>
<li>业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。</li>
</ol>
</li>
<li><ol start="2">
<li>系统隔离。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li>
</ol>
</li>
<li><ol start="3">
<li>数据隔离。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。</li>
</ol>
</li>
</ul>
<h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h2><p>削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。针对秒杀这一场景，削峰从本质上来说就是更多地延缓用户请求的发出，以便减少和过滤掉一些无效请求，它遵从“请求数要尽量少”的原则。  </p>
<p>流量削峰的一些操作思路：排队、答题、分层过滤，这三个都是无损（即不会损失用户的发出请求）的实现方案。  </p>
<h2 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h2><p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样， 拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。  </p>
<p>用消息队列来缓冲瞬时流量的方案，如下图所示：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9D%A5%E7%BC%93%E5%86%B2%E7%9E%AC%E6%97%B6%E6%B5%81%E9%87%8F.png">  </p>
<p>但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。  </p>
<p>除了消息队列，类似的排队方式还有很多，例如：  </p>
<ol>
<li>利用线程池加锁等待也是一种常用的排队方式；  </li>
<li>先进先出、先进后出等常用的内存排队算法的实现方式；  </li>
<li>把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</li>
</ol>
<h2 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h2><p>主要是为了增加购买的复杂度，从而达到两个目的:<br>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。<br>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。  </p>
<p>秒杀答题的设计思路：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E7%A7%92%E6%9D%80%E7%AD%94%E9%A2%98.png">  </p>
<p>如上图所示，整个秒杀答题的逻辑主要分为 3 部分：  </p>
<ul>
<li><ol>
<li>题库生成模块，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。</li>
</ol>
</li>
<li><ol start="2">
<li>题库的推送模块，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。</li>
</ol>
</li>
<li><ol start="3">
<li>题目的图片生成模块，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到 CDN 上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。</li>
</ol>
</li>
</ul>
<p>真正答题的逻辑比较简单，可以理解为：<strong>当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的key 来进行 MD5 加密</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题 key：userId+itemId+question_Id+time+PK</span><br><span class="line">答案 key：userId+itemId+answer+PK</span><br></pre></td></tr></table></figure>

<p>验证的逻辑如下图所示：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E7%AD%94%E9%A2%98%E7%9A%84%E9%AA%8C%E8%AF%81%E9%80%BB%E8%BE%91.png">  </p>
<p>注意，这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的Cookie 是否完整、用户是否重复频繁提交等。  </p>
<p>除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过 1s，因为小于 1s 是人为操作的可能性很小，这样也能防止机器答题的情况。  </p>
<h2 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h2><p>分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E5%88%86%E5%B1%82%E8%BF%87%E6%BB%A4.png">  </p>
<p>假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：  </p>
<ul>
<li>大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；  </li>
<li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；  </li>
<li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；  </li>
<li>最后在数据层完成数据的强一致性校验。</li>
</ul>
<p>分层过滤的核心思想是：<strong>在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求。</strong>  </p>
<p>分层校验的基本原则是：  </p>
<ul>
<li><ol>
<li>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；</li>
</ol>
</li>
<li><ol start="2">
<li>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；</li>
</ol>
</li>
<li><ol start="3">
<li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求；</li>
</ol>
</li>
<li><ol start="4">
<li>对写请求做限流保护，将超出系统承载能力的请求过滤掉；</li>
</ol>
</li>
<li><ol start="5">
<li>对写数据进行强一致性校验，只保留最后有效的数据。</li>
</ol>
</li>
</ul>
<p>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。  </p>
<h1 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><h3 id="响应时间和-QPS"><a href="#响应时间和-QPS" class="headerlink" title="响应时间和 QPS"></a>响应时间和 QPS</h3><p>对于大部分的 Web 系统而言，响应时间一般都是由 CPU 执行时间和线程等待时间（比如RPC、IO 等待、Sleep、Wait 等）组成，即服务器在处理一个请求时，一部分是 CPU 本身在做运算，还有一部分是在各种等待。  </p>
<h3 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h3><p>线程数 &#x3D; [(线程等待时间 + 线程 CPU 时间) &#x2F; 线程 CPU 时间] × CPU 数量  </p>
<p>所以：要提升性能我们就要减少 CPU 的执行时间，另外就是要设置一个合理的并发线程数，通过这两方面来显著提升服务器的性能。  </p>
<h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><p>我们定位的场景是秒杀，它的瓶颈更多地发生在 CPU 上。  </p>
<p>那么，如何发现 CPU 的瓶颈呢？其实有很多 CPU 诊断工具可以发现 CPU 的消耗，最常用的就是 JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间，可以发现哪个函数消耗的 CPU 时间最多，以便你有针对性地做优化。  </p>
<h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><h3 id="减少编码"><a href="#减少编码" class="headerlink" title="减少编码"></a>减少编码</h3><p>Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I&#x2F;O 操作）都比较耗 CPU 资源，不管它是磁盘 I&#x2F;O 还是网络 I&#x2F;O，因为都需要将字符转换成字节，而这个转换必须编码。  </p>
<p>每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。  </p>
<p>那么如何才能减少编码呢？<br>例如，网页输出是可以直接进行流输出的，即用resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。  </p>
<h3 id="减少序列化"><a href="#减少序列化" class="headerlink" title="减少序列化"></a>减少序列化</h3><p>序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。  </p>
<p>序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。  </p>
<p>所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个 Tomcat 容器中，且不能走本机的 Socket，这样才能避免序列化的产生。  </p>
<h3 id="Java-极致优化"><a href="#Java-极致优化" class="headerlink" title="Java 极致优化"></a>Java 极致优化</h3><p>Java 和通用的 Web 服务器（如 Nginx 或 Apache 服务器）相比，在处理大并发的 HTTP请求时要弱一点，所以一般我们都会对大流量的 Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化），而 Java 层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：  </p>
<ul>
<li><p>直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。  </p>
</li>
<li><p>直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。</p>
</li>
</ul>
<h3 id="并发读优化"><a href="#并发读优化" class="headerlink" title="并发读优化"></a>并发读优化</h3><p>如何彻底解决单点的瓶颈：<br>答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。  </p>
<p>那么，又如何缓存（Cache）数据呢？你需要划分成动态数据和静态数据分别进行处理：  </p>
<ul>
<li>像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；  </li>
<li>像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</li>
</ul>
<p>疑惑：像库存这种频繁更新的数据，一旦数据不一致，会不会导致超卖？<br>这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。  </p>
<h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><p>在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。  </p>
<p>那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：  </p>
<ul>
<li><p>下单减库存，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。  </p>
</li>
<li><p>付款减库存，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。  </p>
</li>
<li><p>预扣库存，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p>
</li>
</ul>
<h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><h2 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h2><p>目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。  </p>
<p>由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。  </p>
<p>下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的SQL 语句：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> item <span class="keyword">SET</span> inventory <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> inventory <span class="operator">&gt;=</span> xxx <span class="keyword">THEN</span></span><br><span class="line">inventory<span class="operator">-</span>xxx <span class="keyword">ELSE</span> inventory <span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><p>由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（TransactionPer Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。  </p>
<p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。  </p>
<p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：  </p>
<ul>
<li><p>应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。  </p>
</li>
<li><p>数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</p>
</li>
</ul>
<p>疑惑：排队和锁竞争不都是要等待吗，有啥区别？  </p>
<p>MySQL中，InnoDB 内部的死锁检测，以及 MySQL Server 和InnoDB 的切换会比较消耗性能。<br>淘宝的 MySQL 核心团队还做了很多其他方面的优化，如COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，配合在 SQL 里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条 SQL后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，可以减少网络等待时间（平均约 0.7ms）。  </p>
<p>另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了，以便减少对数据库的更新操作。  </p>
<h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案?"></a>准备Plan B：如何设计兜底方案?</h1><h2 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h2><p>说到系统的高可用建设，它其实是一个系统工程，需要考虑到系统建设的各个阶段，也就是说它其实贯穿了系统建设的整个生命周期：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%BB%BA%E8%AE%BE.png">  </p>
<ol>
<li><p>架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。  </p>
</li>
<li><p>编码阶段：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。  </p>
</li>
<li><p>测试阶段：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。  </p>
</li>
<li><p>发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。  </p>
</li>
<li><p>运行阶段：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。  </p>
</li>
<li><p>故障发生：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</p>
</li>
</ol>
<p>为什么系统的高可用建设要放到整个生命周期中全面考虑？<br>因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。例如在架构阶段，你没有消除单点问题，那么系统上线后，遇到突发流量把单点给挂了，你就只能干瞪眼，有时候想加机器都加不进去。所以高可用建设是一个系统工程，必须在每个环节都做好。  </p>
<p>那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。  </p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。  </p>
<p>降级方案可以这样设计：当秒杀流量达到 5w&#x2F;s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E5%BC%80%E5%85%B3%E7%B3%BB%E7%BB%9F.png">  </p>
<p>执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双 11 零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。  </p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。  </p>
<p>总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于QPS 和线程的限流  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E9%99%90%E6%B5%81%E7%B3%BB%E7%BB%9F.png">  </p>
<ul>
<li><p>客户端限流，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。  </p>
</li>
<li><p>服务端限流，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p>
</li>
</ul>
<p>在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。  </p>
<p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。  </p>
<h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p>如果限流还不能解决问题，最后一招就是直接拒绝服务了。  </p>
<p>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：  </p>
<ul>
<li>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝  </li>
<li>HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</li>
</ul>
<p>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。  </p>
<h1 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h1><h2 id="应用层用队列接受请求，然后结果怎么返回？"><a href="#应用层用队列接受请求，然后结果怎么返回？" class="headerlink" title="应用层用队列接受请求，然后结果怎么返回？"></a>应用层用队列接受请求，然后结果怎么返回？</h2><h2 id="静态化的方案中关于-Hash-分组的问题"><a href="#静态化的方案中关于-Hash-分组的问题" class="headerlink" title="静态化的方案中关于 Hash 分组的问题"></a>静态化的方案中关于 Hash 分组的问题</h2><h2 id="如何才能做好动静分离？有哪些方案可选？以及关于-Cache-失效的问题"><a href="#如何才能做好动静分离？有哪些方案可选？以及关于-Cache-失效的问题" class="headerlink" title="如何才能做好动静分离？有哪些方案可选？以及关于 Cache 失效的问题"></a>如何才能做好动静分离？有哪些方案可选？以及关于 Cache 失效的问题</h2><p>首先，咱们要有个共识，有 Cache 的地方就必然存在失效问题。为啥要失效？因为要保证<br>数据的一致性。所以要用到 Cache 必然会问如何保证 Cache 和 DB 的数据一致性，如果<br>Cache 有分组的话，还要保证一个分组中多个实例之间数据的一致性，就像保证 MySQL<br>的主从一致一样。</p>
<p>其实，失效有主动失效和被动失效两种方式。  </p>
<p>被动失效，主要处理如模板变更和一些对时效性不太敏感数据的失效，采用设置一定时间长度（如只缓存 3 秒钟）这种自动失效的方式。当然，你也要开发一个后台管理界面，以便能够在紧急情况下手工失效某些 Cache。  </p>
<p>主动失效，一般有 Cache 失效中心监控数据库表变化发送失效请求、系统发布也需要清空 Cache 数据等几种场景。其中失效中心承担了主要的失效功能，这个失效中心的逻辑图如下：  </p>
<p><img src="/2021/07/18/interview-seckill-system-design/%E5%A4%B1%E6%95%88%E4%B8%AD%E5%BF%83.png">  </p>
<p>失效中心会监控关键数据表的变更（有个中间件来解析 MySQL 的 binglog，然后发现有Insert、Update、Delete 等操作时，会把变更前的数据以及要变更的数据转成一个消息发送给订阅方），通过这种方式来发送失效请求给 Cache，从而清除 Cache 数据。如果这种失效有失效中心将失效请求发送给每个 CDN 节点上的 Console 机，然后 Console 机来发送失效请求给每台 Cache 机器。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2021/07/18/interview-seckill-system-design/sum.jpg">  </p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p><strong>将请求拦截在系统上游，降低下游压力</strong>：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。  </p>
<p><strong>充分利用缓存：利用缓存可极大提高系统读写速度。</strong>  </p>
<p><strong>消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程</strong>，后台业务根据处理能力，从消息队列中主动的拉取请求消息进行业务处理。  </p>
<h2 id="前端方案"><a href="#前端方案" class="headerlink" title="前端方案"></a>前端方案</h2><p>浏览器端(js)：<br>页面静态化：将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。<br>禁止重复提交：用户提交之后按钮置灰，禁止重复提交<br>用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流  </p>
<h2 id="后端方案"><a href="#后端方案" class="headerlink" title="后端方案"></a>后端方案</h2><h3 id="服务端控制器层-网关层"><a href="#服务端控制器层-网关层" class="headerlink" title="服务端控制器层(网关层)"></a>服务端控制器层(网关层)</h3><p>限制uid（UserID）访问频率：我们上面拦截了浏览器访问的请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问uid，限制访问频率。  </p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有100W用户同时抢100台手机，服务层并发请求压力至少为100W。  </p>
<p>采用消息队列缓存请求：既然服务层知道库存只有100台手机，那完全没有必要把100W个请求都传递到数据库啊，那么可以先把这些请求都写到消息队列缓存一下，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。</p>
<p>利用缓存应对读请求：对类似于12306等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力。  </p>
<p>利用缓存应对写请求：缓存也是可以应对写请求的，比如我们就可以把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。  </p>
<h3 id="数据库层"><a href="#数据库层" class="headerlink" title="数据库层"></a>数据库层</h3><p>数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。  </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/54895548/answer/1352510403">知乎_如何设计秒杀系统？</a><br><a href="https://www.bilibili.com/video/BV1DV411B7Jq">B站_淘宝秒杀系统怎么设计？</a><br><a href="https://zhuanlan.zhihu.com/p/86017321">这是我读过写得最好的【秒杀系统架构】分析与实战！</a><br><a href="https://github.com/tyjwan/second-kill-system/blob/main/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.md">github文档_tyjwan_设计一个秒杀系统</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwODkzOTc1MQ==&mid=2247483938&idx=1&sn=05c11475c9da399cec711c05782e917f&chksm=977a3daaa00db4bcd7c5d27064bee7fb1f6795b87ef84e7ae198fa4206a85ba17cf1c05a24c5&token=904636431&lang=zh_CN&scene=21#wechat_redirect">千万级 高并发 “秒杀” 架构设计（含源码）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247489300&idx=1&sn=27788b31b4b89146a6dd971bc23238d0&chksm=9bd0ba8caca7339ad915c461399369bd54aa846a6e67ca99e1100f1cf77b1dc000d700ec67dd&scene=21#wechat_redirect">秒杀架构模型设计</a><br><a href="https://zhuanlan.zhihu.com/p/92307325">知乎_《进大厂系列》系列-秒杀系统设计</a><br><a href="https://zhuanlan.zhihu.com/p/92228390">请设计一个秒杀系统</a></p>
]]></content>
      <categories>
        <category>System-Design</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>秒杀系统</tag>
      </tags>
  </entry>
  <entry>
    <title>场景题_从A服务获取用户id，从B服务获取用户信息</title>
    <url>/2020/04/16/interview-use-A-get-userid-and-use-B-get-userinfo/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有这样一个场景，需要你从A服务中获取多个用户id，然后根据用户id请求B服务获取用户信息，如何用<code>Golang</code>的<code>channel</code>和协程来实现？  </p>
<h2 id="问题思考和实现"><a href="#问题思考和实现" class="headerlink" title="问题思考和实现"></a>问题思考和实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>由于从A服务中获取的是一个数组形式的用户id，所以我可以考虑从A服务获取用户id后，再用<code>for range</code>循环遍历每一个用户id，给每个用户建立一个通道，开个协程请求B服务获取用户信息，再通过通道传回来。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，请求A服务获取用户id</span></span><br><span class="line">userids := GetAserver()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，请求B服务获取用户信息</span></span><br><span class="line"><span class="keyword">for</span> _,userid := <span class="keyword">range</span> userids &#123;</span><br><span class="line">    userid_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line">    <span class="keyword">go</span> GetBserver(userid_chan,userid)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> info := &lt;- userid_chan:</span><br><span class="line">                <span class="keyword">return</span> info</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul>
<li>每个用户新建一个<code>channel</code>，很浪费  </li>
<li>数据量大了，这样做很不好</li>
</ul>
<h3 id="方法二-待完善"><a href="#方法二-待完善" class="headerlink" title="方法二(待完善)"></a>方法二(待完善)</h3><p>建立2个<code>channel</code>和2个协程 一个协程用来获取用户id数组g1，一个协程服务负责请求B服务获取用户信息g2, g1通过<code>channel</code>给g2，然后g2将请求到的用户信息再通过<code>channel</code>反馈回去。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g1()</span><br><span class="line"><span class="keyword">go</span> g2()</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//g1通过`channel`给g2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三-待完善"><a href="#方法三-待完善" class="headerlink" title="方法三(待完善)"></a>方法三(待完善)</h3><p><strong>核心思路是，A服务的携程不能阻塞，尽量并发等待B的数据。</strong><br>A要新建一个go用来接收B发过来的数据，A的ID可以直接用chan发送到B，B用一个单独的chan一次一个的方式发送结构体到新建的go，新建的go可以打包发给A，或者直接转发给A，所有数据接收完成后，新建的go退出；<br>ID可以一次批量发送，结构体可以用chan，一次一个的处理，也可以打包批次处理，这个可以看需求。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br></pre></td></tr></table></figure>

<h2 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h2><ul>
<li>这个问题的核心是：你如何才能并发处理异步请求，特别是大当量数据的情况。  </li>
<li>并发考虑做个消息队列。</li>
</ul>
<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>特别感谢<code>Go项目实战</code>群里的三位大佬提供的思路：@star,@J,@钢之镇魂曲</p>
]]></content>
      <categories>
        <category>Interview-QA</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>服务</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业16个月的面经整理以及思考</title>
    <url>/2019/10/21/interview-think-and-life/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在写这篇文章之前，先简单介绍要自己的情况。  </p>
<p>2018年6月计算机专业本科毕业，放弃了学校的校招，只身前往成都市求职。  </p>
<p>在经历了两周的投简历，经历了笔试，面试，被培训机构忽悠，外包公司等，最终入职了一家上市游戏公司，三个月后辞职去了一家互联网公司做图形图像视音频算法，本文将记录我毕业工作这16个月的感悟和经验。  </p>
<p>注：以下将以采访的形式分享自己的观点。  </p>
<h2 id="为什么会选择放弃校招？"><a href="#为什么会选择放弃校招？" class="headerlink" title="为什么会选择放弃校招？"></a>为什么会选择放弃校招？</h2><p>因为我是在新疆上的大学，而我认为那里的互联网还是有些落后，技术这东西更新迭代非常快，之前也在学校面过海康威视的技术支持和一家央企的<code>Java</code>开发，虽然个人感觉难度不大(只要不挂科，毕业拿到双证，户口在新疆，笔试面试这些很水)，但我最终还是选择放弃并在毕业时坐飞机来成都。  </p>
<h2 id="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"><a href="#第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？" class="headerlink" title="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"></a>第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？</h2><p>先说下内心的感受，刚开始我父母是不同意我去一座陌生的城市的，觉得待在乌鲁木齐也挺好的啊，后来我和他们耐心沟通后，并承诺待不下去就回来，他们才放过。  </p>
<p>一个人刚来成都时，借宿在朋友家，她白天上班，我就在拉勾、智联招聘、<code>Boss</code>直聘上不断地投简历，只要是和我大学学的东西稍微沾边的。过了段时间，电话就打来了，基本上是确认本人在成都市，顺利毕业拿到双证的就安排面试，于是，我开始了我社招的正式面试：  </p>
<ul>
<li><p>第一家是游戏公司<code>Unity</code>岗，在我刚准备第二天去该公司面试时，负责人在微信上说了句：我们公司是包培训的，培训半年包就业，月薪在<code>xx-yy</code>k以上，于是我断定这是一家游戏公司，放弃；  </p>
</li>
<li><p>第二家是一家北京做人工智能的公司找人工智能实习生，开头带个“欣”字，结果过去之后大门口一张闪闪发光的优秀培训机构映入眼帘，接着我被叫去一个小房间，开始给我讲<code>python</code>多么多么好，你看那些川大电科研究生毕业都找不到工作还不是来我这培训(不好意思，请不要把小概率事件扩大)，我无动于衷，并拒绝了培训，放弃；  </p>
</li>
<li><p>第三家是外包，说主要接美团，腾讯，华为的外包，加班多但是成长快，但我不想去，原因就不说了，放弃；  </p>
</li>
<li><p>第四家是一家做音乐的公司，招的<code>Java</code>开发，我大学总共写的<code>Java</code>不超过20行，于是硬着头皮去面试，数据结构那些答的还好，被问到<code>Java</code>虚拟机我主动要求停止面试，放弃；  </p>
</li>
<li><p>第五家是一家创业游戏公司，先让我做了一些<code>C#</code>笔试题，接着问我能不能接受<code>996</code>和<code>9910</code>加班，我说考虑下，于是也没有了下文；  </p>
</li>
<li><p>第六家是一家上市游戏公司，经历了<code>HR面-技术面-HR面-Boss-面</code>后，顺利拿到<code>offer</code>，面试经验已整理到下面的参考链接中。</p>
</li>
</ul>
<p>列举了这些面试经历后，我只是想阐述当你校招或刚毕业面临社招时，当你已经失去了<code>应届大学毕业生</code>这个保护伞后，你会遇到各式各样的面试，所以请诸位擦亮眼睛，多问几个为什么。  </p>
<h2 id="第一份工作感觉如何，为什么辞职？"><a href="#第一份工作感觉如何，为什么辞职？" class="headerlink" title="第一份工作感觉如何，为什么辞职？"></a>第一份工作感觉如何，为什么辞职？</h2><h3 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h3><p>第一份做游戏研发方面的工作，很兴奋，对研发游戏的每一个步骤都充满了好奇，例如服务端，客户端，策划，美术等。  </p>
<p>大牛很多，给我推荐参考书籍，项目代码质量很高，和在学校写的课设毕设天壤之别。  </p>
<p>活动福利多，比如一些游戏开发大赛，也有幸去厦门参考了一次<code>Game Pith Time</code>。  </p>
<h3 id="So，为什么辞职"><a href="#So，为什么辞职" class="headerlink" title="So，为什么辞职"></a>So，为什么辞职</h3><p>详见参考文章链接<code>离职，新的开始</code>，在此不赘述。  </p>
<h2 id="辞职后做了什么？"><a href="#辞职后做了什么？" class="headerlink" title="辞职后做了什么？"></a>辞职后做了什么？</h2><p>离职后在家躺了三天，然后开始在牛客网上刷题，再投简历，因为之前已经有了一定的工作经验，因此遇到培训机构的概率降低了。之后收到了一家做视音频的发来的面试邀请，约定了面试时间后就去面试，三场面试很快通过拿了<code>offer</code>。  </p>
<h2 id="有什么面试经验想要分享吗？"><a href="#有什么面试经验想要分享吗？" class="headerlink" title="有什么面试经验想要分享吗？"></a>有什么面试经验想要分享吗？</h2><p>面试经验在下面的链接中会详细阐述，在此分享下个人感受  </p>
<ul>
<li><p>1，个人认为开发&#x2F;研发面试时，能力:面试发挥 &#x3D; 7:3，为什么这样说，因为面试是可以突击来的，而能力是突击不来的，即使突击成功，接下来的3-6个月的试用期负责人有足够的时间了解你；  </p>
</li>
<li><p>2，保持好奇，追根究底，务实基础；  </p>
</li>
<li><p>3，可以去听一些师哥师姐的面试经验，如果条件允许最好面对面交谈；  </p>
</li>
<li><p>4，时刻知道自己需要什么，还差什么，如何实现；  </p>
</li>
<li><p>5，建议不要总沉迷技术书籍，适当接触一些哲学，有助于培养自己的思辨能力，因为在当你入职研发岗时，能力又是其次，最重要的是要弄清楚产品的需求。</p>
</li>
</ul>
<h2 id="最后还有想说的吗？"><a href="#最后还有想说的吗？" class="headerlink" title="最后还有想说的吗？"></a>最后还有想说的吗？</h2><p>转眼间已经工作了16个月，其实有时候还会梦见在学校悠哉的生活，5元的饭菜，800&#x2F;一年的宿舍，以及一瓶水，一把椅子，一台电脑坐一天，晚上在操场上慢跑的生活，然后早餐的闹铃又会把这一切打破。  </p>
<p>现在在完成需求的同时，及时利用碎片时间去看一些书籍或视频，在星球里看一看大佬们分享的职场经验，再结合自己的实际情况加以学习利用。  </p>
<p>我们的路还很长，所以如果遇到简历被刷，面试被拒，也不要灰心。  </p>
<p>祝求职顺利！  </p>
<h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><ul>
<li><a href="https://www.jianshu.com/p/df2ea79b027c">心酸，又是一家培训机构</a>  </li>
<li><a href="https://www.ituring.com.cn/article/506666">应届毕业生求职经验分享</a>  </li>
<li><a href="https://www.cnblogs.com/OctoptusLian/p/9157266.html">飞鱼科技游戏开发岗面试经验</a>  </li>
<li><a href="https://www.cnblogs.com/OctoptusLian/p/9634250.html">离职，新的开始</a>  </li>
<li><a href="https://www.cnblogs.com/OctoptusLian/p/9797313.html">华栖云科技图形图像视音频算法岗面试经验</a>  </li>
<li><a href="https://octopuslian.github.io/2019/04/07/about-996-i-want-to-say/">关于996，我想说</a></li>
</ul>
<p>(注意，此文已发布早牛客网上，点击<a href="https://www.nowcoder.com/discuss/321386">链接</a>)  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>生活</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架介绍</title>
    <url>/2022/06/12/introduction-to-gin-framework/</url>
    <content><![CDATA[<h1 id="gin框架介绍"><a href="#gin框架介绍" class="headerlink" title="gin框架介绍"></a>gin框架介绍</h1><p>gin是用go语言开发的一个web框架，简单易用，是一个轻量级框架。  </p>
<h2 id="为什么选择Gin"><a href="#为什么选择Gin" class="headerlink" title="为什么选择Gin"></a>为什么选择Gin</h2><ul>
<li>1.运行响应非常快  </li>
<li>2.快速开发  </li>
<li>3.文档齐全  </li>
<li>4.社区活跃</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>1.快速：基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。  </li>
<li>2.支持中间件：传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。  </li>
<li>3.Crash 处理：Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！  </li>
<li>4.JSON 验证：Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。  </li>
<li>5.路由组：更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。  </li>
<li>6.错误管理：Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。  </li>
<li>7.内置渲染：Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。  </li>
<li>8.可扩展性：新建一个中间件非常简单。</li>
</ul>
<h1 id="Gin环境搭建"><a href="#Gin环境搭建" class="headerlink" title="Gin环境搭建"></a>Gin环境搭建</h1><p><strong>注意：go1.9版本以上，很快将不再支持go1.7或go1.8。</strong>  </p>
<p>先安装Go环境，然后直接运行以下命令即可：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<h1 id="我的第一个Gin项目"><a href="#我的第一个Gin项目" class="headerlink" title="我的第一个Gin项目"></a>我的第一个Gin项目</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//engine := gin.New()</span></span><br><span class="line">    engine := gin.Default()</span><br><span class="line">    engine.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">        context.String(<span class="number">200</span>,<span class="string">&quot;hello gin&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    engine.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h1><h2 id="router-x3D-gin-Default"><a href="#router-x3D-gin-Default" class="headerlink" title="router :&#x3D; gin.Default()"></a>router :&#x3D; gin.Default()</h2><p>初始化一个引擎，是gin.New()的升级。  </p>
<h2 id="router-GET"><a href="#router-GET" class="headerlink" title="router.GET"></a>router.GET</h2><ul>
<li>1.RESTFUL风格的请求方法(method)  </li>
<li>2.有两个参数：<br>  relativePath：路由，string类型<br>  HandlerFunc：执行的函数  </li>
<li>3.可以使用router.Handle代替，多了个的method参数(字符串)，method参数必须是大写的，如：GET</li>
</ul>
<h2 id="执行的函数"><a href="#执行的函数" class="headerlink" title="执行的函数"></a>执行的函数</h2><ul>
<li>1.必须有个参数是gin.Context指针类型的<br>注意：context是gin的一个重要组成部分。用来在中间层传递数据流。  </li>
<li>2.函数是个参数，不能调用</li>
</ul>
<h2 id="router-Run"><a href="#router-Run" class="headerlink" title="router.Run"></a>router.Run</h2><p>启动http监听，有个address参数，字符串类型的，可以指定host和port<br>注意：  </p>
<ul>
<li>addr的host和port是用冒号分隔的  </li>
<li>只指定port，port前面必须要有冒号  </li>
<li>指定了host和port，host和port中间有冒号  </li>
<li>不能只指定host</li>
</ul>
<h1 id="go-mod包管理"><a href="#go-mod包管理" class="headerlink" title="go mod包管理"></a>go mod包管理</h1><p>前提是Go版本&gt;&#x3D;1.11  </p>
<h2 id="什么是module？"><a href="#什么是module？" class="headerlink" title="什么是module？"></a>什么是module？</h2><p>go中包管理工具  </p>
<h2 id="使用module和不使用的区别"><a href="#使用module和不使用的区别" class="headerlink" title="使用module和不使用的区别"></a>使用module和不使用的区别</h2><p>使用环境变量中的GO111MODULE控制是否使用mod  </p>
<ul>
<li>1.开启mod：<code>go env -w GO111MODULE=on</code>，<strong>会将包下载到gopath下的pkg下的mod文件夹中</strong>  </li>
<li>2.关闭mod：<code>go env -w GO111MODULE=off</code>，<strong>会将包下载到gopath下的src下</strong>  </li>
<li>3.<code>go env GO111MODULE=auto</code>,只有当前目录在GOPATH&#x2F;src目录之外而且当前目录包含go.mod文件或者其子目录包含go.mod文件才会启用。</li>
</ul>
<h2 id="go-mod文件的语法介绍"><a href="#go-mod文件的语法介绍" class="headerlink" title="go mod文件的语法介绍"></a>go mod文件的语法介绍</h2><p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my/thing</span><br><span class="line"></span><br><span class="line">go 1.13.4</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        new/thing v2.3.4</span><br><span class="line">        old/thing v1.2.3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>1.module：指明根目录  </li>
<li>2.go 后面跟版本号是指定go的版本  </li>
<li>3.require是个动作指令，对依赖包起作用，比如require(依赖)，还有exclude(排除)，replace(替代)，相同动作的可以放在一个动词+括号组成的结构中，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require (</span><br><span class="line">    new/thing v2.3.4</span><br><span class="line">    old/thing v1.2.3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">require new/thing v2.3.4</span><br><span class="line">require old/thing v1.2.3</span><br><span class="line"></span><br><span class="line">// 排除</span><br><span class="line">exclude old/thing         v1.2.3</span><br><span class="line"></span><br><span class="line">// 替换，使用箭头后的替换前面的</span><br><span class="line">replace bad/thing         v1.4.5     =&gt; good/thing v1.4.5</span><br></pre></td></tr></table></figure>

<p>注意：  </p>
<ul>
<li>exclude和replace仅适用于主的go.mod文件中，其他的依赖中会被忽略、  </li>
<li>可以使用replace替换无法获取的库，比如<code>golang.org/x/crypto replace为github.com.com/golang/crypto</code>  </li>
<li>注释：使用&#x2F;&#x2F;，没有&#x2F;* xxx *&#x2F;这种块注释</li>
</ul>
<h2 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h2><p>go mod help 查看帮助  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">download    下载模块到本地缓存，go env中的GOCACHE路径，可以通过go clean -cache清空缓存多个项目可以共享缓存的包</span><br><span class="line">edit        在工具或脚本中编辑go.mod文件</span><br><span class="line">graph       打印模块需求图</span><br><span class="line">init        在当前目录下初始化新的模块</span><br><span class="line">    go mod init 【项目名】    默认使用当前路径的项目名称</span><br><span class="line">tidy        添加缺失的模块以及移除无用的模块，生成go.sum文件</span><br><span class="line">vendor      会自动下载项目中依赖的包到项目根目录下的vendor文件夹下，并写入go.mod文件，同时生成modules.txt文件</span><br><span class="line">            go mod vender -v     </span><br><span class="line"></span><br><span class="line">verify      检查当前模块的依赖是否全部下载下来，是否下载下来被修改过</span><br><span class="line">why         解释为什么需要包或模块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：-v参数可以查看执行的详细信息</span><br></pre></td></tr></table></figure>

<p>已经完成的项目可以这样操作来使用mod  </p>
<ul>
<li>项目路径下执行go mod init  </li>
<li>然后再执行go mod vendor（或者直接运行项目）</li>
</ul>
<p>项目中可以是这样的执行顺序：  </p>
<ul>
<li>init初始化 –&gt; tidy 增删模块–&gt; verify 校验模块–&gt;vendor</li>
</ul>
<p><strong>注意：项目中引入该项目下的任何路径都要是绝对路径，也就是以改项目名开头的路径</strong>  </p>
<p>使用mod的步骤：  </p>
<ul>
<li>1.开启mod:go111module&#x3D;on  </li>
<li>2.进入项目，执行go mod init (在项目根目录生成go.mod文件)  </li>
<li>3.启动项目（go.mod添加依赖的包）</li>
</ul>
]]></content>
      <categories>
        <category>LearnGin</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Gin</tag>
      </tags>
  </entry>
  <entry>
    <title>抗战传奇之扛包的少年</title>
    <url>/2017/03/12/kang-ri-chuan-qi-zhi-kang-bao-de-shao-nian/</url>
    <content><![CDATA[<p>注意：以下内容纯属个人想象虚构，作者只是一直想完成一项六年前的想法。  </p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>二十世纪初，R国大举进攻Z国，并侵略了大片Z国的领土。此时的Z国百姓民不聊生，为了国家的存亡，民族的尊严，Z国开始同仇敌忾，共同对抗R国的侵略军。而故事的主人公就生活在这样的环境下。  </p>
<p>主人公年仅15岁，本来有着美好的童年，却因侵略者的到来而提早结束了美好的童年。在一次Z国与R国的对抗战役中，他与亲人离散，被炮火的轰鸣声震晕在 战壕中，最后是被解放军救了出来，保住了一条命。  </p>
<p>军队里的人都不知道他叫什么名字，而他自己也在那次炮火声中失去了记忆，大家看到他的衣服上绣着一个“凡”字，于是大家就亲切的叫他“凡子”或者“小凡”。  </p>
<p>小凡很聪明，自幼存在着数理化的天赋，对各种化学想象，物理作用，数学公式尤为敏感，对密码学也做过研究。在他到来的三个月后，就把R国的一份电报破译了，成功为解放军化险为夷，大家都很感激他。  </p>
<p>他做起研究来宛如一副学者的样子，满脑子充满了各种算术符号和理论公式。出去执行任务时通常喜欢一个人，因为他觉得人多会引起敌军的注意，而他当时身材瘦小，可以完全躲避敌军的各种侦查。而他还要个特点，出去在外时无论如何都得背上那个军用旅行包，虽然很重，但他那小小的身体似乎总有使不完的劲，我们曾尝测试过那个旅行包所装东西的重量，同时运用压强公式 p&#x3D;F&#x2F;S 计算得出这个压强只有成年人才能承受，实在想不到这样一个少年怎么会扛住这样的压力，难道是和他从小的锻炼有关？  </p>
<p>总之，小凡每次执行任务回来，总会给我们带来前沿阵地的最新消息，有时候是R国军队布防图，有时候刺探出物资运输车队的运输时间和地点，从而打好伏击战。准确度很高，每次战斗结束都能收获不少的战利品，这样的情况令R国一直记在心里，盘算着要除掉Z国的小凡，在R国眼里，他就像一把刮胡刀，在不知不觉中从你的身上狠狠地刮下几块肉，令你心痛一阵子。所以这段时间R国加强了防御戒备。</p>
<p>记得那是个清晨，小凡像往常一样，扛上他那厚重如累赘般的军用背包，带好装备，食物和水。这次他要执行的任务是去破解掉R国的电力系统，从而为Z国顺利攻取敌军阵地扫清一大障碍。因为在这一段时间内，R国加强了防御工事的建立，而这些工事都是由巨大的发电机组在控制，所以如果小凡能破坏掉R国的这些设施，那么Z国就离胜利不远了！这次的任务凶多吉少，小凡知道此次行动将九死一生，不过他还是要去，为了祖国，为了胜利，是的，他已经在心底做出了选择。去吧，少年，这是你最后一次光荣的完成任务了。  </p>
<p>那是一个清晨，和煦的阳光洒他略带苍白的脸上，如同母亲温暖的手一般抚摸着他。他想，如果这是在和平时期，这该是一种多么幸福的感觉。是的，为了幸福，为了胜利，他必须摧毁掉敌军的电力系统。  </p>
<p>于是，他出发了。因为这次是潜伏性任务，小凡又身手过人，所以人手越少越好。大家一起商量好，待到小凡把电力系统破坏了后，就沿着既定的小路撤离，剩下的事情就交给大部队了。  </p>
<p>当小凡来到敌人城墙前时，看到守卫如此森严的要塞，不禁流下一身汗。不过还好，他用他自制的无线远程遥控直升机，每次装载上一定数量的炸弹，算好来回的路程，再利用抛物线公式（水平方向x&#x3D;vt，竖直方向y&#x3D;1&#x2F;2 gt^2）。只见敌军还没反应过来，电力系统就被摧毁了一大半，正当他暗暗感到任务完成的如此轻松之时，一个小兵发现了头顶上盘旋着的遥控直升机，然后一枪命中了目标，同时拉响了警报，有敌对势力入侵。  </p>
<p>这该怎么办呢？小凡心里暗想对策。如果这时候冲过去，说不定任务没有完成，自己的小命也搭了进去。可是…突然，小凡脑袋上的小灯泡亮了一下。我可以用枚举爆破法破解R国的通讯密码，然后发送虚假口令，让他们撤掉守卫，这样不就行了吗？于是他赶紧拿出自己随身带的小电脑，敲入了几个命令之后，开始了密码爆破，10秒后，一个显示password为“666”的密码出现在小凡的电脑上，哈哈，R国人真是让人感到智商捉急啊，这么简单的密码，难怪这么快就破译出来了。随后小凡赶紧发布了虚假命令，撤除了这里的守卫，然后利用抛物线方程 y&#x3D;ax^2 + bx + c。由于开口向下，所以a为负，之后目测出他所在的位置和电力系统的位置，两点之间确定方程的两个根，再利用韦达定理：x1 + x2 &#x3D; -b&#x2F;a；x1 * x2 &#x3D; c&#x2F;a。求出a b c三个数的比值，丈量好自己应该使出多大牛的力和所扔炸弹的高度，成功将R国最后的电力系统摧毁完了。任务，完成了！  </p>
<p>此时的R国士兵如梦初醒，立马开始了剿灭行动，R国司令也感到问题的严重性，决定倾尽全力也要扫除这一障碍。于是，恶战一触即发！  </p>
<p>任务完成了，可是小凡把信号弹忘记放哪了，可能是情急之下丢在了某个不知名的角落里了。然而现在已经管不了信号弹的事情了，保命要紧，于是他边打边退，在找掩体的同时也在寻找合适的契机给部队发出作战信号。  </p>
<p>终于，他被包围了。这时R国的司令走了出来，很难以想象炸毁我军电力系统的竟然是这样一个“小孩”，如果能为我所用的话…嘻嘻。只见司令官说：我看你年纪轻轻，骨骼惊奇，一定是个打仗的奇才（注：此部分经常在各种电视剧的招降上看到，先夸你一遍，然后再切入正题），如果你肯放下武器，归顺我军，不光后半辈子不愁吃穿，而且还有金钱美女相伴终生…  </p>
<p>小凡想了一下，然后背过身去，举起双手，作投降状。正当R国司令暗自称赞自己的口才之时，只见小凡说了一句话，如果你们哪天能滚出Z国，我就不再打仗，可惜，并不是现在。眨眼间，小凡利用向心力公式 F&#x3D;(mv^2)&#x2F;r ，由于质量和半径已知，力由自己掌控住，然后发出了一发子弹，只见方圆两百米之内的R国敌军呈多米诺骨牌一样纷纷倒下，大家还没搞懂从哪里射出来的子弹，就只见太阳穴就是一个血窟窿，然后软绵绵的倒下（具体场景可以参照电影《通缉令》的结局）。就在这时，小凡找到了信号弹并发射了出去，可惜R国司令也不是白当的，直接一枪打中了小凡的小腿。此时场面一片混乱，小凡借机向城外突围。  </p>
<p>此时Z国的大部队终于看到了小凡发的任务完成的信号弹，于是倾巢出动去夺回R国占领的领土。只留下少量人马看守基地。而此时的小凡正在往基地的方向走，突然，他想到了一个问题：此时我刚发信号弹，Z国司令肯定会集中全部优势力量去攻打的，而我后边R国的部队对我还是穷追不舍，如果把他们带到Z国的基地去，凭借基地的那点守卫力量，肯定是招架不住的，这样后果不堪设想。于是，在通往Z国基地的道路上，他毅然改变了方向，那个方向是通往琅琊山的。  </p>
<p>在上山的途中，小凡边打边往上走，这时候子弹打完了，手榴弹也扔得差不多了，这时候他就开始扔石头，可惜石头只能把敌人砸伤，却无法帮助他们上天。终于，在最后的时刻，他把他周围的石头也扔完了。这时候，他打开了他随身携带的军用旅行包（我们的主人公真是和常人不一样，战斗了这么久还是体力旺盛啊）  。</p>
<p>谜底终于揭晓，原来他的包内分为两层，左边放着纯净水，右边放着一大半的钾粉和铷的碎块，它们都封在石蜡里，防氧化受潮。为什么小凡要随身携带着这些东西呢？原来钾元素和铷元素属于活泼金属，遇到水就会发生爆炸，效果非常棒。小凡要用这些东西，给予敌军最后，也是最沉重的打击。  </p>
<p>于是，神奇的一幕发生了。小凡像天女散花般把钾粉和铷碎块抛洒在各个角落，然后拿出纯净水到处抛洒，R国士兵还在纳闷的时候，周围开始了狂轰滥炸式的毁灭性袭击。R国军队伤亡惨重。他们怕了，这么一个年纪轻轻的小伙子，身体仿佛有着无穷的潜能。必须解决掉他，不然后患无穷，R国司令暗下决心。  </p>
<p>随着爆炸声的结束，R国军队又举行了新一轮的进攻。而小凡，也仿佛看到了自己生命的终点，不过，他还是很开心的。因为完成了任务，因为凭自己一人干掉了这么多的敌人。唯一遗憾的是，不能再为祖国尽忠了。  </p>
<p>永别了，这个世界。希望Z国那边已经成功占领了R国的地盘，这样也就死有所值了！  </p>
<p>小凡走到悬崖边，想着是做自由落体运动还是平抛运动，最后想想，还是简单一点，于是一跃而下。在下落的过程中，他想过这一生中最遗憾的事情，就是没有见到Z国战胜R国的那一刻。此时的他并没有感到些许的疼痛，反而觉得身体轻了许多，随后便是无尽的黑暗吞噬了他…这就是命运的终点吗？  </p>
<p>“小朋友，醒醒，小朋友…”小凡睁开双眼，看到两位年纪轻轻的夫妻看着自己。我这是在哪？我是谁？我怎么什么都记不起来了。只见年轻一点的女士对着他说：“小朋友，你怎么独自一人睡在这树底下啊，你父母呢，你叫什么名字啊，你家在哪啊？”小凡懵了，不知如何去回答，只能说不知道，我好像没有父母，也没有家，别人都叫我小凡。  </p>
<p>那一对夫妇一听，顿时潸然泪下。可怜的孩子，既然相遇就是缘分，不如你就做我们的孩子吧，你说别人一直叫你小凡，那就干脆叫杨凡吧，做一个踏踏实实，平凡而不平庸的一个人。  </p>
<p>小凡问了一句，现在是几几年啊，不用打仗吗？  </p>
<p>那一对夫妇一听，笑了，傻孩子，现在都2010年了，社会和平发展，哪里有战争啊。  </p>
<p>哦，原来是这样，那就好。  </p>
<p>从此，小凡过上了平静的生活，由于他天生对数理化知识的热爱和钻研，使他很快在初三第一学期学习完了初中所有的课程，最后在中考的时候成功考入了全市重点高中，然后和我相遇了。  </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇小说是我高一时，因为学习的知识点杂而碎，所以串成了一则小故事，刚开始只有一点点，后面越积越多。曾经想着去忘却，毕竟只是闹着玩的。但高考一别，我和他从此相隔千里之外。很感激能遇到一位这样的朋友，如树洞一样，吞噬着我所有不愉快的心情，同时我也在学习他那遇事不慌，做事沉稳的习惯，不过我似乎学的并不怎么好。今夜终于要完稿了，看着这三千多字的文章，内心难免会有些激动，远在千里之外的你能感受到吗？  </p>
<p>这篇文章的背景就是来自于你，当时物理老师问你为何背一个那么大的书包，把这学期所有的教科书，练习册和作业本都装进去，不累吗，和一个炸药包一样。由此我突发奇想，想着写一则小故事，把学到的知识点串起来。  </p>
<p>朋友，能认识你我真的很高兴，在一起相处六年了，感谢这六年的时光里有你的陪伴，曾经我们之间也发生过矛盾，甚至达到决裂的程度，但后面我知错了，并勇敢地承认了，才挽回了这段友情。  </p>
<p>深夜，写以此文，纪念和你在一起的美好时光。希望你在那边一切都好。  </p>
<p>愿我们的友谊地久天长。  </p>
]]></content>
      <categories>
        <category>Personal-Noval</category>
      </categories>
      <tags>
        <tag>战争</tag>
        <tag>自制</tag>
        <tag>突发奇想</tag>
        <tag>回忆</tag>
      </tags>
  </entry>
  <entry>
    <title>kubeadm init流程概览</title>
    <url>/2022/03/05/kubeadm-init-process-overview/</url>
    <content><![CDATA[<h1 id="kubeadm-init流程"><a href="#kubeadm-init流程" class="headerlink" title="kubeadm init流程"></a>kubeadm init流程</h1><ul>
<li>1，引导前的检查  </li>
<li>2，生成私钥和数字证书  </li>
<li>3，生成控制平面组件kubeconfig文件  </li>
<li>4，生成控制平面组件manifest文件  </li>
<li>5，下载镜像，等待控制平面启动  </li>
<li>6，保存MasterConfiguration  </li>
<li>7，设定Master标志  </li>
<li>8，进行基于TLS的安全引导相关配置  </li>
<li>9，安装DNS和kube-proxy插件</li>
</ul>
<h1 id="引导前检查"><a href="#引导前检查" class="headerlink" title="引导前检查"></a>引导前检查</h1><p>kubeadm init pre-flight check：  </p>
<ul>
<li>kubeadm版本与要安装的kubernetes版本的比对检查  </li>
<li>kubernetes安装的系统需求检查  </li>
<li>其他检查：用户、主机、端口、swap、工具等</li>
</ul>
<h1 id="生成私钥和数字证书"><a href="#生成私钥和数字证书" class="headerlink" title="生成私钥和数字证书"></a>生成私钥和数字证书</h1><p>kubeadm init生成的私钥与证书：</p>
<ul>
<li>自建CA，生成ca.key和ca.crt  </li>
<li>apiserver的私钥与公钥证书  </li>
<li>apiserver访问kubelet使用的客户端私钥与证书  </li>
<li>sa.key和sa.pub  </li>
<li>Etcd相关私钥和数字证书</li>
</ul>
<h1 id="生成控制平面组件kubeconfig文件"><a href="#生成控制平面组件kubeconfig文件" class="headerlink" title="生成控制平面组件kubeconfig文件"></a>生成控制平面组件kubeconfig文件</h1><p>组成kubeconfig文件：  </p>
<ul>
<li><p>.kube&#x2F;config、&#x2F;etc&#x2F;kubernetes&#x2F;*.conf与KUBECONFIG环境变量  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#echo $KUBECONFIG</span><br><span class="line">/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>Kubeconfig配置：包含cluster、user、和context信息<br><img src="/2022/03/05/kubeadm-init-process-overview/kubeconfig-view.png">  </p>
</li>
<li><p>允许kubectl快速切换context，管理多集群</p>
</li>
</ul>
<h1 id="生成控制平面组件manifest文件"><a href="#生成控制平面组件manifest文件" class="headerlink" title="生成控制平面组件manifest文件"></a>生成控制平面组件manifest文件</h1><p>组成manifest文件：  </p>
<ul>
<li>&#x2F;etc&#x2F;kubernetes&#x2F;manifest  </li>
<li>控制平面组件以Static Pod形式运行  </li>
<li>kubelet读取manifest目录并管理各控制平台组件Pod启动和停止</li>
</ul>
<h1 id="下载镜像并等待控制平面启动"><a href="#下载镜像并等待控制平面启动" class="headerlink" title="下载镜像并等待控制平面启动"></a>下载镜像并等待控制平面启动</h1><p>kubeadm依赖kubelet下载镜像并启动static pod：  </p>
<ul>
<li>从k8s.gcr.io上面的下载组件镜像  </li>
<li>kubeadm会一直探测并等待localhost：6443&#x2F;healthz服务返回成功  </li>
<li>这一过程后，控制平面主要组件都启动Ok</li>
</ul>
<h1 id="安装DNS和kube-proxy插件"><a href="#安装DNS和kube-proxy插件" class="headerlink" title="安装DNS和kube-proxy插件"></a>安装DNS和kube-proxy插件</h1><p>安装Addons：  </p>
<ul>
<li><p>以DaemonSet方式部署Kube-proxy<br><img src="/2022/03/05/kubeadm-init-process-overview/kubectl-daemonset.png">  </p>
</li>
<li><p>部署Kube-dns（也可以用CoreDNS替代）  </p>
</li>
<li><p>DNS插件Pending状态，直到cluster网络就绪</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Kindle下载电子书的方法</title>
    <url>/2020/10/19/kindle-download-books-usage/</url>
    <content><![CDATA[<p>周末尝试下载书籍的方法，在此做一整理：  </p>
<h2 id="方法一，在亚马逊商城下载"><a href="#方法一，在亚马逊商城下载" class="headerlink" title="方法一，在亚马逊商城下载"></a>方法一，在亚马逊商城下载</h2><p>只要kindle绑定了亚马逊账号，在亚马逊购买的书籍就可以在kindle上阅读。  </p>
<h2 id="方法二，用数据线"><a href="#方法二，用数据线" class="headerlink" title="方法二，用数据线"></a>方法二，用数据线</h2><p>用和kindle匹配的数据线连接到电脑上，然后将电子书拖到kindle的文件盘里。  </p>
<p>但是需要注意，kindle连电脑完全看数据线心情。  </p>
<h2 id="方法三，（推荐）用邮箱推送"><a href="#方法三，（推荐）用邮箱推送" class="headerlink" title="方法三，（推荐）用邮箱推送"></a>方法三，（推荐）用邮箱推送</h2><ul>
<li>先登录亚马逊官方账号，在我的设备里找到一个***kindle.cn的邮箱地址，复制下来；  </li>
<li>在设置里将自己的邮箱，比如我的***<a href="mailto:&#x2e;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x2e;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>设置为可以信任的邮箱；  </li>
<li>打开邮件发送页面，将要下载的书籍添加到邮件附件里，点击发送，然后kindle连上wifi，一分钟左右新的书籍就出来了。</li>
</ul>
<p><a href="https://jingyan.baidu.com/article/656db918c1f032e381249c16.html">Kindle 推送教程：教你用电子邮箱推送电子书</a><br><a href="https://jingyan.baidu.com/article/656db918b2cf47a281249cee.html">Kindle如何添加认可的发件人电子邮箱？</a></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>下载书籍</tag>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubeadm join原理</title>
    <url>/2022/03/05/kubeadm-join-principle/</url>
    <content><![CDATA[<h1 id="join：将node加入集群"><a href="#join：将node加入集群" class="headerlink" title="join：将node加入集群"></a>join：将node加入集群</h1><ul>
<li>join前检查  </li>
<li>discovery-token-ca-cert-hash：用于Node验证Master身份  </li>
<li>token：用于Master验证Node身份</li>
</ul>
<p><img src="/2022/03/05/kubeadm-join-principle/kubeadm.png">  </p>
]]></content>
  </entry>
  <entry>
    <title>Kubernetes编排原理——“控制器”设计思想</title>
    <url>/2022/09/07/kubernetes-arrange-principle-controller-manager/</url>
    <content><![CDATA[<p>首先，我们以之前实践过的<code>nginx-deployment.yaml</code>文件为例：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 过滤规则的定义</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 定义Pod副本个数为2</span></span><br><span class="line"> <span class="attr">template:</span> </span><br><span class="line">   <span class="attr">metadata: labels:</span> <span class="comment"># 元数据</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># labels，一组键值对的标签</span></span><br><span class="line">   <span class="attr">spec:</span> </span><br><span class="line">     <span class="attr">containers:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx:1.7.9</span> </span><br><span class="line">       <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Deployment</code>定义的编排动作是：请确保携带了<code>app:nginx</code>标签的<code>Pod</code>的个数永远等于<code>spec.replicas</code>指定的个数-&gt; 2。  </p>
<p>这就意味着，如果在这个集群中，携带<code>app:nginx</code>标签的<code>Pod</code>个数大于等于2，就会有旧的<code>Pod</code>被删除；反之就会有新的<code>Pod</code>被创建。  </p>
<p>那么，究竟是<code>Kubernetes</code>项目的哪个组件在执行这些操作呢？——<code>kube-controller-manager</code>组件。  </p>
<p>实际上，这个组件就是一系列控制器的集合，看下<code>pkg/controller</code>目录  </p>
<p>实际上，这些控制器之所以被统一放在<code>pkg/controller</code>目录下，就是因为它们都遵循<code>Kubernetes</code>项目中的一个通用编排模式——控制循环（<code>control loop</code>）。  </p>
<p>比如，现在有一种待编排的对象X，它有一个对应的控制器。那么，我就可以用一段Go语言风格伪代码来描述：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    实际状态 := 获取集群中对象X的实际状态</span><br><span class="line">    期望状态 := 获取集群中对象X的期望状态</span><br><span class="line">    <span class="keyword">if</span> 实际状态 == 期望状态 &#123;</span><br><span class="line">        什么都不做</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        执行编排动作，将实际状态调整为期望状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>Deployment</code>为例，简单介绍它对控制器模型的实现：  </p>
<ul>
<li>1，<code>Deployment</code>控制器从<code>etcd</code>中获取所有携带了<code>app:nginx</code>标签的<code>Pod</code>，然后统计它们的数量，这就是实际状态；  </li>
<li>2，<code>Deployment</code>对象的<code>Replicas</code>字段的值就是期望状态；  </li>
<li>3，<code>Deployment</code>控制器比较两个状态，然后根据结果确定是创建<code>Pod</code>，还是删除已有的<code>Pod</code>。</li>
</ul>
<p>因此，一个<code>Kubernetes</code>对象的主要编排逻辑在第三步对比阶段完成。这个操作通常称作<strong>调谐（reconcile）</strong>。调谐的过程则称作<strong>调谐循环（reconcile loop）</strong>或者<strong>同步循环（sync loop）</strong>。  </p>
<p>调谐的最终结果往往是对被控制对象的某种写操作。比如，增加&#x2F;删除 Pod，或者更新<code>Pod</code>的某个字段。  </p>
<p>至此，我们可以对<code>Deployment</code>以及其他类似的控制器做一个简单总结：<br><img src="/2022/09/07/kubernetes-arrange-principle-controller-manager/deployment.png">  </p>
<p>类似于<code>Deployment</code>这样的控制器，由上半部分的控制器定义（包括期望状态）和下半部分的被控制对象的模板组成的。这就是为什么在所有API对象的<code>Metadata</code>里，都会有一个名为<code>ownerReference</code>的字段，用于保存当前这个API对象的拥有者的信息。  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>控制器</tag>
        <tag>编排原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes编排原理——容器化守护进程DaemonSet</title>
    <url>/2022/09/08/kubernetes-arrange-principle-daemonset/</url>
    <content><![CDATA[<h1 id="DaemonSet特征"><a href="#DaemonSet特征" class="headerlink" title="DaemonSet特征"></a>DaemonSet特征</h1><p><code>DaemonSet</code>的主要作用是在<code>Kubernetes</code>集群里运行一个<code>Daemon Pod</code>时，这个<code>Pod</code>具有3个特征：  </p>
<ul>
<li>1，每个<code>Pod</code>在<code>Kubernetes</code>集群里的每一个节点上运行；  </li>
<li>2，每个节点上只有一个这样的<code>Pod</code>实例；  </li>
<li>3，当有新节点加入<code>Kubernetes</code>集群后，该<code>Pod</code>会自动地在新节点上被创建出来；而当旧节点被删除后，它上面的<code>Pod</code>也会相应地被回收。</li>
</ul>
<h1 id="DaemonSet工作原理"><a href="#DaemonSet工作原理" class="headerlink" title="DaemonSet工作原理"></a>DaemonSet工作原理</h1><p><code>API</code>对象定义：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">application:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-logging</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">        <span class="comment"># 该镜像的功能：通过fluentd将Docker容器里的日志转发到Elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/fluentd-elasticsearch/fluentd:v3.0.0</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>DaemonSet</code> 跟 Deployment 其实非常相似，只不过是没有<code>replicas</code>字段；它也使用 selector选择管理所有携带了<code>name=fluentd-elasticsearch</code>标签的 Pod。  </p>
<p>而这些 Pod 的模板，也是用 template 字段定义的。在这个字段中，我们定义了一个使用<br>fluentd-elasticsearch:1.20 镜像的容器，<br>而且这个容器挂载了两个 hostPath 类型的<br>Volume，分别对应宿主机的 &#x2F;var&#x2F;log 目录和 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers 目录。当fluentd 启动之后，它会从这两个目录里搜集日志信息，并转发给 ElasticSearch 保存。这样就通过ElasticSearch 就可以很方便地检索这些日志了。  </p>
<p>注意：<code>Docker</code>容器里应用的日志默认保存在宿主机的<code>/var/lib/docker/containers/&#123;&#123;容器ID&#125;&#125;/&#123;&#123;容器ID&#125;&#125;-json.log</code>文件里。  </p>
<h2 id="DaemonSet是如何保证每个节点上有且仅有一个被管理的Pod？"><a href="#DaemonSet是如何保证每个节点上有且仅有一个被管理的Pod？" class="headerlink" title="DaemonSet是如何保证每个节点上有且仅有一个被管理的Pod？"></a>DaemonSet是如何保证每个节点上有且仅有一个被管理的Pod？</h2><p><code>DaemonSet Controller</code>首先从<code>etcd</code>里获取所有的节点列表，然后遍历所有节点。这时去检查当前这个节点是否有一个携带了<code>name: fluentd-elasticsearch</code>标签的<code>Pod</code>在运行。检查结果可能有3种情况：  </p>
<ul>
<li>1，没有这种<code>Pod</code>，这就意味着要在该节点上创建这样一个<code>Pod</code>；  </li>
<li>2，有这种<code>Pod</code>，但是数量大于1，说明要删除该节点上多余的<code>Pod</code>（删除节点上多余的 Pod直接调用 Kubernetes API 就可以了。）；  </li>
<li>3，正好只有一个这种<code>Pod</code>，说明该节点是正常的。</li>
</ul>
<h2 id="如何在指定的-Node-上创建新-Pod-呢？"><a href="#如何在指定的-Node-上创建新-Pod-呢？" class="headerlink" title="如何在指定的 Node 上创建新 Pod 呢？"></a>如何在指定的 Node 上创建新 Pod 呢？</h2><p>用 nodeSelector，选择 Node 的名字即可。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;Node的名字&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过，在 Kubernetes 项目里，nodeSelector 其实已经是一个将要被废弃的字段了。因为现在有了一个新的、功能更完善的字段可以代替它，即：<code>nodeAffinity</code>。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 声明了spec.affinity 字段</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requireDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 这个nodeAffinity 必须在每次调度的时候k考虑</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">node-test</span>  <span class="comment"># 这个pod，将来只能运行在metadata.name是node-test的节点上</span></span><br></pre></td></tr></table></figure>
<p>所以，我们的 DaemonSet Controller 会在创建 Pod 的时候，自动在这个 Pod 的 API对象里，加上这样一个 nodeAffinity 定义。其中，需要绑定的节点名字，正是当前正在遍历的这个 Node。  </p>
<p>当然，DaemonSet 并不需要修改用户提交的 YAML 文件里的 Pod 模板，而是在向Kubernetes 发起请求之前，直接修改根据模板生成的 Pod 对象。  </p>
<p>此外，DaemonSet 还会给这个 Pod 自动加上另外一个与调度相关的字段，叫作tolerations。<br>这个字段意味着这个 Pod，会“容忍”（Toleration）某些 Node 的“污点”（Taint）。  </p>
<p>而 DaemonSet 自动加上的 tolerations 字段，格式如下所示：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-toleration</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span>  <span class="comment"># “容忍”所有被标记为 unschedulable“污点”的Node，“容忍”的效果是允许调度。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node.kubernetes.io/unschedulable</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure>
<p>而在正常情况下，被标记了 unschedulable“污点”的 Node，是不会有任何 Pod 被调度上去的（effect: NoSchedule）。可是，DaemonSet 自动地给被管理的 Pod 加上了这个特殊的 Toleration，就使得这些 Pod 可以忽略这个限制，继而保证每个节点上都会被调度一个 Pod。<br>当然，如果这个节点有故障的话，这个 Pod 可能会启动失败，而 DaemonSet则会始终尝试下去，直到 Pod 启动成功。  </p>
<p>因此，<strong>DaemonSet 的“过人之处”，其实就是依靠Toleration 实现的</strong>。  </p>
<p>假如当前 DaemonSet 管理的，是一个网络插件的 Agent Pod，那么你就必须在这个DaemonSet 的 YAML 文件里，给它的 Pod 模板加上一个能够“容忍”node.kubernetes.io&#x2F;network-unavailable“污点”的 Toleration。<br>例如：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">network-plugin-agent</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node.kubernetes.io/network-unavailable</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure>
<p>在 Kubernetes 项目中，当一个节点的网络插件尚未安装时，这个节点就会被自动加上名<code>node.kubernetes.io/network-unavailable</code>的“污点”。<strong>而通过这样一个 Toleration，调度器在调度这个 Pod 的时候，就会忽略当前节点上的“污点”，从而成功地将网络插件的 Agent 组件调度到这台机器上启动起来</strong>。  </p>
<p>这种机制，正是我们在部署 Kubernetes 集群的时候，能够先部署 Kubernetes 本身、再部署网络插件的根本原因：<strong>因为当时我们所创建的 Weave 的 YAML，实际上就是一个DaemonSet</strong>。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>相比于 <code>Deployment</code>，<br><code>DaemonSet</code> 只管理 <code>Pod</code> 对象，然后通过 <code>nodeAffinity</code> 和<br><code>Toleration</code> 这两个调度器的小功能，保证了每个节点上有且只有一个 Pod。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>编排原理</tag>
        <tag>DaemonSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes编排原理——作业副本与水平拓展/收缩</title>
    <url>/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/</url>
    <content><![CDATA[<p>本文讲解<code>Kubernetes</code>中第一个控制器模式的完整实现：<code>Deployment</code>。它实现了<code>Kubernetes</code>项目中非常重要的功能：<strong>Pod的水平扩展&#x2F;收缩</strong>。  </p>
<p>例如，如果你更新了<code>Deployment</code>的<code>Pod</code>模板，那么<code>Deployment</code>就需要遵循一种叫作<strong>滚动更新rolling update</strong>的方式来升级现有容器。而这个能力的实现依赖<code>Kubernetes</code>项目中一个非常重要的概念（API对象）：<code>ReplicaSet</code>。  </p>
<h1 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h1><p>一个<code>ReplicaSet</code>对象是由副本数目的定义和一个<code>Pod</code>模板组成的。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-set</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br></pre></td></tr></table></figure>
<p>因此，对于一个<code>Deployment</code>所管理的<code>Pod</code>，它的<code>ownerReference</code>就是<code>ReplicaSet</code>。  </p>
<p>接下来分析<code>nginx-deployment.yaml</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 过滤规则的定义</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 定义Pod副本个数为3</span></span><br><span class="line"> <span class="attr">template:</span> </span><br><span class="line">   <span class="attr">metadata: labels:</span> <span class="comment"># 元数据</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># labels，一组键值对的标签</span></span><br><span class="line">   <span class="attr">spec:</span> </span><br><span class="line">     <span class="attr">containers:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx:1.7.9</span> </span><br><span class="line">       <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>一个定义了<code>replicas=3</code>的<code>Deployment</code>，与它的<code>ReplicaSet</code>以及<code>Pod</code>之间实际上是一种“层层控制”的关系  </p>
<p><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/replicaset.png">  </p>
<p><code>ReplicaSet</code>负责通过控制器模式保证系统中<code>Pod</code>个数永远等于指定个数。这也是<code>Deployment</code>只允许容器的<code>restartPolicy=Always</code>的主要原因：只有在容器保证自己始终处于<code>Running</code>状态的前提下，<code>ReplicaSet</code>调整<code>Pod</code>的个数才有意义。  </p>
<p>在此基础上，<code>Deployment</code>通过控制器模式来操作<code>ReplicaSet</code>的个数和属性，进而实现水平扩展&#x2F;收缩和滚动更新这两个编排动作：  </p>
<h2 id="水平扩展-x2F-收缩"><a href="#水平扩展-x2F-收缩" class="headerlink" title="水平扩展&#x2F;收缩"></a>水平扩展&#x2F;收缩</h2><p>实现：<code>Deployment Controller</code>只需要修改它所控制的<code>ReplicaSet</code>的<code>Pod</code>副本个数就可以了。比如，把这个值从3改成4，那么<code>Deployment</code>所对应的<code>ReplicaSet</code>就会根据修改后的值自动创建一个新的<code>Pod</code>。  </p>
<p>操作指令：<code>kubectl scale</code>，比如：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl-scale.png">  </p>
<h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p>以<code>nginx-deployment</code>为例，首先，创建这个<code>nginx-deployment</code>，并检查一下<code>nginx-deployment</code>创建后的状态信息：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- record参数作用</span></span><br><span class="line"><span class="comment"># 记录下你每次操作所执行的命令，以便之后查看</span></span><br><span class="line">kubectl create -f nginx-deployment.yaml --record</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 deployment</span></span><br><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl0.png">  </p>
<p>返回结果包含4个状态字段，含义分别是：  </p>
<ul>
<li>1，<code>DESIRED</code>：用户期望的<code>Pod</code>副本个数（<code>spec.replicas</code>的值）。  </li>
<li>2，<code>CURRENT</code>：当前处于<code>Running</code>状态的<code>Pod</code>的个数  </li>
<li>3，<code>UP-TO-DATE</code>：当前处于最新版本的<code>Pod</code>的个数。所谓最新版本，指的是<code>Pod</code>的<code>Spec</code>部分与<code>Deployment</code>里的<code>Pod</code>模板里定义的完全一致。  </li>
<li>4，<code>AVALLABLE</code>：当前已经可用的<code>Pod</code>的个数，即既是<code>Running</code>状态，又是最新版本，并且已经处于<code>Ready</code>（健康检查显示正常）状态的<code>Pod</code>的个数。——<strong>只有这个字段描述是用户所期望的最终状态</strong></li>
</ul>
<p>此时，可以查看这个<code>Deployment</code>所控制的<code>ReplicaSet</code>：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl1.png">  </p>
<p>在用户提交了一个<code>Deployment</code>对象后，<code>Deployment Controller</code>会立即创建一个<code>Pod</code>副本数为2的<code>ReplicaSet</code>。这个<code>ReplicaSet</code>的名字由<code>Deployment</code>的名字和一个随机字符串共同组成。  </p>
<p><code>ReplicaSet</code>的<code>DESIRED</code>、<code>CURRENT</code>和<code>READY</code>字段的含义，和<code>Deployment</code>中是一致的。所以，<code>Deployment</code>只是在<code>ReplicaSet</code>的基础上添加了<code>UP-TO-DATE</code>这个跟版本有关的状态字段。  </p>
<p>此时，如果修改了<code>Deployment</code>的<code>Pod</code>模板，“滚动更新”就会被触发。  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 nginx镜像的版本</span></span><br><span class="line">kubectl edit deployment/nginx-deployment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment的events</span></span><br><span class="line">kubectl describe deployment nginx-deployment</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl3.png">  </p>
<p>可以看到，当修改了<code>Deployment</code>里的<code>Pod</code>定义之后，<code>Deployment Controller</code>会使用这个修改后的<code>Pod</code>模板创建一个新的<code>ReplicaSet</code>，这个新的<code>ReplicaSet</code>的初始<code>Pod</code>副本数为0。  </p>
<p>在<code>Age=118s</code>的位置，<code>Deployment Controller</code>开始将这个新的<code>ReplicaSet</code>所控制的<code>Pod</code>副本数从0变2，即水平拓展出两个副本。紧接着，在<code>Age=119s</code>所控制的旧的<code>Pod</code>副本数减少一个…如此交替进行——像这样<strong>将一个集群中正在运行的多个Pod版本交替地逐一升级的过程，就是滚动更新。</strong>  </p>
<p>在滚动更新完成之后，可以查看一下新旧两个<code>ReplicaSet</code>的最终状态：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl4.png">  </p>
<p>其中，旧的<code>ReplicaSet</code>已经被水平收缩成了0个副本。  </p>
<p>这种滚动更新的好处：<strong>升级服务的过程中，对原来业务的使用不受影响。</strong>  </p>
<h1 id="Deployment-ReplicaSet-Pod的关系"><a href="#Deployment-ReplicaSet-Pod的关系" class="headerlink" title="Deployment-ReplicaSet-Pod的关系"></a>Deployment-ReplicaSet-Pod的关系</h1><p>综上所述：扩展<code>Deployment</code>、<code>ReplicaSet</code>、<code>Pod</code>的关系图：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/dm-rs-pod.png">  </p>
<p><code>Deployment</code>的控制器实际上控制的是<code>ReplicaSet</code>的数目，以及每个<code>ReplicaSet</code>的属性。而一个应用的版本对应的正是一个<code>ReplicaSet</code>，这个版本应用的<code>Pod</code>数量则由<code>ReplicaSet</code>通过它自己的控制器（<code>ReplicaSet Controller</code>）来保证。通过这样的多个<code>ReplicaSet</code>对象，<code>Kubernetes</code>项目就实现了对多个应用版本的描述。  </p>
<h1 id="Deployment对应用进行版本控制的原理"><a href="#Deployment对应用进行版本控制的原理" class="headerlink" title="Deployment对应用进行版本控制的原理"></a>Deployment对应用进行版本控制的原理</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接修改nginx-development所使用的镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/nginx-deployment nginx=nginx1.91</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl5.png">  </p>
<p>检查一下<code>ReplicaSet</code>状态：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl6.png">  </p>
<p>新版本的<code>ReplicaSet</code>的水平拓展已经停止。而且，此时它已经创建一个<code>Pod</code>，但是没有进入<code>READY</code>状态，因为拉取不到有效镜像。  </p>
<p>如何回滚到旧版本呢？<br>执行<code>kubectl rollout undo</code>：<br><img src="/2022/09/08/kubernetes-arrange-principle-job-copy-and-horizontal-out-or-in/kubectl7.png">  </p>
<p>可以看到，前面执行的创建和更新操作分别对应了版本1和版本3，而那次失败的更新操作对应的是版本4。  </p>
<p>也可以通过<code>kubectl rollout histroty</code>指令，查看每个版本对应的<code>Deployment</code>的API对象的细节：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl rollout histroty deployment/nginx-deployment --revision=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure>

<h2 id="问题：每次更新操作都会生成一个新的ReplicaSet对象，是否浪费资源？"><a href="#问题：每次更新操作都会生成一个新的ReplicaSet对象，是否浪费资源？" class="headerlink" title="问题：每次更新操作都会生成一个新的ReplicaSet对象，是否浪费资源？"></a>问题：每次更新操作都会生成一个新的<code>ReplicaSet</code>对象，是否浪费资源？</h2><p>是的。因此可以用<code>kubectl rollout pause</code>指令，能让我们对<code>Deployment</code>的多次更新操作最后只生成一个<code>ReplicaSet</code>。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>Deployment</code>实际上是一个两层控制器：它通过<code>ReplicaSet</code>的个数来描述应用的版本，通过<code>ReplicaSet</code>的属性来保证<code>Pod</code>的副本数量。  </li>
<li><code>Deployment</code>控制<code>ReplicaSet</code>（版本），<code>ReplicaSet</code>控制<code>Pod</code>（副本数）。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>编排原理</tag>
        <tag>作业副本</tag>
        <tag>水平拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes编排原理——离线业务Job与Cronjob</title>
    <url>/2022/09/08/kubernetes-arrange-principle-job-cronjob/</url>
    <content><![CDATA[<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p><code>API</code>对象定义：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">resouer/ubuntu-bc</span></span><br><span class="line">        <span class="comment"># scale=10000 意思是 计算出的结果取小数点后 10000位</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo &#x27;scale=10000; 4*a(1)&#x27; | bc -l &quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 离线计算的Pod永远不应该被重启</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>在这个模板中，我们定义了一个<code>Ubuntu</code>镜像的容器，他运行计算<code>π</code>的程序，所以，这是一个计算<code>π</code>的容器。  </p>
<p>创建成功后，查看一下这个<code>Job</code>对象：<br>&#x2F;&#x2F;TODO:<br>可以看到，在这个<code>Job</code>对象创建后，它的<code>Pod</code>模板被自动加上了一个<code>controller-uid=&lt;一个随机字符串&gt;</code>这样的<code>Label</code>。从而保证了<code>Job</code>与它所管理的<code>Pod</code>之间的匹配关系。  </p>
<h2 id="离线作业失败了要怎么办？"><a href="#离线作业失败了要怎么办？" class="headerlink" title="离线作业失败了要怎么办？"></a>离线作业失败了要怎么办？</h2><h2 id="Job-Controller工作原理"><a href="#Job-Controller工作原理" class="headerlink" title="Job Controller工作原理"></a>Job Controller工作原理</h2><p>首先，<code>Job Controller</code>控制的对象直接就是<code>Pod</code>。  </p>
<p>其次，<code>Job Controller</code>在控制循环中进行的调谐操作，是根据实际<code>Running</code>状态的<code>Pod</code>的数目、已经成功退出的<code>Pod</code>的数目，以及<code>parallelism</code>、<code>completions</code>参数的值共同计算出在这个周期里应该创建或者删除的<code>Pod</code>数目，然后调用<code>Kubernetes API</code>来执行这个操作。  </p>
<p>因此，<code>Job Controller</code>实际上控制了作业执行的并行度（<code>parallelism</code>），以及总共需要完成的任务数（<code>completions</code>）这两个重要参数。而在实际使用时，需要根据作业的特性来决定并行度和任务数的合理取值。  </p>
<h1 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h1><p><code>CronJob</code>描述的是定时任务，它的<code>API</code>对象如下：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span> <span class="comment"># 从当前开始，每一分钟执行一次</span></span><br><span class="line">  <span class="attr">jobTemplate:</span>  <span class="comment"># 关键！</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">template:</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">containers:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">                <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">                <span class="attr">args:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">              <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<p>原来<code>CronJob</code>是一个<code>Job</code>对象的控制器。  </p>
<p>通过以上例子，创建<code>CronJob</code>对象后，每一分钟后就会有一个<code>Job</code>产生：  </p>
<p>&#x2F;&#x2F;TODO:</p>
<p>此时，<code>CronJob</code>对象会记录下这次<code>Job</code>执行的时间：  </p>
<p>注意：由于定时任务的特殊性，很可能某个<code>Job</code>还没有执行完，另外一个新<code>Job</code>就产生了。此时，可以通过<code>spec.concurrenyPolicy</code>字段来定义具体的处理策略：  </p>
<ul>
<li>1，<code>concurrenyPolicy=Allow</code>：这是默认情况，它意味着这些<code>Job</code>可以同时存在；  </li>
<li>2，<code>concurrenyPolicy=Forbid</code>：这意味着不会创建新的<code>Pod</code>，该创建周期被跳过；  </li>
<li>3，<code>concurrenyPolicy=Replace</code>：这意味着新产生的<code>Job</code>会替换旧的、未执行完的<code>Job</code>。</li>
</ul>
<p>而如果某一次<code>Job</code>创建失败，这次创建就会被标记为<code>&quot;miss&quot;</code>。当在指定的时间窗口内<code>miss</code>的数目达到100时，<code>CronJob</code>会停止再创建这个<code>Job</code>。  </p>
<p>这个时间段可以由<code>spec.startingDeadlineSeconds</code>字段指定。比如，<code>startingDeadlineSeconds=200</code>，意味着在过去200s里，如果<code>miss</code>的数目达到了100，那么这个<code>Job</code>就不会被创建执行了。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>Job</code>是一次性执行的离线任务；  </li>
<li><code>CronJob</code>是定时执行的离线任务，也就是说<code>CronJob</code>对象在控制<code>Job</code>对象，这也说明<strong>用一个对象控制另一个对象，是 Kubernetes 编排的精髓所在</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>编排原理</tag>
        <tag>Job</tag>
        <tag>Cronjob</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes编排原理——Pod</title>
    <url>/2022/09/07/kubernetes-arrange-principle-pod/</url>
    <content><![CDATA[<p>本文将开始系统学习<code>Kubernetes</code>的编排原理，因此先从最重要最基本的<code>Pod</code>开始。  </p>
<h1 id="为什么需要Pod"><a href="#为什么需要Pod" class="headerlink" title="为什么需要Pod"></a>为什么需要Pod</h1><p>首先需要记住：  </p>
<ul>
<li><code>Pod</code>是<code>Kubernetes</code>项目的院子调度单位；  </li>
<li><code>Namespace</code>做隔离，<code>Cgroups</code>做限制，<code>rootfs</code>做文件系统  </li>
<li>容器的本质是进程，<code>Kubernetes</code>的本质是操作系统。</li>
</ul>
<h2 id="Pod的实现原理"><a href="#Pod的实现原理" class="headerlink" title="Pod的实现原理"></a>Pod的实现原理</h2><p>首先需要明白：<code>Pod</code>只是一个逻辑概念，也就是说，<code>Kubernetes</code>真正处理的还是宿主机操作系统上<code>Linux</code>容器的<code>Namespace</code>和<code>Cgroups</code>，并不存在所谓的<code>Pod</code>的边界或者隔离环境。  </p>
<p>那么<code>Pod</code>又是怎么被“创建”出来的呢？——<strong>Pod其实是一组共享了某些资源的容器</strong>。Pod里的所有容器都共享一个<code>Network Namespace</code>，并且可以声明共享同一个<code>Volume</code>。  </p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>这么说来，一个有A、B两个容器的<code>Pod</code>，不就等同于一个容器（容器A）共享另外一个容器（容器B）的网络和<code>Volume</code>的做法吗？<br>这好像通过<code>docker run --net --volumes-from</code>这样的命令就可以实现，比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --net=B --volumes-from=B --name=A image-A ...</span><br></pre></td></tr></table></figure>
<p>但是，如果容器B就必须比容器A先启动，这样一个<code>Pod</code>里的多个容器就不是对等关系，而是拓扑关系。  </p>
<h3 id="问题1解答"><a href="#问题1解答" class="headerlink" title="问题1解答"></a>问题1解答</h3><p>所以，在<code>Kubernetes</code>项目里，<code>Pod</code>的实现需要使用一个中间容器，这个容器叫作<code>Infra</code>容器。在这个<code>Pod</code>中，<code>Infra</code>容器永远是第一个被创建的容器，用户定义的其他容器则通过<code>Join Network Namespace</code>的方式与<code>Infra</code>容器关联在一起。  </p>
<p><img src="/2022/09/07/kubernetes-arrange-principle-pod/infra.png">  </p>
<p>如上图所示，这个<code>Pod</code>里有两个用户容器A和容器B，还有一个<code>Infra</code>容器。<br>在<code>Kubernetes</code>项目里，<code>Infra</code>容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作<code>k8s.gcr.io/pause</code>。这个镜像是用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有100~200KB。  </p>
<p>在<code>Infra</code>容器“hold” <code>Network Namespace</code>后，用户容器就可以加入<code>Infra</code>容器的<code>Network Namespace</code>中了。这也意味着，对于Pod里的容器A和容器B来说：  </p>
<ul>
<li>它们可以直接使用<code>localhost</code>进行通信；  </li>
<li>它们“看到”的网络设备跟<code>Infra</code>容器“看到”的完全一样；  </li>
<li>一个<code>Pod</code>只有一个<code>IP</code>地址，也就是这个<code>Pod</code>的<code>Network Namespace</code>对应的<code>IP</code>地址；  </li>
<li>当然，其他所有网络资源都是一个<code>Pod</code>一份，并且被该<code>Pod</code>中所有容器共享；  </li>
<li><code>Pod</code>的生命周期只跟<code>Infra</code>容器一致，而与容器A和容器B无关。</li>
</ul>
<p>而对于同一个<code>Pod</code>里的所有用户容器来说，它们的进出流量也可以都是通过<code>Infra</code>容器完成的。  </p>
<p>有了这个设计之后，<code>Kubernetes</code>项目只要把所有<code>Volume</code>的定义都设计在<code>Pod</code>层级，就可以实现共享<code>Volume</code>。一个<code>Volume</code>对应的宿主机目录对于<code>Pod</code>来说只有一个，<code>Pod</code>里的容器只要声明挂载这个<code>Volume</code>，就一定可以共享这个<code>Volume</code>对应的宿主机目录。例如：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">two-containers</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debian-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">debian</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/pod-data</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo hello from the debian container &gt; /pod-data/index.html&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>debian-container</code>和<code>nginx-container</code>都声明挂载了<code>shared-data</code>这个<code>Volume</code>。而<code>shared-data</code>是<code>hostPath</code>类型，所以它在宿主机上对应的目录就是<code>/data</code>。而这个目录其实被同时绑定挂载进了<code>debian-container</code>和<code>nginx-container</code>两个容器。  </p>
<p>这就是<code>nginx-container</code>可以从它的<code>/usr/share/nginx/html</code>目录读取到<code>debian-container</code>生成的<code>index.html</code>文件的原因。  </p>
<h2 id="Pod的本质"><a href="#Pod的本质" class="headerlink" title="Pod的本质"></a>Pod的本质</h2><p><strong>Pod实际上是在扮演传统基础设施里“虚拟机”的角色，容器则是这个虚拟机里运行的用户程序。</strong>  </p>
<p>所以，当你需要把一个在虚拟机里运行的应用迁移到<code>Docker</code>容器中时，一定要分析到底哪些进程或组件在这个虚拟机里运行，然后就可以把整台虚拟机想象成<code>Pod</code>，把这些进程分别做成容器镜像，把有顺序关系的容器定义为<code>Init Container</code>。这是从传统应用架构到微服务架构最自然的过渡方式。  </p>
<h1 id="深入解析Pod对象"><a href="#深入解析Pod对象" class="headerlink" title="深入解析Pod对象"></a>深入解析Pod对象</h1><p>首先需要我们得出的结论：<strong>Pod扮演的是传统部署环境中“虚拟机”的角色。这样的设计是为了让用户从传统环境（虚拟机环境）向Kubernetes（容器环境）的迁移更加平滑。</strong>  </p>
<h2 id="Pod中重要字段的含义和用法"><a href="#Pod中重要字段的含义和用法" class="headerlink" title="Pod中重要字段的含义和用法"></a>Pod中重要字段的含义和用法</h2><h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>一个供用户将<code>Pod</code>与<code>Node</code>进行绑定的字段。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line"><span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure>
<p>此配置意味着Pod永远只能在携带了<code>disktype: ssd</code>标签的节点上运行，否则它将调度失败。  </p>
<h3 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h3><p>一旦<code>Pod</code>的这个字段被赋值，<code>Kubernetes</code>项目就会认为这个<code>Pod</code>已调度，调度的结果就是赋值的节点名称。  </p>
<p>注：该字段一般由调度器负责设置，但用户也可以设置它来骗过调度器。  </p>
<h3 id="HostAliases"><a href="#HostAliases" class="headerlink" title="HostAliases"></a>HostAliases</h3><p>定义了<code>Pod</code>的<code>hosts</code>文件（比如<code>/etc/hosts</code>）里的内容。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">hostAliases:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">&quot;10.1.2.3&quot;</span></span><br><span class="line"><span class="attr">hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;foo.remote&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;bar.remote&quot;</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>设置了一组IP和<code>hostname</code>的数据，当这个<code>Pod</code>启动后，<code>/etc/hosts</code>文件的内容将如下所示：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line"><span class="comment"># Kubernetes 管理的hosts文件</span></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">...</span><br><span class="line">10.1.2.3 foo.remote</span><br><span class="line">10.1.2.3 bar.remote</span><br></pre></td></tr></table></figure>

<p>注意：在<code>Kubernetes</code>项目中，如果要设置<code>hosts</code>文件里的内容，一定要通过这种方法；而如果直接修改了<code>hosts</code>文件，在<code>Pod</code>被删除重建之后，<code>kubelet</code>会自动覆盖被修改的内容。  </p>
<h3 id="Containers的ImagePullPolicy"><a href="#Containers的ImagePullPolicy" class="headerlink" title="Containers的ImagePullPolicy"></a>Containers的ImagePullPolicy</h3><p>定义了镜像拉取的策略。</p>
<p><code>ImagePullPolicy</code>的默认值是<code>Always</code>，即每次创建<code>Pod</code>都重新拉取一次镜像，另外，当容器的镜像类似于<code>nginx</code>或者<code>nginx:latest</code>这样的名字时，<code>ImagePullPolicy</code>也会被认为<code>Always</code>。  </p>
<p>如果<code>ImagePullPolicy</code>的值被定义为<code>Never</code>或者<code>IfNotPresent</code>，则意味着<code>Pod</code>永远不会主动拉取这个镜像，或者只在宿主机上不存在这个镜像时才拉取。  </p>
<h3 id="Containers的Lifecycle"><a href="#Containers的Lifecycle" class="headerlink" title="Containers的Lifecycle"></a>Containers的Lifecycle</h3><p>定义的是<code>Container Lifecycle Hooks</code>。<br>它的作用是在容器状态发生变化时出发一系列“钩子”，例如：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span> <span class="comment"># 容器启动后立刻执行一个指定操作</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</span><br><span class="line">      <span class="attr">postStop:</span> <span class="comment"># 容器被结束之前（比如收到SIGKILL信号）立刻指定一个指定操作</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sbin/nginx&quot;</span>, <span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>在容器成功启动之后，我们在<code>/usr/share/message</code>里写入一句“欢迎信息”，而在这个容器被删除之前，我们先调用了<code>Nginx</code>的退出指令，从而实现了容器的“优雅退出”。  </p>
<h2 id="Pod对象在Kubernetes中的生命周期"><a href="#Pod对象在Kubernetes中的生命周期" class="headerlink" title="Pod对象在Kubernetes中的生命周期"></a>Pod对象在Kubernetes中的生命周期</h2><p><code>Pod</code>生命周期的变化主要体现在<code>Pod API</code>对象的<code>Status</code>部分，这是它除<code>Metadata</code>和<code>Spec</code>外第三个重要字段。其中<code>pod.status.phase</code>就是<code>Pod</code>的当前状态，它有如下几种可能的情况：  </p>
<ul>
<li><code>Pending</code>。这个状态意味着<code>Pod</code>的YAML文件已经提交给了<code>Kubernetes</code>，<code>API</code>对象已经被创建并保存到<code>etcd</code>中。但是这个<code>Pod</code>里有些容器因为某种原因不能被顺利创建。比如，调度不成功。  </li>
<li><code>Running</code>。这个状态下，<code>Pod</code>已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行。  </li>
<li><code>Successed</code>。这个状态意味着<code>Pod</code>里所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。  </li>
<li><code>Failed</code>。这个状态下，<code>Pod</code>里至少有一个容器以不正常的状态（非0的返回码）退出。出现这个状态意味着需要想办法调试这个容器的应用，比如查看<code>Pod</code>的<code>Events</code>日志。</li>
<li><code>Unknown</code>。这是一个异常状态，意味着<code>Pod</code>的状态不能持续地被<code>kubelet</code>汇报给<code>kube-apiserver</code>，这很有可能是主从节点（<code>Master</code>和<code>kubelet</code>）间的通信出了问题。</li>
</ul>
<h1 id="Pod对象使用进阶"><a href="#Pod对象使用进阶" class="headerlink" title="Pod对象使用进阶"></a>Pod对象使用进阶</h1><p>本节将从一种特殊的<code>Volume</code>（Projected Volume）开始，带你更加深入地理解<code>Pod</code>对象各个重要字段的含义。  </p>
<p>目前为止，<code>Kubernetes</code>支持的常用<code>Projected Volume</code>共有以下4种  </p>
<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>帮你把<code>Pod</code>想要访问的加密数据存放到<code>etcd</code>中，你就可以通过在<code>Pod</code>的容器里挂载<code>Volume</code>的方式访问这些<code>Secret</code>里保存的信息了。  </p>
<p>典型场景：存放数据库的<code>Credential</code>信息  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-projected-volume</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-projected-volume</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;86400&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-cred</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;/projected-volume&quot;</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-cred</span></span><br><span class="line">    <span class="attr">projected:</span> <span class="comment"># 类型</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">user</span> <span class="comment"># mysql用户</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pass</span> <span class="comment"># mysql密码</span></span><br></pre></td></tr></table></figure>

<p>以<code>Secret</code>对象的方式交给<code>Kubernetes</code>保存，完成这个操作的指令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ./username.txt</span><br><span class="line">admin</span><br><span class="line"></span><br><span class="line">cat ./password.txt</span><br><span class="line">admin123*</span><br><span class="line"></span><br><span class="line">kubectl create secret generic user --form-file=./username.txt</span><br><span class="line">kubectl create secret generic pass --form-file=./password.txt</span><br></pre></td></tr></table></figure>

<p><code>username.txt</code>和<code>password.txt</code>文件里存放的就是用户名和密码，user和pass则是我为<code>Secret</code>对象指定的名字。而想要查看这些<code>Secret</code>对象的话，则只要执行一条<code>kubectl get</code>命令即可：<br><img src="/2022/09/07/kubernetes-arrange-principle-pod/kubectl1.png">  </p>
<p>除了<code>kubectl create secret</code>指令，也可以直接通过编写YAML文件来创建这个<code>Secret</code>对象，比如：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">YMRtaW4=</span>  <span class="comment"># admin -&gt; base64转码，</span></span><br><span class="line">  <span class="attr">pass:</span> <span class="string">MWYyZDF1MmU2N2Rm</span> <span class="comment"># 1f2d1e2e67df -&gt; base64转码</span></span><br></pre></td></tr></table></figure>

<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p><code>ConfigMap</code>保存的是无须加密的、应用所需的配置信息。除此之外，<code>ConfigMap</code>的用法几乎与<code>Secret</code>完全相同。<br>你可以使用<code>kubectl create configmap</code>从文件或者目录创建<code>ConfigMap</code>，也可以直接编写<code>ConfigMap</code>对象的<code>YAML</code>文件。  </p>
<h2 id="Download-API"><a href="#Download-API" class="headerlink" title="Download API"></a>Download API</h2><p><code>Download API</code>的作用是让<code>Pod</code>里的容器能够直接获取这个<code>Pod API</code>对象本身的信息。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-downwardapi-volume</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">zone:</span> <span class="string">us-est-coast</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">test-cluster1</span></span><br><span class="line">    <span class="attr">rack:</span> <span class="string">rack-22</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">client-container</span>  <span class="comment"># 定义一个容器</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;do</span></span><br><span class="line">          <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/labels</span> ]]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/labels;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/podinfo</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">    <span class="attr">projected:</span>  <span class="comment"># 类型</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">downloadAPI:</span> <span class="comment"># 名为podInfo的volume的数据源</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;labels&quot;</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadate.labels</span>  <span class="comment"># 暴露Pod的metadata.labels给容器</span></span><br></pre></td></tr></table></figure>

<h3 id="支持的字段"><a href="#支持的字段" class="headerlink" title="支持的字段"></a>支持的字段</h3><h4 id="使用fieldRef可以声明使用："><a href="#使用fieldRef可以声明使用：" class="headerlink" title="使用fieldRef可以声明使用："></a>使用fieldRef可以声明使用：</h4><ul>
<li>metadata.name——Pod的名词  </li>
<li>metadata.namespace——Pod的Namespace</li>
<li>metadata.uid——Pod的UID</li>
<li>metadata.labels[‘<KEY>‘]——指定<KEY>上的<code>Label</code>值</KEY></KEY></li>
<li>metadata.annotations——Pod的所有Annotation</li>
</ul>
<h4 id="使用resourceFieldRef可以声明使用："><a href="#使用resourceFieldRef可以声明使用：" class="headerlink" title="使用resourceFieldRef可以声明使用："></a>使用resourceFieldRef可以声明使用：</h4><ul>
<li>容器的CPU limit；  </li>
<li>容器的CPU request；  </li>
<li>容器的memory limit；</li>
<li>容器的memory request；  </li>
<li>容器的ephemeral-strorage limit；  </li>
<li>容器的ephemeral-strorage request。</li>
</ul>
<h4 id="通过环境变量声明使用："><a href="#通过环境变量声明使用：" class="headerlink" title="通过环境变量声明使用："></a>通过环境变量声明使用：</h4><ul>
<li>status.podIP——Pod的IP</li>
<li>spec.serviceAccountName——Pod的ServiceAccount名词  </li>
<li>spec.nodeName——Node的名字  </li>
<li>status.hostIP——Node的IP</li>
</ul>
<h2 id="ServiceAccountToken"><a href="#ServiceAccountToken" class="headerlink" title="ServiceAccountToken"></a>ServiceAccountToken</h2><p>ServiceAccount对象的作用是<code>Kubernetes</code>系统内置的一种“服务账户”，它是<code>Kubernetes</code>进行权限分配的对象。比如<code>Service Account A</code>可以只被允许对<code>Kubernetes API</code>进行GET操作，而<code>Service Account B</code>可以有<code>Kubernetes API</code>的所有操作的权限。  </p>
<p>像这样的<code>Service Account</code>的授权信息和文件，实际上保存在它所绑定的一个特殊的<code>Secret</code>对象里。这个特殊的<code>Secret</code>对象叫作<code>ServiceAccountToken</code>。任何在<code>Kubernetes</code>集群上运行的应用，都必须使用<code>ServiceAccountToken</code>里保存的授权信息（也就是<code>Token</code>），才可以合法地访问<code>API Server</code>。  </p>
<p>因此，<code>ServiceAccountToken</code>也可以理解为一种特殊的<code>Secret</code>。  </p>
<h2 id="容器健康检查和恢复机制"><a href="#容器健康检查和恢复机制" class="headerlink" title="容器健康检查和恢复机制"></a>容器健康检查和恢复机制</h2><p>在<code>Kubernetes</code>中，可以为<code>Pod</code>里的容器定义一个健康检查“探针”（Probe）。这样的，<code>kubelet</code>就会根据<code>Probe</code>的返回值决定这个容器的状态，而不是直接以容器是否运行（来自Docker返回的信息）作为依据。这种机制是生产环境中保证应用健康的重要手段。  </p>
<p>例子：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="comment"># 容器启动之后在/tmp目录下创建一个healthy文件，以此作为自己已经正常运行的标志</span></span><br><span class="line">    <span class="comment"># 30秒后，把这个文件删除</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment"># 定义一个健康检查</span></span><br><span class="line">      <span class="attr">exec:</span>  <span class="comment"># 类型是 exec</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="comment"># 检查healthy文件如果存在，这条命令的返回值是0</span></span><br><span class="line">        <span class="comment"># Pod就会认为这个容器不仅已经启动，而且是健康的</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span> <span class="comment"># 在容器启动5秒后检查</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span> <span class="comment"># 每5秒执行一次</span></span><br></pre></td></tr></table></figure>

<p>执行命令，创建<code>Pod</code>：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f liveness.yaml</span><br></pre></td></tr></table></figure>

<p>查看这个<code>Pod</code>的状态：<br><img src="/2022/09/07/kubernetes-arrange-principle-pod/liveness1.png">  </p>
<p>30秒之后再查看一下<code>Pod</code>的<code>Events</code><br><img src="/2022/09/07/kubernetes-arrange-principle-pod/liveness2.png">  </p>
<p>发现已经报告了异常，<code>tmp/healthy</code>文件不存在了，然而<code>Pod</code>的状态仍然是<code>Running</code>。为什么？  </p>
<p>因为<code>Kubernetes</code>中没有<code>Docker</code>的<code>Stop</code>语义。所以虽说是<code>Restart</code>，实际上却是重新创建了容器。  </p>
<p>这个功能就是<code>Kubernetes</code>里的<strong>Pod恢复机制</strong>，也叫<code>restartPolicy</code>。它是<code>Pod</code>的Sepc部分的一个标准字段（<code>pod.spec.restartPolicy</code>），默认值是<code>Always</code>，即无论这个容器何时发生异常，它一定会被重启。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文重点介绍了<code>Pod</code>相关的内容，有<code>Pod</code>实现原理，本质，<code>Pod</code>重要字段的含义和用法，以及声明周期，还有实践“容器健康检查”机制，最后又引出了<code>Kubernetes</code>的<strong>Pod恢复机制</strong>。  </p>
<p>总<code>Pod</code>是学习<code>Kubernetes</code>很重要的一环，后期还需要多实践，体会用法。  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>编排原理</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes编排原理——StatefulSet</title>
    <url>/2022/09/08/kubernetes-arrange-principle-statefulset/</url>
    <content><![CDATA[<h1 id="什么是StatefulSet"><a href="#什么是StatefulSet" class="headerlink" title="什么是StatefulSet"></a>什么是StatefulSet</h1><p>在分布式应用中，它的多个实例之间往往有依赖关系，比如主从关系、主备关系；还有数据存储类应用，它的多个实例往往会在本地磁盘上保存一份数据，而这些实例一旦被结束，即便重建出来，实例与数据之间的对应关系也已经丢失，从而导致应用失败。  </p>
<p>所以，这种实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就称为<strong>有状态应用（stateful application）。</strong>  </p>
<p>得益于控制器模式的设计思想，<code>Kubernetes</code>项目在<code>Deployment</code>基础上扩展出了对有状态应用的初步支持。这个编排功能就是<strong>StatefulSet</strong>。  </p>
<h1 id="拓扑状态"><a href="#拓扑状态" class="headerlink" title="拓扑状态"></a>拓扑状态</h1><p>应用的多个实例之间不是完全对等的。这些应用实例必须按照某种顺序启动，比如应用的主节点A要先于从节点B启动。而如果删除A和B两个<code>Pod</code>，它们再次被创建出来时也必须严格按照这个顺序执行。并且，新创建出来的<code>Pod</code>必须和原来<code>Pod</code>的网络标识一样，这样原先的访问者才能使用同样的方法访问到这个新<code>Pod</code>。  </p>
<h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p><code>Service</code>是<code>Kubernetes</code>项目中用来将一组<code>Pod</code>暴露给外界访问的一种机制。  </p>
<p>Service如何被访问  </p>
<ul>
<li>1，以<code>Service</code>的VIP（<code>virtualIP</code>，虚拟IP）方式。比如，当我访问10.0.23.1这个<code>Service</code>的IP地址时，10.0.23.1其实就是一个VIP，它会把请求转发到该<code>Service</code>所代理的某一个<code>Pod</code>上。  </li>
<li>2，以<code>Service</code>的DNS方式。比如，此时我只要访问<code>my-svc.my-namespace.svc.cluster.local</code>这条DNS记录，就可以访问到名叫<code>my-svc</code>的<code>Service</code>所代理的某一个<code>Pod</code>。</li>
</ul>
<p>在第二种Service DNS的方式下，具体又可以分为两种处理办法：  </p>
<ul>
<li>(1)<code>Normal Service</code>：在这种情况下，你访问<code>my-svc.my-service.svc.cluster.local</code>解析到的，正是<code>my-svc</code>这个<code>Service</code>的VIP，后面的流程就跟VIP方式一致了。  </li>
<li>(2)<code>Headless Service</code>：在这种情况下，你访问<code>my-svc.my-service.svc.cluster.local</code>解析到的，直接就是<code>my-svc</code>代理的某一个<code>Pod</code>的IP地址。这里的区别在于，<code>Headless Service</code>不需要分配一个VIP，而是可以直接以DNS记录的方式解析出被代理<code>Pod</code>的IP地址。</li>
</ul>
<h3 id="Headless-Service定义"><a href="#Headless-Service定义" class="headerlink" title="Headless Service定义"></a>Headless Service定义</h3><p>标准的<code>Headless Service</code>对应的YAML文件：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 注意</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>因此<code>Headless Service</code>的含义是<strong>这个Service没有一个VIP作为 “头”。</strong><br>所以，这个<code>Service</code>被创建后并不会被分配VIP，而是会以DNS记录的方式暴露出它所代理的<code>Pod</code>。而它所代理的<code>Pod</code>，依然是通过<code>Label Selector</code>机制选出的，即所有携带了<code>app: nginx</code>标签的<code>Pod</code>都会被这个<code>Service</code>代理。  </p>
<p>当你按照这样的方式创建了一个<code>Headless Service</code>之后，它所代理的所有<code>Pod</code>的IP地址都会被绑定一个如下格式的DNS记录：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>

<p>这个DNS记录，正是<code>Kubernetes</code>项目为<code>Pod</code>分配的唯一<strong>可解析身份（resolvable idenetity）。</strong>  </p>
<h2 id="StatefulSet如何使用DNS记录来维持Pod的拓扑状态"><a href="#StatefulSet如何使用DNS记录来维持Pod的拓扑状态" class="headerlink" title="StatefulSet如何使用DNS记录来维持Pod的拓扑状态"></a>StatefulSet如何使用DNS记录来维持Pod的拓扑状态</h2><p>编写一个<code>StatefulSet</code>的YAML文件：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span> <span class="comment"># 告诉StatefulSet控制器，在执行循环时请使用Nginx这个 Headless Service来保证Pod解析</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.9.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl create -f</code>创建，查看对象：<br><img src="/2022/09/08/kubernetes-arrange-principle-statefulset/kubectl1.png">  </p>
<p>从上面这个<code>Pod</code>的创建过程可以看出，<code>StatefulSet</code>给它所管理的所有<code>Pod</code>的名字进行了编号，编号规则是：<code>-</code>。而且这些编号都是从0开始累加的，与<code>StatefulSet</code>的每个<code>Pod</code>实例一一对应，绝不重复。  </p>
<p>而且，这些<code>Pod</code>的创建也是严格按照编号顺序进行的。比如<code>web-0</code>进入<code>Running</code><br>状态，并且细分状态变为<code>Ready</code>之前，<code>web-1</code>会一直处于<code>Pending</code>状态。  </p>
<p>使用<code>kubectl exec</code>进入容器查看它们的<code>hostname</code>：<br><img src="/2022/09/08/kubernetes-arrange-principle-statefulset/kubectl2.png">  </p>
<p>可以看到这两个<code>Pod</code>的<code>hostname</code>与<code>Pod</code>名字是一致的，都被分配了对应的编号。  </p>
<p>我们再试着以<code>DNS</code>方式访问这个<code>Headless Service</code>：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动了一个一次性Pod</span></span><br><span class="line">kubectl run -i --<span class="built_in">tty</span> --image busybox dns-test --restart=Never --<span class="built_in">rm</span> /bin/sh</span><br></pre></td></tr></table></figure>

<p>在这个<code>Pod</code>里面，我们尝试用<code>nslookup</code>命令解析<code>Pod</code>对应的<code>Headless Service</code>：<br><img src="/2022/09/08/kubernetes-arrange-principle-statefulset/gk1.png">  </p>
<p>当我们把这两个有状态应用的<code>Pod</code>删掉：<br><img src="/2022/09/08/kubernetes-arrange-principle-statefulset/kubectl3.png">  </p>
<p>可以看到，<code>Kubernetes</code>会按照原先编号的顺序重新创建出两个<code>Pod</code>，并且分配了原来相同的网络身份。  </p>
<p>这样<code>StatefulSet</code>就保证了<code>Pod</code>网络标识的稳定性。  </p>
<h1 id="存储状态"><a href="#存储状态" class="headerlink" title="存储状态"></a>存储状态</h1><p>StatefulSet 对存储状态的管理机制，主要使用的是一个叫作 Persistent Volume Claim 的功能。  </p>
<p>应用的多个实例分别绑定了不同的存储数据。对于这些应用实例来说，<code>Pod A</code>第一次读取到的数据和隔了10分钟之后再次读取到的数据应该是同一份，哪怕在此期间<code>Pod A</code>被重新创建过。典型例子：一个数据库应用的多个存储实例。  </p>
<h1 id="有状态应用实践"><a href="#有状态应用实践" class="headerlink" title="有状态应用实践"></a>有状态应用实践</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>StatefulSet</code>的核心功能，就是通过某种方式记录这些状态，然后在<code>Pod</code>被重新创建时，能够为新<code>Pod</code>恢复这些状态。  </li>
<li><code>StatefulSet</code>这个控制器的主要作用之一，就是使用<code>Pod</code>模板创建<code>Pod</code>时对它们进行编号，并且按照编号的顺序逐一完成创建工作。而当<code>StatefulSet</code>的“控制循环”发现<code>Pod</code>的实际状态与期望状态不一致，需要新建或者删除<code>Pod</code>以进行“调谐”时，它会严格按照这些<code>Pod</code>编号的顺序逐一完成这些操作。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>编排原理</tag>
        <tag>StatefulSet</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Kubernetes构建企业容器云_进阶提高篇</title>
    <url>/2021/09/21/kubernetes-build-enterprise-container-cloud-advance-improve-level/</url>
    <content><![CDATA[<h1 id="使用Helm管理Kubernetes应用"><a href="#使用Helm管理Kubernetes应用" class="headerlink" title="使用Helm管理Kubernetes应用"></a>使用Helm管理Kubernetes应用</h1><h2 id="什么是Helm？"><a href="#什么是Helm？" class="headerlink" title="什么是Helm？"></a>什么是Helm？</h2><p>Helm是一个kubernetes应用的包管理工具，用来管理charts————预先配置好的安装包资源，有点类似于Ubuntu的APT和CentOS中的yum。  </p>
<h2 id="Helm的三个组件"><a href="#Helm的三个组件" class="headerlink" title="Helm的三个组件"></a>Helm的三个组件</h2><ul>
<li>Chart: 一系列 k8s 资源集合的命名，它包含一系列 k8s 资源配置文件的模板 与参数，可供灵活配置  </li>
<li>Repo: 即 chart 的仓库，其中有很多个 chart 可供选择，如官方 helm&#x2F;charts  </li>
<li>Release: 当一个 Chart 部署后生成一个 release</li>
</ul>
<h2 id="创建自己的Chart"><a href="#创建自己的Chart" class="headerlink" title="创建自己的Chart"></a>创建自己的Chart</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linux-node1 ~]# helm create opencmdb </span><br><span class="line">Creating opencmdb </span><br><span class="line"></span><br><span class="line">[root@linux-node1 ~]# tree opencmdb/ </span><br><span class="line">opencmdb/ </span><br><span class="line">├── charts #存放依赖的Chart </span><br><span class="line">├── Chart.yaml </span><br><span class="line">├── templates # 模板目录，存放YAML的模板文件 </span><br><span class="line">│ ├── deployment.yaml </span><br><span class="line">│ ├── _helpers.tpl </span><br><span class="line">│ ├── ingress.yaml </span><br><span class="line">│ ├── NOTES.txt # </span><br><span class="line">│ └── service.yaml </span><br><span class="line">└── values.yaml #给模板里面的变量赋值 </span><br><span class="line"></span><br><span class="line">2 directories, 7 files</span><br></pre></td></tr></table></figure>

<h2 id="制品仓库和Helm"><a href="#制品仓库和Helm" class="headerlink" title="制品仓库和Helm"></a>制品仓库和Helm</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-advance-improve-level/repo-helm.png">  </p>
<h1 id="Kubernetes的认证和鉴权RBAC"><a href="#Kubernetes的认证和鉴权RBAC" class="headerlink" title="Kubernetes的认证和鉴权RBAC"></a>Kubernetes的认证和鉴权RBAC</h1><h1 id="深入理解Kubernetes的内部机制"><a href="#深入理解Kubernetes的内部机制" class="headerlink" title="深入理解Kubernetes的内部机制"></a>深入理解Kubernetes的内部机制</h1><h1 id="Kubernetes的高可用架构"><a href="#Kubernetes的高可用架构" class="headerlink" title="Kubernetes的高可用架构"></a>Kubernetes的高可用架构</h1><h1 id="基于Kubernetes的DevOps实践"><a href="#基于Kubernetes的DevOps实践" class="headerlink" title="基于Kubernetes的DevOps实践"></a>基于Kubernetes的DevOps实践</h1>]]></content>
      <categories>
        <category>Learn-Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>容器云</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Kubernetes构建企业容器云_企业实践篇</title>
    <url>/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/</url>
    <content><![CDATA[<h1 id="理解Kubernetes理念和架构"><a href="#理解Kubernetes理念和架构" class="headerlink" title="理解Kubernetes理念和架构"></a>理解Kubernetes理念和架构</h1><h2 id="传统部署VS虚拟化部署VS容器部署"><a href="#传统部署VS虚拟化部署VS容器部署" class="headerlink" title="传统部署VS虚拟化部署VS容器部署"></a>传统部署VS虚拟化部署VS容器部署</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/tvc-deploy.png">  </p>
<h2 id="企业容器云平台架构"><a href="#企业容器云平台架构" class="headerlink" title="企业容器云平台架构"></a>企业容器云平台架构</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/enter-container-cloud-arch.png">  </p>
<h2 id="Docker编排服务：三驾马车"><a href="#Docker编排服务：三驾马车" class="headerlink" title="Docker编排服务：三驾马车"></a>Docker编排服务：三驾马车</h2><h3 id="DOCKER-SWART——docker"><a href="#DOCKER-SWART——docker" class="headerlink" title="DOCKER SWART——docker"></a>DOCKER SWART——docker</h3><h3 id="MESOS——APACHE"><a href="#MESOS——APACHE" class="headerlink" title="MESOS——APACHE"></a>MESOS——APACHE</h3><h3 id="kubernates——Google"><a href="#kubernates——Google" class="headerlink" title="kubernates——Google"></a>kubernates——Google</h3><h2 id="Kubernates组件架构"><a href="#Kubernates组件架构" class="headerlink" title="Kubernates组件架构"></a>Kubernates组件架构</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/k8s-arch.png">  </p>
<h2 id="Kubernates-Master架构"><a href="#Kubernates-Master架构" class="headerlink" title="Kubernates Master架构"></a>Kubernates Master架构</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/k8s-master-arch.png">  </p>
<h2 id="Kubernetes-Master组件介绍"><a href="#Kubernetes-Master组件介绍" class="headerlink" title="Kubernetes Master组件介绍"></a>Kubernetes Master组件介绍</h2><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><p>Kubernetes API接口，主要处理 REST操作以及更新Etcd中的对象。所有资源增删改查的唯 一入口。在设计上考虑了水平扩缩的需要，可以构建集群。  </p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>集群的资源调度组件，用于绑定Pod到Node上。  </p>
<h3 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h3><p>控制器组件，资源对象的自动化控制中心，例如Node Controller、Endpoints Controller 等。  </p>
<h3 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h3><p>Etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的 后台数据库。所有持久化的状态信息存储在Etcd中。  </p>
<h2 id="Kubernetes-Node架构"><a href="#Kubernetes-Node架构" class="headerlink" title="Kubernetes Node架构"></a>Kubernetes Node架构</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/k8s-node-arch.png">  </p>
<h2 id="Kubernetes-Node组件介绍"><a href="#Kubernetes-Node组件介绍" class="headerlink" title="Kubernetes Node组件介绍"></a>Kubernetes Node组件介绍</h2><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>一个在集群中每个节点上运行的代理。用于管理Pods以及容器、镜像、Volume等，实现对 集群对节点的管理。  </p>
<h3 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h3><p>kube-proxy 是集群中每个节点上运行的网络代理,实现 Kubernetes Service 概念的一部分。 提供网络代理以及负载均衡，kube-proxy 维护节点上的网络规则。这些网络规则允许从集 群内部或外部的网络会话与 Pod 进行网络通信。  </p>
<h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h3><p>负责节点的容器的管理工作，Kubernetes 支持多个容器运行环境: Docker、 containerd、 cri-o、 rktlet 以及任何实现 Kubernetes CRI (容器运行环境接口)。  </p>
<h2 id="Google内部容器平台Borg"><a href="#Google内部容器平台Borg" class="headerlink" title="Google内部容器平台Borg"></a>Google内部容器平台Borg</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/google-borg.png">  </p>
<h2 id="深入理解Kubernetes架构"><a href="#深入理解Kubernetes架构" class="headerlink" title="深入理解Kubernetes架构"></a>深入理解Kubernetes架构</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/understand-k8s-arch.png">  </p>
<h2 id="kubelet的监听端口"><a href="#kubelet的监听端口" class="headerlink" title="kubelet的监听端口"></a>kubelet的监听端口</h2><ul>
<li>–port int32<br>kubelet 服务监听的本机端口号。（默认值为 10250）已弃用： 在 –config 指定的配置文件中进行设置。</li>
</ul>
<p><strong>curl <a href="http://127.0.0.1:10248/healthz">http://127.0.0.1:10248/healthz</a></strong>  </p>
<ul>
<li><p>–healthz-bind-address 0.0.0.0<br>用于运行 healthz 服务器的 IP 地址（对于所 有 IPv4 接口，设置为 0.0.0.0；对于所有 IPv6 接口，设置为 <code>::</code>）（默认值为 127.0.0.1） <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/%E3%80%82%EF%BC%89">https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/。）</a>  </p>
</li>
<li><p>–healthz-port int32<br>本地 healthz 端点使用的端口（设置为 0 表示禁用） （默认值为 10248）</p>
</li>
</ul>
<h2 id="kube-proxy的监听端口"><a href="#kube-proxy的监听端口" class="headerlink" title="kube-proxy的监听端口"></a>kube-proxy的监听端口</h2><p><strong>curl <a href="http://127.0.0.1:10256/healthz">http://127.0.0.1:10256/healthz</a></strong>  </p>
<ul>
<li><p>–healthz-bind-address 0.0.0.0 默认值: 0.0.0.0:10256<br>服务健康检查的 IP 地址和端口（对于所有 IPv4 接口设置为 0.0.0.0，对于所有 IPv6 接口设置为 ::）  </p>
</li>
<li><p>–healthz-port int32 默认值: 10256<br>绑定健康检查服务的端口。使用 0 表示禁用。</p>
</li>
</ul>
<p><strong>curl <a href="http://127.0.0.1:10249/metrics">http://127.0.0.1:10249/metrics</a></strong>  </p>
<ul>
<li><p>–metrics-bind-address 0.0.0.0 默认值: 127.0.0.1:10249<br>metrics 服务器要使用的 IP 地址（所有 IPv4 接口设置为 0.0.0.0，所有 IPv6 接口设置为 <code>::</code>）  </p>
</li>
<li><p>–metrics-port int32 默认值: 10249<br>绑定 metrics 服务器的端口。使用 0 表示禁用。</p>
</li>
</ul>
<h1 id="应用容器化（Docker）"><a href="#应用容器化（Docker）" class="headerlink" title="应用容器化（Docker）"></a>应用容器化（Docker）</h1><h2 id="不可变基础设施（immutable-infrastructure）"><a href="#不可变基础设施（immutable-infrastructure）" class="headerlink" title="不可变基础设施（immutable infrastructure）"></a>不可变基础设施（immutable infrastructure）</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/docker-immutable-infrastructure.png">  </p>
<h2 id="Docker镜像构建最佳实践"><a href="#Docker镜像构建最佳实践" class="headerlink" title="Docker镜像构建最佳实践"></a>Docker镜像构建最佳实践</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/docker-image-practice.png">  </p>
<h1 id="将应用迁移至Kubernetes"><a href="#将应用迁移至Kubernetes" class="headerlink" title="将应用迁移至Kubernetes"></a>将应用迁移至Kubernetes</h1><h2 id="将应用迁移到Kubernetes中"><a href="#将应用迁移到Kubernetes中" class="headerlink" title="将应用迁移到Kubernetes中"></a>将应用迁移到Kubernetes中</h2><h3 id="容器放置在Pod中"><a href="#容器放置在Pod中" class="headerlink" title="容器放置在Pod中"></a>容器放置在Pod中</h3><p>将单个容器或者有依赖 关系的多个容器封装到 Pod中。 </p>
<h3 id="控制器管理Pod"><a href="#控制器管理Pod" class="headerlink" title="控制器管理Pod"></a>控制器管理Pod</h3><p>使用不同的控制器RC、 RS、Deployment、 Job、Cronjob管理Pod 运行。  </p>
<h3 id="管理Pod网络访问"><a href="#管理Pod网络访问" class="headerlink" title="管理Pod网络访问"></a>管理Pod网络访问</h3><p>通过Ser v ice、 Endpoint、Ingres s管 理Pod的网络访问。  </p>
<h3 id="管-理-P-o-d-数-据-存-储"><a href="#管-理-P-o-d-数-据-存-储" class="headerlink" title="管 理 P o d 数 据 存 储"></a>管 理 P o d 数 据 存 储</h3><p>通过Volume、PV、 PVC、Storage Class 管理Pod的数据存储。  </p>
<h2 id="Kubernetes的最小单位Pod"><a href="#Kubernetes的最小单位Pod" class="headerlink" title="Kubernetes的最小单位Pod"></a>Kubernetes的最小单位Pod</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/pod.png">  </p>
<ul>
<li>Pod 里只运行一个单独容器 “one- container-per-Pod”  </li>
<li>Pod 中运行多个有依赖关系的容器</li>
</ul>
<h2 id="Pod、容器、Volume"><a href="#Pod、容器、Volume" class="headerlink" title="Pod、容器、Volume"></a>Pod、容器、Volume</h2><p><img src="/2021/09/21/kubernetes-build-enterprise-container-cloud-practice-level/pod-container-volume.png">  </p>
<h2 id="Pod的定义"><a href="#Pod的定义" class="headerlink" title="Pod的定义"></a>Pod的定义</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">apiVersion: v1 <span class="comment"># 版本号 </span></span><br><span class="line">kind: Pod <span class="comment"># Pod </span></span><br><span class="line">metadata: <span class="comment"># 元数据 </span></span><br><span class="line">name: nginx-pod <span class="comment"># metadata.name Pod的名称 </span></span><br><span class="line">labels: <span class="comment"># metadata.labels 自定义标签列表 </span></span><br><span class="line"> app: nginx </span><br><span class="line">spec: <span class="comment"># Pod中容器的详细定义 </span></span><br><span class="line"> containers: <span class="comment"># spec.containers 容器列表 </span></span><br><span class="line"> - name: nginx <span class="comment"># spec.containers.name 容器名称 </span></span><br><span class="line"> image: nginx:<span class="number">1.13</span><span class="number">.12</span> <span class="comment"># spec.containers.image 容器镜像名称 </span></span><br><span class="line"> ports: <span class="comment"># 容器需要暴露的端口号列表 </span></span><br><span class="line"> - containerPort: <span class="number">80</span> <span class="comment"># 容器监听的端口号</span></span><br></pre></td></tr></table></figure>

<h2 id="YAML编写技巧"><a href="#YAML编写技巧" class="headerlink" title="YAML编写技巧"></a>YAML编写技巧</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul>
<li>YAML使用一个固定的缩进风格表示数据层结构关系。 每个缩进级别由两个空格组成  </li>
<li>不要使用tabs</li>
</ul>
<h3 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YAML my_key: my_value first_level_dict_key: second_level_dict_key:value_in_second_level_dict </span><br><span class="line"></span><br><span class="line">IN Python &#123;&#x27;my_key&#x27;: &#x27;my_value&#x27;&#125; &#123; &#x27;first_level_dict_key&#x27;: &#123; &#x27;second_level_dict_key&#x27;: &#x27;value_in_second_level_dict&#x27; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="管理Kubernetes中的应用"><a href="#管理Kubernetes中的应用" class="headerlink" title="管理Kubernetes中的应用"></a>管理Kubernetes中的应用</h1>]]></content>
      <categories>
        <category>Learn-Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>容器云</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群部署WordPress网站-版本3</title>
    <url>/2022/10/04/kubernetes-cluster-deploy-wordpress-v3/</url>
    <content><![CDATA[<h1 id="版本更新描述"><a href="#版本更新描述" class="headerlink" title="版本更新描述"></a>版本更新描述</h1><p>在基于<a href="https://octopuslian.github.io/2022/10/04/kubernetes-cluster-deploy-wordpress-v2">版本2</a>的基础上继续优化 WordPress 网站的部署，其中的关键是<strong>让数据库 MariaDB 实现数据持久化。</strong>  </p>
<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p>网站的整体架构图变化不大，前面的 Nginx、WordPress 还是原样，只需要修改 MariaDB：  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v3/%E6%9E%B6%E6%9E%84%E5%9B%BE.png">  </p>
<p>因为 MariaDB 由 Deployment 改成了 StatefulSet，所以我们要修改 YAML，添加“serviceName”“volumeClaimTemplates”这两个字段，定义网络标识和 NFS 动态存储卷，然后在容器部分用“volumeMounts”挂载到容器里的数据目录“&#x2F;var&#x2F;lib&#x2F;mysql”，从而实现持久化。  </p>
<h1 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h1><h2 id="修改MariaDB"><a href="#修改MariaDB" class="headerlink" title="修改MariaDB"></a>修改MariaDB</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maria-sts.yml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-sts</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-sts</span></span><br><span class="line">		</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># headless svc</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">maria-svc</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pvc</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">maria-100m-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">nfs-client</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">maria-sts</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">maria-sts</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mariadb:10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mariadb</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;MARIADB_&#x27;</span></span><br><span class="line">          <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">maria-cm</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">maria-100m-pvc</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure>

<h2 id="修改WordPress"><a href="#修改WordPress" class="headerlink" title="修改WordPress"></a>修改WordPress</h2><p>StatefulSet 管理的每个 Pod 都有自己的域名，所以要把 WordPress 的环境变量改成 MariaDB 的新名字，也就是“maria-sts-0.maria-svc”：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">HOST:</span> <span class="string">&#x27;maria-sts-0.maria-svc&#x27;</span>  <span class="comment">#注意这里</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">NAME:</span> <span class="string">&#x27;db&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="检验StatefulSet的持久化存储是否生效"><a href="#检验StatefulSet的持久化存储是否生效" class="headerlink" title="检验StatefulSet的持久化存储是否生效"></a>检验StatefulSet的持久化存储是否生效</h2><p>你可以把这些对象都删除后重新创建，再进入网站，看看是否原来的数据依然存在。或者更简单一点，直接查看 NFS 的存储目录，应该可以看到 MariaDB 生成的一些数据库文件：  </p>
<h1 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h1><p>首先，你应该先去 Dashboard 的项目网站（<a href="https://github.com/kubernetes/dashboard%EF%BC%89%EF%BC%8C%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5%E3%80%82">https://github.com/kubernetes/dashboard），看一下它的说明文档，了解一下它的基本情况。</a>  </p>
<p>安装：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>这个 YAML 里包含了很多对象，虽然文件比较大，但现在的你应该基本都能够看懂了，要点有这么几个：  </p>
<ul>
<li>所有的对象都属于“kubernetes-dashboard”名字空间。  </li>
<li>Dashboard 使用 Deployment 部署了一个实例，端口号是 8443。  </li>
<li>容器启用了 Liveness 探针，使用 HTTPS 方式检查存活状态。  </li>
<li>Service 对象使用的是 443 端口，它映射了 Dashboard 的 8443 端口。</li>
</ul>
<p>使用命令 kubectl apply部署：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dashboard.yaml</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="API-对象"><a href="#API-对象" class="headerlink" title="API 对象"></a>API 对象</h2><ul>
<li>PersistentVolume：简称 PV，是 Kubernetes 对持久化存储的抽象，代表了 LocalDisk、NFS、Ceph 等存储设备，和 CPU、内存一样，属于集群的公共资源。</li>
</ul>
<p>因为不同存储设备之间的差异很大，为了更好地描述 PV 特征，就出现了 StorageClass，它的作用是分类存储设备，让我们更容易去选择 PV 对象。  </p>
<p>PV 一般由系统管理员来创建，我们如果要使用 PV 就要用 PVC（PersistentVolumeClaim）去申请，说清楚需求的容量、访问模式等参数，然后 Kubernetes 就会查找最合适的 PV 分配给我们使用。  </p>
<p>手动创建 PV 的工作量很大，麻烦而且容易出错，所以就有了“动态存储卷”的概念，需要在 StorageClass 里绑定一个 Provisioner 对象，由它来代替人工，根据 PVC 自动创建出符合要求的 PV。  </p>
<p>有了 PV 和 PVC，我们就可以在 Pod 里用“persistentVolumeClaim”来引用 PVC，创建出可供容器使用的 Volume，然后在容器里用“volumeMounts”把它挂载到某个路径上，这样容器就可以读写 PV，实现数据的持久化存储了。  </p>
<p>持久化存储的一个重要应用领域就是保存应用的状态数据，管理有状态的应用，就要使用新的对象 StatefulSet，可以认为它是管理无状态应用对象 Deployment 的一个特例。  </p>
<ul>
<li>StatefulSet：YAML 描述和 Deployment 非常像，“spec”里只是多了一个“serviceName”字段，但它部署应用的方式却与 Deployment 差距很大——<strong>Deployment 创建的 Pod 是随机的名字，而 StatefulSet 会对 Pod 顺序编号、顺序创建，保证应用有一个确定的启动先后次序，这样就可以实现主从、主备等关系。</strong></li>
</ul>
<p>在使用 Service 为 StatefulSet 创建服务的时候，它也会为每个 Pod 单独创建域名，同样也是顺序编号，保证 Pod 有稳定的网络标识，外部用户就可以用这个域名来准确地访问到某个具体的 Pod。  </p>
<p>StatefulSet 还使用“volumeClaimTemplates”字段来定义持久化存储，里面其实就是一个 PVC，每个 Pod 可以用这个模板来生成自己的 PVC 去申请 PV，实现存储卷与 Pod 的独立绑定。  </p>
<p>通过<strong>启动顺序、稳定域名和存储模板</strong>这三个关键能力，StatefulSet 就可以很好地处理 Redis、MySQL 等有状态应用了。  </p>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>只要编写一个新的 YAML（Deployment、DaemonSet、StatefulSet），再用 kubectl apply 应用就可以了。Kubernetes 采用的是“滚动更新”策略，实际上是两个同步进行的“扩容”和“缩容”动作，这样在更新的过程中始终会有 Pod 处于可用状态，能够平稳地对外提供服务。  </p>
<p>应用的更新历史可以用命令 kubectl rollout history 查看，如果有什么意外，就可以用 kubectl rollout undo 来回退。这两个命令相当于给我们的更新流程上了一个保险，可以放心大胆操作，失败就用“S&#x2F;L 大法”。  </p>
<h3 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h3><p>能够限制容器申请的 CPU 和内存数量，不至于过多或者过少，保持在一个合理的程度，更有利于 Kubernetes 调度。  </p>
<h3 id="健康检查（探针）"><a href="#健康检查（探针）" class="headerlink" title="健康检查（探针）"></a>健康检查（探针）</h3><p>检查探针是 Kubernetes 内置的应用监控工具，有 Startup、Liveness、Readiness 三种，分别探测启动、存活、就绪状态，探测的方式也有 exec、tcpSocket、httpGet 三种。组合运用这些就可以灵活地检查容器的状态，Kubernetes 发现不可用就会重启容器，让应用在总体上处于健康水平。  </p>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>Kubernetes 的集群里虽然有很多计算资源，但毕竟是有限的，除了要给 Pod 加上资源配额，我们也要为集群加上资源配额，方法就是用名字空间，把整体的资源池切分成多个小块，按需分配给不同的用户使用。  </p>
<p>名字空间的资源配额使用的是“ResourceQuota”，除了基本的 CPU 和内存，它还能够限制存储容量和各种 API 对象的数量，这样就可以避免多用户互相挤占，更高效地利用集群资源。  </p>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>Kubernetes 提供了 Metrics Server 和 Prometheus 两个工具：  </p>
<ul>
<li>Metrics Server 专门用来收集 Kubernetes 核心资源指标，可以用 kubectl top 来查看集群的状态，它也是水平自动伸缩对象 HorizontalPodAutoscaler 的前提条件。  </li>
<li>Prometheus，继 Kubernetes 之后的第二个 CNCF 毕业项目，是云原生监控领域的“事实标准”，在集群里部署之后就可以用 Grafana 可视化监控各种指标，还可以集成自动报警等功能。</li>
</ul>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>对于底层的基础网络设施，Kubernetes 定义了平坦的网络模型“IP-per-pod”，实现它就要符合 CNI 标准。常用的网络插件有 Flannel、Calico、Cilium 等，Flannel 使用 Overlay 模式，性能较低，Calico 使用 Route 模式，性能较高。  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v3/k8s-%E9%AB%98%E7%BA%A7map.png">  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群部署WordPress网站-版本1</title>
    <url>/2022/10/04/kubernetes-cluster-deploy-wordpress/</url>
    <content><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p>本文我将尝试用<code>Kubernetes</code>集群上搭建一个<code>WordPress</code>网站，他们的内部逻辑关系如下：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/1.png">  </p>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h2 id="编排-MariaDB-对象"><a href="#编排-MariaDB-对象" class="headerlink" title="编排 MariaDB 对象"></a>编排 MariaDB 对象</h2><p><code>MariaDB</code>需要4个环境变量，比如数据库名、用户名、密码等，在<code>Docker</code>里我们是在命令行里使用参数<code>--env</code>，而在<code>Kubernetes</code>里我们就应该使用<strong>ConfigMap</strong>，为此需要定义一个<code>maria-cm</code>对象：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DATABASE:</span> <span class="string">&#x27;db&#x27;</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">ROOT_PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后我们定义<code>Pod</code>对象<code>maria-pod</code>，把配置信息注入<code>Pod</code>，让<code>MariaDB</code>运行时从环境变量读取这些信息：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">database</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mariadb:10</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">maria</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">envFrom:</span> <span class="comment"># 可以一次性地把 ConfigMap 里的字段全导入进 Pod，并且能够指定变量名的前缀（即这里的 MARIADB_），非常方便。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;MARIADB_&#x27;</span></span><br><span class="line">      <span class="attr">configMapRef:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">maria-cm</span></span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl apply</code>创建：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl apply -f maria-cm.yml </span><br><span class="line">configmap/maria-cm created</span><br><span class="line"></span><br><span class="line"># kubectl apply -f maria-pod.yml </span><br><span class="line">pod/maria-pod created</span><br><span class="line"></span><br><span class="line"># kubectl get cm</span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">maria-cm           4      29s</span><br><span class="line"></span><br><span class="line"># kubectl get pod -o wide</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE    IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">maria-pod   1/1     Running   0          2m9s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>现在数据库就成功地在 Kubernetes 集群里跑起来了，IP 地址是“172.17.0.5”，注意这个地址和 Docker 的不同，是 Kubernetes 里的私有网段。  </p>
<h2 id="编排-WordPress-对象"><a href="#编排-WordPress-对象" class="headerlink" title="编排 WordPress 对象"></a>编排 WordPress 对象</h2><p>先用 ConfigMap 定义它的环境变量：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">HOST:</span> <span class="string">&#x27;172.17.0.5&#x27;</span> <span class="comment"># 必须是 MariaDB Pod 的 IP 地址，如果不写正确 WordPress 会无法正常连接数据库。</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">NAME:</span> <span class="string">&#x27;db&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后我们再编写 WordPress 的 YAML 文件：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">website</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">wordpress:5</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">wp-pod</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">envFrom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;WORDPRESS_DB_&#x27;</span></span><br><span class="line">      <span class="attr">configMapRef:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">wp-cm</span></span><br></pre></td></tr></table></figure>

<p>用 kubectl apply 创建对象：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl apply -f wp-cm.yml </span><br><span class="line">configmap/wp-cm created</span><br><span class="line"></span><br><span class="line"># kubectl apply -f wp-pod.yml </span><br><span class="line">pod/wp-pod created</span><br><span class="line"></span><br><span class="line"># kubectl get cm</span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">maria-cm           4      6m21s</span><br><span class="line">wp-cm              4      27s</span><br><span class="line"></span><br><span class="line"># kubectl get pod -o wide</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">maria-pod   1/1     Running   0          9m13s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">wp-pod      1/1     Running   0          3m29s   172.17.0.6   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h2 id="为-WordPress-Pod-映射端口号，让它在集群外可见"><a href="#为-WordPress-Pod-映射端口号，让它在集群外可见" class="headerlink" title="为 WordPress Pod 映射端口号，让它在集群外可见"></a>为 WordPress Pod 映射端口号，让它在集群外可见</h2><p>因为<code>Pod</code>都是运行在<code>Kubernetes</code>内部的私有网段里的，外界无法直接访问，想要对外暴露服务，需要使用一个专门的<code>kubectl port-forward</code>命令，它专门负责把本机的端口映射到在目标对象的端口号，有点类似<code>Docker</code>的参数<code>-p</code>，经常用于<code>Kubernetes</code>的临时调试和测试。  </p>
<p>我们把本地的“8080”映射到 WordPress Pod 的“80”，kubectl 会把这个端口的所有数据都转发给集群内部的 Pod：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl port-forward wp-pod 8080:80 &amp;  # 让端口转发工作在后台进行</span><br><span class="line">[1] 72858</span><br><span class="line"># Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想关闭端口转发，需要敲命令 fg ，它会把后台的任务带回到前台，然后就可以简单地用“Ctrl + C”来停止转发了。  </p>
<h2 id="创建反向代理的-Nginx，让我们的网站对外提供服务"><a href="#创建反向代理的-Nginx，让我们的网站对外提供服务" class="headerlink" title="创建反向代理的 Nginx，让我们的网站对外提供服务"></a>创建反向代理的 Nginx，让我们的网站对外提供服务</h2><p>因为 WordPress 网站使用了 URL 重定向，直接使用“8080”会导致跳转故障，所以为了让网站正常工作，我们还应该在 Kubernetes 之外启动 Nginx 反向代理，保证外界看到的仍然是“80”端口号。  </p>
<p>Nginx 的配置文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  default_type text/html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">      proxy_http_version 1.1;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_pass http://127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用 docker run -v 命令加载这个配置文件，以容器的方式启动这个 Nginx 代理：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --rm --net=host -v `pwd`/wp.conf:/etc/nginx/conf.d/default.conf nginx:alpine</span><br></pre></td></tr></table></figure>


<p>有了 Nginx 的反向代理之后，我们就可以打开浏览器，输入本机的“127.0.0.1”看到 WordPress 的界面：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/wp1.png">  </p>
<p>也可以在 Kubernetes 里使用命令 kubectl logs 查看 WordPress、MariaDB 等 Pod 的运行日志，来验证它们是否已经正确地响应了请求：  </p>
<h1 id="使用-Dashboard-管理-Kubernetes"><a href="#使用-Dashboard-管理-Kubernetes" class="headerlink" title="使用 Dashboard 管理 Kubernetes"></a>使用 Dashboard 管理 Kubernetes</h1><p>启动<code>Dashboard</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure>

<p>它会自动打开浏览器界面，显示出当前 Kubernetes 集群里的工作负载：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/d1.png">  </p>
<p>点击任意一个 Pod 的名字，就会进入管理界面，可以看到 Pod 的详细信息，而右上角有 4 个很重要的功能，分别可以查看日志、进入 Pod 内部、编辑 Pod 和删除 Pod，相当于执行 logs、exec、edit、delete 命令：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/d2.png">  </p>
<p>ConfigMap&#x2F;Secret 等对象也可以在这里任意查看或编辑：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/d3.png">  </p>
<h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><h2 id="Kubernetes-系统和-Docker-系统的区别在哪里？"><a href="#Kubernetes-系统和-Docker-系统的区别在哪里？" class="headerlink" title="Kubernetes 系统和 Docker 系统的区别在哪里？"></a>Kubernetes 系统和 Docker 系统的区别在哪里？</h2><p>关键就在<strong>对应用的封装</strong>和<strong>网络环境</strong>这两点上。  </p>
<p>现在 WordPress、MariaDB 这两个应用被封装成了 Pod（由于它们都是在线业务，所以 Job&#x2F;CronJob 在这里派不上用场），运行所需的环境变量也都被改写成 ConfigMap，统一用“声明式”来管理，比起 Shell 脚本更容易阅读和版本化管理。  </p>
<p>另外，Kubernetes 集群在内部维护了一个自己的专用网络，这个网络和外界隔离，要用特殊的“端口转发”方式来传递数据，还需要在集群之外用 Nginx 反向代理这个地址，这样才能实现内外沟通。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>容器技术开启了云原生的大潮，但成熟的容器技术，到生产环境的应用部署的时候，却显得“步履维艰”。因为容器只是针对单个进程的隔离和封装，而实际的应用场景却是要求许多的应用进程互相协同工作，其中的各种关系和需求非常复杂，在容器这个技术层次很难掌控。  </p>
<p>为了解决这个问题，容器编排（Container Orchestration）就出现了，它可以说是以前的运维工作在云原生世界的落地实践，本质上还是在集群里调度管理应用程序，只不过管理的主体由人变成了计算机，管理的目标由原生进程变成了容器和镜像。  </p>
<p>而现在，容器编排领域的王者就是——Kubernetes。  </p>
<p>Kubernetes 源自 Borg 系统，它凝聚了 Google 的内部经验和 CNCF 的社区智慧，所以战胜了竞争对手 Apache Mesos 和 Docker Swarm，成为了容器编排领域的事实标准，也成为了云原生时代的基础操作系统，学习云原生就必须要掌握 Kubernetes。  </p>
<p>Kubernetes 的 Master&#x2F;Node 架构是它具有自动化运维能力的关键：<br><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/k8s%E6%9E%B6%E6%9E%84.png">  </p>
<p>Kubernetes 把集群里的计算资源定义为节点（Node），其中又划分成控制面和数据面两类。  </p>
<ul>
<li>控制面是 Master 节点，负责管理集群和运维监控应用，里面的核心组件是 apiserver、etcd、scheduler、controller-manager。  </li>
<li>数据面是 Worker 节点，受 Master 节点的管控，里面的核心组件是 kubelet、kube-proxy、container-runtime。</li>
</ul>
<p>此外，Kubernetes 还支持插件机制，能够灵活扩展各项功能，常用的插件有 DNS 和 Dashboard。  </p>
<p>为了更好地管理集群和业务应用，Kubernetes 从现实世界中抽象出了许多概念，称为“API 对象”，描述这些对象就需要使用 YAML 语言。  </p>
<p>YAML 是 JSON 的超集，但语法更简洁，表现能力更强，更重要的是它以“声明式”来表述对象的状态，不涉及具体的操作细节，这样 Kubernetes 就能够依靠存储在 etcd 里集群的状态信息，不断地“调控”对象，直至实际状态与期望状态相同，这个过程就是 Kubernetes 的自动化运维管理。  </p>
<p>Kubernetes 里有很多的 API 对象，其中最核心的对象是“Pod”，它捆绑了一组存在密切协作关系的容器，容器之间共享网络和存储，在集群里必须一起调度一起运行。通过 Pod 这个概念，Kubernetes 就简化了对容器的管理工作，其他的所有任务都是通过对 Pod 这个最小单位的再包装来实现的。  </p>
<p>除了核心的 Pod 对象，基于“单一职责”和“对象组合”这两个基本原则，又有了 Job&#x2F;CronJob 和 ConfigMap&#x2F;Secret：  </p>
<ul>
<li>Job&#x2F;CronJob 对应的是离线作业，它们逐层包装了 Pod，添加了作业控制和定时规则  </li>
<li>ConfigMap&#x2F;Secret 对应的是配置信息，需要以环境变量或者存储卷的形式注入进 Pod，然后进程才能在运行时使用</li>
</ul>
<p>和 Docker 类似，Kubernetes 也提供一个客户端工具，名字叫“kubectl”，它直接与 Master 节点的 apiserver 通信，把 YAML 文件发送给 RESTful 接口，从而触发 Kubernetes 的对象管理工作流程。  </p>
<p>使用 YAML 描述 API 对象也有固定的格式，必须写的“头字段”是“apiVersion”“kind”“metadata”，它们表示对象的版本、种类和名字等元信息。实体对象如 Pod、Job、CronJob 会再有“spec”字段描述对象的期望状态，最基本的就是容器信息，非实体对象如 ConfigMap、Secret 使用的是“data”字段，记录一些静态的字符串信息。  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress/%E5%88%9D%E7%BA%A7map.png">  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群网络</title>
    <url>/2022/03/01/kubernetes-cluster-network/</url>
    <content><![CDATA[<h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="公司网络架构"><a href="#公司网络架构" class="headerlink" title="公司网络架构"></a>公司网络架构</h2><p><img src="/2022/03/01/kubernetes-cluster-network/network-arch1.png">  </p>
<ul>
<li>路由器：网络出口  </li>
<li>核心层：主要完成数据高效转发、链路备份等  </li>
<li>汇聚层：网络策略、安全、工作站交换机的接入、VLAN之间通信等功能  </li>
<li>接入层：工作站的接入</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p><img src="/2022/03/01/kubernetes-cluster-network/switch.png">  </p>
<p>交换机工作在OSI参考模型的第二次，即数据链路层。交换机拥有一条高带宽的背部总线交换矩阵，在同一时间可进行多个端口对之间的数据传输。  </p>
<p>交换技术分为2层和3层：  </p>
<ul>
<li>2层：主要用于小型局域网，仅支持在数据链路层转发数据，对工作站接入。  </li>
<li>3层：三层交换技术诞生，最初是为了解决广播域的问题，多年发展，三层交换机书已经成为构建中大型网络的主要力量。</li>
</ul>
<p>广播域  </p>
<ul>
<li>交换机在转发数据时会先进行广播，这个广播可以发送的区域就是一个广播域。交换机之间对广播帧是透明的，所以交换机之间组成的网络是一个广播域。  </li>
<li>路由器的一个接口下的网络是一个广播域，所以路由器可以隔离广播域。</li>
</ul>
<p>ARP（地址解析协议，在IPV6中用NDP替代）  </p>
<ul>
<li>发送这个广播帧是由ARP协议实现，ARP是通过IP地址获取物理地址的一个TCP&#x2F;IP协议。</li>
</ul>
<p>三层交换机  </p>
<ul>
<li>前面讲的二层交换机只工作在数据链路层，路由器则工作在网络层。而功能强大的三层交换机可同时工作在数据链路层和网络层，并根据 MAC地址或IP地址转发数据包。</li>
</ul>
<p>VLAN（Virtual Local Area Network）：虚拟局域网  </p>
<ul>
<li>VLAN是一种将局域网设备从逻辑上划分成一个个网段。  </li>
<li>一个VLAN就是一个广播域，VLAN之间的通信是通过第3层的路由器来完成的。VLAN应用非常广泛，基本上大部分网络项目都会划分vlan。</li>
</ul>
<p>VLAN的主要好处：  </p>
<ul>
<li>分割广播域，减少广播风暴影响范围。  </li>
<li>提高网络安全性，根据不同的部门、用途、应用划分不同网段。</li>
</ul>
<h2 id="路由技术"><a href="#路由技术" class="headerlink" title="路由技术"></a>路由技术</h2><p><img src="/2022/03/01/kubernetes-cluster-network/router.png">  </p>
<p>路由器主要分为两个端口类型：LAN口和WAN口  </p>
<ul>
<li>WAN口：配置公网IP，接入到互联网，转发来自LAN口的IP数据包。  </li>
<li>LAN口：配置内网IP（网关），连接内部交换机。</li>
</ul>
<p>路由器是连接两个或多个网络的硬件设备，将从端口上接收的数据包，根据数据包的目的地址智能转发出去。  </p>
<p>路由器的功能  </p>
<ul>
<li>路由  </li>
<li>转发  </li>
<li>隔离子网  </li>
<li>隔离广播域</li>
</ul>
<p>路由器是互联网的枢纽，是连接互联网中各个局域网、广域网的设备，相比交换机来说，路由器的数据转发很复杂，它会根据目的地址给出一条最优的路径。那么路径信息的来源有两种：<strong>动态路由和静态路由。</strong>  </p>
<ul>
<li>静态路由：指人工手动指定到目标主机的地址然后记录在路由表中，如果其中某个节点不可用则需要重新指定。  </li>
<li>动态路由：则是路由器根据动态路由协议自动计算出路径永久可用，能实时地<strong>适应网络结构</strong>的变化。</li>
</ul>
<p>常用的动态路由协议  </p>
<ul>
<li>RIP（ Routing Information Protocol ，路由信息协议）  </li>
<li>OSPF（Open Shortest Path First，开放式最短路径优先）  </li>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
</ul>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI（Open System Interconnection）是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。  </p>
<table>
<thead>
<tr>
<th><strong>层次</strong></th>
<th><strong>名称</strong></th>
<th><strong>功能</strong></th>
<th><strong>协议数据单元（PDU）</strong></th>
<th><strong>常见协议</strong></th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层</td>
<td>为用户的应用程序提供网络服务，提供一个接口。</td>
<td>数据</td>
<td>HTTP、FTP、Telnet</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>数据格式转换、数据加密&#x2F;解密</td>
<td>数据单元</td>
<td>ASCII</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>建立、管理和维护会话</td>
<td>数据单元</td>
<td>SSH、RPC</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>建立、管理和维护端到端的连接</td>
<td>段&#x2F;报文</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>IP选址及路由选择</td>
<td>分组&#x2F;包</td>
<td>IP、ICMP、RIP、OSPF</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>硬件地址寻址，差错效验等。</td>
<td>帧</td>
<td>ARP、WIFI</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>利用物理传输介质提供物理连接，传送比特流。</td>
<td>比特流</td>
<td>RJ45、RJ11</td>
</tr>
</tbody></table>
<p><img src="/2022/03/01/kubernetes-cluster-network/osi-table.png">  </p>
<h2 id="TCP-x2F-UDP协议"><a href="#TCP-x2F-UDP协议" class="headerlink" title="TCP&#x2F;UDP协议"></a>TCP&#x2F;UDP协议</h2><p>TCP（Transmission Control Protocol，传输控制协议），面向连接协议，双方先建立可靠的连接，再发送数据。适用于传输数据量大，可靠性要求高的应用场景。  </p>
<p>UDP（User Data Protocol，用户数据报协议），面向非连接协议，不与对方建立连接，直接将数据包发送给对方。适用于一次只传输少量的数据，可靠性要求低的应用场景。相对TCP传输速度快。  </p>
<h1 id="Kubernetes网络模型"><a href="#Kubernetes网络模型" class="headerlink" title="Kubernetes网络模型"></a>Kubernetes网络模型</h1><p><img src="/2022/03/01/kubernetes-cluster-network/k8s%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82.png">  </p>
<p>Kubernetes 要求所有的网络插件实现必须满足如下要求：  </p>
<ul>
<li>一个Pod一个IP  </li>
<li>所有的 Pod 可以与任何其他 Pod 直接通信，无需使用 NAT 映射  </li>
<li>所有节点可以与所有 Pod 直接通信，无需使用 NAT 映射  </li>
<li>Pod内部获取到的<code>IP</code>地址与其他 Pod 或节点与其通信时的<code>IP</code>地址是同一个。</li>
</ul>
<h2 id="Docker容器网络模型"><a href="#Docker容器网络模型" class="headerlink" title="Docker容器网络模型"></a>Docker容器网络模型</h2><p>先看下Linux网络名词：  </p>
<ul>
<li><strong>网络的命名空间：</strong>Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；Docker利用这一特性，实现不同容器间的网络隔离。  </li>
<li><strong>Veth设备对：</strong>Veth设备对的引入是为了实现在不同网络命名空间的通信。  </li>
<li><strong>Iptables&#x2F;Netfilter：</strong>Docker使用Netfilter实现容器网络转发。  </li>
<li><strong>网桥：</strong>网桥是一个二层网络设备，通过网桥可以将Linux支持的不同的端口连接起来，并实现类似交换机那样的多对多的通信。  </li>
<li><strong>路由：</strong>Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。</li>
</ul>
<p>Docker容器网络示意图如下：  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/docker-network.png">  </p>
<h2 id="Pod-网络"><a href="#Pod-网络" class="headerlink" title="Pod 网络"></a>Pod 网络</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="二层交换方案"><a href="#二层交换方案" class="headerlink" title="二层交换方案"></a>二层交换方案</h4><ul>
<li>Pods与Nodes处于同一个二层广播域  </li>
<li>Node的物理网卡桥接到虚拟网桥，开启混杂模式，这样可以将目的MAC地址不是自己的包也转发到Linux Bridge  </li>
<li>适用于小型Kubernetes集群部署</li>
</ul>
<p><img src="/2022/03/01/kubernetes-cluster-network/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%96%B9%E6%A1%88.png">  </p>
<h4 id="三层路由方案"><a href="#三层路由方案" class="headerlink" title="三层路由方案"></a>三层路由方案</h4><ul>
<li>通过路由而不是交换的方式实现pod网络  </li>
<li>更具扩展性  </li>
<li>在集群添加或删除Node时自动维护路由表</li>
</ul>
<p><img src="/2022/03/01/kubernetes-cluster-network/%E4%B8%89%E5%B1%82%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%881.png">  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/%E4%B8%89%E5%B1%82%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%882.png">  </p>
<h4 id="Overlay网络方案"><a href="#Overlay网络方案" class="headerlink" title="Overlay网络方案"></a>Overlay网络方案</h4><p><img src="/2022/03/01/kubernetes-cluster-network/overlay%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88.png">  </p>
<ul>
<li>优点：最大程度的保留原来网络结构，保证原有网络尽量不做改造。  </li>
<li>不足：Overlay网络方案在传输性能上无法与二层、三层方案相比。  </li>
<li>在节点上维护Overlay网络相关路由，实现Pod与Node间的直接通信。</li>
</ul>
<p><img src="/2022/03/01/kubernetes-cluster-network/overlay%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88%E5%9B%BE.png">  </p>
<h4 id="Pod网络实现方案对比"><a href="#Pod网络实现方案对比" class="headerlink" title="Pod网络实现方案对比"></a>Pod网络实现方案对比</h4><ul>
<li>二层方案：简单，性能好，但难于扩展，适用于小规模实验环境  </li>
<li>三层方案：目前生产环境主流使用的一种方案。原生网络的性能是它的优势，同时还具备相比于二层方案更为良好的扩展性。  </li>
<li>Overlay方案：最大优势不改动现有网络结构，但额外负担大导致网络性能不佳。</li>
</ul>
<p><strong>问题：</strong>Pod是K8S最小调度单元，一个Pod由一个容器或多个容器组成，当多个容器时，怎么都用这一个Pod IP？  </p>
<p><strong>实现：</strong>k8s会在每个Pod里先启动一个infra container小容器，然后让其他的容器连接进来这个网络命名空间，然后其他容器看到的网络试图就完全一样了。即网络设备、IP地址、Mac地址等。这就是解决网络共享的一种解法。在Pod的IP地址就是infra container的IP地址。  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/c-to-c.png">  </p>
<p>在 Kubernetes中，每一个<code>Pod</code>都有一个真实的<code>IP</code>地址，并且每一个<code>Pod</code>都可以使用此<code>IP</code>地址与其他<code>Pod</code>通信。  </p>
<p>Pod之间通信会有两种情况：  </p>
<ul>
<li>两个Pod在同一个Node上  </li>
<li>两个Pod在不同Node上</li>
</ul>
<h3 id="第一种情况：两个Pod在同一个Node上"><a href="#第一种情况：两个Pod在同一个Node上" class="headerlink" title="第一种情况：两个Pod在同一个Node上"></a>第一种情况：两个Pod在同一个Node上</h3><p>同节点Pod之间通信道理与Docker网络一样的，如下图：  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/pod-to-pod-2.gif">  </p>
<ol>
<li>对 Pod1 来说，eth0 通过虚拟以太网设备（veth0）连接到 root namespace；  </li>
<li>网桥 cbr0 中为 veth0 配置了一个网段。一旦数据包到达网桥，网桥使用ARP 协议解析出其正确的目标网段 veth1；  </li>
<li>网桥 cbr0 将数据包发送到 veth1；  </li>
<li>数据包到达 veth1 时，被直接转发到 Pod2 的 network namespace 中的 eth0 网络设备。</li>
</ol>
<h3 id="第二种情况：两个Pod在不同Node上"><a href="#第二种情况：两个Pod在不同Node上" class="headerlink" title="第二种情况：两个Pod在不同Node上"></a>第二种情况：两个Pod在不同Node上</h3><p>K8S网络模型要求Pod IP在整个网络中都可访问，这种需求是由第三方网络组件实现。  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/pod-to-pod-3.gif">  </p>
<h3 id="CNI（容器网络接口）"><a href="#CNI（容器网络接口）" class="headerlink" title="CNI（容器网络接口）"></a>CNI（容器网络接口）</h3><p><a href="https://github.com/containernetworking/cni">CNI&#x2F;Container Network Interface，容器网络接口</a>：是一个容器网络规范，Kubernetes网络采用的就是这个CNI规范，CNI实现依赖两种插件，一种CNI Plugin是负责容器连接到主机，另一种是IPAM负责配置容器网络命名空间的网络。  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/CNI%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9E%8B.png">  </p>
<p>CNI工作流程<br>容器<code>runtime</code>调用CNI网络插件实现网络配置：  </p>
<ul>
<li>一般CNI网络插件是以独立的可执行文件形式存在  </li>
<li>调用插件时，数据通过两种方式传递给插件：环境变量和标准输入。  </li>
<li>CNI将容器添加到特定网络的一般流程。</li>
</ul>
<p><img src="/2022/03/01/kubernetes-cluster-network/CNI%E6%8F%92%E4%BB%B6.png">  </p>
<p>CNI插件默认路径：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /opt/cni/bin/</span><br></pre></td></tr></table></figure>

<p>当你在宿主机上部署Flanneld后，flanneld 启动后会在每台宿主机上生成它对应的CNI 配置文件（它其实是一个 ConfigMap），从而告诉Kubernetes，这个集群要使用 Flannel 作为容器网络方案。  </p>
<p>CNI配置文件路径：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/cni/net.d/10-flannel.conflist</span><br></pre></td></tr></table></figure>

<p>当 kubelet 组件需要创建 Pod 的时候，先调用dockershim它先创建一个 Infra 容器。然后调用 CNI 插件为 Infra 容器配置网络。  </p>
<p>这两个路径在kubelet启动参数中定义：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--network-plugin=cni \</span><br><span class="line">--cni-conf-dir=/etc/cni/net.d \</span><br><span class="line">--cni-bin-dir=/opt/cni/bin</span><br></pre></td></tr></table></figure>

<h1 id="Kubernetes网络组件之-Flannel"><a href="#Kubernetes网络组件之-Flannel" class="headerlink" title="Kubernetes网络组件之 Flannel"></a>Kubernetes网络组件之 Flannel</h1><p>Flannel是CoreOS维护的一个网络组件，Flannel为每个Pod提供全局唯一的IP，Flannel使用ETCD来存储Pod子网与Node IP之间的关系。flanneld守护进程在每台主机上运行，并负责维护ETCD信息和路由数据包。  </p>
<h2 id="Flannel-部署"><a href="#Flannel-部署" class="headerlink" title="Flannel 部署"></a>Flannel 部署</h2><p><a href="https://github.com/coreos/flannel">github地址</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<h2 id="Flannel工作模式及原理"><a href="#Flannel工作模式及原理" class="headerlink" title="Flannel工作模式及原理"></a>Flannel工作模式及原理</h2><p>Flannel支持多种数据转发方式：  </p>
<ul>
<li>UDP：最早支持的一种方式，由于性能最差，目前已经弃用。  </li>
<li>VXLAN：Overlay Network方案，源数据包封装在另一种网络包里面进行路由转发和通信  </li>
<li>Host-GW：Flannel通过在各个节点上的Agent进程，将容器网络的路由信息刷到主机的路由表上，这样一来所有的主机都有整个容器网络的路由数据了。</li>
</ul>
<h3 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubeadm部署指定Pod网段</span><br><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"># 二进制部署指定</span><br><span class="line">cat /opt/kubernetes/cfg/kube-controller-manager.conf</span><br><span class="line">--allocate-node-cidrs=true \</span><br><span class="line">--cluster-cidr=10.244.0.0/16 \</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kube-flannel.yml</span><br><span class="line">net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。下图flannel.1的设备就是VXLAN所需的VTEP设备。示意图如下：  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/flanneld-vxlan.png">  </p>
<p>如果Pod 1访问Pod 2，源地址10.244.1.10，目的地址10.244.2.10 ，数据包传输流程如下：  </p>
<ul>
<li><ol>
<li><strong>容器路由：</strong>容器根据路由表从eth0发出  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip route</span><br><span class="line">default via 10.244.0.1 dev eth0 </span><br><span class="line">10.244.0.0/24 dev eth0 scope link  src 10.244.0.45 </span><br><span class="line">10.244.0.0/16 via 10.244.0.1 dev eth0 </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li><strong>主机路由：</strong>数据包进入到宿主机虚拟网卡cni0，根据路由表转发到flannel.1虚拟网卡，也就是来到了隧道的入口。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip route</span><br><span class="line">default via 192.168.31.1 dev ens33 proto static metric 100 </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 </span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink </span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li><strong>VXLAN封装：</strong>而这些VTEP设备（二层）之间组成二层网络必须要知道目的MAC地址。这个MAC地址从哪获取到呢？其实在flanneld进程启动后，就会自动添加其他节点ARP记录，可以通过ip命令查看，如下所示：   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip neigh show dev flannel.1</span><br><span class="line">10.244.1.0 lladdr ca:2a:a4:59:b6:55 PERMANENT</span><br><span class="line">10.244.2.0 lladdr d2:d0:1b:a7:a9:cd PERMANENT</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li><strong>二次封包：</strong>知道了目的MAC地址，封装二层数据帧（容器源IP和目的IP）后，对于宿主机网络来说这个帧并没有什么实际意义。接下来，Linux内核还要把这个数据帧进一步封装成为宿主机网络的一个普通数据帧，好让它载着内部数据帧，通过宿主机的eth0网卡进行传输。<br><img src="/2022/03/01/kubernetes-cluster-network/vxlan-pkg.png"></li>
</ol>
</li>
<li><p>5.<strong>封装到UDP包发出去：</strong>现在能直接发UDP包嘛？到目前为止，我们只知道另一端的flannel.1设备的MAC地址，却不知道对应的宿主机地址是什么。<br>flanneld进程也维护着一个叫做FDB的转发数据库，可以通过bridge fdb命令查看：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bridge fdb show  dev flannel.1</span><br><span class="line">d2:d0:1b:a7:a9:cd dst 192.168.31.61 self permanent</span><br><span class="line">ca:2a:a4:59:b6:55 dst 192.168.31.63 self permanent</span><br></pre></td></tr></table></figure>
<p>可以看到，上面用的对方flannel.1的MAC地址对应宿主机IP，也就是UDP要发往的目的地。使用这个目的IP进行封装。  </p>
</li>
<li><p>6.<strong>数据包到达目的宿主机：</strong>Node1的eth0网卡发出去，发现是VXLAN数据包，把它交给flannel.1设备。flannel.1设备则会进一步拆包，取出原始二层数据帧包，发送ARP请求，经由cni0网桥转发给container。</p>
</li>
</ul>
<h3 id="Host-GW"><a href="#Host-GW" class="headerlink" title="Host-GW"></a>Host-GW</h3><p>host-gw模式相比vxlan简单了许多， 直接添加路由，将目的主机当做网关，直接路由原始封包。  </p>
<p>下面是示意图：  </p>
<p><img src="/2022/03/01/kubernetes-cluster-network/flanneld-hostgw.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kube-flannel.yml</span><br><span class="line">net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;host-gw&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当你设置flannel使用host-gw模式,flanneld会在宿主机上创建节点的路由表：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip route</span><br><span class="line">default via 192.168.31.1 dev ens33 proto static metric 100 </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 </span><br><span class="line">10.244.1.0/24 via 192.168.31.63 dev ens33 </span><br><span class="line">10.244.2.0/24 via 192.168.31.61 dev ens33 </span><br><span class="line">192.168.31.0/24 dev ens33 proto kernel scope link src 192.168.31.62 metric 100 </span><br></pre></td></tr></table></figure>

<p>目的 IP 地址属于 10.244.1.0&#x2F;24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址是 192.168.31.63（即：via 192.168.31.63）。  </p>
<p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。  </p>
<p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.1.20，即 container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 container-2 当中。  </p>
<h1 id="Service——解决Pod的短暂性问题"><a href="#Service——解决Pod的短暂性问题" class="headerlink" title="Service——解决Pod的短暂性问题"></a>Service——解决Pod的短暂性问题</h1><h2 id="Service的特性"><a href="#Service的特性" class="headerlink" title="Service的特性"></a>Service的特性</h2><p>Service解决了因Pod的短暂性给开发者带来的开发复杂性问题  </p>
<ul>
<li>Service是面向Kubernetes云应用的基本构建单元  </li>
<li>Service通过Pod label以及label selector与pod(endpoint)自动建立关联  </li>
<li>Service会将来自客户端的请求流量自动负载到后面的endpoints上</li>
</ul>
<h2 id="Service网络"><a href="#Service网络" class="headerlink" title="Service网络"></a>Service网络</h2><ul>
<li>Cluster IP：Kubernetes集群赋予每个Service在集群内部不变的IP地址  </li>
<li>Service网络：所有Service的Cluster IP地址组合而成的“虚拟网络”  </li>
<li>通过NodePort将网络暴露到集群外部<br><code>外部请求 -&gt; NodeIP:NodePort -&gt; ClusterIP:Port -&gt; ContainerIP:TargetPort</code></li>
</ul>
]]></content>
      <categories>
        <category>Learn-Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 入门</title>
    <url>/2022/02/10/kubernetes-get-start/</url>
    <content><![CDATA[<h1 id="k8s基本介绍"><a href="#k8s基本介绍" class="headerlink" title="k8s基本介绍"></a>k8s基本介绍</h1><h2 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h2><ul>
<li>k8s是谷歌开源的容器集群管理系统  </li>
<li>可以简化应用程序的工作流，加快开发速度</li>
</ul>
<h2 id="为什么需要k8s"><a href="#为什么需要k8s" class="headerlink" title="为什么需要k8s"></a>为什么需要k8s</h2><ul>
<li>真正的生产型应用会涉及多个容器  </li>
<li>容器必须跨多个服务器主机进行部署  </li>
<li>借助k8s构建多个容器的应用服务、跨集群调度、扩展这些容器</li>
</ul>
<h2 id="k8s有哪些应用"><a href="#k8s有哪些应用" class="headerlink" title="k8s有哪些应用"></a>k8s有哪些应用</h2><ul>
<li>跨多台主机进行容器编排  </li>
<li>更加充分地利用硬件，最大程度获取运行企业应用所需的资源  </li>
<li>利用自动布局、自动重启、自动复制以及自动扩展功能，对应用设施状况检查和自我修复</li>
</ul>
<h1 id="k8s相关术语"><a href="#k8s相关术语" class="headerlink" title="k8s相关术语"></a>k8s相关术语</h1><ul>
<li>主机（Master）：用于复制k8s节点的计算机。所有任务分配都来自于此。  </li>
<li>节点（Node）：负责执行请求和所分配任务的计算机。由k8s主机负责对节点进行控制。  </li>
<li>容器集（Pod）：被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个IP地址、IPC、主机名称及其它资源。  </li>
<li>服务（Service）：将工作内容与容器集分离。  </li>
<li>kubelet：运行在节点上的服务，可读取容器清单（container mainfest），确保指定的容器启动并运行。  </li>
<li>kubectl：k8s的命令行配置工具。</li>
</ul>
<h1 id="k8s架构图"><a href="#k8s架构图" class="headerlink" title="k8s架构图"></a>k8s架构图</h1><p><img src="/2022/02/10/kubernetes-get-start/k8s%E6%9E%B6%E6%9E%84%E5%9B%BE.png">  </p>
<p><img src="/2022/02/10/kubernetes-get-start/k8s%E6%9E%B6%E6%9E%84%E5%9B%BE2.png">  </p>
<h1 id="k8s核心组件"><a href="#k8s核心组件" class="headerlink" title="k8s核心组件"></a>k8s核心组件</h1><ul>
<li>集群管理入口：kube-apiserver  </li>
<li>管理控制中心：kube-controller-manager  </li>
<li>调度器：kube-scheduler  </li>
<li>配置中心：etcd  </li>
<li>集群管理工具：kubectl  </li>
<li>节点Pod管家：kubelet  </li>
<li>服务外部代理：kube-proxy</li>
</ul>
<h2 id="apiserver架构解析"><a href="#apiserver架构解析" class="headerlink" title="apiserver架构解析"></a>apiserver架构解析</h2><p><img src="/2022/02/10/kubernetes-get-start/apiserver%E6%9E%B6%E6%9E%84.png">  </p>
<h2 id="k8s应用创建流程和监听机制"><a href="#k8s应用创建流程和监听机制" class="headerlink" title="k8s应用创建流程和监听机制"></a>k8s应用创建流程和监听机制</h2><p><img src="/2022/02/10/kubernetes-get-start/k8s%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6.png">  </p>
<h2 id="k8s核心组件-Controller-Manager"><a href="#k8s核心组件-Controller-Manager" class="headerlink" title="k8s核心组件-Controller Manager"></a>k8s核心组件-Controller Manager</h2><ul>
<li>副本控制器：Replication Controller  </li>
<li>节点控制器：Node Controller  </li>
<li>资源控制器：ResourceQuota Controller  </li>
<li>命名空间控制器：Namespace Controller  </li>
<li>Endpoints控制器：Endpoints Controller  </li>
<li>服务控制器：Service Controller</li>
</ul>
<h2 id="k8s核心组件-Replication-Manager职责"><a href="#k8s核心组件-Replication-Manager职责" class="headerlink" title="k8s核心组件-Replication Manager职责"></a>k8s核心组件-Replication Manager职责</h2><ul>
<li>确保在当前集群中有且仅有N个Pod实例，N是在RC中定义的Pod副本数量  </li>
<li>通过调整RC的spec.replicas属性值来实现系统扩容或缩容  </li>
<li>通过改变RC中的Pod模板（主要是镜像版本）来实现系统的滚动升级</li>
</ul>
<h2 id="k8s核心组件-ResourceQuota-Manager三个层次资源配额管理"><a href="#k8s核心组件-ResourceQuota-Manager三个层次资源配额管理" class="headerlink" title="k8s核心组件-ResourceQuota Manager三个层次资源配额管理"></a>k8s核心组件-ResourceQuota Manager三个层次资源配额管理</h2><ul>
<li>容器级别：可以对CPU和Memory进行限制  </li>
<li>Pod级别：可以对一个Pod内所有容器的可用资源进行限制  </li>
<li>Namespace级别：为Namespace（多租户）级别的资源限制，包括：Pod、RC、Service、ResourceQuota、Secret、PV数量</li>
</ul>
<h2 id="k8s核心组件-Endpoints-Controller说明"><a href="#k8s核心组件-Endpoints-Controller说明" class="headerlink" title="k8s核心组件-Endpoints Controller说明"></a>k8s核心组件-Endpoints Controller说明</h2><p><img src="/2022/02/10/kubernetes-get-start/endpoint.png">  </p>
<h2 id="k8s核心组件-Service-Controller说明"><a href="#k8s核心组件-Service-Controller说明" class="headerlink" title="k8s核心组件-Service Controller说明"></a>k8s核心组件-Service Controller说明</h2><ul>
<li>监听Service的变化  </li>
<li>如果Service是一个LoadBalancer类型，则维护LoadBalancer表</li>
</ul>
<h1 id="kubectl常用命令讲解"><a href="#kubectl常用命令讲解" class="headerlink" title="kubectl常用命令讲解"></a>kubectl常用命令讲解</h1><h2 id="命令式资源管理"><a href="#命令式资源管理" class="headerlink" title="命令式资源管理"></a>命令式资源管理</h2><ul>
<li>创建：create（创建一个资源），expose（暴露一个资源）  </li>
<li>更新：scale（扩展资源），annotate（添加备注）、label（标签）  </li>
<li>删除：delete（删除资源）</li>
</ul>
<h2 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h2><ul>
<li>get：显示一个或多个资源的详细信息  </li>
<li>describe：聚合了相关的信息并输出，比get命令输出的信息更详细。</li>
</ul>
<h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><ul>
<li>log：查看容器log  </li>
<li>exec：执行命令  </li>
<li>cp：用于从容器与物理机文件的拷贝</li>
</ul>
<h2 id="kubectl语法"><a href="#kubectl语法" class="headerlink" title="kubectl语法"></a>kubectl语法</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] [flags]</span><br></pre></td></tr></table></figure>

<ul>
<li>get：kubectl get pod,svc  </li>
<li>log：kubectl log mysql  </li>
<li>exec：kubectl exec -it mysql &#x2F;bin&#x2F;bash</li>
</ul>
<h2 id="k8s中常用资源类型简写"><a href="#k8s中常用资源类型简写" class="headerlink" title="k8s中常用资源类型简写"></a>k8s中常用资源类型简写</h2><ul>
<li>Ing：ingresses的简写  </li>
<li>no：表示集群的nodes节点  </li>
<li>ns：namespace命名空间的简写  </li>
<li>rs：replicasets的简写  </li>
<li>svc：代表服务services  </li>
<li>ep：endpoints的简写</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>Kubernetes网络原理——单机容器网络</title>
    <url>/2022/09/12/kubernetes-network-principle-a-single-machine-container/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h2><p>包括了：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。对于一个进程来说，这些要素，其实就构成了它发起和响应网络请求的基本环境。  </p>
<p>注意：作为一个容器，它可以声明直接使用宿主机的网络栈（–net&#x3D;host），即：不开启 Network Namespace，比如：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器启动后，直接监听的就是宿主机的 80 端口。</span></span><br><span class="line">docker run –d –net=host --name nginx-host nginx</span><br></pre></td></tr></table></figure>

<p>像这样直接使用宿主机网络栈的方式，虽然可以为容器提供良好的网络性能，但也会不可避<br>免地引入共享网络资源的问题，比如端口冲突。<br>所以，在大多数情况下，我们都希望容器进程能使用自己 Network Namespace 里的网络栈，即：<strong>拥有属于自己的 IP 地址和端口。</strong>  </p>
<h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>能够起到虚拟交换机作用的网络设备，它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。  </p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="被隔离的容器进程，跟其他-Network-Namespace-里的容器进程进行交互"><a href="#被隔离的容器进程，跟其他-Network-Namespace-里的容器进程进行交互" class="headerlink" title="被隔离的容器进程，跟其他 Network Namespace 里的容器进程进行交互"></a>被隔离的容器进程，跟其他 Network Namespace 里的容器进程进行交互</h2><p>为了实现上述目的，Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。  </p>
<p>如何把这些容器“连接”到 docker0 网桥上呢？——使用一种名叫Veth Pair的虚拟设备  </p>
<p>Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成<br>对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。比如：  </p>
<p>启动了一个叫作 nginx-1 的容器：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run –d --name nginx-1 nginx</span><br></pre></td></tr></table></figure>

<p>然后进入到这个容器中查看一下它的网络设备：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 nginx-1 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx-1 /bin/bash</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/nginx-1-ifconfig.png">  </p>
<p>启动了一个叫作 nginx-2 的容器：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run –d --name nginx-2 nginx</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/nginx-2-ifconfig.png">  </p>
<p>如果你在 nginx-1 容器里 ping 一下 nginx-2 容器的 IP 地址（172.17.0.3），就会发现同一宿主机上的两个容器默认就是相互连通的。  </p>
<p>这其中的原理：当你在 nginx-1 容器里访问 nginx-2 容器的 IP 地址（比如 ping 172.17.0.3）的时候，这个目的 IP 地址会匹配到 nginx-1 容器里的第二条路由规则。可以看到，这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的IP包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机。  </p>
<p>而要通过二层网络到达 nginx-2 容器，就需要有 172.17.0.3 这个 IP 地址对应的 MAC 地址。所以 nginx-1 容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过IP地址查找对应的 MAC 地址。  </p>
<p>总结：同一个宿主机上的不同容器通过 docker0 网桥进行通信的流程：<br><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/docker0-1.png">  </p>
<p>因此，可以理解为：<strong>默认情况下，被限制在 Network Namespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了跟同其他容器的数据交换。</strong>  </p>
<p>与之类似地，当你在一台宿主机上，访问该宿主机上的容器的 IP 地址时，这个请求的数据<br>包，也是先根据路由规则到达 docker0 网桥，然后被转发到对应的 Veth Pair 设备，最后出现在容器里。这个过程的示意图：<br><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/docker0-2.png">  </p>
<p>同样地，当一个容器试图连接到另外一个宿主机时，比如：ping 10.168.0.3，它发出的请<br>求数据包，首先经过 docker0 网桥出现在宿主机上。然后根据宿主机的路由表里的直连路<br>由规则（10.168.0.0&#x2F;24 via eth0)），对 10.168.0.3 的访问请求就会交给宿主机的 eth0 处理。  </p>
<p>所以，这个数据包就会经宿主机的 eth0 网卡转发到宿主机网络上，最终到达10.168.0.3 对应的宿主机上。<br><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/docker0-3.png">  </p>
<p>类比一下，如果我们通过软件的方式，创建一个整个集群“公用”的网桥，然后把集群里的所有容器都连接到这个网桥上，不就可以相互通信了吗？<br><img src="/2022/09/12/kubernetes-network-principle-a-single-machine-container/docker0-4.png">  </p>
<p>构建这种容器网络的核心在于：我们需要在已有的宿主机网络上，再通过软件构建一个覆盖在已有宿主机网络之上的、可以把所有容器连通在一起的虚拟网络。所以，这种技术就被称为：<strong>Overlay Network（覆盖网络）</strong>。  </p>
<p>而这个 Overlay Network 本身，可以由每台宿主机上的一个“特殊网桥”共同组成。  </p>
<p>比如，当 Node 1 上的 Container 1 要访问 Node 2 上的 Container 3 的时候，Node 1 上的“特殊网桥”在收到数据包之后，能够通过某种方式，把数据包发送到正确的宿主机，比如 Node 2 上。而 Node 2 上的“特殊网桥”在收到数据包后，也能够通过某种方式，把数据包转发给正确的容器，比如 Container 3。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>容器要想跟外界进行通信，它发出的 IP 包就必须从它的<code>Network Namespace</code>里出来，来到宿主机上。而解决这个问题的方法就是：为容器创建一个一端在容器里充当默认网卡、另一端在宿主机上的<code>Veth Pair</code>设备。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>容器</tag>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes网络原理——容器跨主机网络</title>
    <url>/2022/09/12/kubernetes-network-principle-container-accross-host-network/</url>
    <content><![CDATA[<h1 id="Flannel介绍"><a href="#Flannel介绍" class="headerlink" title="Flannel介绍"></a>Flannel介绍</h1><p>要理解容器“跨主通信”的原理，就一定要先从<code>Flannel</code>这个项目开始。  </p>
<p>Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现（种容器跨主网络的主流实现方法。），分别是：  </p>
<ul>
<li>VXLAN  </li>
<li>host-gw  </li>
<li>UDP</li>
</ul>
<h1 id="UDP模式"><a href="#UDP模式" class="headerlink" title="UDP模式"></a>UDP模式</h1><p>UDP 模式，是 Flannel 项目最早支持的一种方式，却也是性能最差的一种方式。<br>所以，这个模式目前已经被弃用。<br>不过，Flannel 之所以最先选择 UDP 模式，就是因为这种模式是最直接、也是最容易理解的容器跨主网络实现。<br><img src="/2022/09/12/kubernetes-network-principle-container-accross-host-network/flannal-udp.png">  </p>
<p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”<br>，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。  </p>
<p>相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，<br>仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：<br><img src="/2022/09/12/kubernetes-network-principle-container-accross-host-network/TUN.png">  </p>
<ul>
<li>第一次：用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；  </li>
<li>第二次：IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；  </li>
<li>第三次：flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的eth0 发出去。</li>
</ul>
<p>此外，我们还可以看到，Flannel 进行 UDP 封装（Encapsulation）和解封装<br>（Decapsulation）的过程，也都是在用户态完成的。在 Linux 操作系统中，上述这些上下文切换和用户态操作的代价其实是比较高的，这也正是造成 Flannel UDP 模式性能不好的主要原因。  </p>
<p>因此，<strong>在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。</strong>  </p>
<h1 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h1><p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。<br>VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）。  </p>
<h2 id="VXLAN-的覆盖网络的设计思想"><a href="#VXLAN-的覆盖网络的设计思想" class="headerlink" title="VXLAN 的覆盖网络的设计思想"></a>VXLAN 的覆盖网络的设计思想</h2><p>在现有的三层网络之上，“覆盖”一层虚拟的、由内核VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。  </p>
<p>而为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为<br>“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。  </p>
<p>而 VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似。<br>只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）。  </p>
<p><img src="/2022/09/12/kubernetes-network-principle-container-accross-host-network/flannel-VALAN.png">  </p>
<ul>
<li><p>图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。  </p>
</li>
<li><p>现在，我们的 container-1 的 IP 地址是 10.1.15.2，要访问的 container-2 的 IP 地址是10.1.16.3。当 container-1 发出请求之后，这个目的地址是10.1.16.3 的 原始 IP包，会先出现在 docker0 网桥，然后被路由到本机 flannel.1 设备进行处理。为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。而这个设备的信息，正是每台宿主机上的 flanneld 进程负责维护的。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>Flannel UDP </code>和<code>Flannel VALAN</code>模式其实都可以称作“隧道”机制，也是很多其他容器网络插件的基础。比如 Weave 的两种模式，以及 Docker 的 Overlay 模式。  </li>
<li>XLAN 模式组建的覆盖网络，其实就是一个由不同宿主机上的 VTEP 设备，也就是flannel.1 设备组成的虚拟二层网络。对于 VTEP 设备来说，它发出的“内部数据帧”就仿佛是一直在这个虚拟的二层网络上流动。这也正是覆盖网络的含义。  </li>
<li>如果你想要在集群中实践 Flannel 的话，可以在 Master节点上执行如下命令来替换网络插件：  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">MY_ZUES_CHAR</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/cni/net.d/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步</span></span><br><span class="line">kubectl delete -f <span class="string">&quot;https://cloud.weave.works/k8s/net?k8s-version=1.11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步</span></span><br><span class="line">在/etc/kubernetes/manifests/kube-controller-manager.yaml里，为容器启动命令添加如下两个参数：</span><br><span class="line">--allocate-node-cidrs=<span class="literal">true</span></span><br><span class="line">--cluster-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步，重启所有的kubelet</span></span><br><span class="line"><span class="comment"># 第五步</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cdflannel.yml</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>容器</tag>
        <tag>网络原理</tag>
        <tag>跨主机</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes弹性伸缩</title>
    <url>/2022/03/01/kubernetes-hpa/</url>
    <content><![CDATA[<h1 id="传统弹性伸缩的困境"><a href="#传统弹性伸缩的困境" class="headerlink" title="传统弹性伸缩的困境"></a>传统弹性伸缩的困境</h1><p>从传统意义上，弹性伸缩主要解决的问题是容量规划与实践负载的矛盾。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/scaling-vs.png">  </p>
<p>蓝色水位线表示集群资源容量随着负载的增加不断扩容，红色曲线表示集群资源实际负载变化。  </p>
<p>弹性伸缩就是要解决当实际负载增大，而集群资源容量没来得及反应的问题。  </p>
<h2 id="Kubernetes中弹性伸缩存在的问题"><a href="#Kubernetes中弹性伸缩存在的问题" class="headerlink" title="Kubernetes中弹性伸缩存在的问题"></a>Kubernetes中弹性伸缩存在的问题</h2><p>常规的做法是给集群资源预留保障集群可用，通常20%左右。这种方式看似没什么问题，但放到Kubernetes中，就会发现如下2个问题。  </p>
<h3 id="机器规格不统一造成机器利用率百分比碎片化"><a href="#机器规格不统一造成机器利用率百分比碎片化" class="headerlink" title="机器规格不统一造成机器利用率百分比碎片化"></a>机器规格不统一造成机器利用率百分比碎片化</h3><p>在一个Kubernetes集群中，通常不只包含一种规格的机器，假设集群中存在4C8G与16C32G两种规格的机器，对于10%的资源预留，这两种规格代表的意义是完全不同的。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/scaling-machine-config.png">  </p>
<p>特别是在缩容的场景下，为了保证缩容后集群稳定性，我们一般会一个节点一个节点从集群中摘除，那么如何判断节点是否可以摘除其利用率百分比就是重要的指标。此时如果大规则机器有较低的利用率被判断缩容，那么很有可能会造成节点缩容后，容器重新调度后的争抢。如果优先缩容小规则机器，则可能造成缩容后资源的大量冗余。  </p>
<h3 id="机器利用率不单纯依靠宿主机计算"><a href="#机器利用率不单纯依靠宿主机计算" class="headerlink" title="机器利用率不单纯依靠宿主机计算"></a>机器利用率不单纯依靠宿主机计算</h3><p>在大部分生产环境中，资源利用率都不会保持一个高的水位，但从调度来讲，调度应该保持一个比较高的水位，这样才能保障集群稳定性，又不过多浪费资源。  </p>
<h2 id="弹性伸缩概念的延伸"><a href="#弹性伸缩概念的延伸" class="headerlink" title="弹性伸缩概念的延伸"></a>弹性伸缩概念的延伸</h2><p>不是所有的业务都存在峰值流量，越来越细分的业务形态带来更多成本节省和可用性之间的跳转。  </p>
<ul>
<li>在线负载型：微服务、网站、API  </li>
<li>离线任务型：离线计算、机器学习  </li>
<li>定时任务型：定时批量计算</li>
</ul>
<p>不同类型的负载对于弹性伸缩的要求有所不同，在线负载对弹出时间敏感，离线任务对价格敏感，定时任务对调度敏感。  </p>
<h1 id="Kubernetes-弹性伸缩布局"><a href="#Kubernetes-弹性伸缩布局" class="headerlink" title="Kubernetes 弹性伸缩布局"></a>Kubernetes 弹性伸缩布局</h1><p>在 Kubernetes 的生态中，在多个维度、多个层次提供了不同的组件来满足不同的伸缩场景。  </p>
<p>有三种弹性伸缩：  </p>
<ul>
<li>CA（Cluster Autoscaler）：Node级别自动扩&#x2F;缩容cluster-autoscaler组件  </li>
<li>HPA（Horizontal Pod Autoscaler）：Pod个数自动扩&#x2F;缩容  </li>
<li>VPA（Vertical Pod Autoscaler）：Pod配置自动扩&#x2F;缩容，主要是CPU、内存addon-resizer组件</li>
</ul>
<p>如果在云上建议 HPA 结合<code>cluster-autoscaler</code>的方式进行集群的弹性伸缩管理。  </p>
<h1 id="Node-自动扩容-x2F-缩容"><a href="#Node-自动扩容-x2F-缩容" class="headerlink" title="Node 自动扩容&#x2F;缩容"></a>Node 自动扩容&#x2F;缩容</h1><h2 id="Cluster-AutoScaler"><a href="#Cluster-AutoScaler" class="headerlink" title="Cluster AutoScaler"></a>Cluster AutoScaler</h2><p><strong>扩容：</strong>Cluster AutoScaler 定期检测是否有充足的资源来调度新创建的 Pod，当资源不足时会调用 Cloud Provider 创建新的 Node。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/cluster-autoscaler-up.png">  </p>
<p><strong>缩容：</strong>Cluster AutoScaler 也会定期监测 Node 的资源使用情况，当一个 Node 长时间资源利用率都很低时（低于 50%）自动将其所在虚拟机从云服务商中删除。此时，原来的 Pod 会自动调度到其他 Node 上面。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/cluster-autoscaler-down.png">  </p>
<p>支持的云提供商：  </p>
<ul>
<li>阿里云：<a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/alicloud/README.md</a>  </li>
<li>AWS： <a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md</a>  </li>
<li>Azure： <a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md</a></li>
</ul>
<h2 id="Ansible扩容Node"><a href="#Ansible扩容Node" class="headerlink" title="Ansible扩容Node"></a>Ansible扩容Node</h2><p><img src="/2022/03/01/kubernetes-hpa/ansible-node-scaler.png">  </p>
<ol>
<li>触发新增Node  </li>
<li>调用Ansible脚本部署组件  </li>
<li>检查服务是否可用  </li>
<li>调用API将新Node加入集群或者启用Node自动加入  </li>
<li>观察新Node状态  </li>
<li>完成Node扩容，接收新Pod</li>
</ol>
<h1 id="Pod自动扩容-x2F-缩容（HPA）"><a href="#Pod自动扩容-x2F-缩容（HPA）" class="headerlink" title="Pod自动扩容&#x2F;缩容（HPA）"></a>Pod自动扩容&#x2F;缩容（HPA）</h1><p>Horizontal Pod Autoscaler（HPA，Pod水平自动伸缩），根据资源利用率或者自定义指标自动调整replication controller, deployment 或 replica set，实现部署的自动扩展和缩减，让部署的规模接近于实际服务的负载。HPA不适于无法缩放的对象，例如DaemonSet。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/hpa-1.png">  </p>
<h2 id="HPA基本原理"><a href="#HPA基本原理" class="headerlink" title="HPA基本原理"></a>HPA基本原理</h2><p>Kubernetes 中的 Metrics Server 持续采集所有 Pod 副本的指标数据。HPA 控制器通过 Metrics Server 的 API（Heapster 的 API 或聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标 Pod 副本数量。当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的副本控制器（Deployment、RC 或 ReplicaSet）发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。如图所示：  </p>
<p><img src="/2022/03/01/kubernetes-hpa/hpa-2.png">  </p>
<p>在弹性伸缩中，冷却周期是不能逃避的一个话题， 由于评估的度量标准是动态特性，副本的数量可能会不断波动。有时被称为颠簸， 所以在每次做出扩容缩容后，冷却时间是多少。  </p>
<p>在 HPA 中，<strong>默认的扩容冷却周期是 3 分钟，缩容冷却周期是 5 分钟。</strong>  </p>
<p>可以通过调整kube-controller-manager组件启动参数设置冷却时间：  </p>
<ul>
<li>–horizontal-pod-autoscaler-downscale-delay ：扩容冷却  </li>
<li>–horizontal-pod-autoscaler-upscale-delay ：缩容冷却</li>
</ul>
<h2 id="HPA的演进历程"><a href="#HPA的演进历程" class="headerlink" title="HPA的演进历程"></a>HPA的演进历程</h2><p>目前 HPA 已经支持了 autoscaling&#x2F;v1、autoscaling&#x2F;v1beta1和autoscaling&#x2F;v1beta2  三个大版本 。  </p>
<p>目前大多数人比较熟悉是autoscaling&#x2F;v1，这个版本只支持CPU一个指标的弹性伸缩。  </p>
<p>而autoscaling&#x2F;v1beta1增加了支持自定义指标，autoscaling&#x2F;v1beta2又额外增加了外部指标支持。  </p>
<p>而产生这些变化不得不提的是Kubernetes社区对监控与监控指标的认识认识与转变。从早期Heapster到Metrics Server再到将指标边界进行划分，一直在丰富监控生态。  </p>
<p>示例：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="string">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="string">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="string">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="string">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="string">targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">apiVersion:</span> <span class="string">autoscaling/v2beta1</span></span><br><span class="line"><span class="string">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="string">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="string">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="string">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="string">-</span> <span class="string">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="string">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="string">kind:</span> <span class="string">AverageUtilization</span></span><br><span class="line">        <span class="string">averageUtilization:</span> <span class="number">50</span></span><br><span class="line">  <span class="string">-</span> <span class="string">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="string">name:</span> <span class="string">packets-per-second</span></span><br><span class="line">      <span class="string">targetAverageValue:</span> <span class="string">1k</span></span><br><span class="line">  <span class="string">-</span> <span class="string">type:</span> <span class="string">Object</span></span><br><span class="line">    <span class="attr">object:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="string">name:</span> <span class="string">requests-per-second</span></span><br><span class="line">      <span class="attr">describedObject:</span></span><br><span class="line">        <span class="string">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line">        <span class="string">kind:</span> <span class="string">Ingress</span></span><br><span class="line">        <span class="string">name:</span> <span class="string">main-route</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="string">kind:</span> <span class="string">Value</span></span><br><span class="line">        <span class="string">value:</span> <span class="string">10k</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="string">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="string">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="string">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="string">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="string">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="string">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="string">-</span> <span class="string">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="string">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="string">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="string">averageUtilization:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h1 id="基于CPU指标缩放"><a href="#基于CPU指标缩放" class="headerlink" title="基于CPU指标缩放"></a>基于CPU指标缩放</h1><h2 id="Kubernetes-API-Aggregation"><a href="#Kubernetes-API-Aggregation" class="headerlink" title="Kubernetes API Aggregation"></a>Kubernetes API Aggregation</h2><p>在 Kubernetes 1.7 版本引入了聚合层，允许第三方应用程序通过将自己注册到kube-apiserver上，仍然通过 API Server 的 HTTP URL 对新的 API 进行访问和操作。为了实现这个机制，Kubernetes 在 kube-apiserver 服务中引入了一个 API 聚合层（API Aggregation Layer），用于将扩展 API 的访问请求转发到用户服务的功能。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/aggergation.png">  </p>
<p>当你访问 apis&#x2F;metrics.k8s.io&#x2F;v1beta1 的时候，实际上访问到的是一个叫作 kube-aggregator 的代理。而 kube-apiserver，正是这个代理的一个后端；而 Metrics Server，则是另一个后端 。通过这种方式，我们就可以很方便地扩展 Kubernetes 的 API 了。  </p>
<p>如果你使用kubeadm部署的，默认已开启。如果你使用二进制方式部署的话，需要在kube-APIServer中添加启动参数，增加以下配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi /opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">...</span><br><span class="line">--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">--proxy-client-cert-file=/opt/kubernetes/ssl/server.pem \</span><br><span class="line">--proxy-client-key-file=/opt/kubernetes/ssl/server-key.pem \</span><br><span class="line">--requestheader-allowed-names=kubernetes \</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra- \</span><br><span class="line">--requestheader-group-headers=X-Remote-Group \</span><br><span class="line">--requestheader-username-headers=X-Remote-User \</span><br><span class="line">--enable-aggregator-routing=true \</span><br></pre></td></tr></table></figure>

<p>在设置完成重启 kube-apiserver 服务，就启用 API 聚合功能了。  </p>
<h2 id="部署-Metrics-Server"><a href="#部署-Metrics-Server" class="headerlink" title="部署 Metrics Server"></a>部署 Metrics Server</h2><p>Metrics Server是一个集群范围的资源使用情况的数据聚合器。作为一个应用部署在集群中。  </p>
<p>Metric server从每个节点上Kubelet公开的摘要API收集指标。  </p>
<p>Metrics server通过Kubernetes聚合器注册在Master APIServer中。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/hpa-3.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># git clone https://github.com/kubernetes-incubator/metrics-server</span><br><span class="line"># cd metrics-server/deploy/1.8+/</span><br><span class="line"># vi metrics-server-deployment.yaml   # 添加2条启动参数</span><br><span class="line">      containers:</span><br><span class="line">      - name: metrics-server</span><br><span class="line">        image: lizhenliang/metrics-server-amd64:v0.3.1</span><br><span class="line">        command:</span><br><span class="line">        - /metrics-server</span><br><span class="line">        - --kubelet-insecure-tls</span><br><span class="line">        - --kubelet-preferred-address-types=InternalIP</span><br><span class="line"></span><br><span class="line"># kubectl create -f .</span><br></pre></td></tr></table></figure>

<p>可通过Metrics API在Kubernetes中获得资源使用率指标，例如容器CPU和内存使用率。这些度量标准既可以由用户直接访问（例如，通过使用<code>kubectl top</code>命令），也可以由集群中的控制器（例如，Horizontal Pod Autoscaler）用于进行决策。   </p>
<p>测试：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes</span><br><span class="line">kubectl top node</span><br></pre></td></tr></table></figure>

<h2 id="autoscaling-x2F-v1（CPU指标实践）"><a href="#autoscaling-x2F-v1（CPU指标实践）" class="headerlink" title="autoscaling&#x2F;v1（CPU指标实践）"></a>autoscaling&#x2F;v1（CPU指标实践）</h2><p>autoscaling&#x2F;v1版本只支持CPU一个指标。  </p>
<p>首先部署一个应用：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-php</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-php</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">lizhenliang/nginx-php</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">java</span></span><br><span class="line">        <span class="attr">resources:</span> </span><br><span class="line">           <span class="attr">requests:</span></span><br><span class="line">             <span class="attr">memory:</span> <span class="string">&quot;300Mi&quot;</span></span><br><span class="line">             <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-php</span></span><br></pre></td></tr></table></figure>

<p>创建HPA策略：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>scaleTargetRef：表示当前要伸缩对象是谁  </p>
<p>targetCPUUtilizationPercentage：当整体的资源利用率超过50%的时候，会进行扩容。  </p>
<p>开启压测：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">ab -n 100000 -c 100  http://10.1.206.176/status.php</span><br></pre></td></tr></table></figure>

<p>10.0.0.147 为ClusterIP。  </p>
<p>检查扩容状态：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get hpa</span><br><span class="line">kubectl top pods</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<p>关闭压测，过一会检查缩容状态。  </p>
<h2 id="autoscaling-x2F-v2beta2（多指标）"><a href="#autoscaling-x2F-v2beta2（多指标）" class="headerlink" title="autoscaling&#x2F;v2beta2（多指标）"></a>autoscaling&#x2F;v2beta2（多指标）</h2><p>为满足更多的需求， HPA 还有 autoscaling&#x2F;v2beta1和 autoscaling&#x2F;v2beta2两个版本。  </p>
<p>这两个版本的区别是 autoscaling&#x2F;v1beta1支持了 Resource Metrics（CPU）和 Custom Metrics（应用程序指标），而在 autoscaling&#x2F;v2beta2的版本中额外增加了 External Metrics的支持。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get hpa.v2beta2.autoscaling -o yaml &gt; /tmp/hpa-v2.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">60</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br></pre></td></tr></table></figure>

<p>与上面v1版本效果一样，只不过这里格式有所变化。  </p>
<p>v2还支持其他另种类型的度量指标，：Pods和Object。  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line"><span class="attr">pods:</span></span><br><span class="line">  <span class="attr">metric:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">packets-per-second</span></span><br><span class="line">  <span class="attr">target:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">    <span class="attr">averageValue:</span> <span class="string">1k</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">Object</span></span><br><span class="line"><span class="attr">object:</span></span><br><span class="line">  <span class="attr">metric:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">requests-per-second</span></span><br><span class="line">  <span class="attr">describedObject:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">main-route</span></span><br><span class="line">  <span class="attr">target:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Value</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">2k</span></span><br></pre></td></tr></table></figure>

<p>metrics中的type字段有四种类型的值：Object、Pods、Resource、External。  </p>
<ul>
<li>Resource：指的是当前伸缩对象下的pod的cpu和memory指标，只支持Utilization和AverageValue类型的目标值。  </li>
<li>Object：指的是指定k8s内部对象的指标，数据需要第三方adapter提供，只支持Value和AverageValue类型的目标值。  </li>
<li>Pods：指的是伸缩对象Pods的指标，数据需要第三方的adapter提供，只允许AverageValue类型的目标值。  </li>
<li>External：指的是k8s外部的指标，数据同样需要第三方的adapter提供，只支持Value和AverageValue类型的目标值。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hpa-v2.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">50</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">packets-per-second</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="string">1k</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Object</span></span><br><span class="line">    <span class="attr">object:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">requests-per-second</span></span><br><span class="line">      <span class="attr">describedObject:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">main-route</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Value</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">10k</span></span><br></pre></td></tr></table></figure>

<h1 id="基于Prometheus自定义指标缩放"><a href="#基于Prometheus自定义指标缩放" class="headerlink" title="基于Prometheus自定义指标缩放"></a>基于Prometheus自定义指标缩放</h1><p>资源指标只包含CPU、内存，一般来说也够了。但如果想根据自定义指标:如请求qps&#x2F;5xx错误数来实现HPA，就需要使用自定义指标了，目前比较成熟的实现是 Prometheus Custom Metrics。自定义指标由Prometheus来提供，再利用k8s-prometheus-adpater聚合到apiserver，实现和核心指标（metric-server)同样的效果。  </p>
<p><img src="/2022/03/01/kubernetes-hpa/hpa-4.png">  </p>
<h2 id="部署Prometheus"><a href="#部署Prometheus" class="headerlink" title="部署Prometheus"></a>部署Prometheus</h2><p>Prometheus（普罗米修斯）是一个最初在SoundCloud上构建的监控系统。自2012年成为社区开源项目，拥有非常活跃的开发人员和用户社区。为强调开源及独立维护，Prometheus于2016年加入云原生云计算基金会（CNCF），成为继Kubernetes之后的第二个托管项目。  </p>
<p><strong>Prometheus</strong> <strong>特点：</strong></p>
<ul>
<li>多维数据模型：由度量名称和键值对标识的时间序列数据  </li>
<li>PromSQL：一种灵活的查询语言，可以利用多维数据完成复杂的查询  </li>
<li>不依赖分布式存储，单个服务器节点可直接工作  </li>
<li>基于HTTP的pull方式采集时间序列数据  </li>
<li>推送时间序列数据通过PushGateway组件支持  </li>
<li>通过服务发现或静态配置发现目标  </li>
<li>多种图形模式及仪表盘支持（grafana）</li>
</ul>
<p><strong>Prometheus组成及架构：</strong>  </p>
<p><img src="/2022/03/01/kubernetes-hpa/prometheus-arch.png">  </p>
<ul>
<li>Prometheus Server：收集指标和存储时间序列数据，并提供查询接口  </li>
<li>ClientLibrary：客户端库  </li>
<li>Push Gateway：短期存储指标数据。主要用于临时性的任务  </li>
<li>Exporters：采集已有的第三方服务监控指标并暴露metrics  </li>
<li>Alertmanager：告警  </li>
<li>Web UI：简单的Web控制台</li>
</ul>
<p><strong>部署：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd prometheus-k8s</span><br><span class="line"># kubectl apply -f .</span><br><span class="line"># kubectl get pods -n kube-system</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-state-metrics-7f7cfc4f54-xjnk7   2/2     Running   0          10m</span><br><span class="line">metrics-server-7dbbcf4c7-8m8x9        1/1     Running   0          10m</span><br><span class="line">prometheus-0                          2/2     Running   0          10m</span><br><span class="line"># kubectl get svc -n kube-system</span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-state-metrics   ClusterIP   10.1.243.160   &lt;none&gt;        8080/TCP,8081/TCP        3d6h</span><br><span class="line">metrics-server       ClusterIP   10.1.56.84     &lt;none&gt;        443/TCP                  13h</span><br><span class="line">prometheus           NodePort    10.1.36.8      &lt;none&gt;        9090:30090/TCP           10m</span><br></pre></td></tr></table></figure>

<p>访问Prometheus UI：<code>http://NdeIP:30090</code>  </p>
<h2 id="部署-Custom-Metrics-Adapter"><a href="#部署-Custom-Metrics-Adapter" class="headerlink" title="部署 Custom Metrics Adapter"></a>部署 Custom Metrics Adapter</h2><p>但是prometheus采集到的metrics并不能直接给k8s用，因为两者数据格式不兼容，还需要另外一个组件(k8s-prometheus-adpater)，将prometheus的metrics 数据格式转换成k8s API接口能识别的格式，转换以后，因为是自定义API，所以还需要用Kubernetes aggregator在主APIServer中注册，以便直接通过&#x2F;apis&#x2F;来访问。  </p>
<p><a href="https://github.com/DirectXMan12/k8s-prometheus-adapter">k8s-prometheus-adapter</a></p>
<p>该 PrometheusAdapter 有一个稳定的Helm Charts，我们直接使用。  </p>
<p>先准备下helm环境：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.0.0-linux-amd64.tar.gz</span><br><span class="line">tar zxvf helm-v3.0.0-linux-amd64.tar.gz </span><br><span class="line">mv linux-amd64/helm /usr/bin/</span><br><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">helm repo update</span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure>

<p>部署prometheus-adapter，指定prometheus地址：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install prometheus-adapter stable/prometheus-adapter --namespace kube-system --set prometheus.url=http://prometheus.kube-system,prometheus.port=9090</span><br><span class="line"># helm list -n kube-system</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -n kube-system</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">prometheus-adapter-77b7b4dd8b-ktsvx   1/1     Running   0          9m</span><br></pre></td></tr></table></figure>

<p>验证，确保适配器注册到APIServer：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get apiservices |grep custom </span><br><span class="line"># kubectl get --raw &quot;/apis/custom.metrics.k8s.io/v1beta1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="基于QPS指标实践"><a href="#基于QPS指标实践" class="headerlink" title="基于QPS指标实践"></a>基于QPS指标实践</h2><p>部署一个应用：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">metrics-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">metrics-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">metrics-app</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">        <span class="attr">prometheus.io/port:</span> <span class="string">&quot;80&quot;</span></span><br><span class="line">        <span class="attr">prometheus.io/path:</span> <span class="string">&quot;/metrics&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">lizhenliang/metrics-app</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">metrics-app</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-app</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">metrics-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">metrics-app</span></span><br></pre></td></tr></table></figure>

<p>该metrics-app暴露了一个Prometheus指标接口，可以通过访问service看到：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 10.1.181.193/metrics</span><br><span class="line"># HELP http_requests_total The amount of requests in total</span><br><span class="line"># TYPE http_requests_total counter</span><br><span class="line">http_requests_total 115006</span><br><span class="line"># HELP http_requests_per_second The amount of requests per second the latest ten seconds</span><br><span class="line"># TYPE http_requests_per_second gauge</span><br><span class="line">http_requests_per_second 0.5</span><br></pre></td></tr></table></figure>

<p>创建HPA策略：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi app-hpa-v2.yml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-app-hpa</span> </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metrics-app</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">http_requests_per_second</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="string">800m</span>   <span class="comment"># 800m 即0.8个/秒</span></span><br></pre></td></tr></table></figure>

<p>这里使用Prometheus提供的指标测试来测试自定义指标（QPS）的自动缩放。  </p>
<h2 id="配置适配器收集特定的指标"><a href="#配置适配器收集特定的指标" class="headerlink" title="配置适配器收集特定的指标"></a>配置适配器收集特定的指标</h2><p>创建好HPA还没结束，因为适配器还不知道你要什么指标（http_requests_per_second），HPA也就获取不到Pod提供指标。  </p>
<p>ConfigMap在default名称空间中编辑prometheus-adapter ，并seriesQuery在该rules: 部分的顶部添加一个新的：   </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl edit cm prometheus-adapter -n kube-system</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus-adapter</span></span><br><span class="line">    <span class="attr">chart:</span> <span class="string">prometheus-adapter-v0.1.2</span></span><br><span class="line">    <span class="attr">heritage:</span> <span class="string">Tiller</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">prometheus-adapter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-adapter</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    rules:</span></span><br><span class="line"><span class="string">    - seriesQuery: &#x27;http_requests_total&#123;kubernetes_namespace!=&quot;&quot;,kubernetes_pod_name!=&quot;&quot;&#125;&#x27;</span></span><br><span class="line"><span class="string">      resources:</span></span><br><span class="line"><span class="string">        overrides:</span></span><br><span class="line"><span class="string">          kubernetes_namespace: &#123;resource: &quot;namespace&quot;&#125;</span></span><br><span class="line"><span class="string">          kubernetes_pod_name: &#123;resource: &quot;pod&quot;&#125;</span></span><br><span class="line"><span class="string">      name:</span></span><br><span class="line"><span class="string">        matches: &quot;^(.*)_total&quot;</span></span><br><span class="line"><span class="string">        as: &quot;$&#123;1&#125;_per_second&quot;</span></span><br><span class="line"><span class="string">      metricsQuery: &#x27;sum(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[2m])) by (&lt;&lt;.GroupBy&gt;&gt;)&#x27;</span></span><br><span class="line"><span class="string"></span><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>该规则将http_requests在2分钟的间隔内收集该服务的所有Pod的平均速率。  </p>
<p>测试API：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get --raw &quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests_per_second&quot;</span><br></pre></td></tr></table></figure>

<p>压测：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab -n 100000 -c 100  http://10.1.181.193/metrics</span><br></pre></td></tr></table></figure>

<p>查看HPA状态：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get hpa</span><br><span class="line">kubectl describe hpa metrics-app-hpa</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2022/03/01/kubernetes-hpa/hpa-5.png">  </p>
<ul>
<li>通过&#x2F;metrics收集每个Pod的http_request_total指标；  </li>
<li>prometheus将收集到的信息汇总；  </li>
<li>APIServer定时从Prometheus查询，获取request_per_second的数据；  </li>
<li>HPA定期向APIServer查询以判断是否符合配置的autoscaler规则；  </li>
<li>如果符合autoscaler规则，则修改Deployment的ReplicaSet副本数量进行伸缩。</li>
</ul>
]]></content>
      <categories>
        <category>Learn-Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>弹性伸缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes网络原理——Ingress对象</title>
    <url>/2022/09/12/kubernetes-network-principle-network-ingress/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的Ingress 服务。  </p>
<p>所以，Ingress 的功能其实很容易理解：<strong>所谓 Ingress，就是 Service 的“Service”</strong>。  </p>
<p>假如我现在有这样一个站点：<code>https://cafe.example.com</code>，其中<code>https://cafe.example.com/coffee</code>对应的是“咖啡点餐系统”，而<code>https://cafe.example.com/tea</code>对应的是<code>茶水点餐系统</code>，这两个系统，分别由名叫<code>coffee</code>和<code>tea</code>两个<code>Deployment</code>来提供服。  </p>
<p>那么，我如何能使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，能够访问到不同的 Deployment 呢？<br>上述功能，在 Kubernetes 里就需要通过 Ingress 对象来描述：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="comment"># 这个字段在Kubernetes里叫IngressRule</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span>  <span class="comment"># Ingress的入口</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span>  <span class="comment"># /tea 对应 tea Deployment的 Service</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tea-svc</span> <span class="comment"># Deployment的 Service的名字</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span>  <span class="comment"># /coffee 对应 coffee Deployment的 Service</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">coffee-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>所谓 Ingress 对象，其实就是<strong>Kubernetes项目对“反向代理”的一种抽象</strong>。  </p>
<p>一个 Ingress 对象的主要内容，实际上就是一个“反向代理”服务（比如：Nginx）的配置文件的描述。而这个代理服务对应的转发规则，就是 IngressRule。  </p>
<p>这就是为什么在每条 IngressRule 里，需要有一个 host 字段来作为这条 IngressRule 的入口，然后还需要有一系列 path 字段来声明具体的转发策略。<br>这其实跟 Nginx、HAproxy等项目的配置文件的写法是一致的。  </p>
<h1 id="以-Nginx-Ingress-Controller-为例"><a href="#以-Nginx-Ingress-Controller-为例" class="headerlink" title="以 Nginx Ingress Controller 为例"></a>以 Nginx Ingress Controller 为例</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Ingress 实际上就是 Kubernetes 对“反向代理”的抽象。  </li>
<li>目前，Ingress 只能工作在七层，而 Service 只能工作在四层。所以当你想要在Kubernetes 里为应用进行 TLS 配置等 HTTP 相关的操作时，都必须通过 Ingress 来进行。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络原理</tag>
        <tag>Ingress</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes网络原理——网络模型与CNI网络插件</title>
    <url>/2022/09/12/kubernetes-network-principle-network-model-and-cni-network-plug-in/</url>
    <content><![CDATA[<h1 id="Kubernetes网络模型"><a href="#Kubernetes网络模型" class="headerlink" title="Kubernetes网络模型"></a>Kubernetes网络模型</h1><p>Kubernetes 是通过一个叫作 CNI 的接口，维护了一个单独的网桥来代替 docker0。<br>这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0。<br><img src="/2022/09/12/kubernetes-network-principle-network-model-and-cni-network-plug-in/1.png">  </p>
<p>在这里，Kubernetes 为 Flannel 分配的子网范围是 10.244.0.0&#x2F;16。<br>这个参数可以在部署的时候指定，比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>注：也可以在部署完成后，通过修改 kube-controller-manager 的配置文件来指定。  </p>
<p>假设 Infra-container-1 要访问 Infra-container-2（也就是 Pod-1 要访问 Pod-2）<br>，这个 IP 包的源地址就是 10.244.0.2，目的 IP 地址是 10.244.1.3。而此时，Infra-container-1 里的 eth0 设备，同样是以 Veth Pair 的方式连接在 Node 1 的 cni0 网桥上。所以这个 IP 包就会经过 cni0 网桥出现在宿主机上。  </p>
<p>需要注意的是，CNI 网桥只是接管所有 CNI 插件负责的、即 Kubernetes 创建的容器（<code>Pod</code>）。而此时，如果你用 docker run 单独启动一个容器，那么 Docker 项目还是会把<br>这个容器连接到 docker0 网桥上。所以这个容器的 IP 地址，一定是属于 docker0 网桥的<br>172.17.0.0&#x2F;16 网段。  </p>
<p>Kubernetes 之所以要设置这样一个与 docker0 网桥功能几乎一样的 CNI 网桥，主要原因<br>包括两个方面：  </p>
<ul>
<li>Kubernetes 项目并没有使用 Docker 的网络模型（CNM），所以它并不希望、也不具备配置 docker0 网桥的能力；  </li>
<li>这还与 Kubernetes 如何配置 Pod，也就是 Infra 容器的 Network Namespace 密切相关。</li>
</ul>
<p>我们知道，Kubernetes 创建一个 Pod 的第一步，就是创建并启动一个 Infra 容器，用<br>来“hold”住这个 Pod 的 Network Namespace，所以，CNI 的设计思想，就是：<strong>Kubernetes 在启动 Infra 容器之后，就可以直接调用CNI 网络插件，为这个 Infra 容器的 Network Namespace，配置符合预期的网络栈。</strong>  </p>
<h1 id="CNI-插件的部署和实现方式"><a href="#CNI-插件的部署和实现方式" class="headerlink" title="CNI 插件的部署和实现方式"></a>CNI 插件的部署和实现方式</h1><p>我们在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在<br>宿主机上安装CNI 插件所需的基础可执行文件。<br>在安装完成后，你可以在宿主机的 &#x2F;opt&#x2F;cni&#x2F;bin 目录下看到它们<br><img src="/2022/09/12/kubernetes-network-principle-network-model-and-cni-network-plug-in/cni-bin.png">  </p>
<p>这些 CNI 的基础可执行文件，按照功能可以分为三类：  </p>
<ul>
<li>第一类：Main 插件，它是用来创建具体网络设备的二进制文件。</li>
<li>第二类： IPAM（IP Address Management）插件，它是负责分配 IP 地址的二进制文件。  </li>
<li>第三类：由 CNI 社区维护的内置 CNI 插件。</li>
</ul>
<p>接下来，你就需要在宿主机上安装 flanneld（网络方案本身）。而在这个过程中，flanneld 启动后会在每台宿主机上生成它对应的CNI 配置文件（它其实是一个ConfigMap），从而告诉 Kubernetes，这个集群要使用 Flannel 作为容器网络方案。<br><img src="/2022/09/12/kubernetes-network-principle-network-model-and-cni-network-plug-in/cni-config.png">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Kubernetes 网络模型  </p>
<ul>
<li>所有容器都可以直接使用 IP 地址与其他容器通信，而无需使用 NAT。  </li>
<li>所有宿主机都可以直接使用 IP 地址与所有容器通信，而无需使用 NAT。反之亦然。  </li>
<li>容器自己“看到”的自己的 IP 地址，和别人（宿主机或者容器）看到的地址是完全一样的。</li>
</ul>
<p>容器与容器之间要“通”，容器与宿主机之间也要“通”。并且，Kubernetes 要求这个“通”还必须是直接基于容器和宿主机的 IP 地址来进行的。  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络原理</tag>
        <tag>CNI</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群部署WordPress网站-版本2</title>
    <url>/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/</url>
    <content><![CDATA[<h1 id="版本更新描述"><a href="#版本更新描述" class="headerlink" title="版本更新描述"></a>版本更新描述</h1><p>完全舍弃了 Docker，把所有的应用都放在 Kubernetes 集群里运行，部署方式也不再是裸 Pod，<strong>而是使用 Deployment，稳定性大幅度提升。</strong>  </p>
<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/%E6%9E%B6%E6%9E%84%E5%9B%BE.png">  </p>
<p>原来的 Nginx 的作用是反向代理，那么在 Kubernetes 里它就升级成了具有相同功能的 Ingress Controller。WordPress 原来只有一个实例，现在变成了两个实例（你也可以任意横向扩容），可用性也就因此提高了不少。而 MariaDB 数据库因为要保证数据的一致性，暂时还是一个实例。  </p>
<p>因为 Kubernetes 内置了服务发现机制 Service，我们再也不需要去手动查看 Pod 的 IP 地址了，只为它们定义了 Service 对象，然后使用域名就可以访问 MariaDB、WordPress 这些服务。  </p>
<p>网站对外提供服务我选择了两种方式：  </p>
<ul>
<li>1，让 WordPress 的 Service 对象以 NodePort 的方式直接对外暴露端口 30088，方便测试；  </li>
<li>2，给 Nginx Ingress Controller 添加“hostNetwork”属性，直接使用节点上的端口号，类似 Docker 的 host 网络模式，好处是可以避开 NodePort 的端口范围限制。</li>
</ul>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h2 id="WordPress-网站部署-MariaDB"><a href="#WordPress-网站部署-MariaDB" class="headerlink" title="WordPress 网站部署 MariaDB"></a>WordPress 网站部署 MariaDB</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DATABASE:</span> <span class="string">&#x27;db&#x27;</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">ROOT_PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后我们需要把 MariaDB 由 Pod 改成 Deployment 的方式，replicas 设置成 1 个，template 里面的 Pod 部分没有任何变化，还是要用 envFrom把配置信息以环境变量的形式注入 Pod，相当于把 Pod 套了一个 Deployment 的“外壳”：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-dep</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mariadb:10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mariadb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;MARIADB_&#x27;</span></span><br><span class="line">          <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">maria-cm</span></span><br></pre></td></tr></table></figure>

<p>我们还需要再为 MariaDB 定义一个 Service 对象，映射端口 3306，让其他应用不再关心 IP 地址，直接用 Service 对象的名字来访问数据库服务：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-svc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br></pre></td></tr></table></figure>

<p>因为这三个对象都是数据库相关的，所以可以在一个 YAML 文件里书写，对象之间用 — 分开，这样用 kubectl apply 就可以一次性创建好：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wp-maria.yml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">DATABASE:</span> <span class="string">&#x27;db&#x27;</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">ROOT_PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-dep</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mariadb:10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mariadb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;MARIADB_&#x27;</span></span><br><span class="line">          <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">maria-cm</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">maria-svc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">maria-dep</span></span><br></pre></td></tr></table></figure>

<p>执行命令后，你应该用 kubectl get 查看对象是否创建成功，是否正常运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl apply -f wp-maria.yml </span><br><span class="line">configmap/maria-cm created</span><br><span class="line">deployment.apps/maria-dep created</span><br><span class="line">service/maria-svc created</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/1.png">  </p>
<h2 id="WordPress-网站部署-WordPress"><a href="#WordPress-网站部署-WordPress" class="headerlink" title="WordPress 网站部署 WordPress"></a>WordPress 网站部署 WordPress</h2><p>因为刚才创建了 MariaDB 的 Service，所以在写 ConfigMap 配置的时候“HOST”就不应该是 IP 地址了，而<strong>应该是 DNS 域名，也就是 Service 的名字maria-svc，这点需要特别注意</strong>：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-cm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">HOST:</span> <span class="string">&#x27;maria-svc&#x27;</span></span><br><span class="line">  <span class="attr">USER:</span> <span class="string">&#x27;wp&#x27;</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="attr">NAME:</span> <span class="string">&#x27;db&#x27;</span></span><br></pre></td></tr></table></figure>

<p>WordPress 的 Deployment 写法和 MariaDB 也是一样的，给 Pod 套一个 Deployment 的“外壳”，replicas 设置成 2 个，用字段“envFrom”配置环境变量：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wp-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-dep</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">wp-dep</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">wp-dep</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">wordpress:5</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">wordpress</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">&#x27;WORDPRESS_DB_&#x27;</span></span><br><span class="line">          <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">wp-cm</span></span><br></pre></td></tr></table></figure>

<p>然后我们仍然要为 WordPress 创建 Service 对象，这里我使用了“NodePort”类型，并且手工指定了端口号“30088”（必须在 30000~32767 之间）：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wp-dep</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-svc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30088</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wp-dep</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<p>用 kubectl apply 部署 WordPress：  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/2.png">  </p>
<p>因为 WordPress 的 Service 对象是 NodePort 类型的，我们可以在集群的每个节点上访问 WordPress 服务。  </p>
<p>比如一个节点的 IP 地址是“192.168.10.210”，那么你就在浏览器的地址栏里输入“<a href="http://192.168.10.210:30088”，其中的“30088”就是在">http://192.168.10.210:30088”，其中的“30088”就是在</a> Service 里指定的节点端口号，然后就能够看到 WordPress 的安装界面了：  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/3.png">  </p>
<h2 id="WordPress-网站部署-Nginx-Ingress-Controller"><a href="#WordPress-网站部署-Nginx-Ingress-Controller" class="headerlink" title="WordPress 网站部署 Nginx Ingress Controller"></a>WordPress 网站部署 Nginx Ingress Controller</h2><p>首先我们需要定义 Ingress Class，名字就叫“wp-ink”：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-ink</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">controller:</span> <span class="string">nginx.org/ingress-controller</span></span><br></pre></td></tr></table></figure>

<p>执行<code>kuebctl apply -f wp-ink.yml</code>后，可能会出现  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: unable to recognize &quot;wp-ink.yml&quot;: no matches for kind &quot;IngressClass&quot; in version &quot;networking.k8s.io/v1&quot;</span><br></pre></td></tr></table></figure>
<p>这样的报错信息，我当前的<code>kubernetes</code>版本为<code>v.18.9</code>，</p>
<p>然后用 kubectl create 命令生成 Ingress 的样板文件，指定域名是“wp.test”，后端 Service 是“wp-svc:80”，Ingress Class 就是刚定义的“wp-ink”：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl create ing wp-ing --rule=&quot;wp.test/=wp-svc:80&quot; --class=wp-ink $out</span><br></pre></td></tr></table></figure>

<p>得到的 Ingress YAML 就是这样，注意路径类型我还是用的前缀匹配“Prefix”：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-ing</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">wp-ink</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">wp.test</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">wp-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>接下来就是最关键的 Ingress Controller 对象了，它仍然需要从 Nginx 项目的示例 YAML 修改而来，要改动名字、标签，还有参数里的 Ingress Class。  </p>
<p>这个 Ingress Controller 不使用 Service，而是给它的 Pod 加上一个特殊字段 hostNetwork，让 Pod 能够使用宿主机的网络，相当于另一种形式的 NodePort：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-kic-dep</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nginx-ingress</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">wp-kic-dep</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">wp-kic-dep</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># use host network</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>准备好 Ingress 资源后，我们创建这些对象：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f wp-ing.yml -f wp-kic.yml</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Kubernetes 是云原生时代的操作系统，它能够管理大量节点构成的集群，让计算资源“池化”，从而能够自动地调度运维各种形式的应用。  </p>
<p>搭建多节点的 Kubernetes 集群是一件颇具挑战性的工作，好在社区里及时出现了 kubeadm 这样的工具，可以“一键操作”，使用 kubeadm init、kubeadm join 等命令从无到有地搭建出生产级别的集群。  </p>
<p>kubeadm 使用容器技术封装了 Kubernetes 组件，所以只要节点上安装了容器运行时（Docker、containerd 等），它就可以自动从网上拉取镜像，然后以容器的方式运行组件，非常简单方便。  </p>
<p>在这个更接近实际生产环境的 Kubernetes 集群里，学习了Deployment、DaemonSet、Service、Ingress、Ingress Controller 等 API 对象：  </p>
<ul>
<li><p>Deployment 是用来管理 Pod 的一种对象，它代表了运维工作中最常见的一类在线业务，在集群中部署应用的多个实例，而且可以很容易地增加或者减少实例数量，从容应对流量压力。<br>Deployment 的定义里有两个关键字段：一个是 replicas，它指定了实例的数量；另一个是 selector，它的作用是使用标签“筛选”出被 Deployment 管理的 Pod，这是一种非常灵活的关联机制，实现了 API 对象之间的松耦合。  </p>
</li>
<li><p>DaemonSet 是另一种部署在线业务的方式，它很类似 Deployment，但会在集群里的每一个节点上运行一个 Pod 实例，类似 Linux 系统里的“守护进程”，适合日志、监控等类型的应用。<br>DaemonSet 能够任意部署 Pod 的关键概念是“污点”（taint）和“容忍度”（toleration）。Node 会有各种“污点”，而 Pod 可以使用“容忍度”来忽略“污点”，合理使用这两个概念就可以调整 Pod 在集群里的部署策略。</p>
</li>
</ul>
<p>由 Deployment 和 DaemonSet 部署的 Pod，在集群中处于“动态平衡”的状态，总数量保持恒定，但也有临时销毁重建的可能，所以 IP 地址是变化的，这就为微服务等应用架构带来了麻烦。  </p>
<ul>
<li><p>Service 是对 Pod IP 地址的抽象，它拥有一个固定的 IP 地址，再使用 iptables 规则把流量负载均衡到后面的 Pod，节点上的 kube-proxy 组件会实时维护被代理的 Pod 状态，保证 Service 只会转发给健康的 Pod。<br>Service 还基于 DNS 插件支持域名，所以客户端就不再需要关心 Pod 的具体情况，只要通过 Service 这个稳定的中间层，就能够访问到 Pod 提供的服务。<br>Service 是四层的负载均衡，但现在的绝大多数应用都是 HTTP&#x2F;HTTPS 协议，要实现七层的负载均衡就要使用 Ingress 对象。  </p>
</li>
<li><p>Ingress 定义了基于 HTTP 协议的路由规则，但要让规则生效，还需要 Ingress Controller 和 Ingress Class 来配合工作。<br>Ingress Controller 是真正的集群入口，应用 Ingress 规则调度、分发流量，此外还能够扮演反向代理的角色，提供安全防护、TLS 卸载等更多功能。<br>Ingress Class 是用来管理 Ingress 和 Ingress Controller 的概念，方便我们分组路由规则，降低维护成本。</p>
</li>
</ul>
<p>不过 Ingress Controller 本身也是一个 Pod，想要把服务暴露到集群外部还是要依靠 Service。Service 支持 NodePort、LoadBalancer 等方式，但 NodePort 的端口范围有限，LoadBalancer 又依赖于云服务厂商，都不是很灵活。折中的办法是用少量 NodePort 暴露 Ingress Controller，用 Ingress 路由到内部服务，外部再用反向代理或者 LoadBalancer 把流量引进来。  </p>
<p><img src="/2022/10/04/kubernetes-cluster-deploy-wordpress-v2/k8s-%E4%B8%AD%E7%BA%A7map.png">  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes存储原理——深入理解本地持久化数据卷</title>
    <url>/2022/09/09/kubernetes-storage-principle-local-persistent-data-volume/</url>
    <content><![CDATA[<h1 id="关于本地持久化存储"><a href="#关于本地持久化存储" class="headerlink" title="关于本地持久化存储"></a>关于本地持久化存储</h1><p>用户希望 Kubernetes 能够直接使用宿主机上的本地磁盘目录，而不依赖于远程存储服务，来提供“持久化”的容器<code>Volume</code>。  </p>
<p>这样做的好处就是：由于这个<code>Volume</code>直接使用的是本地磁盘，尤其是<code>SSD</code>盘，它的读<br>写性能相比于大多数远程存储来说，要好得多。  </p>
<h1 id="Local-PV的设计难点"><a href="#Local-PV的设计难点" class="headerlink" title="Local PV的设计难点"></a>Local PV的设计难点</h1><h2 id="如何把本地磁盘抽象成PV"><a href="#如何把本地磁盘抽象成PV" class="headerlink" title="如何把本地磁盘抽象成PV"></a>如何把本地磁盘抽象成PV</h2><p>首先，<strong>绝对不能把一个宿主机上的目录当作 PV 使用</strong>。<br>这是因为，这种本地目录的存储行为完全不可控，它所在的磁盘随时都可能被应用写满，甚至造成整个宿主机宕机。而且，不同的本地目录之间也缺乏哪怕最基础的 I&#x2F;O 隔离机制。  </p>
<p>所以，一个 Local Persistent Volume 对应的存储介质，一定是一块额外挂载在宿主机的磁盘或者块设备（“额外”的意思是，它不应该是宿主机根目录所使用的主硬盘）。这个原<br>则，我们可以称为<strong>一个 PV 一块盘</strong>。  </p>
<h2 id="调度器如何保证-Pod-始终能被正确地调度到它所请求的-Local-Persistent-Volume-所在的节点上"><a href="#调度器如何保证-Pod-始终能被正确地调度到它所请求的-Local-Persistent-Volume-所在的节点上" class="headerlink" title="调度器如何保证 Pod 始终能被正确地调度到它所请求的 Local Persistent Volume 所在的节点上"></a>调度器如何保证 Pod 始终能被正确地调度到它所请求的 Local Persistent Volume 所在的节点上</h2><p>对于常规的 PV 来说，Kubernetes 都是先调度 Pod 到某个节点上，然后，再通过“两阶段处理”来“持久化”这台机器上的 Volume 目录，进而完成Volume 目录与容器的绑定挂载。  </p>
<p>可是，对于 Local PV 来说，节点上可供使用的磁盘（或者块设备），必须是运维人员提前<br>准备好的。它们在不同节点上的挂载情况可以完全不同，甚至有的节点可以没这种磁盘。  </p>
<p>所以，这时候，调度器就必须能够知道所有节点与 Local Persistent Volume 对应的磁盘的关联关系，然后根据这个信息来调度 Pod。  </p>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>存储原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程入门：任务式学习指南-薪资转换工具</title>
    <url>/2025/01/27/learn-java-task-guide-1-salary/</url>
    <content><![CDATA[<h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><p>程序是如何帮助人类提高生产效率的？程序世界是由什么组成的？想在Java程序中如鱼得水，首先需要了解Java程序的基本语法。通过本次任务线索的学习，完成薪资转换工具。<br>需求如下：当用户输入月薪时，计算出对应的日薪（每月工作日22天）和年薪（1年13薪）并进行输出显示。  </p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>掌握Java的基本输入输出。  </li>
<li>掌握Java的基本数据类型和变量。  </li>
<li>掌握Java运算符。  </li>
<li>掌握格式化输出。</li>
</ul>
<h1 id="任务线索"><a href="#任务线索" class="headerlink" title="任务线索"></a>任务线索</h1><p>为了完成薪资转换工具，在理解需求的基础上需要学习Java语言如何开始编写，程序的结构是什么样的，数据应该存储在哪里，如何进行数据的输入，如何根据输入的数据进行处理后按照格式要求进行输出。  </p>
<h2 id="Java程序基本结构及注释"><a href="#Java程序基本结构及注释" class="headerlink" title="Java程序基本结构及注释"></a>Java程序基本结构及注释</h2><h1 id="任务实施"><a href="#任务实施" class="headerlink" title="任务实施"></a>任务实施</h1><h2 id="问题分析，确定资源"><a href="#问题分析，确定资源" class="headerlink" title="问题分析，确定资源"></a>问题分析，确定资源</h2><p>分析任务描述，需要根据用户输入的月薪计算日薪和年薪并进行输出；需要准备三个double类型的变量分别存储月薪、日薪和年薪。  </p>
<h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><ul>
<li>第一步：接收用户输入月薪。  </li>
<li>第二步：进行业务处理。  </li>
<li>第三步：按要求格式化输出结果。</li>
</ul>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SalaryDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***薪资转换工具 v1.0***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入薪资：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 接收月薪</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> input.nextDouble();</span><br><span class="line">        <span class="comment">// 进行业务处理</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">mDay</span> <span class="operator">=</span> salary / <span class="number">22</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">mYear</span> <span class="operator">=</span> salary * <span class="number">13</span>;</span><br><span class="line">        <span class="comment">// 格式化输出</span></span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###,###.00&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;日薪为：&quot;</span> + df.format(mDay));</span><br><span class="line">        System.out.println(<span class="string">&quot;年薪为：&quot;</span> + df.format(mYear));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LearnJava</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes存储原理——PV和PVC的设计和实现</title>
    <url>/2022/09/09/kubernetes-storage-principle-pv-pvc/</url>
    <content><![CDATA[<h1 id="PV和PVC"><a href="#PV和PVC" class="headerlink" title="PV和PVC"></a>PV和PVC</h1><p><code>PV</code>是持久化存储数据卷。  </p>
<p>这个<code>API</code>对象主要定义的是一个持久化存储在宿主机上的目录，比如一个<code>NFS</code>的挂载目录。  </p>
<p>下面来定义一个<code>NFS</code>类型的<code>PV</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>PVC</code>描述的是<code>Pod</code>所希望使用的持久化存储的属性。比如<code>Volume</code>存储的大小、可读写权限。  </p>
<p><code>PVC</code>对象通常由平台的用户创建，或者以<code>PVC</code>模板的方式为<code>StatefulSet</code>的一部分，然后由<code>StatefulSet</code>控制器负责创建带编号的<code>PVC</code>。比如，用户可以声明一个1GB大小的<code>PVC</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<p>用户创建的<code>PVC</code>要真正被容器使用，就必须先和某个符合条件的<code>PV</code>进行绑定。这里要检查两个条件：  </p>
<ul>
<li>1，<code>PV</code>和<code>PVC</code>的<code>spec</code>字段：比如<code>PV</code>的存储大小必须满足<code>PVC</code>要求；  </li>
<li>2，<code>PV</code>和<code>PVC</code>的<code>storageClassName</code>字段必须一样。</li>
</ul>
<p>在成功将<code>PVC</code>和<code>PV</code>绑定之后，<code>Pod</code>就可以像使用<code>hostPath</code>等常规类型的<code>Volume</code>一样在自己的<code>YAML</code>文件里声明使用这个<code>PVC</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">web-frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span> <span class="comment"># 声明自己要使用的pvc名字</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">nfs</span> <span class="comment"># 类型</span></span><br></pre></td></tr></table></figure>
<p>这个<code>YAML</code>文件描述的是：在<code>volumes</code>字段里声明自己要使用的<code>PVC</code>名字，然后等<code>Pod</code>创建之后，<code>kuberlet</code>就会把该<code>PVC</code>所对应的<code>PV</code>——一个NFS类型的<code>Volume</code>挂载在这个<code>Pod</code>容器内的目录上。  </p>
<p>可以看出，<code>PVC</code>和<code>PV</code>设计跟“面对对象”的思想非常相似——可以把<code>PVC</code>理解为持久化存储的“接口”，它提供了对某种持久化存储的描述，但不提供具体的实现；实现是由<code>PV</code>负责完成。  </p>
<h1 id="Volume-Controller"><a href="#Volume-Controller" class="headerlink" title="Volume Controller"></a>Volume Controller</h1><p>在<code>Kubernetes</code>中存在一个专门处理持久化存储的控制器，叫作<code>Volume Controller</code>。  </p>
<h2 id="PersistentVolumeController"><a href="#PersistentVolumeController" class="headerlink" title="PersistentVolumeController"></a>PersistentVolumeController</h2><p><code>PersistentVolumeController</code>会不断查看当前每一个<code>PVC</code>是否已经处于<code>Bound</code>状态，如果不是，它会遍历所有可用的<code>PV</code>，并尝试将其与这个“单身”的<code>PVC</code>进行绑定，这样<code>Kubernetes</code>就可以保证用户提交的每一个<code>PVC</code>只要有合适的<code>PV</code>出现，就能很快地进入绑定状态。  </p>
<h3 id="PV与PVC绑定是什么意思？"><a href="#PV与PVC绑定是什么意思？" class="headerlink" title="PV与PVC绑定是什么意思？"></a><code>PV</code>与<code>PVC</code>绑定是什么意思？</h3><p>将<code>PV</code>对象的名字填在<code>PVC</code>对象的<code>spec.volumeName</code>字段上。<br>所以<code>Kubernetes</code>只要获取这个<code>PVC</code>对象，就一定能找到它所绑定的<code>PV</code>。  </p>
<h3 id="这个PV对象是如何变成容器里的一个持久化存储呢？"><a href="#这个PV对象是如何变成容器里的一个持久化存储呢？" class="headerlink" title="这个PV对象是如何变成容器里的一个持久化存储呢？"></a>这个<code>PV</code>对象是如何变成容器里的一个持久化存储呢？</h3><p>首先，容器的<code>Volume</code>，其实就是将一个宿主机上的目录跟一个容器里的目录绑定挂载在了一起。  </p>
<p>所谓的<strong>持久化Volume</strong>，指的就是该宿主机上的目录具备“持久性”，即该目录里面的内容既不会因为容器的删除而被清理，也不会跟当前的宿主机绑定。当容器重启或在其他节点上重建之后，它仍能通过挂载这个<code>Volume</code>访问到这些内容。  </p>
<p>所以，大多数情况下，持久化<code>Volume</code>的实现往往依赖一个远程存储服务，比如远程文件存储，远程块存储等；而<code>Kubernetes</code>需要做的是使用这些存储服务来为容器准备一个持久化的宿主机目录，以供将来进行绑定挂载时使用。所谓“持久化”，指的是容器在该目录里写入的文件都会保存在远程存储中，从而使该目录具备了“持久性”。  </p>
<h1 id="“持久化”宿主机的过程（处理PV的具体原理）"><a href="#“持久化”宿主机的过程（处理PV的具体原理）" class="headerlink" title="“持久化”宿主机的过程（处理PV的具体原理）"></a>“持久化”宿主机的过程（处理PV的具体原理）</h1><h2 id="第一阶段-Attach"><a href="#第一阶段-Attach" class="headerlink" title="第一阶段-Attach"></a>第一阶段-Attach</h2><p>当一个<code>Pod</code>调度到一个节点上之后，<code>kubelet</code>就要负责为这个<code>Pod</code>创建它的<code>Volume</code>目录。默认情况下，<code>kubelet</code>为<code>Volume</code>创建的目录是一个宿主机上的路径，比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/kubelet/pods/&lt;Pod 的ID&gt;/volumes/kubernetes.io-&lt;Volume 类型&gt;/&lt;Volume 名字&gt;</span><br></pre></td></tr></table></figure>

<p>如果你的<code>Volume</code>类型是远程块存储，比如<code>Google Cloud</code>的<code>Persistent Disk</code>，那么<code>kubelet</code>需要先调用<code>Google Cloud</code>的<code>API</code>，将它提供的<code>Persistent Disk</code>挂载到<code>Pod</code>所在的宿主机上。相当于执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcloud compute instances attach-disk &lt;虚拟机名字&gt; --disk &lt;远程磁盘名字&gt;</span><br></pre></td></tr></table></figure>

<p>这一步为虚拟机挂载远程磁盘的操作。  </p>
<p>如果你的<code>Volume</code>类型是远程文件存储，直接进入第二阶段。  </p>
<h2 id="第二阶段-Mount"><a href="#第二阶段-Mount" class="headerlink" title="第二阶段-Mount"></a>第二阶段-Mount</h2><p><code>kubelet</code>格式化这个磁盘设备，然后把它挂载到宿主机指定的挂载点上。  </p>
<h2 id="疑惑：Kubernetes如何定义和区分这两个阶段的呢？"><a href="#疑惑：Kubernetes如何定义和区分这两个阶段的呢？" class="headerlink" title="疑惑：Kubernetes如何定义和区分这两个阶段的呢？"></a>疑惑：Kubernetes如何定义和区分这两个阶段的呢？</h2><p>在具体的<code>Volume</code>插件的实现接口上，<code>Kubernetes</code>分别给这两个阶段提供了不同的参数列表：  </p>
<ul>
<li>第一阶段：<code>Kubernetes</code>提供的可用参数是<code>nodeName</code>-宿主机的名字；  </li>
<li>第二阶段：<code>Kubernetes</code>提供的可用参数是<code>dir</code>-<code>Volume</code>的宿主机目录。</li>
</ul>
<h1 id="Storage-Class"><a href="#Storage-Class" class="headerlink" title="Storage Class"></a>Storage Class</h1><p>由于PV 这个对象是由运维人员创建完成的，但是，在大规模的生产环境里，这其实是一个非常麻烦的工作。因为一个大规模的 Kubernetes 集群里很可能有成千上万个 PVC，这就意味着运维人员必须得事先创建出成千上万个 PV。更麻烦的是，随着新的 PVC 不断被提交，运维人员就不得不继续添加新的、能满足条件的 PV，否则新的 Pod 就会因为 PVC 绑定不到 PV而失败。在实际操作中，这几乎没办法靠人工做到。  </p>
<p>所以，Kubernetes 为我们提供了一套可以自动创建 PV 的机制，即：Dynamic<br>Provisioning。  </p>
<p>Dynamic Provisioning 机制工作的核心，在于一个名叫 StorageClass 的 API 对象。  </p>
<p><strong>而 StorageClass 对象的作用，就是创建 PV 的模板</strong>。具体地说<code>StorageClass</code>对象会定义如下两个部分内容：</p>
<ul>
<li>第一，PV 的属性。比如，存储类型、Volume 的大小等等。  </li>
<li>第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。</li>
</ul>
<p>有了这样两个信息之后，Kubernetes 就能够根据用户提交的 PVC，找到一个对应的<br>StorageClass 了。然后，Kubernetes 就会调用该 StorageClass 声明的存储插件，创建出需要的 PV。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>PV</code>，<code>PVC</code>，<code>StorageClass</code>之间的关系：<br><img src="/2022/09/09/kubernetes-storage-principle-pv-pvc/pv-pvc-storageclass.png">  </p>
<ul>
<li><code>PVC</code>描述的是<code>Pod</code>想使用的持久化存储的属性，比如存储的大小、读写权限等；  </li>
<li><code>PV</code>描述的则是一个具体的<code>Volume</code>的属性，比如<code>Volume</code>的类型、挂载目录、远程存储服务器地址等；  </li>
<li><code>StorageClass</code>的作用则是充当<code>PV</code>的模板，并且只有同属于一个<code>StorageClass</code>的<code>PV</code>和<code>PVC</code>才可以绑定在一起；  </li>
<li><code>StorageClass</code>的另一个重要作用是指定<code>PV</code>的<code>Provisioner</code>（存储指针）。此时，如果你的存储插件支持<code>Dynamic Provisioning</code>，<code>Kubernetes</code>就可以自动为你创建<code>PV</code>。</li>
</ul>
]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>存储原理</tag>
        <tag>持久化存储</tag>
        <tag>PV</tag>
        <tag>PVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程入门：任务式学习指南-出租车计费</title>
    <url>/2025/01/27/learn-java-task-guide-2-taxi-fare/</url>
    <content><![CDATA[<h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><p>本次任务是解决出租车计费问题。某市出租车计费标准见表3-1，请根据此标准完成一个出租车计费模拟功能，能够计算总费用和列出产生费用项目详细情况说明，帮助出租车师傅和乘客了解计费标准。<br><img src="/2025/01/27/learn-java-task-guide-2-taxi-fare/1.png">  </p>
<ul>
<li>早高峰为7∶00（含）～9∶00（不含）； 晚高峰为17∶00（含）～19∶00（不含）。  </li>
<li>出租车结算以元为单位，元以下四舍五入。  </li>
<li>过路、过桥费由乘客负担。</li>
</ul>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>掌握if语法。  </li>
<li>掌握switch语法。  </li>
<li>使用字符串常用方法。</li>
</ul>
<h1 id="任务线索"><a href="#任务线索" class="headerlink" title="任务线索"></a>任务线索</h1><h2 id="Java程序执行结构概述"><a href="#Java程序执行结构概述" class="headerlink" title="Java程序执行结构概述"></a>Java程序执行结构概述</h2><p>1996年，计算机科学家Bohm和Jacopini证明了：任何简单或复杂的算法都可以由顺序结构、选择结构和循环结构这三种基本结构组合而成。<br><img src="/2025/01/27/learn-java-task-guide-2-taxi-fare/2.png">  </p>
<h2 id="if语法"><a href="#if语法" class="headerlink" title="if语法"></a>if语法</h2><p>Java采用“if”关键字进行选择结构的处理。  </p>
<p><code>if</code>语句块的大括号是可选的，如果没有大括号限定，<code>if</code>语句只能影响条件判断后的一个指令（或许是一个分号结尾的执行代码，或许是一个其他的完整语法结构）。<br>注意：条件表达式的结果必须是boolean类型。  </p>
<p>如果需要根据条件执行二选一或者多选一的操作，需要用到<code>else</code>关键字进行配合（<code>else</code>是语法中的可选项）。</p>
<h2 id="switch语法"><a href="#switch语法" class="headerlink" title="switch语法"></a>switch语法</h2><p><code>switch</code>也是一种选择结构，相对于多重<code>if</code>结构，可读性更好，但是也有些特殊的语法要求。  </p>
<p><code>switch</code>执行逻辑：表达式与<code>case</code>后的匹配值一致时执行对应<code>case</code>包含的代码块，其他代码块不执行。<br><code>default</code>是可选项，与<code>if else</code>中<code>else</code>的作用相同，在没有匹配项的时候执行<code>default</code>后的代码块。<br><code>break</code>关键词也是可选的，它的作用在于退出<code>switch</code>结构。如果没有写<code>break</code>，代码会一直顺序向下执行。原则上Java不限制<code>case</code>和<code>default</code>的编写顺序，但习惯上如果有<code>default</code>都会放在最后。  </p>
<h1 id="任务实施"><a href="#任务实施" class="headerlink" title="任务实施"></a>任务实施</h1>]]></content>
      <categories>
        <category>LearnJava</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发中的FanIn范式学习</title>
    <url>/2019/06/02/learn-to-golang-fanin/</url>
    <content><![CDATA[<p>在学习并发时，对<code>Fanin</code>和<code>Fanout</code>这两个范式印象深刻，特此记录一下学习心得。  </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>扇出（Fan-out）是一个术语，用于描述启动多个goroutines以处理来自管道的输入的过程，并且扇入（fan-in）是描述将多个结果组合到一个通道中的过程的术语。  </p>
<p>画个图  </p>
<p><img src="/2019/06/02/learn-to-golang-fanin/fanin_o.png" alt="fanin">  </p>
<p><img src="/2019/06/02/learn-to-golang-fanin/fanout_o.png" alt="fanout">    </p>
<p>这样做有什么好处呢，下面来看看源码。  </p>
<h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><p>在<code>concurrent_map.go</code>文件中  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iter returns an iterator which could be used in a for range loop.</span></span><br><span class="line"><span class="comment">// Deprecated: using IterBuffered() will get a better performence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span></span> Iter() &lt;-<span class="keyword">chan</span> Tuple &#123;</span><br><span class="line">	chans := snapshot(m)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Tuple)</span><br><span class="line">	<span class="keyword">go</span> fanIn(chans, ch)</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chans []<span class="keyword">chan</span> Tuple, out <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chans))  <span class="comment">//总共要进入的管道数目</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chans &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> t := <span class="keyword">range</span> ch &#123;  <span class="comment">//取出每一个管道内的数据</span></span><br><span class="line">				out &lt;- t  <span class="comment">//将数据发送给管道接收者out</span></span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()  <span class="comment">//每取完一次管道内的数据，管道数目减1</span></span><br><span class="line">		&#125;(ch)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(out)  <span class="comment">//管道内的数据已经取完，关闭管道接收者out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画图演示下过程<br><img src="/2019/06/02/learn-to-golang-fanin/chan_o.png" alt="chan">  </p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li><code>sync.WaitGroup</code><br>sync.WaitGroup只有3个方法，Add()，Done()，Wait()。其中Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，计数不为0, 阻塞Wait()的运行。<br>因此当计数为0时，也就是要进入的管道数都没有的时候，关闭管道。</li>
</ul>
<h2 id="FanIn范式的用途"><a href="#FanIn范式的用途" class="headerlink" title="FanIn范式的用途"></a>FanIn范式的用途</h2><p>在此引用我看到的一段话  </p>
<blockquote>
<p>管道的一个有趣属性是它的各个阶段相互独立，方便组合。你可以多次重复使用管道的各个阶段。因此，在多个goroutine上重用管道的单个阶段实现并行化，将有助于提高管道的性能。<br>事实上，这种模式被称为扇入扇出。<br>那么在什么情况下适用于这种模式呢？如果出现以下两种情况，你就可以考虑这么干了：<br>    不依赖模块之前的计算结果。<br>    运行需要很长时间。</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.kancloud.cn/mutouzhang/go/596844">扇入扇出_Concurrency in Go 中文笔记</a>  </li>
<li><a href="https://austburn.me/blog/a-better-fan-in-fan-out-example.html">Go: A Better Fan-out, Fan-in Example</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>并发</tag>
        <tag>范式</tag>
        <tag>FanIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1-Two Sum | 两数之和</title>
    <url>/2019/06/09/leetcode-1-two-sum/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">two-sum</a>  </p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>简单题。常规解法（解法1），用两个<code>for</code>循环来做，第一个循环从数组<code>nums</code>下标为0开始遍历，第二个循环从数组下标1开始遍历，如果没找到两数之和的<code>target</code>值，就将两个循环的下标加1，继续循环，直到找到目标值，返回结果并退出。  </p>
<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;  <span class="comment">//第一个循环</span></span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;  <span class="comment">//第二个循环</span></span><br><span class="line">            <span class="keyword">if</span> x+nums[j] == target &#123;  <span class="comment">//如果数组前一个值+后一个值 = target</span></span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;  <span class="comment">//返回这两个值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 104-maximum-depth-of-binary-tree | 二叉树的最大深度</title>
    <url>/2020/12/02/leetcode-104-maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a>  </p>
<h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>此题可以用递归来解：  </p>
<h3 id="递归Golang"><a href="#递归Golang" class="headerlink" title="递归Golang"></a>递归Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left := maxDepth(root.Left) <span class="comment">// 左子树的最大深度</span></span><br><span class="line">        right := maxDepth(root.Right) <span class="comment">// 右子树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">int</span>(math.Max(<span class="type">float64</span>(left), <span class="type">float64</span>(right)) + <span class="number">1</span>) <span class="comment">// 深度加上根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 111-minimum-depth-of-binary-tree | 二叉树的最小深度</title>
    <url>/2020/12/05/leetcode-111-minimum-depth-of-binary-tree/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a>  </p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := minDepth(root.Left)</span><br><span class="line">    rightDepth := minDepth(root.Right)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(leftDepth,rightDepth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-122-best-time-to-buy-and-sell-stock-ii | 买卖股票的最佳时机II</title>
    <url>/2019/12/06/leetcode-122-best-time-to-buy-and-sell-stock-ii/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>  </li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于没有规定交易次数，所以可以遍历<code>prices</code>数组。<br>如果后一个比前一个大，做差，并累积利润，最后返回结果。  </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">            <span class="comment">//如果后一笔比前一笔数额大，做减法，累积利润</span></span><br><span class="line">            maxProfit = maxProfit + prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1137-n-th-tribonacci-number | 第 N 个泰波那契数</title>
    <url>/2020/12/05/leetcode-1137-n-th-tribonacci-number/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a>  </p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tribonacci</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp,x,y,z := <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>;i &lt;= n;i++ &#123;</span><br><span class="line">        tmp = x + y + z</span><br><span class="line">        x = y</span><br><span class="line">        y = z</span><br><span class="line">        z = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-13-roman-to-integer | 罗马数字转整数</title>
    <url>/2021/02/05/leetcode-13-roman-to-integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/roman-to-integer/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/roman-to-integer/">力扣</a>  </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先维护一个<code>map</code>，用于建立罗马数字和整数的关系，接着挨个破译即可。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> charToIntMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">    charToIntMap[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span></span><br><span class="line">    charToIntMap[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">&#x27;V&#x27;</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">&#x27;L&#x27;</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            sum += charToIntMap[s[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn执行：</span><br><span class="line">执行用时：16 ms, 在所有 Go 提交中击败了22.55%的用户</span><br><span class="line">内存消耗：3.1 MB, 在所有 Go 提交中击败了78.12%的用户</span><br><span class="line"></span><br><span class="line">leetcode执行：</span><br><span class="line">Runtime: 8 ms, faster than 64.36% of Go online submissions for Roman to Integer.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Roman to Integer.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-136-single-number | 只出现一次的数字</title>
    <url>/2019/12/15/leetcode-136-single-number/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/single-number/">leetcode中国</a>  </li>
<li><a href="https://leetcode.com/problems/single-number/">leetcode</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>第一步，新建一个<code>map</code>，用一个<code>for</code>循环，记录<code>nums</code>数组中出现的元素和次数，如果重复出现，<code>value</code>置为2，出现一次置为1；  </li>
<li>第二步，再用一个<code>for</code>循环，遍历这个新建<code>map</code>，判断<code>value</code>为是否1，如果为1，就把<code>value</code>为1对应的<code>key</code>返回即可。</li>
</ul>
<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    numsmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> numsmap[v] != <span class="number">0</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">2</span>  <span class="comment">//有重复，value为2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">1</span>  <span class="comment">//无重复，value为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> numsmap &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">            result = k  <span class="comment">//返回那个只出现一次的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-121-best-time-to-buy-and-sell-stock | 买卖股票的最佳时机</title>
    <url>/2019/12/05/leetcode-121-best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">原题链接</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">中文原题链接</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>1，暴力求解，直接求出买入和买出的最大值返回即可。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>方法一：暴力法求解</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(prices); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[j] - prices[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-14-longest-common-prefix | 最长公共前缀</title>
    <url>/2021/02/06/leetcode-14-longest-common-prefix/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-common-prefix/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/longest-common-prefix/">LeetCode-cn</a>  </p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= strs.length &lt;= 200</span><br><span class="line">0 &lt;= strs[i].length &lt;= 200</span><br><span class="line">strs[i] consists of only lower-case English letters.</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题目的简单描述就是找一堆字符串的相同前缀，比如<code>flower</code>、<code>flow</code>、<code>flight</code>，发现每个字符串都有前缀<code>fl</code>，于是就将<code>fl</code>返回即可，本题就是要实现这样一个在字符串数组中找最长前缀的函数。  </p>
<h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">//排除特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	res := strs[<span class="number">0</span>]               <span class="comment">//获取字符串数组里的第一个元素</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> strs[<span class="number">1</span>:] &#123; <span class="comment">//从字符串数组第二个元素开始遍历</span></span><br><span class="line">		<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(v) &amp;&amp; i &lt; <span class="built_in">len</span>(res); i++ &#123; <span class="comment">//遍历两数组里的元素</span></span><br><span class="line">			<span class="keyword">if</span> res[i] != v[i] &#123; <span class="comment">//做判断，如果不相等</span></span><br><span class="line">				<span class="keyword">break</span> <span class="comment">//直接结束循环</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res = res[:i]</span><br><span class="line">		<span class="keyword">if</span> res == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> res <span class="comment">//返回空</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种相似解法，会用到<a href="https://golang.org/pkg/strings/#Index">strings.Index</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    prefix := strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _,k := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">for</span> strings.Index(k,prefix) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            prefix = prefix[:<span class="built_in">len</span>(prefix) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">力扣：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.3 MB, 在所有 Go 提交中击败了55.76%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Longest Common Prefix.</span><br><span class="line">Memory Usage: 2.4 MB, less than 100.00% of Go online submissions for Longest Common Prefix.</span><br></pre></td></tr></table></figure>

<h2 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/">力扣官方题解-5种解法</a></p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 141-linked-list-cycle | 环形链表</title>
    <url>/2020/12/04/leetcode-141-linked-list-cycle/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a>  </p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>该题是面试常考题型，以前好友面字节游戏引擎岗的时候专门考过。  </p>
<h3 id="快慢指针Golang"><a href="#快慢指针Golang" class="headerlink" title="快慢指针Golang"></a>快慢指针Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow := head  <span class="comment">//慢指针</span></span><br><span class="line">    fast := head.Next  <span class="comment">//快指针</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="comment">//一块一慢，如果两个指针指向同一个值，说明链表有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1480_running-sum-of-1d-array | 一维数组的动态和</title>
    <url>/2020/07/03/leetcode-1480-running-sum-of-1d-array/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">leetcode中国</a>  </p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>设置中间变量，循环一次，记录一次元素和，遍历完后返回结果。  </p>
<ul>
<li>Golang</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runningSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//中间变量，一边循环，一边保存元素和</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="comment">//将索引小于等于i的全部元素相加，赋值索引为i的元素</span></span><br><span class="line">        sum += nums[i]</span><br><span class="line">        nums[i] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1512 number of good pairs | 好数对的数目</title>
    <url>/2020/10/05/leetcode-1512-number-of-good-pairs/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">https://leetcode-cn.com/problems/number-of-good-pairs/</a>  </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一，暴力法"><a href="#方法一，暴力法" class="headerlink" title="方法一，暴力法"></a>方法一，暴力法</h3><p>先声明一个计数值<code>count</code>作为返回的结果，然后从数组下标０开始，挨个遍历下标０之后的值，接着做判断，如果两个值相等就将<code>count</code>加１，否则继续循环，直到结束返回<code>count</code>值即可。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIdenticalPairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//暴力法</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>;j &lt; <span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> x == nums[j] &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 179.largest-number | 最大数</title>
    <url>/2021/04/25/leetcode-179-largest-number/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。  </p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure>

<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-189-rotate-array | 旋转数组</title>
    <url>/2020/02/13/leetcode-189-rotate-array/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href>leetcode中国</a></li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="方法一，暴力求解"><a href="#方法一，暴力求解" class="headerlink" title="方法一，暴力求解"></a>方法一，暴力求解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//暴力解决</span></span><br><span class="line">    <span class="keyword">var</span> temp,previous <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++ &#123;</span><br><span class="line">        previous = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            temp = nums[j]</span><br><span class="line">            nums[j] = previous</span><br><span class="line">            previous = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方法二，使用额外的数组"><a href="#方法二，使用额外的数组" class="headerlink" title="方法二，使用额外的数组"></a>方法二，使用额外的数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//使用额外的数组</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        a[(i+k) % <span class="built_in">len</span>(nums)] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20-valid-parentheses | 有效的括号</title>
    <url>/2021/01/22/leetcode-20-valid-parentheses/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/valid-parentheses/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode-cn</a>  </p>
<p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ul>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;()&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;(]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;([)]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= s.length &lt;= 104</span><br><span class="line">s consists of parentheses only &#x27;()[]&#123;&#125;&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题是经典的考察栈的题目。  </p>
<h3 id="解法一：使用strings-Replace替换为空"><a href="#解法一：使用strings-Replace替换为空" class="headerlink" title="解法一：使用strings.Replace替换为空"></a>解法一：使用<a href="https://golang.org/pkg/strings/#Replace">strings.Replace</a>替换为空</h3><p>直接用<code>strings.Replace</code>方法，将<code>()、[]、&#123;&#125;</code>这样的字符串替换为空，如果最后全都可以替换掉，说明是有效字符串，返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(s) != <span class="number">0</span> &#123;</span><br><span class="line">		temp := s</span><br><span class="line">		s = strings.Replace(s, <span class="string">&quot;()&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">		s = strings.Replace(s, <span class="string">&quot;[]&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">		s = strings.Replace(s, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s == temp &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn执行：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了6.50%的用户</span><br><span class="line">内存消耗：7.1 MB, 在所有 Go 提交中击败了5.26%的用户</span><br><span class="line"></span><br><span class="line">leetcode执行：</span><br><span class="line">Runtime: 4 ms, faster than 5.19% of Go online submissions for Valid Parentheses.</span><br><span class="line">Memory Usage: 7 MB, less than 7.32% of Go online submissions for Valid Parentheses.</span><br></pre></td></tr></table></figure>

<h3 id="解法二：栈"><a href="#解法二：栈" class="headerlink" title="解法二：栈"></a>解法二：栈</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//考虑空字符串的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//定义一个栈</span></span><br><span class="line">	stack := <span class="built_in">make</span>([]<span class="type">int32</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    <span class="comment">//判断括号是否匹配</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;(&#x27;</span> || v == <span class="string">&#x27;[&#x27;</span> || v == <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">//左括号，入栈</span></span><br><span class="line">            stack[length] = v</span><br><span class="line">            length++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//右括号，比较栈顶，匹配则移除，不匹配就返回false</span></span><br><span class="line">            <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[length<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>) || (v == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack[length<span class="number">-1</span>] == <span class="string">&#x27;[&#x27;</span>) || (v == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack[length<span class="number">-1</span>] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                length--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn执行：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2 MB, 在所有 Go 提交中击败了72.86%的用户</span><br><span class="line"></span><br><span class="line">leetcode执行：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Valid Parentheses.</span><br><span class="line">Memory Usage: 2 MB, less than 98.88% of Go online submissions for Valid Parentheses.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>括号问题</tag>
        <tag>replace</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-2-add-two-numbers | 两数相加</title>
    <url>/2019/12/23/leetcode-2-add-two-numbers/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//先考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sum := l1.Val + l2.Val</span><br><span class="line">    nextNode := addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    <span class="keyword">if</span> sum &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123; Val: sum, Next: nextNode &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tempNode := &amp;ListNode&#123;</span><br><span class="line">            Val: <span class="number">1</span>,</span><br><span class="line">            Next: <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123;</span><br><span class="line">            Val: sum - <span class="number">10</span>,</span><br><span class="line">            Next: addTwoNumbers(nextNode, tempNode),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-242-valid-anagram | 有效的字母异位词</title>
    <url>/2020/02/07/leetcode-242-valid-anagram/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/">leetcode中国</a>  </p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    countmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint8</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		countmap[s[i]]++</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        countmap[t[i]]--</span><br><span class="line">        <span class="keyword">if</span> countmap[t[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>map</tag>
        <tag>字符串比较</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21.Merge Two Sorted Lists | 合并两个有序链表</title>
    <url>/2021/02/08/leetcode-21-merge-two-sorted-lists/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode-cn</a>  </p>
<p>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: l1 = [], l2 = []</span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: l1 = [], l2 = [0]</span><br><span class="line">Output: [0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">The number of nodes in both lists is in the range [0, 50].</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">Both l1 and l2 are sorted in non-decreasing order.</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题是经典的考察链表的题目。  </p>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><ul>
<li>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</li>
<li>返回值：每一层调用都返回排序好的链表头</li>
<li>本级递归内容：如果 <code>l1</code> 的 <code>val</code> 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</li>
<li><code>O(m+n)O(m+n)</code>，<code>mm</code> 为 <code>l1</code>的长度，<code>nn</code> 为 <code>l2</code> 的长度</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1.Val &lt; l2.Val) &#123;</span><br><span class="line">        l1.Next = mergeTwoLists(l1.Next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.Next = mergeTwoLists(l1, l2.Next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.6 MB, 在所有 Go 提交中击败了26.43%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Merge Two Sorted Lists.</span><br><span class="line">Memory Usage: 2.6 MB, less than 51.09% of Go online submissions for Merge Two Sorted Lists.</span><br></pre></td></tr></table></figure>

<p>可以看到，该解法执行用时为0ms，非常高效。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/">力扣-画解算法：21. 合并两个有序链表</a></p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-26.Remove Duplicates from Sorted Array | 删除排序数组中的重复项</title>
    <url>/2021/02/09/leetcode-26-remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode-cn</a>  </li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">leetcode</a></li>
</ul>
<p>Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.  </p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  </p>
<p>Clarification:  </p>
<p>Confused why the returned value is an integer but your answer is an array?  </p>
<p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.  </p>
<p>Internally you can think of this:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2]</span><br><span class="line">Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#x27;t matter what you leave beyond the returned length.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4]</span><br><span class="line">Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn&#x27;t matter what values are set beyond the returned length.</span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= nums.length &lt;= 3 * 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums is sorted in ascending order.</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题就是希望让我返回一个没有重复数字的数组的大小，且不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。  </p>
<h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>用<code>for</code>循环从数组<code>nums</code>末尾的最后一个数字开始遍历，让数组<code>nums</code>末尾最后一个数字与末尾最后倒数第二个数字做比较，如果后一个等于前一个，则从数组中删除后一个元素，直到遍历完成，返回新数组的长度。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums[:i],nums[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：双指针法"><a href="#解法二：双指针法" class="headerlink" title="解法二：双指针法"></a>解法二：双指针法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;  <span class="comment">//考虑特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="number">0</span>; <span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>;j &lt; <span class="built_in">len</span>(nums);j++ &#123;  <span class="comment">//j是快指针</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] != nums[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：8 ms, 在所有 Go 提交中击败了86.25%的用户</span><br><span class="line">内存消耗：4.6 MB, 在所有 Go 提交中击败了65.76%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 99.38% of Go online submissions for Remove Duplicates from Sorted Array.</span><br><span class="line">Memory Usage: 4.6 MB, less than 100.00% of Go online submissions for Remove Duplicates from Sorted Array.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-27. Remove Element | 移除元素</title>
    <url>/2021/02/10/leetcode-27-remove-element/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/remove-element/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/remove-element/">LeetCode-cn</a>  </p>
<p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.  </p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  </p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.  </p>
<p>Clarification:  </p>
<p>Confused why the returned value is an integer but your answer is an array?  </p>
<p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.  </p>
<p>Internally you can think of this:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2]</span><br><span class="line">Explanation: Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line">It doesn&#x27;t matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3]</span><br><span class="line">Explanation: Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn&#x27;t matter what values are set beyond the returned length.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 50</span><br><span class="line">0 &lt;= val &lt;= 100</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为简单。  </p>
<p>特别注意<strong>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</strong>  </p>
<h3 id="解法一：双指针法"><a href="#解法一：双指针法" class="headerlink" title="解法一：双指针法"></a>解法一：双指针法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//双指针法</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(nums);j++ &#123;  <span class="comment">//遍历nums数组</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] != val &#123;  <span class="comment">//如果nums下标 j 对应的元素不等于 val</span></span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.1 MB, 在所有 Go 提交中击败了99.85%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Remove Element.</span><br><span class="line">Memory Usage: 2.1 MB, less than 17.08% of Go online submissions for Remove Element.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-283-move-zeroes | 移动零</title>
    <url>/2020/02/07/leetcode-283-move-zeroes/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/move-zeroes/">leetcode中国</a></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="comment">//1，先将非0的数排到数组前面</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">            nums[index] = v</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2，再排是0的数到nums数组后面</span></span><br><span class="line">    <span class="keyword">for</span> i:=index;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-217-contains-duplicate | 存在重复元素</title>
    <url>/2019/12/07/leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate">leetcode中国</a><br><a href="https://leetcode.com/problems/contains-duplicate/">leetcode</a>  </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑到特殊情况，<strong>nums数组元素为0和1，直接返回false</strong><br>设置计数变量<code>count</code>，将第一次遍历数组得到的元素与第二次遍历数组得到的元素做判断，如果两数相等，就将<code>count</code>加1，在结束循环后对<code>count</code>做判断，<code>count</code>值不等于0返回<code>true</code>，否则返回<code>false</code>。  </p>
<p>这里尤其需要注意，第一次遍历数组的下标一定比第二次遍历出的数组元素下标大，举个例子：<br>输入<code>[1,2,3,1]</code>，判断这个数组里有没有重复元素，第一次遍历<code>nums[0]</code>得到1，那么第二次遍历时肯定不能从<code>nums[0]</code>开始，必须从<code>nums[1]</code>开始往后累加，不然在同一个数组中，将下标相等的两个元素做比较，肯定相等，从而AC不通过。  </p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> || <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">//考虑nums特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[j] &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="附录，踩坑记录"><a href="#附录，踩坑记录" class="headerlink" title="附录，踩坑记录"></a>附录，踩坑记录</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>创建一个<code>shift</code>数组，第一步先遍历<code>nums</code>数组，将每次遍历取出的<code>num</code>与<code>shift</code>数组里的值做判断，如果相等就代表重复，<code>count</code>增1，最后在循环结束后，对<code>count</code>做判断，如果不等于1，返回<code>true</code>，否则返回<code>false</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shift []<span class="type">int</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(shift) == <span class="number">0</span> &#123;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _,s := <span class="keyword">range</span> shift &#123;</span><br><span class="line">                <span class="keyword">if</span> s == num &#123;</span><br><span class="line">                    count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">1</span> &amp;&amp; count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第一版存在的问题"><a href="#第一版存在的问题" class="headerlink" title="第一版存在的问题"></a>第一版存在的问题</h4><ul>
<li>为什么要复制数组，直接用原来的<code>nums</code>数组做<code>range</code>不可以吗？  </li>
<li><code>append</code>数组有问题  </li>
<li>没有考虑<code>nums</code>数组元素为1和0两种特殊情况  </li>
<li>判断条件只需满足<code>count != 0</code>即可</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-28-implement-strstr | 实现 strStr()</title>
    <url>/2021/02/12/leetcode-28-implement-strstr/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/implement-strstr/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/implement-strstr/">LeetCode-cn</a>  </p>
<p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Clarification:</p>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= haystack.length, needle.length &lt;= 5 * 104</span><br><span class="line">haystack and needle consist of only lower-case English characters.</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度简单。<br>这道题就是说要找到<code>needle</code>在<code>haystack</code>第一个出现的位置，如果没有出现就返回<code>-1</code>。  </p>
<h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    len_h := <span class="built_in">len</span>(haystack)  <span class="comment">//获取haystack字符串的长度</span></span><br><span class="line">    len_n := <span class="built_in">len</span>(needle)  <span class="comment">//获取needle字符串的长度</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len_h-len_n+<span class="number">1</span>;i++ &#123;</span><br><span class="line">        j := <span class="number">0</span>;  <span class="comment">//子串每次都要重头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> ;j&lt;len_n;j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i+j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == len_n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.2 MB, 在所有 Go 提交中击败了64.54%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Implement strStr().</span><br><span class="line">Memory Usage: 2.3 MB, less than 100.00% of Go online submissions for Implement strStr().</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>Golang</code>中的内置函数<a href="https://golang.org/pkg/strings/#Index">strings.Index</a>也可以实现，可以参考它的源码实现。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Index(haystack,needle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>暴力法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-287-find-the-duplicate-number | 寻找重复数</title>
    <url>/2020/05/26/leetcode-287-find-the-duplicate-number/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">find-the-duplicate-number</a>  </p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><ul>
<li>建立一个key为int，value为int的map；  </li>
<li>第一遍<code>for range</code>循环遍历<code>nums</code>数组，将<code>nums</code>数组里的元素出现的次数记录进<code>map</code>中；  </li>
<li>第二遍<code>for range</code>循环遍历<code>map</code>，将value不为1的num取出返回，即为重复数。</li>
</ul>
<p>这个解法需要用两次<code>for</code>循环，效率不高，下面我考虑用第二种解法。  </p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><ul>
<li>建立一个key为int，value为bool类型的map；  </li>
<li>一遍<code>for range</code>循环遍历<code>nums</code>数组，如果这个<code>num</code>第一次出现，就将其value置为true，否则直接返回这个<code>num</code>，因为value为true代表这个<code>num</code>已经出现过一次了，第二次再遍历到它时，即为重复数。</li>
</ul>
<p>go代码  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numsmap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !numsmap[num] &#123;</span><br><span class="line">            <span class="comment">//只出现一次</span></span><br><span class="line">            numsmap[num] = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>map</tag>
        <tag>循环</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-292-nim-game | Nim 游戏</title>
    <url>/2019/12/19/leetcode-292-nim-game/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/nim-game/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只要不被4整除就行。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canWinNim</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>合理分析问题，做数学归纳，有时候可以化繁为简，一眼洞穿题目的本质！  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/">leetcdoe官方解答</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 322. Coin Change | 零钱兑换</title>
    <url>/2022/01/04/leetcode-322-coin-change/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>  </p>
<h1 id="解法一：贪心算法"><a href="#解法一：贪心算法" class="headerlink" title="解法一：贪心算法"></a>解法一：贪心算法</h1><p>贪心算法，就是指它的每一步计算作出的都是在当前看起来最好的选择，也就是说它所作出的选择只是在某种意义上的局部最优选择，并不从整体最优考虑。  </p>
<p>基本思路：<br>1，根据问题来建立数学模型，一般面试题会定义一个简单模型；<br>2，把待求解问题划分成若干个子问题，对每个子问题进行求解，得到子问题的局部最优解；<br>3，把子问题的局部最优解进行合并，得到最后基于局部最优解的一个解，即原问题的答案。  </p>
<p>举例：我们从 c[0]&#x3D;5, c[1]&#x3D;3 且 k&#x3D;11 的情况下寻求最少硬币数。按照“贪心原则”，我们先挑选面值最大的，即为 5 的硬币放入钱包。接着，还有 6 元待解（即 11-5 &#x3D; 6）。这时，我们再次“贪心”，放入 5 元面值的硬币。  </p>
<p><img src="/2022/01/04/leetcode-322-coin-change/%E8%B4%AA%E5%BF%831.png">  </p>
<h1 id="解法二：贪心算法的优化"><a href="#解法二：贪心算法的优化" class="headerlink" title="解法二：贪心算法的优化"></a>解法二：贪心算法的优化</h1><h1 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h1><p>动态规划问题一定具备以下三个特征：<br>1，重叠子问题：在穷举的过程中（比如通过递归），存在重复计算的现象；<br>2，无后效性：子问题之间的依赖是单向性的，某阶段状态一旦确定，就不受后续决策的影响；<br>3，最优子结构：子问题之间必须相互独立，或者说后续的计算可以通过前面的状态推导出来。  </p>
<p>当剩余的金额为 0 时结束穷举，因为这时不需要任何硬币就已经凑出目标金额了。在动态规划中，我们将其称之为初始化状态。  </p>
<p>接着，我们按照上面提到的凑硬币的思路，找出子问题与原问题之间会发生变化的变量。原问题指定了硬币的面值，同时没有限定硬币的数量，因此它们俩无法作为“变量”。唯独剩余需要兑换的金额是变化的，因此在这个题目中，唯一的变量是目标兑换金额 k。在动态规划中，我们将其称之为状态参数。  </p>
<p>接着，既然我们确定了状态，那么什么操作会改变状态，并让它不断逼近初始化状态呢？每当我们挑一枚硬币，用来凑零钱，就会改变状态。在动态规划中，我们将其称之为决策。  </p>
<p>终于，我们构造了一个初始化状态 -&gt; 确定状态参数 -&gt; 设计决策的思路。  </p>
<p>现在来写状态转移方程，通常情况下，状态转移方程的参数就是状态转移过程中的变量，即状态参数。而函数的返回值就是答案，在这里是最少兑换的硬币数。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DP(values, k) &#123;</span><br><span class="line">    res = MAX</span><br><span class="line">    <span class="keyword">for</span> c in values</span><br><span class="line">        <span class="comment">// 作出决策，找到需要硬币最少的那个结果</span></span><br><span class="line">        res = min(res, <span class="number">1</span> + DP(values, k-c)) <span class="comment">// 递归调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res == MAX</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着这个思路，我把状态转移方程给写出来，它是这样的：  </p>
<p><img src="/2022/01/04/leetcode-322-coin-change/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png">  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    memo := <span class="built_in">make</span>([]<span class="type">int</span>,amount + <span class="number">1</span>)  <span class="comment">//创建备忘录</span></span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; amount+<span class="number">1</span>;i++ &#123;</span><br><span class="line">        memo[i] = amount + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; amount+<span class="number">1</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _,coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> i - coin &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = min(memo[i],memo[i - coin] + <span class="number">1</span>)  <span class="comment">//作出决策</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> memo[amount] == amount + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：通过  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：8 ms, 在所有 Go 提交中击败了92.64% 的用户</span><br><span class="line">内存消耗：6.3 MB, 在所有 Go 提交中击败了95.87% 的用户</span><br></pre></td></tr></table></figure>

<h1 id="辨别一个算法问题是否该使用动态规划来解的五大特点"><a href="#辨别一个算法问题是否该使用动态规划来解的五大特点" class="headerlink" title="辨别一个算法问题是否该使用动态规划来解的五大特点"></a>辨别一个算法问题是否该使用动态规划来解的五大特点</h1><ul>
<li>求最优解问题（最大值和最小值）；  </li>
<li>求可行性（True 或 False）；  </li>
<li>求方案总数；  </li>
<li>数据结构不可排序（Unsortable）；  </li>
<li>算法不可使用交换（Non-swappable）。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 329.longest-increasing-path-in-a-matrix | 矩阵中的最长递增路径</title>
    <url>/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。  </p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。  </p>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a>  </p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeSumBST</span><span class="params">(root *TreeNode, low <span class="type">int</span>, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Left, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="宽度优先搜索（待完善）"><a href="#宽度优先搜索（待完善）" class="headerlink" title="宽度优先搜索（待完善）"></a>宽度优先搜索（待完善）</h3>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-34-find-first-and-last-position-of-element-in-sorted-array | 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2021/07/17/leetcode-34-find-first-and-last-position-of-element-in-sorted-array/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p><strong>进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">nums 是一个非递减数组</span><br><span class="line">-109 &lt;= target &lt;= 109</span><br></pre></td></tr></table></figure>

<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="常规解法-暴力-O-n"><a href="#常规解法-暴力-O-n" class="headerlink" title="常规解法-暴力-O(n)"></a>常规解法-暴力-O(n)</h3><ul>
<li>利用数组有序的特点，从头到尾遍历一次数组  </li>
<li>在遍历的开始，检查遍历到的元素是否等于target，遇到刚好等于target的时候，记录当前位置  </li>
<li>接着遍历，检查遍历到大元素是否不等于target，遇到刚好不等于target的时候，记录当前位置的前一个位置即可</li>
</ul>
<h3 id="进阶解法-二分查找-O-log-n"><a href="#进阶解法-二分查找-O-log-n" class="headerlink" title="进阶解法-二分查找-O(log n)"></a>进阶解法-二分查找-O(log n)</h3><ul>
<li>基本思想：在一个区间范围里看处在中间位置的元素的值nums[mid]与目标元素target的大小关系，进而决定目标值落在哪一个部分里  </li>
<li>目标元素target在有序数组中很可能存在多个  </li>
<li>使用二分查找方法看到的处在中间元素的值nums[mid]恰好等于目标元素target的时候，还需要继续查找（继续做二分查找）</li>
</ul>
<p>方法1：使用<code>sort.SearchInts</code>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    leftmost := sort.SearchInts(nums, target)  <span class="comment">//sort.SearchInts封装好的二分查找</span></span><br><span class="line">    <span class="keyword">if</span> leftmost == <span class="built_in">len</span>(nums) || nums[leftmost] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;  <span class="comment">//不存在，范围[-1,-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    rightmost := sort.SearchInts(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;leftmost, rightmost&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：自己实现  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left := search(nums, target)</span><br><span class="line">    <span class="keyword">if</span> left == <span class="built_in">len</span>(nums) || nums[left] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right := search(nums, target+<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="comment">// [l, r]</span></span><br><span class="line">	<span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">		mid := l + (r-l)&gt;&gt;<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			l = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lai-gen-gao-shou-xue-xie-er-fen-cha-zhao-y602/">leetcode题解_来跟高手学写二分查找</a><br><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-mo-ban-go-by-xilepeng-d60d/">leetcode题解_二分查找+模板go</a><br><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/go-er-fen-cha-zhao-de-bian-chong-by-wo-s-lajb/">leetcode题解_Go 二分查找的变种</a>  </p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-344-reverse-string | 反转字符串</title>
    <url>/2019/12/12/leetcode-344-reverse-string/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/reverse-string/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步，使用<code>for</code>循环，将数组<code>s</code>里的最后一位<code>append</code>进新数组<code>result</code>，以此类推<br>第二步，将新数组<code>result</code>里的值复制到数组s即可  </p>
<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="type">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result,s[<span class="built_in">len</span>(s)-i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> result &#123;</span><br><span class="line">        s[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-35. Search Insert Position | 搜索插入位置</title>
    <url>/2021/02/13/leetcode-35-search-insert-position/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/search-insert-position/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode-cn</a></p>
<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: nums = [1,3,5,6], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: nums = [1], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums contains distinct values sorted in ascending order.</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。</p>
<h3 id="解法一：暴力求解法"><a href="#解法一：暴力求解法" class="headerlink" title="解法一：暴力求解法"></a>解法一：暴力求解法</h3><p>使用<code>for</code>循环遍历<code>nums</code>数组，从下标<code>0</code>开始按个与目标值<code>target</code>进行对比，如果<code>nums[i]&gt;=target</code>，说明目标值在数组所有元素之前，直接返回<code>i</code>即可；另一种情况就是目标值在数组所有元素之后，这时返回<code>nums</code>数组长度<code>len(nums)</code>即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：2.9 MB, 在所有 Go 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure>

<h3 id="解法二：二分查找法"><a href="#解法二：二分查找法" class="headerlink" title="解法二：二分查找法"></a>解法二：二分查找法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low := <span class="number">0</span></span><br><span class="line">    high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">        <span class="comment">// 下方写法为了防止数据溢出，如果先加在除以2 加完的值可能会大于INT_MAX，造成溢出 </span></span><br><span class="line">        mid := low + (high - low) / <span class="number">2</span></span><br><span class="line">        guess := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">//找到了，返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> guess &gt; target &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid +<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 8.78% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.3 MB, less than 6.08% of Go online submissions for Search Insert Position.</span><br></pre></td></tr></table></figure>

<h3 id="解法三：golang-sort-SearchInts包"><a href="#解法三：golang-sort-SearchInts包" class="headerlink" title="解法三：golang-sort.SearchInts包"></a>解法三：<a href="https://golang.org/pkg/sort/#SearchInts">golang-sort.SearchInts</a>包</h3><p>解题时不推荐。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.SearchInts(nums, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>暴力法</tag>
        <tag>排序</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-38. Count and Say | 外观数列</title>
    <url>/2021/02/14/leetcode-38-count-and-say/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/count-and-say/">LeetCode</a><br><a href="https://leetcode-cn.com/problems/count-and-say/">LeetCode-cn</a></p>
<p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:</p>
<ul>
<li>countAndSay(1) &#x3D; “1”</li>
<li>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.</li>
</ul>
<p>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = say &quot;11&quot; = two 1&#x27;s = &quot;21&quot;</span><br><span class="line">countAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= n &lt;= 30</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。<br>典型的递归题目。  </p>
<h3 id="解法一：笨办法-打表"><a href="#解法一：笨办法-打表" class="headerlink" title="解法一：笨办法-打表"></a>解法一：笨办法-打表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;11&quot;</span>,</span><br><span class="line"><span class="string">&quot;21&quot;</span>,</span><br><span class="line"><span class="string">&quot;1211&quot;</span>,</span><br><span class="line"><span class="string">&quot;111221&quot;</span>,</span><br><span class="line"><span class="string">&quot;312211&quot;</span>,</span><br><span class="line"><span class="string">&quot;13112221&quot;</span>,</span><br><span class="line"><span class="string">&quot;1113213211&quot;</span>,</span><br><span class="line"><span class="string">&quot;31131211131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;13211311123113112211&quot;</span>,</span><br><span class="line"><span class="string">&quot;11131221133112132113212221&quot;</span>,</span><br><span class="line"><span class="string">&quot;3113112221232112111312211312113211&quot;</span>,</span><br><span class="line"><span class="string">&quot;1321132132111213122112311311222113111221131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;11131221131211131231121113112221121321132132211331222113112211&quot;</span>,</span><br><span class="line"><span class="string">&quot;311311222113111231131112132112311321322112111312211312111322212311322113212221&quot;</span>,</span><br><span class="line"><span class="string">&quot;132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211&quot;</span>,</span><br><span class="line"><span class="string">&quot;11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211&quot;</span>,</span><br><span class="line"><span class="string">&quot;1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221&quot;</span>,</span><br><span class="line"><span class="string">&quot;11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211&quot;</span>,</span><br><span class="line"><span class="string">&quot;311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>,</span><br><span class="line"><span class="string">&quot;111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221&quot;</span>,</span><br><span class="line"><span class="string">&quot;3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211&quot;</span>,</span><br><span class="line"><span class="string">&quot;132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>,</span><br><span class="line"><span class="string">&quot;31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221&quot;</span>,</span><br><span class="line"><span class="string">&quot;13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211&quot;</span>,</span><br><span class="line"><span class="string">&quot;11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>,</span><br><span class="line"><span class="string">&quot;3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码时间复杂度为<code>O(1)</code>  </p>
<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.1 MB, 在所有 Go 提交中击败了99.11%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 2.1 MB, less than 100.00% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure>

<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(<span class="string">&quot;1&quot;</span>,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digui</span><span class="params">(prestr <span class="type">string</span>,n <span class="type">int</span>)</span></span><span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prestr</span><br><span class="line">    &#125;</span><br><span class="line">    temp:=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(prestr);i&gt;<span class="number">0</span>;&#123;</span><br><span class="line">        j:=i</span><br><span class="line">        <span class="keyword">for</span> ;j&gt;<span class="number">0</span>&amp;&amp;prestr[j<span class="number">-1</span>:j] == prestr[i<span class="number">-1</span>:i];j--&#123;&#125;</span><br><span class="line">        temp=strconv.Itoa(i-j)+prestr[i<span class="number">-1</span>:i]+temp</span><br><span class="line">        i = i-(i-j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(temp,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：12 ms, 在所有 Go 提交中击败了28.30%的用户</span><br><span class="line">内存消耗：7.3 MB, 在所有 Go 提交中击败了25.81%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 46.85% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 6.6 MB, less than 32.43% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-392-is-subsequence | 判断子序列</title>
    <url>/2020/07/31/leetcode-392-is-subsequence/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://leetcode-cn.com/problems/is-subsequence/">leetcode中国</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>Golang </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)  </span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span> <span class="comment">//初始化两个指针i,j分别指向s和t初始化的位置</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &amp;&amp; j &lt; m &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">            i++  <span class="comment">//匹配成功，则i,j同时右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++  <span class="comment">//匹配失败，则j右移，i不变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == n  <span class="comment">//最终如果i移动到s的末尾，就说明s是t的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-387-first-unique-character-in-a-string | 字符串中的第一个唯一字符</title>
    <url>/2020/02/11/leetcode-387-first-unique-character-in-a-string/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">leetcode中国</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1，建立一个字符为<code>key</code>，出现次数为<code>int</code>类型的<code>map</code>；<br>2，第一次循环，记录字符串中每个字符出现的次数；<br>3，第二次循环，找出<code>index</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// build hash map : character and how often it appears</span></span><br><span class="line">    cmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        c := s[i]</span><br><span class="line">        cmap[c] = cmap[c] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the index</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cmap[s[i]] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-412-fizz-buzz | Fizz Buzz</title>
    <url>/2020/02/02/leetcode-412-fizz-buzz/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/fizz-buzz/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按照题目要求的一步步写，读取<code>n</code>的值，然后开始一个<code>for</code>循环在里面一个个判断满足的结果，注意要先将<code>既是3又是5的倍数</code>这一条件进行优先判断。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fizzBuzz</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">&quot;FizzBuzz&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">&quot;Buzz&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">&quot;Fizz&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,strconv.Itoa(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 42.trapping-rain-water | 接雨水</title>
    <url>/2021/04/25/leetcode-42-trapping-rain-water/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  </p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left, right, leftMax, rightMax, res <span class="type">int</span></span><br><span class="line">	right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		<span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">			<span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line">				<span class="comment">//设置左边最高柱子</span></span><br><span class="line">				leftMax = height[left]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池</span></span><br><span class="line">				res += leftMax - height[left]</span><br><span class="line">			&#125;</span><br><span class="line">			left++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> height[right] &gt; rightMax &#123; </span><br><span class="line">				<span class="comment">//设置右边最高柱子</span></span><br><span class="line">				rightMax = height[right] </span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池</span></span><br><span class="line">				res += rightMax - height[right] </span><br><span class="line">			&#125;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-448-Find All Numbers Disappeared in an Array | 找到所有数组中消失的数字</title>
    <url>/2019/07/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">Find All Numbers Disappeared in an Array</a>  </p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目意思是找出1～n(n是指数组的长度)内没有出现的数。例如[4,3,2,7,8,2,3,1]里1~8没有出现的数有5,6，所以输出就是[5,6]。  </p>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)  <span class="comment">//获取数组的长度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[i]<span class="number">-1</span> != i &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">			nums[i],nums[nums[i]<span class="number">-1</span>] = nums[nums[i]<span class="number">-1</span>],nums[i]  <span class="comment">//交换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i]<span class="number">-1</span> != i &#123;</span><br><span class="line">			ans = <span class="built_in">append</span>(ans,i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-485-Max Consecutive Ones | 最大连续1的个数</title>
    <url>/2019/06/17/leetcode-485-Max-Consecutive-Ones/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/max-consecutive-ones/">Max Consecutive Ones</a>  </p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="题目意思"><a href="#题目意思" class="headerlink" title="题目意思"></a>题目意思</h3><p>给定一个二进制数组，计算数组中出现的最大连续1的个数。</p>
<p>注意：</p>
<ul>
<li>输入数组只包含0和1</li>
<li>数组长度是正整数并且不会超过10000</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>遍历数组并对连续的数计数，最终取最大值。</p>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul>
<li><p>错误  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> max <span class="type">int</span>  <span class="comment">//声明最大值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;= <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] = v &#123;</span><br><span class="line">				max++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				max=<span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正确1  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="comment">//考虑特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] == <span class="number">1</span> &#123;</span><br><span class="line">				count++  <span class="comment">//计数</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>  <span class="comment">//没有合适的就置为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正确2  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum, max <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		sum *= v</span><br><span class="line">		<span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">			max = sum</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-509-fibonacci-number | 斐波那契数</title>
    <url>/2021/07/19/leetcode-509-fibonacci-number/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">力扣_509. 斐波那契数</a>  </p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>

<p>给你 n ，请计算 F(n) 。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 30</span><br></pre></td></tr></table></figure>

<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="常用递归解法"><a href="#常用递归解法" class="headerlink" title="常用递归解法"></a>常用递归解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组解法"><a href="#数组解法" class="headerlink" title="数组解法"></a>数组解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">31</span>)</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    nums[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-53-maximum-subarray | 最大子序和</title>
    <url>/2019/12/10/leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray">leetcode中文</a><br><a href="https://leetcode.com/problems/maximum-subarray/">leetcode</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//一个临时值，和一个最大值</span></span><br><span class="line">    temp,max := <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            temp = temp + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp &gt; max &#123;</span><br><span class="line">            max = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//dp解法</span></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">//做判断</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangban-dong-tai-gui-hua-fu-sha-gua-ban-si-lu-sh/">golang版动态规划，附傻瓜版思路（傻瓜也能看懂）</a>  </li>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangjie-fa-si-lu-by-iphpt/">Golang解法+思路</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-557-reverse-words-in-a-string-iii | 反转字符串中的单词 III</title>
    <url>/2019/12/19/leetcode-557-reverse-words-in-a-string-iii/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>1，先将字符串分解成数组</li>
<li>2，使用<code>for range</code>循环取出数组中的元素，并执行反转字符串的操作</li>
<li>3，将反转后的字符串<code>append</code>进一个新的<code>string</code>类型的数组</li>
<li>4，循环遍历这个新的<code>string</code>类型的数组，拼接成一个字符串，返回最终结果</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	ss := strings.Fields(s)</span><br><span class="line">	<span class="keyword">var</span> results []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> ss &#123;</span><br><span class="line">		<span class="keyword">var</span> shift_str []<span class="type">byte</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">			shift_str = <span class="built_in">append</span>(shift_str, str[<span class="built_in">len</span>(str)-i<span class="number">-1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		results = <span class="built_in">append</span>(results, <span class="type">string</span>(shift_str))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	re := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> results &#123;</span><br><span class="line">		<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">			re = re + value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			re = re + <span class="string">&quot; &quot;</span> + value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，此方案不是最优解，后期再更新优化后的解法，目前只为快速解决题目。  </p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-66-Plus One | 加一</title>
    <url>/2019/06/10/leetcode-66-Plus-One/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/plus-one/">plus one</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>模拟十进制进位加法</li>
<li>注意处理有进位的情况</li>
</ul>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul>
<li><p>解法一  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	digitslength := <span class="built_in">len</span>(digits)  <span class="comment">//获取数组长度</span></span><br><span class="line">	<span class="keyword">for</span> i := digitslength - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> digits[i] &lt; <span class="number">9</span> &#123;  <span class="comment">//判断数组尾部是否小于9</span></span><br><span class="line">			digits[i]++</span><br><span class="line">			<span class="keyword">return</span> digits</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有进位的情况</span></span><br><span class="line">		digits[i] = <span class="number">0</span>  <span class="comment">//数组最后一位置为0</span></span><br><span class="line">		res := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;  </span><br><span class="line">		res = <span class="built_in">append</span>(res,digits...)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法二  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	digits = <span class="built_in">append</span>(digits,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>;i &gt; <span class="number">0</span>;i-- &#123;</span><br><span class="line">		digits[i] = digits[i] + digits[i<span class="number">-1</span>]</span><br><span class="line">		digits[i<span class="number">-1</span>] = digits[i]/<span class="number">10</span>  <span class="comment">//取除数</span></span><br><span class="line">		digits[i] %= <span class="number">10</span>  <span class="comment">//取余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits[<span class="number">1</span>:]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-70-climbing-stairs | 爬楼梯</title>
    <url>/2019/12/17/leetcode-70-climbing-stairs/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><ul>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/">leetcode中国</a></li>
</ul>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>第一层：0+1&#x3D;1种<br>第二层：1+1&#x3D;2种<br>第三层：2+1&#x3D;3种<br>第四层：3+2&#x3D;5种<br>第五层：5+3&#x3D;8种<br>第六层：8+5&#x3D;13种<br>…</p>
<p>得出结论：<strong>第<code>x</code>层爬楼梯的方法数量&#x3D;第<code>x-1</code>层种+第<code>x-2</code>层种</strong>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//小于2，直接返回值</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FirstNum := <span class="number">1</span></span><br><span class="line">    SecondNum := <span class="number">2</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">3</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        result = FirstNum + SecondNum  <span class="comment">//当前层 = 倒数第一层 + 倒数第二层</span></span><br><span class="line">        FirstNum = SecondNum</span><br><span class="line">        SecondNum = result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>转移方程：<code>f(x)=f(x−1)+f(x−2)</code>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7-reverse-integer | 整数反转</title>
    <url>/2019/12/08/leetcode-7-reverse-integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/reverse-integer/">leetcode中国</a>  </li>
<li><a href="https://leetcode.com/problems/reverse-integer/">leetcode</a></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过题目可以看出来，这道题是让我们翻转一个整数，比如123，个位是1十位是2百位是3，反转后个位是3十位是2百位是1。  </p>
<p>需要解决两个问题  </p>
<ul>
<li>1，排除为0的情况  </li>
<li>2，反转数字</li>
</ul>
<h3 id="解法一：Golang"><a href="#解法一：Golang" class="headerlink" title="解法一：Golang"></a>解法一：Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//考虑x为负数的情况</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> re <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        re = re*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x = x/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> re &lt; <span class="number">0x7fffffff</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：弹出和推入数字-amp-溢出前进行检查"><a href="#解法二：弹出和推入数字-amp-溢出前进行检查" class="headerlink" title="解法二：弹出和推入数字 &amp; 溢出前进行检查"></a>解法二：弹出和推入数字 &amp; 溢出前进行检查</h3><p>照着<a href="https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/">官方题解</a>的解法一:弹出和推入数字 &amp; 溢出前进行检查写的Go版本  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    rev := <span class="number">0</span></span><br><span class="line">    INT_MIN:=<span class="number">-2147483648</span></span><br><span class="line">    INT_MAX:=<span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        pop := x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> rev &gt; INT_MAX / <span class="number">10</span> || rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt;<span class="number">7</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rev &lt; INT_MIN / <span class="number">10</span> || rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        rev = rev * <span class="number">10</span> + pop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-704-binary-search | 二分查找</title>
    <url>/2021/07/17/leetcode-704-binary-search/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">你可以假设 nums 中的所有元素是不重复的。</span><br><span class="line">n 将在 [1, 10000]之间。</span><br><span class="line">nums 的每个元素都将在 [-9999, 9999]之间。</span><br></pre></td></tr></table></figure>

<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>中规中矩的一道专门考察二分查找的题目，直接上代码，注释写的很详细了。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left,right := <span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>  <span class="comment">//初始化左右指针</span></span><br><span class="line">    <span class="keyword">for</span> ;left &lt;= right; &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span>  <span class="comment">//定中间指针</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123; <span class="comment">//如果中间指针下标所对应的值大于target</span></span><br><span class="line">            right--  <span class="comment">//右指针向左移动一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123; <span class="comment">//如果中间指针下标所对应的值小于target</span></span><br><span class="line">            left++ <span class="comment">//左指针向右移动一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == target &#123; <span class="comment">//如果中间指针下标所对应的值等于target</span></span><br><span class="line">            <span class="keyword">return</span> mid  <span class="comment">//返回mid</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">//否则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一个细节：用二分查找的前提一定是这个<code>nums</code>数组是有序的，否则要先做排序。  </p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_771_jewels_and_stones | 宝石与石头</title>
    <url>/2020/10/02/leetcode-771-jewels-and-stones/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/jewels-and-stones/">jewels-and-stones</a></p>
<h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>两个<code>for</code>循环，暴力求解  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numJewelsInStones</span><span class="params">(J <span class="type">string</span>, S <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,s := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="keyword">for</span> _,j := <span class="keyword">range</span> J &#123;</span><br><span class="line">            <span class="keyword">if</span> s == j &#123;</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>一个<code>for</code>循环和一个<code>map</code>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numJewelsInStones</span><span class="params">(J <span class="type">string</span>, S <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    jewels := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, j := <span class="keyword">range</span> J &#123;</span><br><span class="line">        jewels[j] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="keyword">if</span> jewels[s] &#123;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>循环</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78-subsets | 子集</title>
    <url>/2019/12/12/leetcode-78-subsets/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/subsets/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySlice</span><span class="params">(src []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	temp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> src &#123;</span><br><span class="line">		temp = <span class="built_in">append</span>(temp, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, []<span class="type">int</span>&#123;&#125;) <span class="comment">//第一步 包含空集</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        length := <span class="built_in">len</span>(result)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line">			<span class="comment">//设定两个下标元素,从0开始遍历nums的值</span></span><br><span class="line">			<span class="comment">//里层复制数组,接着append进去下标为j的值组成nums的一个子集,再append进result数组</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, <span class="built_in">append</span>(copySlice(result[j]), nums[i]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>代码直接写成<code>for j := 0; j &lt; length; j++</code>会超出内存限制，我在本地虚拟机上运行时，会卡爆电脑，原因正在找。  </p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-9-palindrome-number | 回文数</title>
    <url>/2019/12/16/leetcode-9-palindrome-number/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-number/">leetcode中国</a></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><ul>
<li>1，先将<code>x</code>转为字符串类型，这样好根据下标来判断是否为回文数；  </li>
<li>2，声明<code>i</code>和<code>j</code>两个<code>int</code>型变量，其中<code>i</code>在字符串<code>x</code>的最左边，<code>j</code>在字符串<code>x</code>的最右边，<code>i</code>从左往右开始递增，<code>j</code>从右往左开始递减，每次当<code>i</code>递增和<code>j</code>递减一次后，判断<code>i</code>和<code>j</code>下标所对应的元素是否相等，如果不相等，说明不是回文数，返回<code>false</code>，否则最终返回<code>true</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	x_str := strconv.Itoa(x) <span class="comment">// 整型转换为字符串</span></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(x_str)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">//i从左开始，j从右开始，i递增，j递减，逐个判断下标i和j对应的数字是否相等</span></span><br><span class="line">		<span class="keyword">if</span> x_str[i] != x_str[j] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/">动画：回文数的三种解法 | 法解种三的数文回：画动</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88-Merge Sorted Array | 合并两个有序数组</title>
    <url>/2019/07/01/leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/merge-sorted-array/">merge-sorted-array</a>  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	nums := <span class="built_in">make</span>([]<span class="type">int</span>,n+m)  <span class="comment">//创建一个混合数组，长度是nums1和nums2的和</span></span><br><span class="line">	<span class="comment">//三个变量i，j，k，分别指向nums1，nums2，和混合数组的末尾</span></span><br><span class="line">	<span class="keyword">for</span> i,j,k := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;i &lt; m || j &lt; n;k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">				nums[k] = nums1[i]</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nums[k] = nums2[j]</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &#123;</span><br><span class="line">			nums[k] = nums1[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[k] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1,nums)  <span class="comment">//把nums的数拷贝到nums1里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode binary-tree-inorder-traversal | 二叉树的中序遍历</title>
    <url>/2020/12/01/leetcode-94-binary-tree-inorder-traversal/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a>  </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        helper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; ret)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            helper(root.left, ret);</span><br><span class="line">            ret.add(root.val);</span><br><span class="line">            helper(root.right, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_905_Sort-Array-By-Parity | 按奇偶排序数组</title>
    <url>/2019/06/19/leetcode-905-Sort-Array-By-Parity/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/sort-array-by-parity/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china">905. Sort Array By Parity</a>  </p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParity</span>(<span class="params">self, A</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> &gt; A[j] % <span class="number">2</span>:</span><br><span class="line">                A[i], A[j] = A[j], A[i] <span class="comment">#互换</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[j] % <span class="number">2</span> == <span class="number">1</span>: j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>

<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = A.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">swap</span>(A[i--],A[len--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_977_Squares-of-a-Sorted-Array | 有序数组的平方</title>
    <url>/2019/06/19/leetcode-977-Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul>
<li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">leetcode中国</a></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>此题比较简单，意思就是对数组里的数字进行排序和开平方。代码如下  </p>
<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[i] * A[i];  <span class="comment">//对数组中每个数都平方</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);  <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, A: <span class="string">&#x27;List[int]&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> x*x</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">map</span>(f,A))</span><br></pre></td></tr></table></figure>


<h2 id="开启刷题之路"><a href="#开启刷题之路" class="headerlink" title="开启刷题之路"></a>开启刷题之路</h2><p>加入了大佬创建的刷题圈，目标是一天一道LeetCode算法题，按专题刷，加油！  </p>
<p><img src="/2019/06/19/leetcode-977-Squares-of-a-Sorted-Array/sky.jpg"></p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>汇总LeetCode实现数据结构和算法的题目</title>
    <url>/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/</url>
    <content><![CDATA[<p>汇总各种实现数据结构和算法的<code>LeetCode</code>题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构算法的知识。  </p>
<h2 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表-跳表"></a>链表-跳表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></p>
<p><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表</a></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/">1381. 设计一个支持增量操作的栈</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-circular-deque/">641. 设计循环双端队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a>  </p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a>  </p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a>  </p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a>  </p>
<p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a>  </p>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p>
<p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a>  </p>
<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a>  </p>
<p><a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-circular-deque/">641. 设计循环双端队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a>  </p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du/">LCP 10. 二叉树任务调度</a></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>  </p>
<h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><p><a href="https://leetcode-cn.com/problems/design-twitter/">355. 设计推特</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-underground-system/">1396. 设计地铁系统</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-browser-history/">1472. 设计浏览器历史记录</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-parking-system/">1603. 设计停车系统</a>  </p>
<p><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/">1656. 设计有序流</a>  </p>
<p><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/">1678. 设计 Goal 解析器</a></p>
]]></content>
      <categories>
        <category>LeetCode-Solutions</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04.二维数组中的查找</title>
    <url>/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">力扣-剑指 Offer 04. 二维数组中的查找</a>  </p>
<p>我的复述：<br>有一个二维数组<br><img src="/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/twoarray.png"><br>它满足从左往右，从上到下递增的规律，也就是说越接近左上角的数字越小，越接近右下角的数字就越大，现在我们要实现一个高效的算法（函数），查找这个二维数组中是否存在某个值，存在就返回<code>true</code>，不存在返回<code>false</code>。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>先用一个循环，每次遍历出一个数组<code>nums</code>，然后用<a href="https://golang.org/pkg/sort/#SearchInts">sort.SearchInts</a>查出<code>nums</code>数组中<code>target</code>的下标，接着做下判断即可。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, nums := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">		<span class="comment">//遍历数组切片，查找数组中是否含有target值，如果查找不到，返回值是target应该插入数组的位置（会保持数组的递增顺序）</span></span><br><span class="line">		i := sort.SearchInts(nums, target) <span class="comment">//查找nums数组中target的下标</span></span><br><span class="line">		<span class="comment">//插入的位置小于数组长度 且 插入数组的位置上的值和目标值相等</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; target == nums[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-cn执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">28 ms, 在所有 Go 提交中击败了80.58%的用户</span><br><span class="line">内存消耗：6.6 MB, 在所有 Go 提交中击败了70.78%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：7ms</span><br><span class="line">超过8.42%用Go提交的代码</span><br><span class="line">占用内存：3204KB</span><br><span class="line">超过44.21%用Go提交的代码</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>举例，查找数字8：<br><img src="/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/target-8.png">  </p>
<p>先让指针<code>i</code>和<code>j</code>都集中在左下角18的位置上，当发现<code>18&gt;8</code>，那就说明<strong>18这一整行</strong>都大于8，因此将指针<code>i</code>向上移动一个位置；<br>当发现<code>10&gt;8</code>，那就说明<strong>10这一整行</strong>都大于8，因此将指针<code>i</code>向上移动一个位置；<br>当发现<code>3&lt;8</code>，那就说明从数字3往上这一列，都比目标值8要小，因此将指针<code>j</code>向右移动一个位置；<br>当发现<code>6&lt;8</code>，说明从数字6往上这一列，都比目标值8要小，因此将指针<code>j</code>向右移动一个位置；<br>当发现<code>9&gt;8</code>，说明数字9向右边一整行的数字都大于8，因此将指针<code>i</code>向上移动一个位置；<br>当发现<code>8=8</code>，说明目标值8是存在的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//从数组的左下角位置开始去搜索整个二维数组</span></span><br><span class="line">        <span class="comment">//1，当发现当前遍历的元素大于target时，意味着这个元素后面的所有元素也都大于target，那么就不用去搜索这一行了</span></span><br><span class="line">        <span class="comment">//2，当发现当前遍历的元素小于target时，意味着这个元素上面的所有元素也都小于target，那么就不用去搜索这一列了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化i和j为数组左下角元素</span></span><br><span class="line">        <span class="comment">//最后一行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第0列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从数组的左下角开始出发，只要 i 和 j 没有越界继续判断</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="comment">//当发现当前遍历的元素大于target时，意味着这个元素后面的所有元素也都大于target</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                <span class="comment">//行索引向上移动，即i--，即消去矩阵第i行元素</span></span><br><span class="line">                i--;</span><br><span class="line">            <span class="comment">//当发现当前遍历的元素小于target时，意味着这个元素的所有元素也都小于target</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//列索引向右移动一格，即j++，即消去矩阵第j列元素</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//否则，说明找到目标值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：47.3 MB, 在所有 Java 提交中击败了31.35%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>暴力</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">力扣-剑指 Offer 03. 数组中重复的数字</a>  </p>
<p>我的复述：<br>假设一个名为<code>nums</code>的数组里<code>[2,3,1,0,2,5,3]</code>，只需要写代码，找出重复的数字2或者3即可。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>最常用，也是最容易想到的解法。  </p>
<p>一次遍历，将扫描到数字做判断，如果可以在<code>map</code>中查到，就添加进去，否则返回这个数字，因为这个数字已经在<code>map</code>里存在了，属于重复数字。</p>
<p><img src="/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/dict.png">  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nummap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !nummap[num] &#123;</span><br><span class="line">            nummap[num] = <span class="literal">true</span>  <span class="comment">//map中没有这个num</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num  <span class="comment">//重复，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">56 ms, 在所有 Go 提交中击败了8.84%的用户</span><br><span class="line">内存消耗：8.9 MB, 在所有 Go 提交中击败了39.48%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：832KB</span><br><span class="line">超过100.00%用Go提交的代码</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//HashSet的特点是不会存储重复元素</span></span><br><span class="line">        <span class="comment">//所以可以用HashSet来查找出重复的元素</span></span><br><span class="line">        Set&lt;Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组，设置此时遍历的元素为num</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//如果发现dic中已经存储了num</span></span><br><span class="line">            <span class="comment">//那么说明找到了重复的那个元素</span></span><br><span class="line">            <span class="keyword">if</span> (dic.contains(num)) &#123;</span><br><span class="line">                <span class="comment">//把num这个结果进行返回</span></span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，说明dic中还没有存储num</span></span><br><span class="line">                dic.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h2><p>遍历数组并通过交换操作，使元素的 索引与值一一对应（即<code>nums[i] = inums[i]=i</code>）。因而，就能通过索引映射对应的值，起到与字典等价的作用。可以看这个<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/">题解</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == i &#123;</span><br><span class="line">            i++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[nums[i]] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        nums[i] = nums[tmp]</span><br><span class="line">        nums[tmp] = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-cn执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">40 ms, 在所有 Go 提交中击败了86.59%的用户</span><br><span class="line">内存消耗：8.7 MB, 在所有 Go 提交中击败了89.50%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a>  </p>
<p>我的复述：<br>每个字符串的空格，都替换为<code>&quot;%20&quot;</code>。<br><img src="/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/des.png">  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一：使用strings-Replace"><a href="#解法一：使用strings-Replace" class="headerlink" title="解法一：使用strings.Replace"></a>解法一：使用strings.Replace</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">//不推荐，纯属AC题目来玩，但strings.Replace内部逻辑可以借鉴</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：遍历添加"><a href="#解法二：遍历添加" class="headerlink" title="解法二：遍历添加"></a>解法二：遍历添加</h2><p><img src="/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/demo1.png">  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">//一次循环，遇到&#x27; &#x27;，给当前字符串尾部加上 &quot;%20&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">            ans = ans + <span class="string">&quot;%20&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + <span class="type">string</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.4 MB, 在所有 Go 提交中击败了16.95%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：2ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：956KB</span><br><span class="line">超过23.81%用Go提交的代码</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>lcof</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">力扣-剑指 Offer 06. 从尾到头打印链表</a>  </p>
<p>我的复述：<br><img src="/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/des.png"><br>链表的最后一个节点变为数组的头部，相当于将链表反转以后，用数组的形式将反转后的链表节点输出。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一：两个for循环"><a href="#解法一：两个for循环" class="headerlink" title="解法一：两个for循环"></a>解法一：两个for循环</h2><ul>
<li>1，先声明两个整型数组；  </li>
<li>2，第一个<code>for</code>循环从头到尾记录链表的每个节点的值；</li>
<li>3，第二个<code>for</code>循环逆序记录链表的每个节点的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="type">int</span>  <span class="comment">//正序</span></span><br><span class="line">    <span class="keyword">var</span> er []<span class="type">int</span>  <span class="comment">//逆序</span></span><br><span class="line">    <span class="keyword">for</span> ;head != <span class="literal">nil</span>; &#123;</span><br><span class="line">        re = <span class="built_in">append</span>(re,head.Val)  <span class="comment">//从头到尾记录链表的每个节点的值</span></span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(re)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">        er = <span class="built_in">append</span>(er,re[i])  <span class="comment">//逆序记录链表的每个节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> er  <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-cn执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.5 MB, 在所有 Go 提交中击败了46.84%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure>

<h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/liang-chong-jie-fa-zhan-yu-di-gui-by-jalan/">两种解法：栈与递归</a>  </p>
<ul>
<li>递归函数作用：将链表节点值逆序存入结果集</li>
<li>结束条件：当节点为空时</li>
<li>递归调用条件：当下一个节点不为空时</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := reversePrint(head.Next)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(res, head.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-cn执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了63.34%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.7 MB, 在所有 Go 提交中击败了28.61%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure>

<h2 id="解法三：栈"><a href="#解法三：栈" class="headerlink" title="解法三：栈"></a>解法三：栈</h2><ul>
<li>1，构建一个栈，将链表里的节点依次压入这个栈中；  </li>
<li>2，初始化一个数组，再从栈中取出值放入数组中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//构建一个栈，用来存储链表中每个节点的值</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建一个指针，指向链表的头结点位置，从它开始向后遍历</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//不断的遍历原链表中的每个节点，直到为null</span></span><br><span class="line">        <span class="keyword">while</span> ( curNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//把每个节点的值加入到栈中</span></span><br><span class="line">            stack.push(curNode.val);</span><br><span class="line">            <span class="comment">//curNode向后移动</span></span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取栈的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="comment">//定义一个同样长度的数组 res</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="comment">//遍历栈，从栈顶挨个弹出每个值，把这些值依次加入到数组res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">            <span class="comment">//数组接收栈顶元素值</span></span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//构建一个栈，用来存储链表中每个节点的值</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//构建一个指针，指向链表的头结点位置，从它开始向后遍历</span></span><br><span class="line">    curNode := head</span><br><span class="line">    <span class="comment">//不断的遍历原链表中的每个节点，直到为nil</span></span><br><span class="line">    <span class="keyword">for</span> curNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//把每个节点的值加入到栈中</span></span><br><span class="line">        stack = <span class="built_in">append</span>(stack,curNode.Val)</span><br><span class="line">        <span class="comment">//curNode向后移动</span></span><br><span class="line">        curNode = curNode.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈的长度</span></span><br><span class="line">    size := <span class="built_in">len</span>(stack)</span><br><span class="line">    <span class="comment">//定义一个同样长度的数组 res</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>,size)</span><br><span class="line">    <span class="comment">//遍历栈，从栈顶挨个弹出每个值，把这些值依次加入到数组res中</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; size;i++ &#123;</span><br><span class="line">        <span class="comment">//数组接收栈顶元素值</span></span><br><span class="line">        res[i] = stack[<span class="built_in">len</span>(stack)-i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了51.87%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <url>/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">力扣-剑指 Offer 07. 重建二叉树</a>  </p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>二叉树的遍历顺序</li>
</ul>
<p>1，前序（Pre-order）：根-左-右<br>2，中序（In-order）：左-根-右<br>3，后序（Post-order）：左-右-根  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>按题目给的示例来划分：<br>前序遍历划分 [ 3 | 9 | 20 15 7 ]<br>中序遍历划分 [ 9 | 3 | 15 20 7 ]  </p>
<p>根据以上性质，可得出以下推论：  </p>
<ul>
<li>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。  </li>
<li>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。  </li>
<li>根据中序遍历中的左 &#x2F; 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li>
</ul>
<p>考虑通过递归对所有子树进行划分：  </p>
<ul>
<li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p>
</li>
<li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ；</p>
</li>
<li><p>递推工作：<br>建立根节点 node ： 节点值为 preorder[root] ；<br>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p>
</li>
</ul>
<p><img src="/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/7-tijie.png">  </p>
<p>网上摘的保姆式的注解  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java借助Map版本 (Go的没写出来，等后面写出来了再更新)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="type">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> pre_root, <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的有边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">3 ms, 在所有 Java 提交中击败了55.11%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">38.4 MB, 在所有 Java 提交中击败了80.00%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go，不借助Map版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root_val := preorder[<span class="number">0</span>]</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inorder[i] != root_val &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    left_tree := buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    right_tree := buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    root.Val = root_val</span><br><span class="line">    root.Left = left_tree</span><br><span class="line">    root.Right = right_tree</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode-cn执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了95.75%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.2 MB, 在所有 Go 提交中击败了25.36%的用户</span><br></pre></td></tr></table></figure>

<p>牛客网运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时间：5ms</span><br><span class="line">超过39.31%用Go提交的代码</span><br><span class="line">占用内存：2344KB</span><br><span class="line">超过9.75%用Go提交的代码</span><br></pre></td></tr></table></figure>

<h1 id="思考：为什么二叉树的题目一般用递归来解？"><a href="#思考：为什么二叉树的题目一般用递归来解？" class="headerlink" title="思考：为什么二叉树的题目一般用递归来解？"></a>思考：为什么二叉树的题目一般用递归来解？</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/">4种解法（递归，栈，队列），最后一种击败了100%的用户</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/">力扣官方题解</a><br><a href="https://blog.csdn.net/Mr_SCX/article/details/106690412">【面试题】重建二叉树（解题思路分析+Java、Python实现+代码详细注释）</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/">面试题07. 重建二叉树（递归法，清晰图解）</a></p>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/2022/05/06/leetcode-lcof-09-yong-liang-ge-zhan-shi-xian-dui-lie/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a>  </p>
<p>我的复述：  </p>
<table>
<thead>
<tr>
<th align="left">函数操作</th>
<th align="center">CQueue</th>
<th align="right">deleteHead</th>
<th align="right">appendTail</th>
<th align="right">appendTail</th>
<th align="right">deleteHead</th>
<th align="right">deleteHead</th>
</tr>
</thead>
<tbody><tr>
<td align="left">入参</td>
<td align="center">[]</td>
<td align="right">[]</td>
<td align="right">5</td>
<td align="right">2</td>
<td align="right">[]</td>
<td align="right">[]</td>
</tr>
<tr>
<td align="left">返回结果</td>
<td align="center">null</td>
<td align="right">-1</td>
<td align="right">null</td>
<td align="right">null</td>
<td align="right">5</td>
<td align="right">2</td>
</tr>
</tbody></table>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>队列的特点：先进先出  </li>
<li>栈的特点：先进后出</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul>
<li>1，<code>CQueue</code>：直接初始化两个栈；  </li>
<li>2，<code>appendTail</code>：往<code>stack1</code>里压入元素；  </li>
<li>3，<code>deleteHead</code>：先判断<code>stack2</code>若不为空，直接弹出元素；若<code>stack1</code>和<code>stack2</code>都为空，根据题意返回-1；如果<code>stack1</code>不为空，循环里面的元素，把<code>stack1</code>弹出的元素压入<code>stack2</code>，这样stack2的栈顶元素就是stack1的栈底元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="comment">//创建栈 stack1 用来充当队列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="comment">//创建栈 stack2 用来辅助 stack1 执行队列的一些复杂操作</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化 stack1</span></span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化 stack2</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在队列的尾部添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        直接将元素放到 stack1 中</span></span><br><span class="line"><span class="comment">        比如原队列</span></span><br><span class="line"><span class="comment">        ---------------------</span></span><br><span class="line"><span class="comment">        队尾 1 2 3 4 5 队头</span></span><br><span class="line"><span class="comment">        --------------------</span></span><br><span class="line"><span class="comment">        当前 value 为 6</span></span><br><span class="line"><span class="comment">        那么由 stack1 和 stack2 组成的队列就是</span></span><br><span class="line"><span class="comment">        --------------------</span></span><br><span class="line"><span class="comment">        队尾 6 1 2 3 4 5 队头</span></span><br><span class="line"><span class="comment">        --------------------</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在队列的头部删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1，如果 stack2 栈不为空，说明 stack2 里面已经存储了一些元素，并且stack 的栈顶元素就是两个栈中最早加入的元素</span></span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//返回 stack2 的栈顶元素，满足了队列先进先出的特点</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，如果 stack2 为空，并且发现stack1 也为空，说明 stack1和stack2 构建的队列中没有元素</span></span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//直接返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，如果stack2为空，但stack1不为空，那么需要将stack1中的元素依次 【倒序】 放入stack2中，</span></span><br><span class="line">        <span class="comment">//对于stack1 来说，越早加入的元素在 【栈顶】，越晚加入的元素在【栈顶】</span></span><br><span class="line">        <span class="comment">//由于队列是【先进先出】，所以删除的应该是stack1的【栈底】元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//获取stack1的栈顶元素并将该元素从stack1弹出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">topValue</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">            <span class="comment">//把该元素加入到stack2，这样stack2的栈顶元素就是stack1的栈底元素</span></span><br><span class="line">            stack2.push(topValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4，返回stack2的栈顶元素，满足了队列先进先出的特点</span></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/2022/05/08/leetcode-lcof-10-i-fei-bo-na-qi-shu-lie/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a>  </p>
<p>我的复试：<br><img src="/2022/05/08/leetcode-lcof-10-i-fei-bo-na-qi-shu-lie/yanshi.png">  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化数组dp</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于F(0) = 0，所以 dp[0] = 0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于F(1) = 1，所以 dp[1] = 1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过for循环来填充dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="comment">//dp[i]的计算规则</span></span><br><span class="line">            <span class="comment">//F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//答案需要取模 1e9+7 (1000000007)</span></span><br><span class="line">            dp[i] %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了13.79%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//边界处理</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数组dp</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//由于F(0) = 0，所以 dp[0] = 0</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment">//由于F(1) = 1，所以 dp[1] = 1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过for循环来填充dp</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>;i &lt;= n;i++ &#123;</span><br><span class="line">        <span class="comment">//dp[i]的计算规则</span></span><br><span class="line">        <span class="comment">//F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="comment">//答案需要取模 1e9+7 (1000000007)</span></span><br><span class="line">        dp[i] %= <span class="number">1000000007</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：1.8 MB, 在所有 Go 提交中击败了40.31%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <url>/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。  </p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="循环求余法"><a href="#循环求余法" class="headerlink" title="循环求余法"></a>循环求余法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span></span><br><span class="line">        a = b</span><br><span class="line">        b = sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/2022/05/08/leetcode-lcof-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双指针-二分查找"><a href="#双指针-二分查找" class="headerlink" title="双指针+二分查找"></a>双指针+二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="comment">//设置left，right指针分别指向 numbers 数组左右两端</span></span><br><span class="line">        <span class="comment">//left指向当前区间的最左边位置，所以初始化为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//right指向当前区间的最右边位置，所以初始化为nums.length - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环进行二分查找，直到左端点位置超过右端点</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//mid为中点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//当mid点所在元素大于数组末端的元素时，由于原来的数组是递增有序的，此时出现了异常，大的数在前面</span></span><br><span class="line">            <span class="comment">//所以旋转点在[mid + 1,end]区间里面</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">                <span class="comment">//所以旋转点在[mid + 1,end]区间里面，更新left的位置为mid + 1</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">                <span class="comment">//当mid点所在元素小于数组末端的元素时，由于原来的数组是递增有序的</span></span><br><span class="line">                <span class="comment">//所以旋转点在[left,mid]区间里面，更新right的位置为mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//采取遍历的方式</span></span><br><span class="line">                <span class="keyword">return</span> findMin(numbers,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从头到尾遍历numbers，获取最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] numbers,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//默认为数组的第一个元素为最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> numbers[left];</span><br><span class="line">        <span class="comment">//从头到尾遍历numbers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt;= right;i++) &#123;</span><br><span class="line">            <span class="comment">//当发现此时遍历的元素值小于result</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; result) &#123;</span><br><span class="line">                <span class="comment">//更新result</span></span><br><span class="line">                result = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：40.9 MB, 在所有 Java 提交中击败了81.71%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minArray</span><span class="params">(numbers []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//设置left，right指针分别指向 numbers 数组左右两端</span></span><br><span class="line">    <span class="comment">//left指向当前区间的最左边位置，所以初始化为0</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    <span class="comment">//right指向当前区间的最右边位置，所以初始化为nums.length - 1</span></span><br><span class="line">    right := <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="comment">//循环进行二分查找，直到左端点位置超过右端点</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">//mid为中点</span></span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="comment">//当mid点所在元素大于数组末端的元素时，由于原来的数组是递增有序的，此时出现了异常，大的数在前面</span></span><br><span class="line">        <span class="comment">//所以旋转点在[mid + 1,end]区间里面</span></span><br><span class="line">        <span class="keyword">if</span> numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">            <span class="comment">//所以旋转点在[mid + 1,end]区间里面，更新left的位置为mid + 1</span></span><br><span class="line">            left  = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[mid] &lt;numbers[right] &#123;</span><br><span class="line">            <span class="comment">//当mid点所在元素小于数组末端的元素时，由于原来的数组是递增有序的</span></span><br><span class="line">            <span class="comment">//所以旋转点在[left,mid]区间里面，更新right的位置为mid</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//采取遍历的方式</span></span><br><span class="line">            <span class="keyword">return</span> findMin(numbers,left,right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从头到尾遍历numbers，获取最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(numbers []<span class="type">int</span>,left,right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//默认为数组的第一个元素为最小值</span></span><br><span class="line">    result := numbers[left]</span><br><span class="line">    <span class="comment">//从头到尾遍历numbers</span></span><br><span class="line">    <span class="keyword">for</span> i := left;i &lt;= right;i++ &#123;</span><br><span class="line">        <span class="comment">//当发现此时遍历的元素值小于result</span></span><br><span class="line">        <span class="keyword">if</span> numbers[i] &lt; result &#123;</span><br><span class="line">            <span class="comment">//更新result</span></span><br><span class="line">            result = numbers[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <url>/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。  </p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。  </p>
<p>题目同<a href="https://leetcode-cn.com/problems/word-search/">leetcode 70.word-search</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="type">byte</span>, word <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="built_in">len</span>(board); row ++&#123;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>;col &lt; <span class="built_in">len</span>(board[row]); col ++&#123;</span><br><span class="line">            <span class="keyword">if</span> dfs(board, word, row, col, <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(board [][]<span class="type">byte</span>, word <span class="type">string</span>, i, j, idx <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//越界或者字符不相等</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(board) || </span><br><span class="line">    j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) || </span><br><span class="line">    board[i][j] != word[idx] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已被访问</span></span><br><span class="line">    tmpCh := board[i][j]</span><br><span class="line">    board[i][j] = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下左右检查一下</span></span><br><span class="line">    check := (dfs(board, word, i+<span class="number">1</span>, j, idx+<span class="number">1</span>) || dfs(board, word, i<span class="number">-1</span>, j, idx + <span class="number">1</span>) || </span><br><span class="line">    dfs(board, word, i, j+<span class="number">1</span>, idx+<span class="number">1</span>) || dfs(board, word, i, j<span class="number">-1</span>, idx+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    board[i][j] = tmpCh</span><br><span class="line">    <span class="keyword">return</span> check</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>矩阵路径</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <url>/2022/05/09/leetcode-lcof-18-shan-chu-lian-biao-de-jie-dian/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a>  </p>
<p>我的复述：<br>假如有一个链表是<code>4-&gt;1-&gt;5-&gt;9</code>，指定删除节点5，那么返回新的链表为<code>4-&gt;1-&gt;9</code>。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li>定义<code>pre</code>和<code>cur</code>两个指针  </li>
<li>当<code>cur</code>指向要删除的节点时，让<code>pre</code>直接指向<code>cur</code>指针的下一个节点即可</li>
</ul>
<p><img src="/2022/05/09/leetcode-lcof-18-shan-chu-lian-biao-de-jie-dian/two-pointers.png">  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况处理，删除的节点是头结点时</span></span><br><span class="line">        <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="comment">//设置两个指针，一个指针指向当前的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//一个指针指向当前节点的下一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//当cur为空或cur节点值等于val时跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            <span class="comment">//两个指针不断的向前移动</span></span><br><span class="line">            <span class="comment">//pre来到cur的位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//cur来到下一个节点位置</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于覆盖掉了cur的节点值</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="comment">//最后返回链表头结点即可</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：40.8 MB, 在所有 Java 提交中击败了63.11%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//特殊情况处理，删除的节点是头结点时</span></span><br><span class="line">    <span class="keyword">if</span> head.Val == val &#123;</span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置两个指针，一个指针指向当前的节点</span></span><br><span class="line">    pre := head</span><br><span class="line">    <span class="comment">//一个指针指向当前节点的下一个节点</span></span><br><span class="line">    cur := head.Next</span><br><span class="line">    <span class="comment">//当cur为空或cur节点值等于val时跳出循环</span></span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Val != val &#123;</span><br><span class="line">        <span class="comment">//两个指针不断的向前移动</span></span><br><span class="line">        <span class="comment">//pre来到cur的位置</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment">//cur来到下一个节点位置</span></span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定节点</span></span><br><span class="line">    pre.Next = cur.Next</span><br><span class="line">    <span class="comment">//最后返回链表头结点即可</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>双百通过：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.7 MB, 在所有 Go 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <url>/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>  </p>
<p>我的复述：<br><img src="/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/jiou.png">  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li><p>声明左指针<code>left</code>在数组的最左边，右指针<code>right</code>在数组的最右边；<br><img src="/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/tp1.png">  </p>
</li>
<li><p>左指针<code>left</code>指向的数字为1，是奇数，因此移动到下一个数字2；  </p>
</li>
<li><p>左指针指向的数字2位偶数，右指针指向的数字3位奇数，因此将两个指针指向的数字调换；<br><img src="/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/tp2.png"></p>
</li>
</ul>
<p><img src="/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/tp3.png">  </p>
<ul>
<li>左指针指向下一个数字4，是偶数，需要调换，因此需要右指针<code>right</code>指向一个奇数，而此时的右指针指向的是数字6，也是偶数，所以将右指针向左移动一个位置，指向数字5；  </li>
<li>当右指针指向数字5的时候，发现是奇数，因此与左指针<code>left</code>指向的数字4进行调换；  </li>
<li>调换后，左指针继续向右边移动，当发现左右指针重合，遍历结束。<br><img src="/2022/05/10/leetcode-lcof-21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/tp4.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//定义左指针left</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义右指针right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义临时变量 tmp</span></span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="comment">//移动left 和 right，直到left在right右侧或者相遇为止</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//如果left指针指向的元素是奇数，那么说明元素在左侧了，观察其它元素，即让 left 向右移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>) left++;</span><br><span class="line">            <span class="comment">//如果right指针指向的元素是偶数，那么说明元素在右侧了，观察其它元素，即让 right 向左移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span>) right--;</span><br><span class="line">            <span class="comment">//否则就说明，此时要么 left 指向的元素值为偶数，要么 right 指向的元素为奇数</span></span><br><span class="line">            <span class="comment">//交换这两个位置的元素</span></span><br><span class="line">            tmp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：48.9 MB, 在所有 Java 提交中击败了84.14%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//定义左指针left</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    <span class="comment">//定义右指针right</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment">//定义临时变量 tmp</span></span><br><span class="line">    <span class="keyword">var</span> tmp <span class="type">int</span></span><br><span class="line">    <span class="comment">//移动left 和 right，直到left在right右侧或者相遇为止</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">//如果left指针指向的元素是奇数，那么说明元素在左侧了，观察其它元素，即让 left 向右移动</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果right指针指向的元素是偶数，那么说明元素在右侧了，观察其它元素，即让 right 向左移动</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则就说明，此时要么 left 指向的元素值为偶数，要么 right 指向的元素为奇数</span></span><br><span class="line">        <span class="comment">//交换这两个位置的元素</span></span><br><span class="line">        tmp = nums[left]</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">        nums[right] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：16 ms, 在所有 Go 提交中击败了88.81%的用户</span><br><span class="line">内存消耗：6.4 MB, 在所有 Go 提交中击败了23.34%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <url>/2022/05/18/leetcode-lcof-22-lian-biao-zhong-dao-shu-di-kge-jie-dian/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a>  </p>
<p>我的复述：<br>假如有一个链表为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，输入的k&#x3D;2，则输出为该链表倒数第2个节点，也就是正数第5个节点5。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li>新建<code>latter</code>和<code>former</code>两个快慢双指针；  </li>
<li>先将<code>former</code>指针向前移动<code>k</code>个长度；  </li>
<li>再同时将<code>latter</code>和<code>former</code>指针向链表尾部移动；  </li>
<li>当<code>former</code>指针指向为<code>null</code>时，此时<code>latter</code>指针指向的就是要返回的值。</li>
</ul>
<p><img src="/2022/05/18/leetcode-lcof-22-lian-biao-zhong-dao-shu-di-kge-jie-dian/tp.png">  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化两个指针 former和latter，一开始都指向链表的头节点</span></span><br><span class="line">        <span class="comment">//指针former指向链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">former</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//指针latter指向列表的头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">latter</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//让former指针先向前走k步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让这两个指针former和latter同时向前移动，直到后指针former指向NULL</span></span><br><span class="line">        <span class="keyword">while</span> (former != <span class="literal">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//初始化两个指针 former和latter，一开始都指向链表的头节点</span></span><br><span class="line">    <span class="comment">//指针former指向链表的头节点</span></span><br><span class="line">    former := head</span><br><span class="line">    <span class="comment">//指针latter指向列表的头结点</span></span><br><span class="line">    latter := head</span><br><span class="line">    <span class="comment">//让former指针先向前走k步</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; k;i++ &#123;</span><br><span class="line">        former = former.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让这两个指针former和latter同时向前移动，直到后指针former指向NULL</span></span><br><span class="line">    <span class="keyword">for</span> former != <span class="literal">nil</span> &#123;</span><br><span class="line">        former = former.Next</span><br><span class="line">        latter = latter.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <url>/2022/05/19/leetcode-lcof-24-fan-zhuan-lian-biao/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>1，先递归到链表的尾部：<br><img src="/2022/05/19/leetcode-lcof-24-fan-zhuan-lian-biao/r1.png">  </p>
<p>2，反转尾部，变为头部：<br><img src="/2022/05/19/leetcode-lcof-24-fan-zhuan-lian-biao/r2.png">  </p>
<p>3，以此类推，完成反转：<br><img src="/2022/05/19/leetcode-lcof-24-fan-zhuan-lian-biao/r3.png">  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//寻找递归终止条件</span></span><br><span class="line">        <span class="comment">//1、head指向的节点为null</span></span><br><span class="line">        <span class="comment">//2、head指向的节点的下一个节点为null</span></span><br><span class="line">        <span class="comment">//在这两种情况下，反转之后的结果还是它自己本身</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span></span><br><span class="line">        <span class="comment">//因为到最后一个节点的时候，由于当前节点的head的next节点是空，所以会直接返回head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如原链表为 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span></span><br><span class="line">        <span class="comment">//5-&gt;4</span></span><br><span class="line">        <span class="comment">//第一次执行下面代码的时候，head为4，那么head.next = 5</span></span><br><span class="line">        <span class="comment">//那么head.next.next 就是 5.next，意思就是去设置5的下一个节点</span></span><br><span class="line">        <span class="comment">//等号右侧为head，意思就是设置5的下一个节点是4</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//head原来的下一节点指向自己，所以head自己本身就不能再指向原来的下一节点了</span></span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们把每次反转后的结果传递给上一层</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行用时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：40.7 MB, 在所有 Java 提交中击败了71.89%的用户</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//寻找递归终止条件</span></span><br><span class="line">    <span class="comment">//1、head指向的节点为null</span></span><br><span class="line">    <span class="comment">//2、head指向的节点的下一个节点为null</span></span><br><span class="line">    <span class="comment">//在这两种情况下，反转之后的结果还是它自己本身</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> ||head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span></span><br><span class="line">    <span class="comment">//因为到最后一个节点的时候，由于当前节点的head的next节点是空，所以会直接返回head</span></span><br><span class="line">    cur := reverseList(head.Next)</span><br><span class="line">    <span class="comment">//比如原链表为 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span></span><br><span class="line">    <span class="comment">//5-&gt;4</span></span><br><span class="line">    <span class="comment">//第一次执行下面代码的时候，head为4，那么head.next = 5</span></span><br><span class="line">    <span class="comment">//那么head.next.next 就是 5.next，意思就是去设置5的下一个节点</span></span><br><span class="line">    <span class="comment">//等号右侧为head，意思就是设置5的下一个节点是4</span></span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    <span class="comment">//head原来的下一节点指向自己，所以head自己本身就不能再指向原来的下一节点了</span></span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">//我们把每次反转后的结果传递给上一层</span></span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <url>/2022/08/17/leetcode-lcof-26-shu-de-zi-jie-gou/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始如果 A 或者 B为空，直接返回false</span></span><br><span class="line">        <span class="comment">// 因为题目约定空树不是任意一个树的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来考虑以下几种情况</span></span><br><span class="line">        <span class="comment">// A的根节点 VS B的根节点</span></span><br><span class="line">        <span class="comment">// 1、A的根节点和B的根节点相同情况，依次比较它们的子节点</span></span><br><span class="line">        <span class="comment">// 2、A的根节点和B的根节点不相同情况，A的左子树 VS B的根节点</span></span><br><span class="line">        <span class="comment">// 3、A的根节点和B的根节点不相同情况，A的右子树 VS B的根节点</span></span><br><span class="line">        <span class="keyword">return</span> isSub(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSub</span><span class="params">(TreeNode A,TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// A和B 不匹配的情况有很多，我们需要一开始去找它们完全匹配的情况</span></span><br><span class="line">        <span class="comment">// 即遍历完B，直接为null，说明B的全部节点和A的子结构匹配上</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A中的节点为空，但B中的节点不为空，说明不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A和B都不为空，但数值不同，说明不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时，当前这个点是匹配的，继续递归判断左子树和右字树是否 分别匹配</span></span><br><span class="line">        <span class="keyword">return</span> isSub(A.left,B.left) &amp;&amp; isSub(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 25. 合并两个排序的链表</title>
    <url>/2022/05/24/leetcode-lcof-25-he-bing-liang-ge-pai-xu-de-lian-biao/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><img src="/2022/05/24/leetcode-lcof-25-he-bing-liang-ge-pai-xu-de-lian-biao/p1.png">  </p>
<p>合并后：<br><img src="/2022/05/24/leetcode-lcof-25-he-bing-liang-ge-pai-xu-de-lian-biao/p2.png">  </p>
<p>最后返回<code>dummy</code>节点的<code>Next</code>节点即可。  </p>
<h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//一开始设置一个虚拟节点，它的值为-1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置一个指针，指向虚拟节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过一个循环，不断的比较 l1和l2 中当前的节点值的大小，直到 l1 或者 l2 遍历完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果l1当前节点的值小于等于l2当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                <span class="comment">//让pre指向节点的next指针指向这个更小值的节点</span></span><br><span class="line">                <span class="comment">//即指向l1</span></span><br><span class="line">                pre.next = l1;</span><br><span class="line">                <span class="comment">//让l1向后移动</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//让pre指向节点的next指针指向这个更小值的节点</span></span><br><span class="line">                <span class="comment">//即指向l2</span></span><br><span class="line">                pre.next = l2;</span><br><span class="line">                <span class="comment">//让l2向后移动</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让pre向后移动</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳出循环后，l1或者l2中可能有剩余的节点没有被观察过</span></span><br><span class="line">        <span class="comment">//直接把剩下的节点加入到pre的next指针位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果l1中还有节点</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：41 MB, 在所有 Java 提交中击败了95.58%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <url>/2022/08/17/leetcode-lcof-27-er-cha-shu-de-jing-xiang/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a>  </p>
<p>相当于复制后做一下翻转，本来是左子树变为右子树，同理右子树变左子树：<br><img src="/2022/08/17/leetcode-lcof-27-er-cha-shu-de-jing-xiang/1.png">  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 当节点为空时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置一个临时的节点 tmp 用来存储当前节点的左子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下两个操作是交换当前节点的左右子树</span></span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的左子树为节点的右子树</span></span><br><span class="line">        <span class="comment">// 同时递归下去，不停的交换子树中的节点</span></span><br><span class="line">        root.right = mirrorTree(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的右子树为节点的左子树</span></span><br><span class="line">        <span class="comment">// 同时递归下去，不停的交换字树中的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.7 MB, 在所有 Java 提交中击败了82.58%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <url>/2022/08/17/leetcode-lcof-28-dui-cheng-de-er-cha-shu/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>1，从根节点出发，先判断左子树的值和右子树的是否相等；  </li>
<li>2，若相等，从左子树的节点递归出发，以及右子树的节点递归出发，继续判断是否相等；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 递归判断左子树和又子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetricalCor(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetricalCor</span><span class="params">(TreeNode L,TreeNode R)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果某根子树的左右两个子树同时为空，肯定是对称的，直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 说明根子树的左右两个子树有某子树为空，某子树有值，不对称，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> || R == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 左子树的值与右子树的值不相等，不对称，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (L.val != R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 递归对比当前节点的左子树的左子树与右子树的右子树、左子树的右子树与右子树的左子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetricalCor(L.left,R.right) &amp;&amp; isSymmetricalCor(L.right,R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <url>/2022/08/23/leetcode-lcof-30-bao-han-minhan-shu-de-zhan/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a>  </p>
<p>栈的特点：先进后出，后进先出。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="数据栈和辅助栈"><a href="#数据栈和辅助栈" class="headerlink" title="数据栈和辅助栈"></a>数据栈和辅助栈</h2><ul>
<li>0，声明一个栈为<code>stack1</code>，另一个栈为<code>stack2</code>  </li>
<li>1，<code>push(-2)</code>到<code>stack1</code>，此时该栈中的最小值是-2，因此<code>stack2</code> push进-2  </li>
<li>2，<code>push(0)</code>到<code>stack1</code>，此时该栈中的最小值是-2，因此<code>stack2</code> 再次push进-2  </li>
<li>3，<code>push(-3)</code>到<code>stack1</code>，此时该栈中的最小值是-3，因此<code>stack2</code> push进-3</li>
</ul>
<p>此时两个栈中的值为：  </p>
<p><img src="/2022/08/23/leetcode-lcof-30-bao-han-minhan-shu-de-zhan/1.png">  </p>
<ul>
<li>4，此时调用最小栈的<code>min</code>，从<code>stack2</code>中<code>pop</code>最小值为-3  </li>
<li>5，调用最小栈的<code>pop</code>操作，同时从<code>stack1</code>和<code>stack2</code>中把-3弹出去（删除掉）</li>
</ul>
<p>此时两个栈中的值为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line">               栈顶</span><br><span class="line"> 0                                  -2</span><br><span class="line"> -2                                 -2</span><br><span class="line">               栈底</span><br><span class="line">stack1                            stack2</span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li>6，执行最小栈的<code>top</code>操作，从<code>stack1</code> 获取出此时的栈顶元素0  </li>
<li>7，执行最小栈的<code>min</code>操作，从<code>stack2</code> 获取出此时的栈顶元素-2，也就是此时最小栈里的最小值为-2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个栈</span></span><br><span class="line">    <span class="comment">// 创建stack1，用来作为数据栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建stack2，用来作为辅助栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 stack1</span></span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 stack2</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小栈的压入操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据栈 stack1直接压入 x</span></span><br><span class="line">        stack1.push(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果辅助栈 stack2为空，可以直接压入 x</span></span><br><span class="line">        <span class="comment">// 此时，由于只有一个元素，stack2中的【栈顶元素】就是 stack1 中的 【最小元素】</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// stack2 直接压入x</span></span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 辅助栈 stack2 不为空</span></span><br><span class="line">            <span class="keyword">if</span> (stack2.peek() &gt;= x) &#123;</span><br><span class="line">                <span class="comment">// 如果辅助栈 stack2 的栈顶元素大于等于x，可以把 x 压入到 stack2 中</span></span><br><span class="line">                stack2.push(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果辅助栈 stack2 的栈顶元素小于x，不可以把 x 压入到 stack2 中</span></span><br><span class="line">                <span class="comment">// 所以将辅助栈原先的【栈顶元素】压入即可</span></span><br><span class="line">                stack2.push(stack2.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 数据栈 stack1 直接pop</span></span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="comment">// 数据栈 stack2 直接pop</span></span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据栈 stack1 的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 由于 stack2的【栈顶元素】是 stack1的【最小元素】，所以直接返回stack2的栈顶元素即可</span></span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：14 ms, 在所有 Java 提交中击败了22.98%的用户</span><br><span class="line">内存消耗：43.7 MB, 在所有 Java 提交中击败了17.84%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
    <url>/2022/08/28/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="队列-二维数组"><a href="#队列-二维数组" class="headerlink" title="队列+二维数组"></a>队列+二维数组</h2><p>过程：<br><img src="/2022/08/28/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii/1.png">  </p>
<p>最终转换结果：<br><img src="/2022/08/28/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii/2.png">  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置res用来保存输出结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置一个队列，用来存储二叉树中的元素</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队列添加二叉树的根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">// 遍历队列，直到队列为空，说明访问了二叉树中所有的节点</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 用来记录queue的长度，即每层节点的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 用来保存每一层节点，保存成功后添加到res中</span></span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 使用 for 循环，将queue中的元素添加到temp中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                <span class="comment">// 从queue中取出一个节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 把节点存放到list中</span></span><br><span class="line">                temp.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断当前节点的左子节点是否有值，如果有，则添加到queue中</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断当前节点的右子节点是否有值，如果有，则添加到queue中</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把存放了每一层元素的数组temp添加到res中</span></span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：41.8 MB, 在所有 Java 提交中击败了10.94%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <url>/2022/08/28/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>初始化队列<code>queue</code>和结果数组<code>res</code>，从二叉树根节点3开始  </li>
<li>先将3推入到队列<code>queue</code>中，看3有没有左子树和右子树  </li>
<li>有的话，将3从队列<code>queue</code>中取出，放入结果数组<code>res</code>的第一位，此时<code>res = []int&#123;3&#125;</code>  </li>
<li>访问3的左子树节点9，将9推入到队列<code>queue</code>中  </li>
<li>此时看9有没有左子树和右子树，没有，将9从队列<code>queue</code>中取出放入结果数组<code>res</code>中，此时<code>res = []int&#123;3,9&#125;</code>  </li>
<li>访问3的右子树节点20，将20推入到队列<code>queue</code>中  </li>
<li>此时看20有没有左子树和右子树，有，将左子树15推入队列<code>queue</code>中</li>
<li>看15有没有左子树和右子树，没有，将队列中的20，15依次取出放入结果数组<code>res</code>，此时<code>res = []int&#123;3,9,20,15&#125;</code>  </li>
<li>访问20的右子树7，发现7没有左子树和右子树，将7推入进队列<code>queue</code>中，然后取出放入<code>res</code>，此时<code>res = []int&#123;3,9,20,15,7&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 根节点为空的情况返回空数组</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个队列，用来保存节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个list，用来保存输出的节点</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先让根节点入队</span></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历队列，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取队列的头部元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 把节点值存放到list中</span></span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="comment">// 判断该节点是否有左右子节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果左子节点有值，则把左子节点加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果右子树有值，则把右子节点加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把list转化为数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了97.77%的用户</span><br><span class="line">内存消耗：41.5 MB, 在所有 Java 提交中击败了28.48%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <url>/2022/10/04/leetcode-lcof-40-zui-xiao-de-kge-shu/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a>  </p>
<p>题意就是从一个整数数组中，取出前k个最小的数。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="简单直接"><a href="#简单直接" class="headerlink" title="简单直接"></a>简单直接</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(arr)  <span class="comment">// 按从小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> arr[:k]  <span class="comment">// 从下表0开始算，取前k个最小值后返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Swap(i, j <span class="type">int</span>)&#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    sort.Sort(IntSlice(arr))</span><br><span class="line">    <span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">0</span> || <span class="built_in">len</span>(arr) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> quickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>, k<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数传入待排序数组 nums</span></span><br><span class="line"><span class="comment">// 排序区间的左端点 left</span></span><br><span class="line"><span class="comment">// 排序区间的右端点 right</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, left, right, index <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 调用函数 partition，将 left 和 right 之间的元素划分为左右两部分</span></span><br><span class="line">	mid := partition(nums, left, right)</span><br><span class="line">	<span class="comment">// 如果 mid 下标恰巧为 index，那么找到了最小的 k 个数</span></span><br><span class="line">	<span class="keyword">if</span> mid == index &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[:mid+<span class="number">1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> mid &gt; index &#123;</span><br><span class="line">		<span class="comment">// 对 mid 左侧的元素进行快速排序</span></span><br><span class="line">		<span class="keyword">return</span> quickSort(nums, left, mid<span class="number">-1</span>, index)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 对 mid 右侧的元素进行快速排序</span></span><br><span class="line">		<span class="keyword">return</span> quickSort(nums, mid+<span class="number">1</span>, right, index)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 设置当前区间的第一个元素为基准元素</span></span><br><span class="line">	pivot := nums[left]</span><br><span class="line">	<span class="comment">// left 向右移动，right 向左移动，直到 left 和 right 指向同一元素为止</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		<span class="comment">// 只有当遇到小于 pivot 的元素时，right 才停止移动</span></span><br><span class="line">		<span class="comment">// 此时，right 指向了一个小于 pivot 的元素，这个元素不在它该在的位置上</span></span><br><span class="line">		<span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] &gt;= pivot &#123;</span><br><span class="line">			<span class="comment">// 如果 right 指向的元素是大于 pivot 的，那么</span></span><br><span class="line">			<span class="comment">// right 不断的向左移动</span></span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将此时的 nums[left] 赋值为 nums[right]</span></span><br><span class="line">		<span class="comment">// 执行完这个操作，比 pivot 小的这个元素被移动到了左侧</span></span><br><span class="line">		nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 只有当遇到大于 pivot left 才停止移动</span></span><br><span class="line">		<span class="comment">// 此时，left 指向了一个大于 pivot 的元素，这个元素不在它该在的位置上</span></span><br><span class="line">		<span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] &lt;= pivot &#123;</span><br><span class="line">			<span class="comment">// 如果 left 指向的元素是小于 pivot 的，那么</span></span><br><span class="line">			<span class="comment">// left 不断的向右移动</span></span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将此时的 nums[right] 赋值为 nums[left]</span></span><br><span class="line">		<span class="comment">// 执行完这个操作，比 pivot 大的这个元素被移动到了右侧</span></span><br><span class="line">		nums[right] = nums[left]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时，left 和 right 相遇，那么需要将此时的元素设置为 pivot</span></span><br><span class="line">	<span class="comment">// 这个时候，pivot 的左侧元素都小于它，右侧元素都大于它</span></span><br><span class="line">	nums[left] = pivot</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/">剑指 Offer 40. 最小的 k 个数（基于快速排序的数组划分，清晰图解)</a>  </p>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/2022/10/06/leetcode-lcof-45-ba-shu-zu-pai-cheng-zui-xiao-de-shu/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a>  </p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数  </li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导0</li>
</ul>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目要求把数组中所有的数字一起拼凑出一个最小的数字，那么</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="1-9排序再组合"><a href="#1-9排序再组合" class="headerlink" title="1~9排序再组合"></a>1~9排序再组合</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 直接将数组中的元素按照 从1到9进行排序</span></span><br><span class="line">    sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> compareNumber(nums[i],nums[j])</span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="keyword">var</span> res strings.Builder</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    	res.WriteString(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,nums[i]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareNumber</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">	str1 := fmt.Sprintf(<span class="string">&quot;%d%d&quot;</span>,a,b)</span><br><span class="line">	str2 := fmt.Sprintf(<span class="string">&quot;%d%d&quot;</span>,b,a)</span><br><span class="line">	<span class="keyword">if</span> str1&lt;str2&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.algomooc.com/045.html#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">吴师兄学算法-剑指 Offer 45. 把数组排成最小的数</a></p>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <url>/2022/08/30/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu-iii/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>该题和<a href="https://octopuslian.github.io/2022/08/28/leetcode-lcof-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a>解法很像。  </p>
<p>需要注意，此题中将队列<code>queue</code>需要换成<strong>双端队列</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 res 用来保存输出结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 设置一个队列，用来存储二叉树中的元素</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队列添加二叉树的根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">// 用来判断当前的层数是否为奇数层，初始化在0层，为偶数层</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOddNumber</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历队列，直到队列为空，说明访问了二叉树中所有的节点</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 用来记录 queue 的长度，即每层节点的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 奇偶层总是交替出现的</span></span><br><span class="line">            <span class="comment">// 通过取反操作，判断当前的层数是否为奇偶层</span></span><br><span class="line">            <span class="comment">// 由于 isOddNumber 初始化为false，所以第一次进来这个 while 循环取反后为true，符合第一层是奇数层的含义</span></span><br><span class="line">            isOddNumber = !isOddNumber;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成一个双端队列temp，用来保存每一层节点，保存成功后添加到 res 中</span></span><br><span class="line">            LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 for 循环，将queue 中的元素按照给定的规则添加的 temp 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                <span class="comment">// 从 queue 取出一个节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (isOddNumber) &#123;</span><br><span class="line">                    <span class="comment">// 如果是奇数层，那么按顺序添加到双端队列的尾部</span></span><br><span class="line">                    temp.addLast(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是偶数层，那么按照顺序添加到双端队列的头部</span></span><br><span class="line">                    temp.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断当前节点的左子节点是否有值，如果有，则添加到queue中</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="comment">// 判断当前节点的右子节点是否有值，如果有，则添加到queue中</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把存放了每一层元素的数组 temp 添加到结果数组中</span></span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leetcode-cn</code>执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了96.57%的用户</span><br><span class="line">内存消耗：41.4 MB, 在所有 Java 提交中击败了69.13%的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <url>/2022/10/06/leetcode-lcof-42-lian-xu-zi-shu-zu-de-zui-da-he/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a>  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//一个临时值，和一个最大值</span></span><br><span class="line">    temp,max := <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            temp = temp + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp &gt; max &#123;</span><br><span class="line">            max = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 因为后面会使用到 nums 的长度</span></span><br><span class="line">	<span class="comment">// 所以先进行判空操作</span></span><br><span class="line">	<span class="comment">// 如果数组 nums 为空，返回 0</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取数组的长度</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 设置一个数组 dp，长度和数组 nums 长度一致</span></span><br><span class="line">	<span class="comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span></span><br><span class="line">	<span class="comment">// dp[1] 表示以第 1 个元素结尾的最大子数组的和</span></span><br><span class="line">	<span class="comment">// dp[i] 表示以第 i 个元素结尾的最大子数组的和</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span></span><br><span class="line">	<span class="comment">// 初始化 dp[0]</span></span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变量 maxNum 表示数组 dp 中最大的那个值</span></span><br><span class="line">	<span class="comment">// 即 maxNum 表示最大的连续字段和</span></span><br><span class="line">	maxNum := dp[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 1 开始遍历数组 nums</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 在遍历的过程中，去获取以第 i 个元素结尾的最大子数组的和</span></span><br><span class="line">		<span class="comment">// 如果以 nums[i-1]结尾的最大字段和为正数</span></span><br><span class="line">		<span class="comment">// 那么以第 i 个元素结尾的最大子数组的和就是自己本身加上以 nums[i-1]结尾的最大字段和</span></span><br><span class="line">		<span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// dp[i-1] 是正数</span></span><br><span class="line">			<span class="comment">// 所以 dp[i] 的值为 nums[i] 加上 dp[i-1]</span></span><br><span class="line">			<span class="comment">// 因为 正数 + 变量 &gt; 变量</span></span><br><span class="line">			<span class="comment">// dp[i -1] + nums[i] &gt; nums[i]</span></span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则 dp[i-1] 不是正数，为负数或者 0</span></span><br><span class="line">			<span class="comment">// 那么 dp[i] 的值为 nums[i]</span></span><br><span class="line">			<span class="comment">// 因为 负数 + 变量 &lt; 变量</span></span><br><span class="line">			<span class="comment">// dp[i -1] + nums[i] &lt; nums[i]</span></span><br><span class="line">			dp[i] = nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在更新 dp[i] 的过程中，更新 maxNum 的值</span></span><br><span class="line">		<span class="comment">// 如果此时 dp[i] 的值大于了 maxNum</span></span><br><span class="line">		<span class="keyword">if</span> maxNum &lt; dp[i] &#123;</span><br><span class="line">			<span class="comment">// 那么 maxNum 更新为 dp[i]</span></span><br><span class="line">			maxNum = dp[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <url>/2022/10/06/leetcode-lcof-52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a>  </p>
<p>和判断两个链表是否相交类似。  </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 边界判断</span></span><br><span class="line">    <span class="keyword">if</span> headB == <span class="literal">nil</span> || headA == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个指针 pointA，指向链表 A 的头节点</span></span><br><span class="line">    <span class="comment">// 设置一个指针 pointB，指向链表 B 的头节点</span></span><br><span class="line">    pointA, pointB := headA, headB</span><br><span class="line">    <span class="comment">// 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点</span></span><br><span class="line">    <span class="comment">// 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的之和减一</span></span><br><span class="line">    <span class="comment">// pointA 和 pointB 都会同时指向 null</span></span><br><span class="line">    <span class="comment">// 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交</span></span><br><span class="line">    <span class="comment">// 那么 pointA 移动了 7 + 11 - 1 次之后，会指向 null</span></span><br><span class="line">    <span class="comment">// pointB 移动了 7 + 11 - 1  次之后，也指向 null</span></span><br><span class="line">    <span class="comment">// 这个时候就跳出了循环</span></span><br><span class="line">    <span class="keyword">for</span> pointA != pointB &#123;</span><br><span class="line">        <span class="comment">// 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 </span></span><br><span class="line">        <span class="keyword">if</span> pointA == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 指针 pointA 跳转到链表 B 上  </span></span><br><span class="line">            pointA = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话 pointA 不断的向后移动</span></span><br><span class="line">            pointA = pointA.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 </span></span><br><span class="line">        <span class="keyword">if</span> pointB == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 指针 pointA 跳转到链表 B 上  </span></span><br><span class="line">            pointB = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话 pointB 不断的向后移动</span></span><br><span class="line">            pointB = pointB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可</span></span><br><span class="line">    <span class="comment">// 2、此时，headA 和 headB 不相交，那么 pointA 和 pointB 均为 null，也返回任意一个均可</span></span><br><span class="line">    <span class="keyword">return</span> pointA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetBook-binary-search | 二分查找</title>
    <url>/2021/01/23/leetcode-leetbook-binary-search/</url>
    <content><![CDATA[<h2 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h2><p>在最简单的形式中，二分查找对具有指定左索引和右索引的连续序列进行操作。这就是所谓的查找空间。二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。  </p>
<h2 id="LC二分查找"><a href="#LC二分查找" class="headerlink" title="LC二分查找"></a>LC二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">你可以假设 nums 中的所有元素是不重复的。</span><br><span class="line">n 将在 [1, 10000]之间。</span><br><span class="line">nums 的每个元素都将在 [-9999, 9999]之间。</span><br></pre></td></tr></table></figure>

<h3 id="Golang代码"><a href="#Golang代码" class="headerlink" title="Golang代码"></a>Golang代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low := <span class="number">0</span></span><br><span class="line">    high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">        mid := low + (high - low) / <span class="number">2</span></span><br><span class="line">        midValue := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> midValue == target &#123;</span><br><span class="line">            <span class="comment">//target值存在，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> midValue &gt; target&#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找模板分析"><a href="#二分查找模板分析" class="headerlink" title="二分查找模板分析"></a>二分查找模板分析</h2><p>你在网上看到的 99% 的二分查找问题会归结于这 3 个模板中的一个。有些问题可以使用多个模板来实现，但是当你做更多的练习时，你会注意到一些模板比其他模板更适合某些问题。  </p>
<p><img src="/2021/01/23/leetcode-leetbook-binary-search/muban.png">  </p>
<p>这三个模板不同之处在于：  </p>
<ul>
<li>左、中、右索引的分配。  </li>
<li>循环或递归终止条件。  </li>
<li>后处理的必要性。</li>
</ul>
<p>模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更 高级一些，用于解决某些类型的问题。  </p>
<h3 id="模板-1-left-lt-x3D-right"><a href="#模板-1-left-lt-x3D-right" class="headerlink" title="模板 #1 (left &lt;&#x3D; right)"></a>模板 #1 (left &lt;&#x3D; right)</h3><ul>
<li>二分查找的最基础和最基本的形式。  </li>
<li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。  </li>
<li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<h3 id="模板-2-left-lt-right"><a href="#模板-2-left-lt-right" class="headerlink" title="模板 #2 (left &lt; right)"></a>模板 #2 (left &lt; right)</h3><ul>
<li>一种实现二分查找的高级方法。  </li>
<li>查找条件需要访问元素的直接右邻居。  </li>
<li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。  </li>
<li>保证查找空间在每一步中至少有 2 个元素。  </li>
<li>需要进行后处理。 当你剩下 1 个元素时，循环 &#x2F; 递归结束。 需要评估剩余元素是否符合条件。</li>
</ul>
<h3 id="模板-3-left-1-lt-right"><a href="#模板-3-left-1-lt-right" class="headerlink" title="模板 #3 (left + 1 &lt; right)"></a>模板 #3 (left + 1 &lt; right)</h3><ul>
<li>实现二分查找的另一种方法。  </li>
<li>搜索条件需要访问元素的直接左右邻居。  </li>
<li>使用元素的邻居来确定它是向右还是向左。  </li>
<li>保证查找空间在每个步骤中至少有 3 个元素。  </li>
<li>需要进行后处理。 当剩下 2 个元素时，循环 &#x2F; 递归结束。 需要评估其余元素是否符合条件。</li>
</ul>
<h2 id="时间和空间复杂度："><a href="#时间和空间复杂度：" class="headerlink" title="时间和空间复杂度："></a>时间和空间复杂度：</h2><p>时间：O(log n) —— 算法时间  </p>
<p>因为二分查找是通过对查找空间中间的值应用一个条件来操作的，并因此将查找空间折半，在更糟糕的情况下，我们将不得不进行 O(log n) 次比较，其中 n 是集合中元素的数目。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么是 log n？</span><br><span class="line"></span><br><span class="line">二分查找是通过将现有数组一分为二来执行的。</span><br><span class="line">因此，每次调用子例程(或完成一次迭代)时，其大小都会减少到现有部分的一半。</span><br><span class="line">首先 N 变成 N/2，然后又变成 N/4，然后继续下去，直到找到元素或尺寸变为 1。</span><br><span class="line">迭代的最大次数是 log N (base 2) 。</span><br></pre></td></tr></table></figure>

<p>空间：O(1) —— 常量空间  </p>
<p>虽然二分查找确实需要跟踪 3 个指标，但迭代解决方案通常不需要任何其他额外空间，并且可以直接应用于集合本身，因此需要 O(1) 或常量空间。  </p>
<p>注：以上内容来自LeetCode-cn中的LeetBook内容。  </p>
<p>希望通过今天的学习可以入门了解二分查找。  </p>
]]></content>
      <categories>
        <category>Learn-algo</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode 1844 · subarray sum equals to k II | 子数组和为K II</title>
    <url>/2021/12/27/lintcode-1844-subarray-sum-equals-to-k-ii/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.lintcode.com/problem/1844/">1844 · 子数组和为K II</a>  </p>
<h1 id="暴力算法-O-n-3"><a href="#暴力算法-O-n-3" class="headerlink" title="暴力算法 O(n^3)"></a>暴力算法 O(n^3)</h1><p>把所有子数组都撸一遍。  </p>
<p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 子数组左端点 start //O(n)</span><br><span class="line">    for 子数组右端点 end  //O(n)</span><br><span class="line">        for start 到 end 求和  //O(n)</span><br><span class="line">            判断是不是k</span><br></pre></td></tr></table></figure>

<h1 id="暴力算法优化-O-n-2"><a href="#暴力算法优化-O-n-2" class="headerlink" title="暴力算法优化 O(n^2)"></a>暴力算法优化 O(n^2)</h1><p>用前缀和数组在 O(1) 时间内直接算得子数组和  </p>
<p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 子数组左端点 start //O(n)</span><br><span class="line">    for 子数组右端点 end  //O(n)</span><br><span class="line">        判断prefixSum[end + 1] - prefixSum[start]  //O(1)</span><br><span class="line">            是不是k</span><br></pre></td></tr></table></figure>


<h1 id="for右端点end"><a href="#for右端点end" class="headerlink" title="for右端点end"></a>for右端点end</h1><p>用 HashSet &#x2F; set<br>对于一个 end，要使得 start-end 之间最短，start 就要尽可能大  </p>
<ul>
<li>如何找到 prefixSum[start] &#x3D; prefixSum[end + 1] - k 的最大 start?<br>用 HashMap &#x2F; dict 记录得到某个 prefixSum 的最大 start 是多少</li>
</ul>
]]></content>
      <categories>
        <category>LintCode-Solutions</category>
      </categories>
  </entry>
  <entry>
    <title>一些生活好习惯</title>
    <url>/2019/02/23/life-good-habit/</url>
    <content><![CDATA[<p>又是一个周末，又是晚睡晚起，早饭随便吃一点，总说着要注意休息，但总不当回事。  </p>
<p>在此立一个flag，从今天起，如果不是特别紧急的事情，哪怕留到明天去做，我也一定要早点睡觉！！！  </p>
<h2 id="每天要做"><a href="#每天要做" class="headerlink" title="每天要做"></a>每天要做</h2><ul>
<li><p>晚上十点前准时上床睡觉，早上六点起床。  </p>
</li>
<li><p>坚持吃早饭，鸡蛋牛奶蔬菜面包水果玉米糊糊都行，吃六分饱即可。  </p>
</li>
<li><p>上班骑车，或走路，锻炼身体，公司离住处很近，所以不要太急，过马路看红绿灯，礼让行人。  </p>
</li>
<li><p>早上坚持练习英语口语，背记英语单词。  </p>
</li>
<li><p>到了工作时间，先把工作上的事情做完，再做其他的。  </p>
</li>
<li><p>中午保证半小时的睡眠时间，不玩手机。  </p>
</li>
<li><p>完成一个<code>LeetCode</code>上的编程题。  </p>
</li>
<li><p>出门前对自己一个微笑。  </p>
</li>
<li><p>写日记。</p>
</li>
</ul>
<h2 id="每周要做"><a href="#每周要做" class="headerlink" title="每周要做"></a>每周要做</h2><ul>
<li><p>去健身房锻炼身体三次，跑步，肌肉练习均可。  </p>
</li>
<li><p>至少完成一个ARTS。  </p>
</li>
<li><p>和家里人打电话，对他们说我很好；和伶儿通个电话，并告诉她我很想你。  </p>
</li>
<li><p>去吃点好吃的，见一见朋友，放松身心。</p>
</li>
</ul>
<h2 id="每月要做"><a href="#每月要做" class="headerlink" title="每月要做"></a>每月要做</h2><ul>
<li><p>做总结。  </p>
</li>
<li><p>读完一本科普或小说。</p>
</li>
</ul>
<h2 id="每年要做"><a href="#每年要做" class="headerlink" title="每年要做"></a>每年要做</h2><ul>
<li><p>去一个自己从没去过的地方。  </p>
</li>
<li><p>回家陪父母聊聊天。</p>
</li>
</ul>
<p><img src="/2019/02/23/life-good-habit/flower.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode-200-Longest Palindromic Substring | 最长回文子串</title>
    <url>/2021/11/16/lintcode-200-longest-palindromic-substring/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.lintcode.com/problem/200/description">lintcode</a>  </p>
<h2 id="暴力循环O-n-3"><a href="#暴力循环O-n-3" class="headerlink" title="暴力循环O(n^3)"></a>暴力循环O(n^3)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">伪代码</span><br><span class="line">for 起点 O(n)</span><br><span class="line">    for 终点 O(n)</span><br><span class="line">        检测中间的子串是不是一个回文串 O(n)</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n^3)</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: input string</span></span><br><span class="line"><span class="string">    @return: a string as the longest palindromic substring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s),<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - length + <span class="number">1</span>):</span><br><span class="line">                l,r = i,i+length-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> l&gt;=r:</span><br><span class="line">                    <span class="keyword">return</span> s[i:i+length]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="O-n-3-的实现方法下比较好的Coding-Quality"><a href="#O-n-3-的实现方法下比较好的Coding-Quality" class="headerlink" title="O(n^3) 的实现方法下比较好的Coding Quality"></a>O(n^3) 的实现方法下比较好的Coding Quality</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: input string</span></span><br><span class="line"><span class="string">    @return: a string as the longest palindromic substring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s),<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - length + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> self.is_palindrome(s, i, i + length - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> s[i:i + length]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">self,s,left,right</span>):</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left &gt;= right</span><br></pre></td></tr></table></figure>

<p>(待更新)  </p>
<h2 id="基于中心点枚举法-Enumeration的最佳实践"><a href="#基于中心点枚举法-Enumeration的最佳实践" class="headerlink" title="基于中心点枚举法 Enumeration的最佳实践"></a>基于中心点枚举法 Enumeration的最佳实践</h2><h2 id="基于中心线枚举的方法"><a href="#基于中心线枚举的方法" class="headerlink" title="基于中心线枚举的方法"></a>基于中心线枚举的方法</h2><h2 id="基于动态规划-Dynamic-Programming-的最佳实践"><a href="#基于动态规划-Dynamic-Programming-的最佳实践" class="headerlink" title="基于动态规划 Dynamic Programming 的最佳实践"></a>基于动态规划 Dynamic Programming 的最佳实践</h2><h2 id="基于区间型动态规划的解法"><a href="#基于区间型动态规划的解法" class="headerlink" title="基于区间型动态规划的解法"></a>基于区间型动态规划的解法</h2>]]></content>
      <categories>
        <category>LintCode-Solutions</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode 406 · Minimum Size Subarray Sum | 和大于S的最小子数组</title>
    <url>/2021/12/27/lintcode-406-minimum-size-subarray-sum/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.lintcode.com/problem/406/">406 · 和大于S的最小子数组</a>  </p>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>枚举子数组 &#x3D; 枚举起点与终点<br>对于每个找到的子数组，遍历并求和<br>更新最短的、满足要求的子数组即可  </p>
<p>时间复杂度 O(n ^ 3)，空间复杂度 O(1)  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: an array of integers</span></span><br><span class="line"><span class="string">    @param s: An integer</span></span><br><span class="line"><span class="string">    @return: an integer representing the minimum size of subarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSize</span>(<span class="params">self, nums, s</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                sum_of_subarray = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end + <span class="number">1</span>):</span><br><span class="line">                    sum_of_subarray += nums[i]</span><br><span class="line">                <span class="keyword">if</span> sum_of_subarray &gt;= s:</span><br><span class="line">                    min_length = <span class="built_in">min</span>(min_length,end-start+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"><span class="comment"># Time Limit Exceeded</span></span><br></pre></td></tr></table></figure>

<h1 id="前缀和优化"><a href="#前缀和优化" class="headerlink" title="前缀和优化"></a>前缀和优化</h1><p>首先使用 O(n) 的时间获得前缀和数组<br>然后O(n ^ 2)枚举起点终点，同时借助前缀和计算子数组和<br>子数组和 &gt;&#x3D; s ：更新子数组的长度  </p>
<p>总时间复杂度 O(n + n ^ 2) &#x3D; O(n ^ 2)<br>空间复杂度 O(n)  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: an array of integers</span></span><br><span class="line"><span class="string">    @param s: An integer</span></span><br><span class="line"><span class="string">    @return: an integer representing the minimum size of subarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSize</span>(<span class="params">self, nums, s</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        prefix_sum = self.get_prefix_sum(nums)</span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> prefix_sum[end + <span class="number">1</span>] - prefix_sum[start] &gt;= s:</span><br><span class="line">                    min_length = <span class="built_in">min</span>(min_length,end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_prefix_sum</span>(<span class="params">self,nums</span>):</span><br><span class="line">        prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums) + <span class="number">1</span>):</span><br><span class="line">            prefix_sum.append(prefix_sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prefix_sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>对于每个下标 i ，都让他作为子数组左边界<br>使用二分法找出子数组最靠左的右边界<br>使用前缀和求出子数组之和，与s比较并更新答案  </p>
<p>总时间复杂度：O(n * logn) &#x3D; 枚举起点位置：O(n) + 二分终点位置：O(logn)<br>总空间复杂度：O(n)  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: an array of integers</span></span><br><span class="line"><span class="string">    @param s: An integer</span></span><br><span class="line"><span class="string">    @return: an integer representing the minimum size of subarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSize</span>(<span class="params">self, nums, s</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        prefix_sum = self.get_prefix_sum(nums)</span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            end = self.get_end_of_subarray(prefix_sum, start, s)</span><br><span class="line">                <span class="keyword">if</span> prefix_sum[end + <span class="number">1</span>] - prefix_sum[start] &gt;= s:</span><br><span class="line">                    min_length = <span class="built_in">min</span>(min_length,end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_prefix_sum</span>(<span class="params">self,nums</span>):</span><br><span class="line">        prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums) + <span class="number">1</span>):</span><br><span class="line">            prefix_sum.append(prefix_sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prefix_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_end_of_subarray</span>(<span class="params">self,prefix_sum,start,s</span>):</span><br><span class="line">        left,right = start,<span class="built_in">len</span>(prefix_sum)-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum[mid + <span class="number">1</span>] - prefix_sum[start] &gt;= s:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prefix_sum[left + <span class="number">1</span>] - prefix_sum[start] &gt;= s:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a>同向双指针</h1><p>遍历每一个左指针 i<br>找到满足 sum(a[i],…,a[j]) &gt;&#x3D; s 的右指针 j<br>更新最短的子数组长度  </p>
<p>时间复杂度为 O(2 * n) &#x3D; O(n)<br>空间复杂度 O(1)  </p>
<p>模板  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">j = 0 or j=1</span><br><span class="line">for i from 0 to (n-1)</span><br><span class="line">    while j &lt; n and (i,j的搭配不满足条件)</span><br><span class="line">        j += 1</span><br><span class="line">    if (i,j的搭配不满足条件)</span><br><span class="line">        处理i,j的这次搭配</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: an array of integers</span></span><br><span class="line"><span class="string">    @param s: An integer</span></span><br><span class="line"><span class="string">    @return: an integer representing the minimum size of subarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSize</span>(<span class="params">self, nums, s</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        sum_of_subarray = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> sum_of_subarray &lt; s:</span><br><span class="line">                sum_of_subarray += nums[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sum_of_subarray &gt;= s:</span><br><span class="line">                min_length = <span class="built_in">min</span>(min_length,j - i)</span><br><span class="line">            sum_of_subarray -= nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><h2 id="哪些是“连续”的"><a href="#哪些是“连续”的" class="headerlink" title="哪些是“连续”的"></a>哪些是“连续”的</h2><ul>
<li>子串 (substring) – 连续  </li>
<li>子数组 (subarray) – 连续  </li>
<li>子序列 (subsequence) – 不连续</li>
</ul>
<h2 id="遇到subarray的解题技巧"><a href="#遇到subarray的解题技巧" class="headerlink" title="遇到subarray的解题技巧"></a>遇到subarray的解题技巧</h2><ul>
<li>prefixSum  </li>
<li>同向双指针</li>
</ul>
<h2 id="所有的双指针解法时间复杂度都是O-n"><a href="#所有的双指针解法时间复杂度都是O-n" class="headerlink" title="所有的双指针解法时间复杂度都是O(n)"></a>所有的双指针解法时间复杂度都是O(n)</h2>]]></content>
      <categories>
        <category>LintCode-Solutions</category>
      </categories>
  </entry>
  <entry>
    <title>LintCode Java教程 练习题答案</title>
    <url>/2022/01/07/lintcode-learn-java/</url>
    <content><![CDATA[<h1 id="Java-基础语法：语法、变量与运算"><a href="#Java-基础语法：语法、变量与运算" class="headerlink" title="Java 基础语法：语法、变量与运算"></a>Java 基础语法：语法、变量与运算</h1><h2 id="2160-·-打印-“Hello-Java”"><a href="#2160-·-打印-“Hello-Java”" class="headerlink" title="2160 · 打印 “Hello Java”"></a>2160 · 打印 “Hello Java”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* Your first java code</span></span><br><span class="line"><span class="comment">     * print Hello Java to console</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">		System.out.print(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2157-·-打印-Welcome-to-LintCode"><a href="#2157-·-打印-Welcome-to-LintCode" class="headerlink" title="2157 · 打印 Welcome to LintCode!"></a>2157 · 打印 Welcome to LintCode!</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Welcome to LintCode!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2289-·-字符的ASCII码（Java-版）"><a href="#2289-·-字符的ASCII码（Java-版）" class="headerlink" title="2289 · 字符的ASCII码（Java 版）"></a>2289 · 字符的ASCII码（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">char</span> c= scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(c+<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2814-ASCII码对应的字符（Java-版）"><a href="#2814-ASCII码对应的字符（Java-版）" class="headerlink" title="2814.ASCII码对应的字符（Java 版）"></a>2814.ASCII码对应的字符（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">128</span> &amp;&amp; num &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(num&gt;<span class="number">0</span>?(<span class="type">char</span>)num:<span class="string">&quot;error&quot;</span>);	</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        sc.close();</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2759-·-Integer-的取值范围"><a href="#2759-·-Integer-的取值范围" class="headerlink" title="2759 · Integer 的取值范围"></a>2759 · Integer 的取值范围</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equivalence</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> a.equals(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2611-·-判断两个数组是否相等"><a href="#2611-·-判断两个数组是否相等" class="headerlink" title="2611 · 判断两个数组是否相等"></a>2611 · 判断两个数组是否相等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalityOfArrays</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span> arr2[])</span> &#123;</span><br><span class="line">        <span class="comment">// -- write your code here --</span></span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(arr1,arr2))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2166-·-简单的加减乘除运算"><a href="#2166-·-简单的加减乘除运算" class="headerlink" title="2166 · 简单的加减乘除运算"></a>2166 · 简单的加减乘除运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addition</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> a + b;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtraction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multiplication</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2826-·-数字-2-的朋友"><a href="#2826-·-数字-2-的朋友" class="headerlink" title="2826 · 数字 2 的朋友"></a>2826 · 数字 2 的朋友</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFriend</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n) == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2820-·-小数字的和"><a href="#2820-·-小数字的和" class="headerlink" title="2820 · 小数字的和"></a>2820 · 小数字的和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> len=scan.nextInt();</span><br><span class="line">        <span class="type">int</span>[] s=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            s[i]=scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求最大</span></span><br><span class="line">        <span class="type">int</span> max=Arrays.stream(s).max().orElse(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//过滤并求和</span></span><br><span class="line">        <span class="type">int</span> total=Arrays.stream(s).filter(f -&gt; f!=max).sum();</span><br><span class="line">        System.out.println(total);	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2823-·-这是什么三角形？"><a href="#2823-·-这是什么三角形？" class="headerlink" title="2823 · 这是什么三角形？"></a>2823 · 这是什么三角形？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">cin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cin.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> cin.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">180</span> - a -b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (a + b == <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;直角三角形&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (a + b &lt; <span class="number">90</span>) &#123; <span class="comment">//c &gt; 90</span></span><br><span class="line">            System.out.println(<span class="string">&quot;钝角三角形&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;锐角三角形&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;无法组成三角形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2515-·-唯一存在的数字"><a href="#2515-·-唯一存在的数字" class="headerlink" title="2515 · 唯一存在的数字"></a>2515 · 唯一存在的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums: Represents the incoming number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A int value representing whether the</span></span><br><span class="line"><span class="comment">     *          return is a palindrome or not</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniqueNumber</span><span class="params">(<span class="type">int</span> nums[])</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-控制语句：分支与循环"><a href="#Java-控制语句：分支与循环" class="headerlink" title="Java 控制语句：分支与循环"></a>Java 控制语句：分支与循环</h1><h2 id="2411-·-打印每月含有的天数"><a href="#2411-·-打印每月含有的天数" class="headerlink" title="2411 · 打印每月含有的天数"></a>2411 · 打印每月含有的天数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// read data from console</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// output the answer to the console according to the</span></span><br><span class="line">        <span class="comment">// requirements of the question</span></span><br><span class="line">        <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;31 days&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;30 days&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((((year % <span class="number">4</span>) == <span class="number">0</span>) &amp;&amp; ((year % <span class="number">100</span>) != <span class="number">0</span>)) ||</span><br><span class="line">                    ((year % <span class="number">400</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;29 days&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;28 days&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2323-·-命中率评级-（Java-版）"><a href="#2323-·-命中率评级-（Java-版）" class="headerlink" title="2323 · 命中率评级 （Java 版）"></a>2323 · 命中率评级 （Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// read data from console</span></span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="comment">// output the answer to the console according to the</span></span><br><span class="line">        <span class="comment">// requirements of the question</span></span><br><span class="line">        <span class="keyword">switch</span>(n/<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2290-·-求最大公约数（Java-版）"><a href="#2290-·-求最大公约数（Java-版）" class="headerlink" title="2290 · 求最大公约数（Java 版）"></a>2290 · 求最大公约数（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// please print the greatest common divisor of a and b</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minval</span> <span class="operator">=</span> Math.min(a,b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> Math.max(a,b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(maxVal % minval == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(minval);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= <span class="number">2</span>;</span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">            b /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">3</span>== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            a /= <span class="number">3</span>;</span><br><span class="line">            b /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a%<span class="number">5</span> ==<span class="number">0</span> &amp;&amp; b%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= <span class="number">5</span>;</span><br><span class="line">            a /= <span class="number">5</span>;</span><br><span class="line">            b /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2813-·-求-1-—-100-的偶数和"><a href="#2813-·-求-1-—-100-的偶数和" class="headerlink" title="2813 · 求 1 — 100 的偶数和"></a>2813 · 求 1 — 100 的偶数和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			res += i;</span><br><span class="line">			i += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Even sum of 1 - 100: &quot;</span>+res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2259-·-求和（Java-版）"><a href="#2259-·-求和（Java-版）" class="headerlink" title="2259 · 求和（Java 版）"></a>2259 · 求和（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// read data from console</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">// output the answer to the console according to the requirements of the question</span></span><br><span class="line">        System.out.println((<span class="number">1</span>+n)*n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2822-·-截取下标为5的字符"><a href="#2822-·-截取下标为5的字符" class="headerlink" title="2822 · 截取下标为5的字符"></a>2822 · 截取下标为5的字符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建Scanner对象</span></span><br><span class="line">		String s=sc.next();               <span class="comment">//创建输入一个字符串</span></span><br><span class="line">		<span class="type">char</span>[] ch=s.toCharArray();		  <span class="comment">//将字符串转化为char型数组</span></span><br><span class="line">		System.out.print(ch[<span class="number">5</span>]);		  <span class="comment">//输出char型数组下标为5的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2825-·-判断字符串是否相等"><a href="#2825-·-判断字符串是否相等" class="headerlink" title="2825 · 判断字符串是否相等"></a>2825 · 判断字符串是否相等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">		System.out.println(str1.equals(str2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2336-·-字符串中的字母大小写转换"><a href="#2336-·-字符串中的字母大小写转换" class="headerlink" title="2336 · 字符串中的字母大小写转换"></a>2336 · 字符串中的字母大小写转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str:   Indicates the string passed in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  means return the case-converted string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alphabetConversion</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);           </span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                c += <span class="number">32</span>;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                c -= <span class="number">32</span>;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2408-·-字符串字符排序"><a href="#2408-·-字符串字符排序" class="headerlink" title="2408 · 字符串字符排序"></a>2408 · 字符串字符排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str: Arbitrary non-empty string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String in alphabetical ascending order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="comment">// 将数组转化成字符串</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2828-·-拼接字符串并改为大写"><a href="#2828-·-拼接字符串并改为大写" class="headerlink" title="2828 · 拼接字符串并改为大写"></a>2828 · 拼接字符串并改为大写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;I love &quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		str1 = str1.concat(str2);</span><br><span class="line">		str1 = str1.toUpperCase();</span><br><span class="line">		System.out.println(str1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2329-·-求直角坐标系内两点间距离（Java-版）"><a href="#2329-·-求直角坐标系内两点间距离（Java-版）" class="headerlink" title="2329 · 求直角坐标系内两点间距离（Java 版）"></a>2329 · 求直角坐标系内两点间距离（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// read data from console</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">// output the answer to the console according to the</span></span><br><span class="line">        <span class="comment">// requirements of the question</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">distance</span> <span class="operator">=</span> Math.sqrt(((x1 - x2) * (x1 - x2)) +</span><br><span class="line">                ((y1 - y2) * (y1 - y2)));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2283-·-圆型周长（Java-版）"><a href="#2283-·-圆型周长（Java-版）" class="headerlink" title="2283 · 圆型周长（Java 版）"></a>2283 · 圆型周长（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">// please print the perimeter of the circle</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f&quot;</span>,<span class="number">2</span>*Math.PI*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2289-·-字符的ASCII码（Java-版）-1"><a href="#2289-·-字符的ASCII码（Java-版）-1" class="headerlink" title="2289 · 字符的ASCII码（Java 版）"></a>2289 · 字符的ASCII码（Java 版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">char</span> c= scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(c+<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2837-·-复制指定元素"><a href="#2837-·-复制指定元素" class="headerlink" title="2837 · 复制指定元素"></a>2837 · 复制指定元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="type">int</span> [] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			newArr[i] = arr[i];</span><br><span class="line">			System.out.print(newArr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2838-·-随机生成数字"><a href="#2838-·-随机生成数字" class="headerlink" title="2838 · 随机生成数字"></a>2838 · 随机生成数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">		<span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">			System.out.println(r.nextInt(n)+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2675-·-日期格式转换"><a href="#2675-·-日期格式转换" class="headerlink" title="2675 · 日期格式转换"></a>2675 · 日期格式转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dateConversion</span><span class="params">(String str)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">// -- write your code here --</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年M月d日&quot;</span>).format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2829-·-简单的手机号码验证"><a href="#2829-·-简单的手机号码验证" class="headerlink" title="2829 · 简单的手机号码验证"></a>2829 · 简单的手机号码验证</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[3-9]&#123;1&#125;[0-9]&#123;9&#125;+$&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2832-·-简单校验一下邮箱格式"><a href="#2832-·-简单校验一下邮箱格式" class="headerlink" title="2832 · 简单校验一下邮箱格式"></a>2832 · 简单校验一下邮箱格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^[^0-9]\\w*([.+-]\\w+)*@[a-z0-9]+(.com)+(\\.[\\.a-zA-Z0-9]+)*&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s); </span><br><span class="line">        <span class="keyword">return</span> matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2840-·-简单的字符串匹配替换"><a href="#2840-·-简单的字符串匹配替换" class="headerlink" title="2840 · 简单的字符串匹配替换"></a>2840 · 简单的字符串匹配替换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceString</span> <span class="params">(String str, String replacement)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> str.replaceAll(<span class="string">&quot;[\\]/\\|~!@#$%\\^&amp;\\*\\(\\);:_\\+\\-\\[\\]]+&quot;</span>, replacement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-面向对象入门"><a href="#Java-面向对象入门" class="headerlink" title="Java 面向对象入门"></a>Java 面向对象入门</h1><h2 id="2848-·-完善合适的类"><a href="#2848-·-完善合适的类" class="headerlink" title="2848 · 完善合适的类"></a>2848 · 完善合适的类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">	<span class="comment">//write your code here</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">protected</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Name: &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;, age: &quot;</span> + String.valueOf(<span class="built_in">this</span>.age);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2851-·-动物园的新朋友"><a href="#2851-·-动物园的新朋友" class="headerlink" title="2851 · 动物园的新朋友"></a>2851 · 动物园的新朋友</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name,type;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAnimalMessage</span><span class="params">(String name, String type, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAnimalMessage</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot; is a &quot;</span>+type+<span class="string">&quot; and is &quot;</span>+age+<span class="string">&quot; years old this year.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2852-·-补充-Student-类的属性和方法"><a href="#2852-·-补充-Student-类的属性和方法" class="headerlink" title="2852 · 补充 Student 类的属性和方法"></a>2852 · 补充 Student 类的属性和方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEX_FEMALE</span> <span class="operator">=</span> <span class="string">&quot;female&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEX_MALE</span> <span class="operator">=</span> <span class="string">&quot;male&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = &quot;</span>+name+<span class="string">&quot;, age = &quot;</span>+age+<span class="string">&quot;, sex = &quot;</span>+sex;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2853-·-普通单例模式"><a href="#2853-·-普通单例模式" class="headerlink" title="2853 · 普通单例模式"></a>2853 · 普通单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a Single Instance Class.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="comment">//创建 SingleClass 的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2842-·-无参构造函数的使用（一）"><a href="#2842-·-无参构造函数的使用（一）" class="headerlink" title="2842 · 无参构造函数的使用（一）"></a>2842 · 无参构造函数的使用（一）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">180.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2843-·-无参构造函数的使用（二）"><a href="#2843-·-无参构造函数的使用（二）" class="headerlink" title="2843 · 无参构造函数的使用（二）"></a>2843 · 无参构造函数的使用（二）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2850-·-有参构造函数的使用（一）"><a href="#2850-·-有参构造函数的使用（一）" class="headerlink" title="2850 · 有参构造函数的使用（一）"></a>2850 · 有参构造函数的使用（一）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">( <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2212-·-编写对象属性的赋值方法和打印方法"><a href="#2212-·-编写对象属性的赋值方法和打印方法" class="headerlink" title="2212 · 编写对象属性的赋值方法和打印方法"></a>2212 · 编写对象属性的赋值方法和打印方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String occupation;</span><br><span class="line">    String telephone;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, </span></span><br><span class="line"><span class="params">                    String occupation,</span></span><br><span class="line"><span class="params">                    String telephone,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> age,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.occupation = occupation;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =  name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOccupation</span><span class="params">(String occupation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupation = occupation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTelephone</span><span class="params">(String telephone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">int</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + System.lineSeparator() +</span><br><span class="line">        <span class="string">&quot;Age: &quot;</span>+ age + System.lineSeparator() +</span><br><span class="line">        <span class="string">&quot;Telephone: &quot;</span> + telephone + System.lineSeparator() +</span><br><span class="line">        <span class="string">&quot;Occupation: &quot;</span> + occupation + System.lineSeparator() +</span><br><span class="line">        <span class="string">&quot;Salary: &quot;</span> + salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2614-·-求长方形的周长和面积"><a href="#2614-·-求长方形的周长和面积" class="headerlink" title="2614 · 求长方形的周长和面积"></a>2614 · 求长方形的周长和面积</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> width)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.length=length;</span><br><span class="line">        <span class="built_in">this</span>.width=width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">float</span> zhouchang=(length+width)*<span class="number">2</span>;</span><br><span class="line">        <span class="type">float</span> mianji=length*width;</span><br><span class="line">        String s=<span class="string">&quot;周长为: &quot;</span>+zhouchang+<span class="string">&quot;,面积为: &quot;</span>+mianji;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2244-·-打印工作内容"><a href="#2244-·-打印工作内容" class="headerlink" title="2244 · 打印工作内容"></a>2244 · 打印工作内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Java-面向对象进阶"><a href="#Java-面向对象进阶" class="headerlink" title="# Java 面向对象进阶"></a># Java 面向对象进阶</h1>]]></content>
      <categories>
        <category>LearnJava</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode Python教程 练习题答案</title>
    <url>/2022/05/05/lintcode-learn-python/</url>
    <content><![CDATA[<h1 id="基础语法、变量与运算"><a href="#基础语法、变量与运算" class="headerlink" title="基础语法、变量与运算"></a>基础语法、变量与运算</h1><h2 id="2274-·-第一个-Python-程序：打印-Hello-World"><a href="#2274-·-第一个-Python-程序：打印-Hello-World" class="headerlink" title="2274 · 第一个 Python 程序：打印 Hello World"></a>2274 · 第一个 Python 程序：打印 Hello World</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Your first python code</span></span><br><span class="line"><span class="comment"># print Hello World to console</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2920-·-获取输入数据并打印它"><a href="#2920-·-获取输入数据并打印它" class="headerlink" title="2920 · 获取输入数据并打印它"></a>2920 · 获取输入数据并打印它</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please write your code here</span></span><br><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<h2 id="2924-·-定义字符串和数字并打印"><a href="#2924-·-定义字符串和数字并打印" class="headerlink" title="2924 · 定义字符串和数字并打印"></a>2924 · 定义字符串和数字并打印</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please write your code here</span></span><br><span class="line">str_1 = <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">num_1 = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(str_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_1))</span><br><span class="line"><span class="built_in">print</span>(str_1)</span><br><span class="line"><span class="built_in">print</span>(num_1)</span><br></pre></td></tr></table></figure>

<h2 id="2407-·-计算-a-aa-aaa-aaaa-的值"><a href="#2407-·-计算-a-aa-aaa-aaaa-的值" class="headerlink" title="2407 · 计算 a + aa + aaa + aaaa 的值"></a>2407 · 计算 a + aa + aaa + aaaa 的值</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_sum</span>(<span class="params">int_1: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param int_1: Input number</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># -- write your code here --</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        temp += int_1</span><br><span class="line">        answer += temp</span><br><span class="line">        temp *= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>

<h2 id="2271-·-整数运算（Python-版）"><a href="#2271-·-整数运算（Python-版）" class="headerlink" title="2271 · 整数运算（Python 版）"></a>2271 · 整数运算（Python 版）</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="2271-·-整数运算（Python-版）-1"><a href="#2271-·-整数运算（Python-版）-1" class="headerlink" title="2271 · 整数运算（Python 版）"></a>2271 · 整数运算（Python 版）</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(a - b)</span><br><span class="line"><span class="built_in">print</span>(a * b)</span><br><span class="line"><span class="built_in">print</span>(a // b)</span><br></pre></td></tr></table></figure>

<h2 id="2919-·-整数运算2"><a href="#2919-·-整数运算2" class="headerlink" title="2919 · 整数运算2"></a>2919 · 整数运算2</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line"><span class="built_in">print</span>(a % b)</span><br><span class="line"><span class="built_in">print</span>(a ** b)</span><br><span class="line"><span class="built_in">print</span>(a // b)</span><br></pre></td></tr></table></figure>

<h2 id="2269-·-交换两个整数（Python-版）"><a href="#2269-·-交换两个整数（Python-版）" class="headerlink" title="2269 · 交换两个整数（Python 版）"></a>2269 · 交换两个整数（Python 版）</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;, b =&#x27;</span>, b)</span><br></pre></td></tr></table></figure>

<h2 id="2267-·-求三个数的最大值（Python-版）"><a href="#2267-·-求三个数的最大值（Python-版）" class="headerlink" title="2267 · 求三个数的最大值（Python 版）"></a>2267 · 求三个数的最大值（Python 版）</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">b = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">c = <span class="built_in">int</span>(sys.argv[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># you need to print the maximum</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a, b, c))</span><br></pre></td></tr></table></figure>

<h2 id="2271-·-整数运算（Python-版）-2"><a href="#2271-·-整数运算（Python-版）-2" class="headerlink" title="2271 · 整数运算（Python 版）"></a>2271 · 整数运算（Python 版）</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(a - b)</span><br><span class="line"><span class="built_in">print</span>(a * b)</span><br><span class="line"><span class="built_in">print</span>(a // b)</span><br></pre></td></tr></table></figure>

<h2 id="2269-·-交换两个整数（Python-版）-1"><a href="#2269-·-交换两个整数（Python-版）-1" class="headerlink" title="2269 · 交换两个整数（Python 版）"></a>2269 · 交换两个整数（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a , b = b , a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a , b))</span><br></pre></td></tr></table></figure>

<h2 id="2267-·-求三个数的最大值（Python-版）-1"><a href="#2267-·-求三个数的最大值（Python-版）-1" class="headerlink" title="2267 · 求三个数的最大值（Python 版）"></a>2267 · 求三个数的最大值（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">b = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">c = <span class="built_in">int</span>(sys.argv[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a,b,c))</span><br></pre></td></tr></table></figure>

<h2 id="2917-·-两个变量间的逻辑运算"><a href="#2917-·-两个变量间的逻辑运算" class="headerlink" title="2917 · 两个变量间的逻辑运算"></a>2917 · 两个变量间的逻辑运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">a = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)</span><br></pre></td></tr></table></figure>

<h2 id="2418-·-位运算左移三位（Python-版）"><a href="#2418-·-位运算左移三位（Python-版）" class="headerlink" title="2418 · 位运算左移三位（Python 版）"></a>2418 · 位运算左移三位（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line"><span class="built_in">print</span>(n &lt;&lt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2937-·-二进制数最右边的-1"><a href="#2937-·-二进制数最右边的-1" class="headerlink" title="2937 · 二进制数最右边的 1"></a>2937 · 二进制数最右边的 1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get the number a</span></span><br><span class="line">num_1 = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># Please write your code here</span></span><br><span class="line">x = num_1&amp;(num_1-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num_1-x)</span><br></pre></td></tr></table></figure>

<h2 id="2948-·-给会员打折"><a href="#2948-·-给会员打折" class="headerlink" title="2948 · 给会员打折"></a>2948 · 给会员打折</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get Variables</span></span><br><span class="line">price = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">customer = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">vip = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">blacklist = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># please write your code here</span></span><br><span class="line"><span class="keyword">if</span> customer <span class="keyword">in</span> vip: <span class="comment"># 判断顾客是否是VIP</span></span><br><span class="line">	price=<span class="string">&quot;%.2f&quot;</span>%(<span class="number">0.70</span>*price)</span><br><span class="line"><span class="keyword">elif</span> customer <span class="keyword">in</span> blacklist: <span class="comment"># 判断顾客是否在黑名单</span></span><br><span class="line">	price=-<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(price)</span><br></pre></td></tr></table></figure>

<h2 id="2950-·-查看是否是同一对象"><a href="#2950-·-查看是否是同一对象" class="headerlink" title="2950 · 查看是否是同一对象"></a>2950 · 查看是否是同一对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please write your code here</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="2216-·-字符串的相加、重复输出、切片"><a href="#2216-·-字符串的相加、重复输出、切片" class="headerlink" title="2216 · 字符串的相加、重复输出、切片"></a>2216 · 字符串的相加、重复输出、切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_repeat_slicing</span>(<span class="params">str_1: <span class="built_in">str</span>, str_2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param str_1: The first source string</span></span><br><span class="line"><span class="string">    :param str_2: The Second source string</span></span><br><span class="line"><span class="string">    :return: tuple: A tuple containing three new strings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># -- write your code here --</span></span><br><span class="line">    a = str_1 + str_2</span><br><span class="line">    b = str_1 * <span class="number">2</span></span><br><span class="line">    c = str_1[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    res = (a,b,c)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="2363-·-根据行边界符拆分字符串并找出最长行"><a href="#2363-·-根据行边界符拆分字符串并找出最长行" class="headerlink" title="2363 · 根据行边界符拆分字符串并找出最长行"></a>2363 · 根据行边界符拆分字符串并找出最长行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">splitlines</span>(<span class="params">src: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param src: The source string needs to be processed</span></span><br><span class="line"><span class="string">    :return: The maximum length of the string</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># -- write your code here --</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(src.splitlines(),key=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2395-·-统计字符串出现的次数"><a href="#2395-·-统计字符串出现的次数" class="headerlink" title="2395 · 统计字符串出现的次数"></a>2395 · 统计字符串出现的次数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_string</span>(<span class="params">str_1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param str_1: Input string</span></span><br><span class="line"><span class="string">    :return: Count the number of occurrences of a string</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># -- write your code here --</span></span><br><span class="line">    coun_a = str_1.count(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    coun_going = str_1.count(<span class="string">&#x27;going&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> (coun_a,coun_going)</span><br></pre></td></tr></table></figure>

<h2 id="2923-·-定义一个列表"><a href="#2923-·-定义一个列表" class="headerlink" title="2923 · 定义一个列表"></a>2923 · 定义一个列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">str_1 = <span class="built_in">str</span>(<span class="built_in">input</span>())</span><br><span class="line">num_1 = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># Please print the list of definitions</span></span><br><span class="line">list_1=[str_1,num_1]</span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br></pre></td></tr></table></figure>

<h2 id="2314-·-列表修改、添加和删除元素"><a href="#2314-·-列表修改、添加和删除元素" class="headerlink" title="2314 · 列表修改、添加和删除元素"></a>2314 · 列表修改、添加和删除元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">list_update_del</span>(<span class="params">list_1: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param list_1:  the source list</span></span><br><span class="line"><span class="string">    :return: modified list_1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># --write your code here--</span></span><br><span class="line">    <span class="comment"># 修改第三个元素为1999</span></span><br><span class="line">    list_1[<span class="number">2</span>] = <span class="number">1999</span></span><br><span class="line">    <span class="comment"># 列表添加一个元素‘jiuzhang’</span></span><br><span class="line">    list_1.append(<span class="string">&#x27;jiuzhang&#x27;</span>)</span><br><span class="line">    <span class="comment"># 删除列表的第一个元素</span></span><br><span class="line">    list_1.remove(list_1[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list_1</span><br></pre></td></tr></table></figure>


<h2 id="2925-·-定义一个元组"><a href="#2925-·-定义一个元组" class="headerlink" title="2925 · 定义一个元组"></a>2925 · 定义一个元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">num_1 = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">num_2 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># Please print the list of definitions</span></span><br><span class="line">t =(num_1,num_2)</span><br><span class="line"><span class="built_in">print</span>(t,<span class="built_in">type</span>(t),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3137-·-分割元组"><a href="#3137-·-分割元组" class="headerlink" title="3137 · 分割元组"></a>3137 · 分割元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_tuple = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line">i = <span class="built_in">int</span>(<span class="built_in">len</span>(my_tuple) / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple[:i])</span><br><span class="line"><span class="built_in">print</span>( my_tuple[i:])</span><br></pre></td></tr></table></figure>

<h2 id="3138-·-元素在元组内的出现次数"><a href="#3138-·-元素在元组内的出现次数" class="headerlink" title="3138 · 元素在元组内的出现次数"></a>3138 · 元素在元组内的出现次数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_tuple = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple.count(x))</span><br></pre></td></tr></table></figure>

<h2 id="3139-·-集合中最大的元素"><a href="#3139-·-集合中最大的元素" class="headerlink" title="3139 · 集合中最大的元素"></a>3139 · 集合中最大的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_set = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(my_set))</span><br></pre></td></tr></table></figure>

<h2 id="3140-·-集合运算"><a href="#3140-·-集合运算" class="headerlink" title="3140 · 集合运算"></a>3140 · 集合运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_set1 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">my_set2 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">my_set3 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_set1 &amp; my_set2 - my_set3))</span><br></pre></td></tr></table></figure>

<h2 id="3141-·-集合中绝对值小于-10-的元素之和"><a href="#3141-·-集合中绝对值小于-10-的元素之和" class="headerlink" title="3141 · 集合中绝对值小于 10 的元素之和"></a>3141 · 集合中绝对值小于 10 的元素之和</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_set = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>([num <span class="keyword">for</span> num <span class="keyword">in</span> my_set <span class="keyword">if</span> <span class="built_in">abs</span>(num) &lt;<span class="number">10</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="3142-·-字典中不同的-value-数目"><a href="#3142-·-字典中不同的-value-数目" class="headerlink" title="3142 · 字典中不同的 value 数目"></a>3142 · 字典中不同的 value 数目</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_dict = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">set</span>(my_dict.values())))</span><br></pre></td></tr></table></figure>

<h2 id="3143-·-字典合并后的大小"><a href="#3143-·-字典合并后的大小" class="headerlink" title="3143 · 字典合并后的大小"></a>3143 · 字典合并后的大小</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_dict1 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">my_dict2 = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line">my_dict1.update(my_dict2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_dict1))</span><br></pre></td></tr></table></figure>

<h2 id="3144-·-根据字典替换列表元素"><a href="#3144-·-根据字典替换列表元素" class="headerlink" title="3144 · 根据字典替换列表元素"></a>3144 · 根据字典替换列表元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">my_dict = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">nums = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">print</span>([my_dict[i] <span class="keyword">for</span> i <span class="keyword">in</span> nums ])</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="2315-·-判断三角形（Python-版）"><a href="#2315-·-判断三角形（Python-版）" class="headerlink" title="2315 · 判断三角形（Python 版）"></a>2315 · 判断三角形（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line">lis = [a, b, c]</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> * <span class="built_in">max</span>(lis) &lt; <span class="built_in">sum</span>(lis) :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Is a triangle&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not a triangle&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2202-·-求和（Python-版）"><a href="#2202-·-求和（Python-版）" class="headerlink" title="2202 · 求和（Python 版）"></a>2202 · 求和（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">	num = num + i</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<h2 id="2356-·-打印九九乘法表（Python-版）"><a href="#2356-·-打印九九乘法表（Python-版）" class="headerlink" title="2356 · 打印九九乘法表（Python 版）"></a>2356 · 打印九九乘法表（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="comment"># output the answer to the console according to the requirements of the question</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i*j&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span> <span class="keyword">if</span> j&lt;i <span class="keyword">else</span> <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3167-·-交错和（Python-版）"><a href="#3167-·-交错和（Python-版）" class="headerlink" title="3167 · 交错和（Python 版）"></a>3167 · 交错和（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">sum</span>+=-i</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">sum</span>+=i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3170-·-找到第一个平方大于-n-的整数"><a href="#3170-·-找到第一个平方大于-n-的整数" class="headerlink" title="3170 · 找到第一个平方大于 n 的整数"></a>3170 · 找到第一个平方大于 n 的整数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line">candidate = <span class="number">1</span> <span class="comment"># 从整数1开始递增</span></span><br><span class="line"><span class="keyword">while</span> candidate ** <span class="number">2</span> &lt;= n: <span class="comment"># 循环直到找到第一个平方大于n的整数</span></span><br><span class="line">    candidate += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br></pre></td></tr></table></figure>

<h2 id="3174-·-值为下标的倍数的元素个数（Python-版）"><a href="#3174-·-值为下标的倍数的元素个数（Python-版）" class="headerlink" title="3174 · 值为下标的倍数的元素个数（Python 版）"></a>3174 · 值为下标的倍数的元素个数（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">arr = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line">count = <span class="number">0</span> <span class="comment"># 初始化计数器</span></span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr): <span class="comment"># 遍历列表arr</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>: <span class="comment"># i为0时，特判arr[i]是否为0</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> num % i == <span class="number">0</span>: <span class="comment"># i不为0时，判断arr[i]是否为i的倍数</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h2 id="3175-·-组成三角形的元组个数"><a href="#3175-·-组成三角形的元组个数" class="headerlink" title="3175 · 组成三角形的元组个数"></a>3175 · 组成三角形的元组个数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read data from console</span></span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># write your code here</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>): <span class="comment"># 遍历所有元素值不超过n的三元组</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>): </span><br><span class="line">            triplet = <span class="built_in">sorted</span>((i,j,k)) <span class="comment"># 对每个三元组进行排序</span></span><br><span class="line">            <span class="keyword">if</span> triplet[<span class="number">0</span>]+triplet[<span class="number">1</span>] &gt; triplet[<span class="number">2</span>]: <span class="comment"># 判断最小的两个数之和是否大于第三个数</span></span><br><span class="line">               count +=<span class="number">1</span> <span class="comment"># 计数器加1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="2932-·-打印学生平均成绩"><a href="#2932-·-打印学生平均成绩" class="headerlink" title="2932 · 打印学生平均成绩"></a>2932 · 打印学生平均成绩</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please write your code here</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_avg</span>(<span class="params">*score, **info</span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;name: %s, age: %d, avg: %.2f&quot;</span> % </span><br><span class="line">                (info[<span class="string">&#x27;student_name&#x27;</span>], </span><br><span class="line">                info[<span class="string">&#x27;student_age&#x27;</span>], </span><br><span class="line">                <span class="built_in">sum</span>(score)/<span class="built_in">len</span>(score)))</span><br></pre></td></tr></table></figure>

<h2 id="2124-·-打印-Hello-Python"><a href="#2124-·-打印-Hello-Python" class="headerlink" title="2124 · 打印 Hello Python"></a>2124 · 打印 Hello Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_python</span>():</span><br><span class="line">    <span class="comment"># --write your code here--</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3166-·-求两数绝对值之和（Python-版）"><a href="#3166-·-求两数绝对值之和（Python-版）" class="headerlink" title="3166 · 求两数绝对值之和（Python 版）"></a>3166 · 求两数绝对值之和（Python 版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your code here.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">num1,num2</span>):</span><br><span class="line">    <span class="keyword">return</span>(numAbs(num1)+numAbs(num2))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numAbs</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> (-num <span class="keyword">if</span> num&lt;<span class="number">0</span> <span class="keyword">else</span> num)</span><br></pre></td></tr></table></figure>

<h2 id="3171-·-找出-1-n-中能被-x-整除的数"><a href="#3171-·-找出-1-n-中能被-x-整除的数" class="headerlink" title="3171 · 找出 1 - n 中能被 x 整除的数"></a>3171 · 找出 1 - n 中能被 x 整除的数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your code here.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">n:<span class="built_in">int</span>,x:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">list</span>=[x*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n//x+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>,<span class="built_in">len</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2126-·-导入一个模块文件夹下的中一个文件"><a href="#2126-·-导入一个模块文件夹下的中一个文件" class="headerlink" title="2126 · 导入一个模块文件夹下的中一个文件"></a>2126 · 导入一个模块文件夹下的中一个文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write your code here</span></span><br><span class="line"><span class="keyword">from</span> branch <span class="keyword">import</span> solution</span><br><span class="line"><span class="comment"># keep the code below</span></span><br><span class="line">solution.do()</span><br></pre></td></tr></table></figure>

<h2 id="3164-·-重命名导入的同名文件"><a href="#3164-·-重命名导入的同名文件" class="headerlink" title="3164 · 重命名导入的同名文件"></a>3164 · 重命名导入的同名文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your code here</span></span><br><span class="line"><span class="keyword">from</span> branch1 <span class="keyword">import</span> solution <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">from</span> branch2 <span class="keyword">import</span> solution <span class="keyword">as</span> b</span><br><span class="line"><span class="comment"># Keep the code below</span></span><br><span class="line">a.do()</span><br><span class="line">b.do()</span><br></pre></td></tr></table></figure>

<h2 id="3176-·-输出对应日期的正午时间点"><a href="#3176-·-输出对应日期的正午时间点" class="headerlink" title="3176 · 输出对应日期的正午时间点"></a>3176 · 输出对应日期的正午时间点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your code here.</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">year,month,day</span>):</span><br><span class="line">    <span class="keyword">return</span> datetime(year,month,day,<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3148-·-使用-lambda-函数构造一元二次多项式"><a href="#3148-·-使用-lambda-函数构造一元二次多项式" class="headerlink" title="3148 · 使用 lambda 函数构造一元二次多项式"></a>3148 · 使用 lambda 函数构造一元二次多项式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">equation</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="comment"># Write your code here.</span></span><br><span class="line">    k = <span class="keyword">lambda</span> x : a*x**<span class="number">2</span> + b*x + c</span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>

<h2 id="3162-·-根据年龄对成员进行排序"><a href="#3162-·-根据年龄对成员进行排序" class="headerlink" title="3162 · 根据年龄对成员进行排序"></a>3162 · 根据年龄对成员进行排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_list</span>(<span class="params">members: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="comment"># Write your code here.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(members,key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="2930-·-向文件里写入列表"><a href="#2930-·-向文件里写入列表" class="headerlink" title="2930 · 向文件里写入列表"></a>2930 · 向文件里写入列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_list</span>(<span class="params">path: <span class="built_in">str</span>, list_1: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="comment"># Please write your code</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="built_in">str</span>(list_1))</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<h2 id="2931-·-从文件中读取字典并修改它"><a href="#2931-·-从文件中读取字典并修改它" class="headerlink" title="2931 · 从文件中读取字典并修改它"></a>2931 · 从文件中读取字典并修改它</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_write_dict</span>(<span class="params">path:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Please write your code</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> fp:</span><br><span class="line">        py_dic = json.load(fp)</span><br><span class="line">        py_dic[<span class="string">&#x27;age&#x27;</span>]=<span class="number">18</span></span><br><span class="line">        js_str = <span class="string">f&#x27;<span class="subst">&#123;py_dic&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fps:</span><br><span class="line">            json.dump(js_str,fps)</span><br></pre></td></tr></table></figure>

<h2 id="2934-·-读取-csv-文件并修改"><a href="#2934-·-读取-csv-文件并修改" class="headerlink" title="2934 · 读取 csv 文件并修改"></a>2934 · 读取 csv 文件并修改</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_write_csv</span>(<span class="params">path:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Please write your code</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines=f.readlines()</span><br><span class="line">        lines[<span class="number">0</span>]=lines[<span class="number">0</span>].replace(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;student_name&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.writelines(lines)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="2942-·-阻止黑名单上的人"><a href="#2942-·-阻止黑名单上的人" class="headerlink" title="2942 · 阻止黑名单上的人"></a>2942 · 阻止黑名单上的人</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiscoverBlacklist</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selection</span>(<span class="params">blacklist: <span class="built_in">list</span>, customers: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="comment"># please write your code here</span></span><br><span class="line">    <span class="keyword">for</span> customer <span class="keyword">in</span> customers:</span><br><span class="line">        <span class="keyword">if</span> customer <span class="keyword">in</span> blacklist:</span><br><span class="line">            <span class="keyword">raise</span> DiscoverBlacklist(<span class="string">&#x27;Alert, %s is on the blacklist.&#x27;</span> % customer)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Welcome to the next visit&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2933-·-打印学生平均成绩（异常版）"><a href="#2933-·-打印学生平均成绩（异常版）" class="headerlink" title="2933 · 打印学生平均成绩（异常版）"></a>2933 · 打印学生平均成绩（异常版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please define the exception here</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeywordNotFound</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    my_message = <span class="string">&quot;Incomplete keywords&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(KeywordNotFound, self).__init__(self.my_message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotAllNumbers</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    my_message = <span class="string">&quot;It&#x27;s not all about numbers&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NotAllNumbers, self).__init__(self.my_message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_avg</span>(<span class="params">*args, **kwargs</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># Please write your code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;student_name&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs <span class="keyword">or</span> <span class="string">&#x27;student_age&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">raise</span> KeywordNotFound()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> NotAllNumbers()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name: &#123;&#125;, age: &#123;&#125;, avg: &#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(kwargs[<span class="string">&#x27;student_name&#x27;</span>], kwargs[<span class="string">&#x27;student_age&#x27;</span>], <span class="built_in">float</span>(<span class="built_in">sum</span>(args))/<span class="built_in">len</span>(args))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnPython</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode SQL教程 练习题答案</title>
    <url>/2022/01/06/lintcode-learn-sql/</url>
    <content><![CDATA[<p>SQL 教程链接：<a href="https://www.lintcode.com/learn">https://www.lintcode.com/learn</a>  </p>
<h1 id="LEVEL1"><a href="#LEVEL1" class="headerlink" title="LEVEL1:"></a>LEVEL1:</h1><ul>
<li><p>2045 · Output Hello LintCode</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;Hello LintCode!&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2013 · Check the name of the teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> `teachers`</span><br></pre></td></tr></table></figure>
</li>
<li><p>2007 · Check course name and class size</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,`student_count` <span class="keyword">FROM</span> courses</span><br></pre></td></tr></table></figure>
</li>
<li><p>2009 · Query all teachers</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `teachers`</span><br></pre></td></tr></table></figure>
</li>
<li><p>1981 · Check the nationality of all teachers</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> country <span class="keyword">FROM</span> teachers</span><br></pre></td></tr></table></figure>
</li>
<li><p>2011.Search for information on courses with more than 1000 participants</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `student_count`<span class="operator">&gt;</span><span class="number">1000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2012 · Find course information for the course named Artificial Intelligence</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> courses <span class="keyword">WHERE</span> `name`<span class="operator">=</span> <span class="string">&#x27;Artificial Intelligence&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2017 · Inserting SQL course information into the course table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> courses <span class="keyword">VALUES</span> (<span class="number">14</span>,&quot;SQL&quot;,<span class="number">200</span>,&quot;2021-02-25&quot;,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2021 · Insert teacher information into the specified column of the teachers table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teachers` (`name`,`email`,`age`,`country`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;XiaoFu&#x27;</span>,<span class="string">&#x27;XiaoFu@lintcode.com&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2020 · Update on the number of students choosing artificial intelligence</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `courses` <span class="keyword">SET</span> `student_count`<span class="operator">=</span><span class="number">500</span> <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;Artificial Intelligence&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2004 · Delete all courses until 2020</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `created_at`<span class="operator">&lt;</span><span class="string">&#x27;2020-1-1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2019 · Delete all rows in the table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `courses`</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL2："><a href="#LEVEL2：" class="headerlink" title="LEVEL2："></a>LEVEL2：</h1><ul>
<li><p>1952 · Query teachers over 20 years old</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `age`<span class="operator">&gt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1953 · Query the name of the Chinese teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1957 · Inquire about courses starting before May 2020</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,`created_at` <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `created_at`<span class="operator">&gt;=</span><span class="string">&#x27;2020-1-1&#x27;</span> <span class="keyword">AND</span> `created_at`<span class="operator">&lt;</span><span class="string">&#x27;2020-5-1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1958 · Query the courses that meet the conditions taught by the specified teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `teacher_id`<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> `student_count`<span class="operator">&gt;</span><span class="number">500</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2001 · Query the course information of ‘Web’ or ‘Big Data’</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses`<span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;Web&#x27;</span> <span class="keyword">OR</span> `name`<span class="operator">=</span><span class="string">&#x27;Big Data&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2040 · Search for courses with an instructor id of less than 3 and more than 800 students</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> (<span class="keyword">NOT</span> `teacher_id`<span class="operator">=</span><span class="number">3</span>) <span class="keyword">AND</span> (`student_count`<span class="operator">&gt;</span><span class="number">800</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1960 · Query course information for a specific time</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> created_at <span class="keyword">IN</span> (<span class="string">&#x27;2021-1-1&#x27;</span>,<span class="string">&#x27;2021-1-3&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1962 · Query courses with teacher id other than 1 and 3</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> courses <span class="keyword">WHERE</span> `teacher_id` <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1964 · Query for course information about the number of students within the specified range</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `student_count` <span class="keyword">BETWEEN</span> <span class="number">50</span> <span class="keyword">AND</span> <span class="number">55</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1972 · Inquire about Chinese and Japanese teachers who have e-mail addresses</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> (email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>) <span class="keyword">AND</span> (`country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">OR</span> `country`<span class="operator">=</span><span class="string">&#x27;JP&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1974 · Query teacher information by email</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,`email` <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `email` <span class="keyword">LIKE</span> <span class="string">&#x27;%@qq.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1982 · Check the age of teachers and sort them in ascending order</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> `age` <span class="keyword">FROM</span> `teachers` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1977 · Sorted by age of Chinese teachers in descending order</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1980 · Search for the oldest Chinese teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age` <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL3"><a href="#LEVEL3" class="headerlink" title="LEVEL3:"></a>LEVEL3:</h1><ul>
<li><p>2034 · Check the average age of teachers at the end of the specified mailbox</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(`age`) <span class="keyword">AS</span> `average_teacher_age` <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `email` <span class="keyword">LIKE</span>(<span class="string">&#x27;%@qq.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1987 · Find the age of the oldest Chinese teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(`age`) <span class="keyword">AS</span> <span class="string">&#x27;max_age&#x27;</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1989 · Check the age of the youngest teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(`age`) <span class="keyword">AS</span> min_age <span class="keyword">FROM</span> `teachers`</span><br></pre></td></tr></table></figure>
</li>
<li><p>1991 · Count the total number of students for teacher #3</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(`student_count`) <span class="keyword">AS</span> select_student_sum <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> `teacher_id`<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1995 · Check the average age of teachers over 20 years old</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(`age`)) <span class="keyword">AS</span> avg_teacher_age <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `age`<span class="operator">&gt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1997 · Check the information of teachers who do not have email and are older than 20 years old</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> ISNULL(`email`) <span class="keyword">AND</span> `age`<span class="operator">&gt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1985 · Number of teachers aged 20 to 28 who are Chinese and British nationals</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> teacher_count <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> `country` <span class="keyword">IN</span>(<span class="string">&#x27;CN&#x27;</span>,<span class="string">&#x27;UK&#x27;</span>) <span class="keyword">AND</span> `age` <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">28</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2081 · Insert the current date into the table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `records` <span class="keyword">VALUES</span> (CURDATE());</span><br></pre></td></tr></table></figure>
</li>
<li><p>2037 · Search for course titles and course dates through August 2020</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,<span class="type">DATE</span>(`created_at`) <span class="keyword">AS</span> `created_date` <span class="keyword">FROM</span> courses <span class="keyword">WHERE</span> `created_at`<span class="operator">&lt;</span><span class="string">&#x27;2020-8-1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2030 · Query the hours of all course creation times</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,<span class="built_in">EXTRACT</span>(<span class="keyword">HOUR</span> <span class="keyword">FROM</span> `created_at`) <span class="keyword">AS</span> `created_hour` <span class="keyword">FROM</span> `courses`</span><br></pre></td></tr></table></figure>
</li>
<li><p>2046 · The date the course was created is displayed in ‘year-month-day hour:minute:second’</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(`created_at`,<span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>) <span class="keyword">AS</span> `DATE_FORMAT` <span class="keyword">FROM</span> courses;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2028 · Postpone all course creation dates by one day</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,DATE_ADD(`created_at`,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> new_created <span class="keyword">FROM</span> `courses`</span><br></pre></td></tr></table></figure>
</li>
<li><p>2032 · Advance all course creation dates by one day</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `id`,`name`,DATE_SUB(`created_at`, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">FROM</span> `courses` <span class="keyword">DAY</span>) <span class="keyword">AS</span> `new_created`</span><br></pre></td></tr></table></figure>
</li>
<li><p>2029 · Calculate the number of days from 03&#x2F;26&#x2F;2019 to the course creation time</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(`created_at`,<span class="string">&#x27;2019-3-26&#x27;</span>) <span class="keyword">AS</span> date_diff <span class="keyword">FROM</span> `courses`</span><br></pre></td></tr></table></figure>
</li>
<li><p>2036 · Calculate the number of months difference between the start date and the current date of all courses in the schedule</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">MONTH</span>,`created_at`,<span class="string">&#x27;2020-4-22&#x27;</span>) <span class="keyword">AS</span> `MonthDiff` <span class="keyword">FROM</span> `courses`</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL4："><a href="#LEVEL4：" class="headerlink" title="LEVEL4："></a>LEVEL4：</h1><ul>
<li><p>2084 · Add primary key constraints to the course table courses</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `courses` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(`id`);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2085 · Remove the primary key constraint from the course table <code>courses</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `courses` <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2091 · Adding Foreign Key Constraints to Course Tables</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `courses` <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`teacher_id`) <span class="keyword">REFERENCES</span> teachers(`id`)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2062 · Query the id and name of all courses taught by the specified teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `c`.`id`,`c`.`name` <span class="keyword">AS</span> `course_name`, `t`.`name` <span class="keyword">AS</span> `teacher_name` <span class="keyword">FROM</span> `courses` `c` <span class="keyword">INNER</span> <span class="keyword">JOIN</span> `teachers` `t` <span class="keyword">ON</span> `c`.`teacher_id`<span class="operator">=</span>`t`.`id` <span class="keyword">WHERE</span> `t`.`name`<span class="operator">=</span><span class="string">&#x27;Eastern Heretic&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2051 · Search for the names of teachers from China and the names of courses they taught</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name <span class="keyword">AS</span> course_name, t.name <span class="keyword">AS</span> teacher_name <span class="keyword">FROM</span> teachers t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> t.id<span class="operator">=</span>c.teacher_id <span class="keyword">WHERE</span> `t`.`country`<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2053 · Check the name, email and course name of the teacher from China</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name <span class="keyword">AS</span> course_name,t.name <span class="keyword">AS</span> teacher_name,t.email <span class="keyword">AS</span> teacher_email <span class="keyword">FROM</span> courses c <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> teachers t <span class="keyword">ON</span> t.id<span class="operator">=</span>c.teacher_id <span class="keyword">WHERE</span> t.country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2055 · Search for all course names and their corresponding instructor names and nationalities</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name <span class="keyword">AS</span> course_name,t.name <span class="keyword">AS</span> teacher_name,t.country <span class="keyword">AS</span> teacher_country <span class="keyword">FROM</span> courses c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> teachers t <span class="keyword">on</span> c.teacher_id<span class="operator">=</span>t.idUNION</span><br><span class="line"><span class="keyword">SELECT</span> c.name <span class="keyword">AS</span> course_name,t.name <span class="keyword">AS</span> teacher_name,t.country <span class="keyword">AS</span> teacher_country <span class="keyword">FROM</span> courses c <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> teachers t <span class="keyword">on</span> c.teacher_id<span class="operator">=</span>t.id</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL-5"><a href="#LEVEL-5" class="headerlink" title="LEVEL 5:"></a>LEVEL 5:</h1><ul>
<li><p>2078 · Find out the number of teachers of different ages</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `age`,<span class="built_in">COUNT</span>(`age`) <span class="keyword">AS</span> age_count <span class="keyword">FROM</span> `teachers` <span class="keyword">GROUP</span> <span class="keyword">BY</span> `age` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age` <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2082 · Statistics on the number of courses taught by each teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.name <span class="keyword">AS</span> teacher_name,IFNULL(<span class="built_in">COUNT</span>(c.id),<span class="number">0</span>) <span class="keyword">AS</span> course_count <span class="keyword">FROM</span> teachers t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> t.id<span class="operator">=</span>c.teacher_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name <span class="keyword">ORDER</span> <span class="keyword">BY</span> course_count <span class="keyword">DESC</span>, t.name</span><br></pre></td></tr></table></figure>
</li>
<li><p>2076 · Search for information on teachers of the same nationality whose average age is greater than the average age of all teachers</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> country<span class="operator">=</span><span class="keyword">any</span>(<span class="keyword">SELECT</span> country <span class="keyword">FROM</span> teachers <span class="keyword">GROUP</span> <span class="keyword">BY</span> `country` <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(age)<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> teachers));</span><br></pre></td></tr></table></figure>
</li>
<li><p>2060 · Search for the name of the teacher for the ‘Big Data’ course</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> id<span class="operator">=</span>(<span class="keyword">SELECT</span> teacher_id <span class="keyword">FROM</span> courses <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Big Data&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2056 · Copy the data in the teachers table that are older than 20 to another table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teachers_bkp` <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2057 · Modify course information created by instructor Eastern Heretic</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `courses` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;PHP&#x27;</span>,student_count<span class="operator">=</span><span class="number">300</span> <span class="keyword">WHERE</span> teacher_id<span class="operator">=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Eastern Heretic&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2059 · Remove faculty who have created courses before 2020</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> teacher_id <span class="keyword">FROM</span> courses <span class="keyword">WHERE</span> created_at<span class="operator">&lt;</span><span class="string">&#x27;2020-1-1&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2077 · Search for information on courses and instructors with the highest number of students</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_name,student_count,teacher_name <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> `c`.`name` `course_name`, c.student_count <span class="keyword">AS</span> `student_count`,`t`.`name` <span class="keyword">AS</span> `teacher_name`</span><br><span class="line"><span class="keyword">FROM</span> `teachers` `t` ASLEFT <span class="keyword">JOIN</span> `courses` `c` <span class="keyword">ON</span> `c`.`teacher_id` <span class="operator">=</span> `t`.`id`) `T` <span class="keyword">WHERE</span> student_count<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(student_count) <span class="keyword">FROM</span> `courses`)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2065 · Check the course names of all courses taught by all teachers who are older than 20 years old</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> teacher_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2070 · Search for the name of a course created later than the creation time of any of the specified teacher’s courses</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> (`created_at`<span class="operator">&gt;</span><span class="keyword">ANY</span>(<span class="keyword">SELECT</span> `created_at` <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> teacher_id<span class="operator">=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Southern Emperor&#x27;</span>))) <span class="keyword">AND</span> teacher_id <span class="operator">&lt;&gt;</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> teachers <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Southern Emperor&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2066 · Search for course information for courses with more students than the number of students in all courses of the oldest teacher</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> student_count<span class="operator">&gt;</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> student_count <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> teacher_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> `teachers` <span class="keyword">WHERE</span> age<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> teachers)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>2069 · Search for the course name and number of students in the course with the highest number of students per instructor</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,student_count <span class="keyword">FROM</span> `courses` <span class="keyword">WHERE</span> (teacher_id,student_count) <span class="keyword">IN</span>(<span class="keyword">SELECT</span> teacher_id,<span class="built_in">MAX</span>(student_count) <span class="keyword">FROM</span> `courses` <span class="keyword">GROUP</span> <span class="keyword">BY</span> teacher_id)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2086 · Search for the nationality of the teacher starting with ‘U’ and the total number of students between 2000 and 5000 and the total number of students of that nationality</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.country <span class="keyword">AS</span> country,<span class="built_in">SUM</span>(c.student_count) <span class="keyword">AS</span> student_count <span class="keyword">FROM</span> teachers t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> t.id<span class="operator">=</span>c.teacher_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> country <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(student_count) <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">5000</span> <span class="keyword">AND</span> country <span class="keyword">LIKE</span> <span class="string">&#x27;U%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL6："><a href="#LEVEL6：" class="headerlink" title="LEVEL6："></a>LEVEL6：</h1><ul>
<li>2616 · Insert Kansas information into the teacher table  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 Kansas 的信息 --</span></span><br><span class="line"><span class="comment">-- Write your SQL Query here --</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teachers` (`name`, `age`, `country`)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Kansas&#x27;</span>, <span class="number">41</span>, <span class="string">&#x27;UK&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="LEVEL7："><a href="#LEVEL7：" class="headerlink" title="LEVEL7："></a>LEVEL7：</h1>]]></content>
      <categories>
        <category>LearnSQL</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>龙潭水乡半日游</title>
    <url>/2020/06/07/long-tan-shui-xiang-half-a-day-trip/</url>
    <content><![CDATA[<p>今天看了天气，不是很热，和女朋友计划去龙潭水乡玩一玩。  </p>
<p>坐车大概花了一个半小时，因为是快速公交，时间上节约了大概半小时。  </p>
<p>到达指定地点后，哇，人很少，很有江南水乡的气息，和小学语文课本上见到的一样呢。  </p>
<p>到处都是桥，路面凹凸不平，水面上的荷花很好看，景区内也有穿着汉服拍照的小哥哥小姐姐。  </p>
<p>我和她选择了一些人比较少的地方取景，摆姿势，不得不说，自己私底下看了看讲拍摄的文章，还是很有用，女朋友夸我拍照技术也进步了，哈哈。(可想而知以前在拍照上打击的有多惨～～～)  </p>
<p>溜达了一圈，不知是不是疫情的缘故，这里好多商家都只有店名，但房子内都已搬空，慢悠悠的走在街道上，迎面吹来的微风，看着波澜不惊的水面，心也归于平静，暂时忘却工作上的烦恼。  </p>
<p>晚上回家，买了两斤小龙虾和自制的鸡腿抓饭当做晚饭，感谢又度过了一个轻松愉快的周末。  </p>
<p><img src="/2020/06/07/long-tan-shui-xiang-half-a-day-trip/ltsx.jpg">  </p>
]]></content>
      <categories>
        <category>Travel-notes</category>
      </categories>
      <tags>
        <tag>龙潭水乡</tag>
        <tag>旅游</tag>
        <tag>散步</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用gcc调试c语言程序</title>
    <url>/2020/05/03/linux-gcc-debug-c-program/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>看到一些用<code>C语言</code>写的数据结构的程序，很不错，想用<code>gcc</code>调试一下程序，增进记忆，本文记录学习和使用<code>gcc</code>调试<code>C程序</code>的过程。  </p>
<h2 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h2><h3 id="1，生成可调试程序test"><a href="#1，生成可调试程序test" class="headerlink" title="1，生成可调试程序test"></a>1，生成可调试程序test</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test -g BinarySortTree.c</span><br></pre></td></tr></table></figure>

<h3 id="2，gdb开始调试"><a href="#2，gdb开始调试" class="headerlink" title="2，gdb开始调试"></a>2，gdb开始调试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure>

<h3 id="3，设置断点"><a href="#3，设置断点" class="headerlink" title="3，设置断点"></a>3，设置断点</h3><p>这里可以设置行数，或者函数名  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break 118</span><br></pre></td></tr></table></figure>

<h3 id="4，运行程序"><a href="#4，运行程序" class="headerlink" title="4，运行程序"></a>4，运行程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>

<h3 id="5，调试"><a href="#5，调试" class="headerlink" title="5，调试"></a>5，调试</h3><ul>
<li>n，一行一行的执行  </li>
<li>c，continue-执行到下一个断点处  </li>
<li>print,打印出变量信息</li>
</ul>
<h3 id="6，退出调试"><a href="#6，退出调试" class="headerlink" title="6，退出调试"></a>6，退出调试</h3><p>quit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在<code>gdb</code>中如果遇到困惑，可以输入<code>help</code>获取相关帮助信息  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单记录了使用<code>gdb</code>的常用命令，个人比较喜欢这种用命令行的方式去调试程序，当然也可以去<code>VSCode</code>等软件去做。</p>
]]></content>
      <categories>
        <category>Learn-C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Debug</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>低调成长</title>
    <url>/2019/01/17/low-growth/</url>
    <content><![CDATA[<h2 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a>意外惊喜</h2><p>这段时间有两个意外发生在我的身上  </p>
<h3 id="头条邀请"><a href="#头条邀请" class="headerlink" title="头条邀请"></a>头条邀请</h3><p>下午打开Gmail邮箱，意外发现了除了Medium的推送外，还夹带着一封头条后端开发岗的邀请…<br><img src="/2019/01/17/low-growth/%E5%A4%B4%E6%9D%A1%E9%9D%A2%E8%AF%95.png">  </p>
<h3 id="写书邀请"><a href="#写书邀请" class="headerlink" title="写书邀请"></a>写书邀请</h3><p>除了面试邀请，还在前段时间在博客园上收到了一家北京出版社编辑发的写开发实战书籍的邀请。<br>（写书曾经想过写，但不是现在写，因为技术还没有积淀下来，写了也是浪费精力和纸张）  </p>
<h2 id="低调成长"><a href="#低调成长" class="headerlink" title="低调成长"></a>低调成长</h2><p>想起两年前我大二，对于这样的邀请我是可望而不可即的，因为技术太渣，校招时四轮笔试做了一塌糊涂。<br>但是，当现在机会摆在我的面前时，我不禁想问下自己，现在接受真的合适吗？<br>最好的目前并不一定适合自己。<br>现在的还处于学习上升期阶段，除了在部门内负责流媒体服务外，还要学习网络，数据库和算法相关知识，需要巩固C&#x2F;C++和Go语言编程；不断的接受一些有挑战性的任务，在踩坑和写Bug中茁壮成长。<br>我一直相信，只要自己坚持做一件认为对的事情，培养成一个习惯（例如写日记，早起晨练，学习），那么这就是个如蛹化蝶的过程，最终将会振翅飞翔。<br><img src="/2019/01/17/low-growth/%E8%8A%B1%E6%B5%B7.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装 MQTT</title>
    <url>/2023/10/10/mac-install-mqtt/</url>
    <content><![CDATA[<h1 id="安装MQTT服务器"><a href="#安装MQTT服务器" class="headerlink" title="安装MQTT服务器"></a>安装MQTT服务器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Mosquitto MQTT 服务器</span></span><br><span class="line">brew install mosquitto</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Mosquitto 服务器</span></span><br><span class="line">brew services start mosquitto</span><br><span class="line">==&gt; Successfully started `mosquitto` (label: homebrew.mxcl.mosquitto)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证 Mosquitto 服务器是否正在运行</span></span><br><span class="line">brew services list</span><br><span class="line">Name      Status  User     File</span><br><span class="line">mosquitto started  *        *</span><br></pre></td></tr></table></figure>

<h1 id="安装MQTT客户端"><a href="#安装MQTT客户端" class="headerlink" title="安装MQTT客户端"></a>安装MQTT客户端</h1><p>访问<a href="https://github.com/emqx/MQTTX">github-MQTTX</a>，找到<code>MQTTX-1.9.6-arm64.pkg</code>下载安装即可。  </p>
<p>然后就可以看到有个<code>MQTTX</code>的图标，表示<code>MQTT</code>客户端安装成功。  </p>
<p><img src="/2023/10/10/mac-install-mqtt/mqttx.jpg">  </p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>启动<code>MQTTX</code>  </p>
<p>输入带*号的信息，点击连接，然后订阅对应的topic，就可以收到该topic收到的信息了。  </p>
]]></content>
      <categories>
        <category>LearnMQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装 Kubernetes</title>
    <url>/2023/07/20/mac-install-kubernetes/</url>
    <content><![CDATA[<h1 id="首先安装Docker-for-Mac"><a href="#首先安装Docker-for-Mac" class="headerlink" title="首先安装Docker for Mac"></a>首先安装Docker for Mac</h1><h1 id="Enable-Kubernetes"><a href="#Enable-Kubernetes" class="headerlink" title="Enable Kubernetes"></a>Enable Kubernetes</h1><p>设置里打开Kubernetes，下载会持续一段时间：<br><img src="/2023/07/20/mac-install-kubernetes/enable-k8s.png">  </p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~  kubectl get nodes</span><br><span class="line">NAME             STATUS   ROLES           AGE   VERSION</span><br><span class="line">docker-desktop   Ready    control-plane   46h   v1.27.2</span><br><span class="line"></span><br><span class="line">~  kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   46h</span><br><span class="line">kube-node-lease   Active   46h</span><br><span class="line">kube-public       Active   46h</span><br><span class="line">kube-system       Active   46h</span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/65559363">在MAC上安装K8S (kubernets) for Docker Desktop</a></li>
</ul>
]]></content>
      <categories>
        <category>MacNote</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装 Docker</title>
    <url>/2023/07/20/mac-install-docker/</url>
    <content><![CDATA[<h1 id="安装-Docker-for-Mac"><a href="#安装-Docker-for-Mac" class="headerlink" title="安装 Docker for Mac"></a>安装 Docker for Mac</h1><p>访问<a href="https://docs.docker.com/desktop/install/mac-install/">https://docs.docker.com/desktop/install/mac-install/</a></p>
<p>下载.dmg文件后，拖拽到应用文件夹里即可。</p>
<h1 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h1><p>命令行输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~  docker version</span><br><span class="line">Client:</span><br><span class="line">Cloud integration: v1.0.35</span><br><span class="line">Version:           24.0.2</span><br><span class="line">API version:       1.43</span><br><span class="line">Go version:        go1.20.4</span><br><span class="line">Git commit:        cb74dfc</span><br><span class="line">Built:             Thu May 25 21:51:16 2023</span><br><span class="line">OS/Arch:           darwin/arm64</span><br><span class="line">Context:           desktop-linux</span><br><span class="line"></span><br><span class="line">Server: Docker Desktop 4.21.1 (114176)</span><br><span class="line">Engine:</span><br><span class="line">Version:          24.0.2</span><br><span class="line">API version:      1.43 (minimum version 1.12)</span><br><span class="line">Go version:       go1.20.4</span><br><span class="line">Git commit:       659604f</span><br><span class="line">Built:            Thu May 25 21:50:59 2023</span><br><span class="line">OS/Arch:          linux/arm64</span><br><span class="line">Experimental:     false</span><br><span class="line">containerd:</span><br><span class="line">Version:          1.6.21</span><br><span class="line">GitCommit:        3dce8eb055cbb6872793272b4f20ed16117344f8</span><br><span class="line">runc:</span><br><span class="line">Version:          1.1.7</span><br><span class="line">GitCommit:        v1.1.7-0-g860f061</span><br><span class="line">docker-init:</span><br><span class="line">Version:          0.19.0</span><br><span class="line">GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://zhuanlan.zhihu.com/p/91116621">Mac下安装docker的三种方法</a></p>
]]></content>
      <categories>
        <category>MacNote</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装 MySQL</title>
    <url>/2023/07/20/mac-install-mysql/</url>
    <content><![CDATA[<h1 id="brew命令安装"><a href="#brew命令安装" class="headerlink" title="brew命令安装"></a>brew命令安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install mysql</span><br><span class="line">mysql --version</span><br></pre></td></tr></table></figure>


<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="The-server-quit-without-updating-PID-file-x2F-opt-x2F-homebrew-x2F-var-x2F-mysql-x2F-neozhangdeMacBook-Pro-local-pid"><a href="#The-server-quit-without-updating-PID-file-x2F-opt-x2F-homebrew-x2F-var-x2F-mysql-x2F-neozhangdeMacBook-Pro-local-pid" class="headerlink" title="The server quit without updating PID file (&#x2F;opt&#x2F;homebrew&#x2F;var&#x2F;mysql&#x2F;neozhangdeMacBook-Pro.local.pid)"></a>The server quit without updating PID file (&#x2F;opt&#x2F;homebrew&#x2F;var&#x2F;mysql&#x2F;neozhangdeMacBook-Pro.local.pid)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql.server start</span><br><span class="line">Password:</span><br><span class="line">Starting MySQL</span><br><span class="line">.Logging to &#x27;/opt/homebrew/var/mysql/neozhangdeMacBook-Pro.local.err&#x27;.</span><br><span class="line">ERROR! The server quit without updating PID file (/opt/homebrew/var/mysql/neozhangdeMacBook-Pro.local.pid).</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown -R mysql /opt/homebrew/var/mysql</span><br><span class="line">sudo mysql.server restart</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MacNote</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装NiFi</title>
    <url>/2024/01/12/mac-install-nifi/</url>
    <content><![CDATA[<h1 id="安装NiFi"><a href="#安装NiFi" class="headerlink" title="安装NiFi"></a>安装NiFi</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install nifi</span><br></pre></td></tr></table></figure>

<h1 id="启动NiFi"><a href="#启动NiFi" class="headerlink" title="启动NiFi"></a>启动NiFi</h1><h2 id="第一次登录"><a href="#第一次登录" class="headerlink" title="第一次登录"></a>第一次登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nifi start</span><br></pre></td></tr></table></figure>

<p>在<code>/opt/homebrew/Cellar/nifi/1.24.0/libexec/logs</code>下执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -exec grep -H &quot;Generated&quot; &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">./nifi-app_2024-01-11_17.0.log:Generated Username [xxx]</span><br><span class="line">./nifi-app_2024-01-11_17.0.log:Generated Password [xxx]</span><br></pre></td></tr></table></figure>

<p>找到生成的用户名和密码。  </p>
<p>浏览器访问<code>https://localhost:8443/nifi</code>  </p>
<p>输入<code>user</code>和<code>password</code>，点击<code>LOG IN</code>  </p>
<p><img src="/2024/01/12/mac-install-nifi/nifi-login.png">  </p>
<h2 id="自定义NiFi用户名密码"><a href="#自定义NiFi用户名密码" class="headerlink" title="自定义NiFi用户名密码"></a>自定义NiFi用户名密码</h2><p>因为系统生成的用户名和密码比较难记，因此我们可以自定义用户名和密码  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止NiFi</span></span><br><span class="line">nifi stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户名密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码长度必须在12位以上</span></span><br><span class="line">nifi set-single-user-credentials nifi nifi12345678</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动NiFi</span></span><br><span class="line">nifi start</span><br><span class="line"></span><br><span class="line">nifi run</span><br></pre></td></tr></table></figure>

<p>这样后面启动<code>NiFi</code>后，就可以使用自定义的用户名和密码登录了。  </p>
]]></content>
      <categories>
        <category>LearnNiFi</category>
      </categories>
      <tags>
        <tag>NiFi</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装 Redis</title>
    <url>/2023/07/20/mac-install-redis/</url>
    <content><![CDATA[<h1 id="brew安装"><a href="#brew安装" class="headerlink" title="brew安装"></a>brew安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>


<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Could-not-connect-to-Redis-at-127-0-0-1-6379-Connection-refused"><a href="#Could-not-connect-to-Redis-at-127-0-0-1-6379-Connection-refused" class="headerlink" title="Could not connect to Redis at 127.0.0.1:6379: Connection refused"></a>Could not connect to Redis at 127.0.0.1:6379: Connection refused</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused not connected&gt;</span><br></pre></td></tr></table></figure>

<p>原因：启动redis-server后，使用control+c退出了redis，此时使用redis-cli命令连接redis，就会被拒绝。</p>
<p>如何解决？</p>
<ul>
<li>开两个命令行，一个用于启动redis-server，另一个用于连接redis</li>
<li>redis-server后台运行，随开机自启</li>
</ul>
]]></content>
      <categories>
        <category>MacNote</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>雪中回忆</title>
    <url>/2016/11/22/memories-in-the-snow/</url>
    <content><![CDATA[<p>今天凌晨一不小心又熬夜了，插上耳机听着BBC，睡了五个小时后自然醒来，看到宿舍窗外一阵白色的反光，我想，难道冬天的第一场雪就这么来了？  </p>
<p>是的，我没有猜错，今年冬天的第一场雪就这样悄悄地来了。这意味着我又要把衣服加厚，去上学的路上又要注意脚下的积雪…  </p>
<p>突然想起，曾经上大学前，下雪的厚度都能盖过膝盖。每次下雪，心中的童心就会被无限放大。男生女生在操场上打雪仗，我会在不经意间把一个同学撂倒，然后摁在地上，让其他同学围上来把他活埋，如果觉得还不过瘾，可以搭建一个小雪山，然后把某个幸运儿扔进去，看着他在雪山里快乐地翻滚；又或者捧起一大块雪，拧成一个团，带回教室做成房子，然后看着它慢慢地融化；看书看累了，刷理科题刷烦了，我会约上一两个朋友在雪地里打一架，当然点到为止，至今记得是一胜一负一平的战绩。我想，那时候应该是我冬天最快乐的时光吧。  </p>
<p>新疆的冬天，一般是10点钟天亮，我记得那时候我早晨8点半就得到学校。有一次我独自一人在操场上散步，周围静得吓人，我尝试坐在雪地里，闭上眼睛，倾听周围的声音。刚开始我很害怕，害怕背后突然有人给我一棍子，然后把我拐走，有几次很想睁开眼睛看看周围的情况，结果都被我克制住了。过了段时间，我听到了一百米外居民楼上炒菜的声音；我听到了有人关上防盗门走下楼梯的声音；最后，我听到了自己的心跳声。  </p>
<p>是的，我听到了自己的心跳声，让我知道我还是个人，而不是机器。在那段浸泡在缺氧的书堆中的日子，我曾把自己想象成一台机器，一台天天只知道听课，刷题，中午去吃“机油”的机器。我放弃了我的乒乓球，我的编程，放弃了我喜欢的人，只为全身心去参加那个遥不可及，却无比重要的考试。是的，老师说了：只要过了那场考试，你们就自由了！  </p>
<p>是吗？我不知道。我只知道我现在依旧没有自由，我要面临着课程设计，面临着就业的压力，当然还有同行的竞争。  </p>
<p>下雪了，我忍不住伸手托起一片雪花，静静地看着它从我的手心上融化，透心的冰凉，转瞬被体温掩盖。回忆，终究是要埋藏在记忆深处，在适当的时间跑出来回味，至少证明，我曾经拥有过。  </p>
<p>现在在大学里的我过得很好，尝试了许多以前一直想做，却不敢做的事情。日子平平淡淡，如水房的自来水般细水长流，没有学生会的头衔，没有社团的标签，却知道每天自己该做什么。  </p>
<p>现在的我过得也很幸福。黑夜中，我不再害怕一个人独处，校园里的夜景，我愿带着她一一走过。  </p>
<p>也许，这就是我目前最简单，最平凡，也是对我来说最满足的生活吧。我如一台老式计算机，在机器上运行着C程序，编译速度虽然慢了一点，却从没有停止过运转。  </p>
<p>雪停了，冬天来了。就让这份记忆像ROM存储器一样永远存放在回忆中。  </p>
<p>只有放下思想的包袱，才能身轻如燕地去追逐梦想。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>快乐</tag>
        <tag>回忆</tag>
        <tag>下雪</tag>
      </tags>
  </entry>
  <entry>
    <title>最怕常年不联系的朋友突然的关心</title>
    <url>/2020/02/22/most-afraid-of-strange-friends-studdenly-care/</url>
    <content><![CDATA[<p>最近有件事让我既喜又悲，那就是常年不联系的朋友，对我突然的关心。  </p>
<h2 id="大学好友lss"><a href="#大学好友lss" class="headerlink" title="大学好友lss"></a>大学好友lss</h2><p>过年没事看到lss的朋友圈，说他在乌鲁木齐的公司晋升了高级主管，我很开心，于是找他闲聊了几句。  </p>
<p>然后就问我“兄弟，办信用卡不”，我说不办，立马用哈哈缓解尴尬的气氛，还不死心的说一句“帮我问问身边的呗，有需要可以联系我”。  </p>
<p>我回了句好吧之后，立马结束了聊天。  </p>
<h2 id="高中同学djx"><a href="#高中同学djx" class="headerlink" title="高中同学djx"></a>高中同学djx</h2><p>高一是一个班的同学，文静，好学，前些天突然QQ联系我做过小游戏没，要给客户群活跃气氛用，我就帮她想办法，然后加上微信后开始步入正题“微信上绑工行卡没”，一句话放佛让我懂了她主动联系我的真实目的。  </p>
<p>我立马拒绝绑卡，我觉得没必要，她仍然坚持说帮个忙嘛，我没理，就这样在尬聊中结束了。  </p>
<h2 id="办卡的目的"><a href="#办卡的目的" class="headerlink" title="办卡的目的"></a>办卡的目的</h2><p>随后我咨询了在四大会计师事务所之一工作的朋友，为什么会有这么多办卡的？她解释道：办信用卡就和花呗的原理一样，只不过逾期了要给银行交利息，至于为什么有办卡的，估计是银行员工有指标要拉人。  </p>
<h2 id="铁心"><a href="#铁心" class="headerlink" title="铁心"></a>铁心</h2><p>还是应了那句话：最怕常年不联系的人突然的关心。  </p>
<p>记得上大学那会，一到寒暑假宿舍群安静的要命，突然一位舍友问我一句“在吗”，我猜测应该是找我有事，或者借钱，于是故意等过了八个小时后才回复他，最后也印证了我的猜想。  </p>
<p>也记得在大三暑假那会，我在北京去找中农的好友玩，在一家商场碰到一位美女在推销英语课程，说是帮个忙嘛，她只是为了完成指标，我心一软就答应了，写下自己的联系方式，结果从那天开始到此后的一年时间内，总是接到来自上海、北京、杭州的推销电话，我真是感到无语。  </p>
<p>因此，以后再遇到这种类似的情况，不管当年交情有多么的深厚，不好意思，从此我们是陌路。  </p>
<p>我有时也在问自己，这样是不是太铁石心肠了？——是吗，也许吧。但没办法，社会就是这个样子，你要为了完成指标而四处充当销售，用当年的友情去变现自己的业绩，但我也是有自己的底线，不容逾越！  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>朋友</tag>
        <tag>利益</tag>
      </tags>
  </entry>
  <entry>
    <title>6 小时掌握 Docker 与 K8s 架构核心</title>
    <url>/2021/10/19/master-core-docker-and-k8s-architecture-in-six-hours/</url>
    <content><![CDATA[<h1 id="Docker-核心技术"><a href="#Docker-核心技术" class="headerlink" title="Docker 核心技术"></a>Docker 核心技术</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>基于 Linux 内核的 Cgroup，Namespace，以及Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。  </p>
</li>
<li><p>最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从1.11 开始，则进一步演进为使用 runC 和 Containerd。  </p>
</li>
<li><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得Docker 技术比虚拟机技术更为轻便、快捷。</p>
</li>
</ul>
<h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更高效的利用系统资源</span><br><span class="line">更快速的启动时间</span><br><span class="line">一致的运行环境</span><br><span class="line">持续交付和部署</span><br><span class="line">更轻松的迁移</span><br><span class="line">更轻松的维护和扩展</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h2><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动：</span><br><span class="line">• docker run</span><br><span class="line">-it 交互</span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 磁盘挂载</span><br><span class="line">• 启动已终止容器</span><br><span class="line">docker start</span><br><span class="line">• 停止容器</span><br><span class="line">docker stop</span><br><span class="line">• 查看容器进程</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">• 查看容器细节：</span><br><span class="line">docker inspect &lt;containerid&gt; • 进入容器:</span><br><span class="line">docker attach</span><br><span class="line">docker exec</span><br><span class="line">• 通过 nsenter：</span><br><span class="line">PID=$(docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br><span class="line">$ nsenter --target $PID --mount --uts --ipc --net --pid</span><br><span class="line">• 拷贝文件至容器内：</span><br><span class="line">docker cp file1 &lt;containerid&gt;:/file-to-path</span><br></pre></td></tr></table></figure>

<h2 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h2><ul>
<li>cat Dockerfile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV MY_SERVICE_PORT=80</span><br><span class="line">ADD bin/amd64/httpserver /httpserver</span><br><span class="line">ENTRYPOINT /httpserver</span><br></pre></td></tr></table></figure>

<ul>
<li>将Dockerfile打包成镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t cncamp/httpserver:$&#123;tag&#125; .</span><br><span class="line">docker push cncamp/httpserver:v1.0S</span><br></pre></td></tr></table></figure>

<ul>
<li>运行容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d cncamp/httpserver:v1.0</span><br></pre></td></tr></table></figure>

<h2 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h2><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><ul>
<li>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：  </li>
<li>系统可以为进程分配不同的 Namespace；  </li>
<li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰 。</li>
</ul>
<h2 id="Docker优势"><a href="#Docker优势" class="headerlink" title="Docker优势"></a>Docker优势</h2><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><ul>
<li>不需要再启动内核，所以应用扩缩容时可以秒速启动。  </li>
<li>资源利用率高，直接使用宿主机内核调度资源，性能损失小。  </li>
<li>方便的 CPU、内存资源调整。  </li>
<li>能实现秒级快速回滚。  </li>
<li>一键启动所有依赖服务，测试不用为搭建环境犯愁，PE 也不用为建站复杂担心。  </li>
<li>镜像一次编译，随处使用。  </li>
<li>测试、生产环境高度一致（数据除外）。</li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul>
<li>应用的运行环境和宿主机环境无关，完全由镜像控制，一台物理机上部署多种环境的镜像测试。  </li>
<li>多个应用版本可以并存在机器上。</li>
</ul>
<h3 id="镜像增量分发"><a href="#镜像增量分发" class="headerlink" title="镜像增量分发"></a>镜像增量分发</h3><p>由于采用了 Union FS， 简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种 layer 的概念，每次发布只传输变化的部分，节约带宽。  </p>
<h3 id="社区活跃："><a href="#社区活跃：" class="headerlink" title="社区活跃："></a>社区活跃：</h3><p>Docker 命令简单、易用，社区十分活跃，且周边组件丰富。  </p>
<h1 id="Kubernetes-架构原则和对象设计"><a href="#Kubernetes-架构原则和对象设计" class="headerlink" title="Kubernetes 架构原则和对象设计"></a>Kubernetes 架构原则和对象设计</h1><h2 id="核心技术概念和-API-对象"><a href="#核心技术概念和-API-对象" class="headerlink" title="核心技术概念和 API 对象"></a>核心技术概念和 API 对象</h2>]]></content>
      <categories>
        <category>Learn-Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>我的编程竞赛生涯</title>
    <url>/2018/07/07/my-career-in-coding-competition/</url>
    <content><![CDATA[<h2 id="初识编程"><a href="#初识编程" class="headerlink" title="初识编程"></a>初识编程</h2><p>记得第一次接触编程是上高一的时候，那时的我懵懂无知，但对周围充满着好奇，尤其是科技。当时学校的机器人兴趣小组招人，我稀里糊涂的就进去玩。当时我以为是焊板子连线路，谁知道刚一进教室就让我们开始学习C语言，用Turbo C写程序。当时白天上课，中午在实验室内做俯卧撑（因为一道题做错要做一百个俯卧撑，所以当时我中午基本都是在做俯卧撑度过的），晚上写作业兼用纸写程序。  </p>
<p>我想就是从那时起我才明白，原来电脑不光是可以用来打游戏、做网页和打字，还可以玩更深层的东西，所以考大学选专业的时候毅然选择了计算机科学与技术专业。  </p>
<h2 id="结识牛人"><a href="#结识牛人" class="headerlink" title="结识牛人"></a>结识牛人</h2><p>刚入大学的时候，碰到了一位胖胖的湖南朋友，他所理解的编程比我的要更深，后来才知道原来他从初中就开始写程序，高中时斩获全国信息学奥赛一等奖。他是我编程路上的第一位引路人。  </p>
<h2 id="多次遭遇挫折"><a href="#多次遭遇挫折" class="headerlink" title="多次遭遇挫折"></a>多次遭遇挫折</h2><p>第一次挫折是在和他（指湖南朋友）的对话上，总是觉得年龄差不多，但差距太大。记得当时他手中经常翻阅的两本书，一本叫《C++ primer》，一本是刘汝佳的《算法艺术与信息学竞赛》，为此我还专门借过来看。  </p>
<p>大二时准备编程竞赛，第一次觉得自己智商被碾压，许多题目解题思路理解，但就是写不出，写出来后也有数不清的bug，当时给我的打击特别大。有时候甚至开始怀疑起人生，学编程有什么用？学算法有什么用？学计算机专业又有什么用？  </p>
<h2 id="打开通向外面的窗户"><a href="#打开通向外面的窗户" class="headerlink" title="打开通向外面的窗户"></a>打开通向外面的窗户</h2><p>不知从什么时候开始，我开始将“孰能生巧，勤能补拙，念念不忘，必有回响”这句话当做我的座右铭，激励着我不断前进，不断成长。  </p>
<p>从一天恍恍惚惚吃饭睡觉中荒废过去过渡到在实验室刷OJ找题解看书总结到博客里；从闭门造车的困境到不断与各大学校的高手请教；从开始以学校内排名靠前为目标到超越学校所有人为起点；我在逐渐思考的过程中完成着一次又一次的蜕变。  </p>
<h2 id="去北京参赛的收获"><a href="#去北京参赛的收获" class="headerlink" title="去北京参赛的收获"></a>去北京参赛的收获</h2><p>去北京参加决赛带给我最大的收获就是，人外有人，天外有天。  </p>
<p>你可以看到一小时写完提前交卷走人的；也可以看到赛前就已经准备了自己写好的模板的选手；也因此结识了一位在北邮读研的朋友。和他们的沟通，我收获了更好更新的学习方法，也拓宽了我的眼界，为以后做足了更完善的规划。  </p>
<h2 id="靠自己"><a href="#靠自己" class="headerlink" title="靠自己"></a>靠自己</h2><p>以前我总想着要是有XX大神在我身边就好了，有XX大佬一直带着我就更棒了。殊不知这就像爬山虎，爬的越高，对墙的依赖也就越高，结果发现，离开了墙，我什么也不是。  </p>
<p>不要把大神想的那么高不可攀，也不要把自己想的这么愚不可及，做一个简单的人，平和而执着，谦虚而无畏。  </p>
<h2 id="思维的转变，注重健康"><a href="#思维的转变，注重健康" class="headerlink" title="思维的转变，注重健康"></a>思维的转变，注重健康</h2><p>不管再怎样钻研技术，记得一定要注意身体，身体是革命的本钱。  </p>
<p>这句烂掉牙的话，曾经的我对此不屑一顾，现在却明白，不能用健康去换成长，不然到最后就没有命去享受。  </p>
<p>犹记得大二时在辅导员自习室呆到凌晨四点，写程序查资料经常搞到凌晨三点，结果第二天醒来上火长痘痘，每天都很难受，现在的我就算比别人慢点，也要有保质保量的睡眠。  </p>
<h2 id="与世界同步"><a href="#与世界同步" class="headerlink" title="与世界同步"></a>与世界同步</h2><p>大学毕业后，我拿到了一家公司研发岗的offer，入职第三周，在部门内有位大佬说的话我记忆尤新，他说“模仿一个写出来你也不会懂原理是什么，自己搞清楚原理，即使学的不那么好也比抄的能学到更多”。  </p>
<p>我想，虽然我的大学四年已经结束，但我的编程生涯在历经了四年的重重洗礼，踩过的坑，走过的路，现在也依旧会继续持续稳定的走下去，只是会比以前走的更加迅速，更加快乐。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>编程</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>我的数学建模竞赛生涯</title>
    <url>/2017/09/17/my-career-in-math-modeling-competition/</url>
    <content><![CDATA[<p>2017年9月17日14点20分，我写下了这段话，同时距离2017年全国大学生数学建模竞赛截止还剩不到十个小时的时间。这次建模的结束，也将标志着我本科阶段的建模生涯画上了句号。  </p>
<p>记得第一次参加建模时，与全国各地的大学生在同一时间开始竞赛，心中充满着激动与紧张。  </p>
<p>每年建模竞赛时期，总会涌现出许多个建模赛题讨论群，刚开始大家会相互询问解题的思路，源程序解析，中间也有参杂着有偿贩卖建模数据或赛题思路的“小商人”。最后要在服务器上提交论文的时候，服务器总会不堪重压的奔溃掉，这仿佛成了历年比赛的固定套路。  </p>
<p>“建模从选题到换题，从换题到瞎编，从瞎编到提交”，这应该是每年搞建模最喜欢自嘲的一段话。是的，从前年B题的滴滴打车，到去年A题的船舶停靠系统，再到今年B题的拍照赚钱方案，每一年的建模题目，A题总是专业性最强，也最能吓住队员的，相反B题看起来总是那么亲和，看起来好像是专门为自己量身打造的题目，然而当把B题深入探讨后，才发觉并不是那么容易的，毕竟命题人不是傻子。因为B题要考虑的附加因素太多，而且数据量总是那么庞大，队员在处理这些数据的时候，也逐渐地消耗着队员的耐心和精力，最后是打击信心。  </p>
<p>建模最常用的软件，就是MATLAB、Lingo、SAS这三件套了，当然如果有需要还可以用R、Python去解决。在建模期间，最常见的模型算法就是灰色预测、主成分分析、聚类分析、BP神经网络、模拟退火算法等，还有Logistic回归预测、马尔代夫模型等。因为对这些模型的了解，让我发现数学在生活中的应用，同时也大概明白了为什么那些商场、运营商总是推出一些特别优惠的方案活动，反而生意更好，而不用担心他们破产——原来背后他们都已经用数学建立模型，预测好了收益和风险。  </p>
<p>参加了三次数学建模国赛，几乎每年都像程序设定好了一样，在第二天中午精神崩溃，充满迷茫，心情压抑。可是，当我问我自己，既然这么累，为什么还要坚持参加呢？——我想是因为我享受这建模的过程。  </p>
<p>和队友讨论问题的解决思路，制定合适的解决方案，再配合一定的科学计算更具有说服力。我很喜欢那种带着适当的压力，在网速比较好的机房，现学现卖一些要用到的算法和模型，因为这样我觉得我的效率比较高，也在学成之后更加有成就感。当然，有成就感也会伴随着失败，几乎每次比赛进行到中后期时，我都会感到离完成论文的目标遥不可及，有好几次想着中途放弃，但看到队友仍然在电脑前处理数据，尝试建模，演算过程，我就会不知不觉的坚持下去。或许这就是它的魅力所在，毕竟和一群小伙伴三天三夜共同做着一件事，也未尝不是一次心灵上的旅途。  </p>
<p>三天三夜的时光转瞬即过，本科阶段的建模生涯就此结束。在这里我不仅锻炼了我的学习能力，与团队的沟通，领导能力，而且培养了我严谨的求学态度，也对论文的写作有了一定的热身练习。最重要的是，它让我懂得了，其实我们现在所走的路，总是在白夜中交替进行着，我们的能力也因此会在这希望与失望交织在一起的螺旋式楼梯上缓慢上升着。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>竞赛</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>我的理想生活(1)</title>
    <url>/2020/10/21/my-dream-life-first/</url>
    <content><![CDATA[<p>今天和@hanxu老友聊起以后想从事的工作，借此情形记录下来，不知未来十年或二十年可否实现。  </p>
<p>我的理想生活，必须要自由，自由到不需要按时打卡上下班，不需要将自己的身躯固定在格子间里，不需要看某些人的脸色行事，不需要维持表面装出来的微笑表情，不需要整天盯着手机收发消息；  </p>
<p>我的理想生活，必须要充实，充实到可以尽情做自己想做的事情，它带给我的快乐远远超过这件事的本身；  </p>
<p>我的理想生活，必须要有它所存在的意义，而这样的意义我也在不停的寻找，六年的时间里，我放佛找到了些许轮廓：我可以尝试翻译国外的经典书籍，首先要要求自己的翻译水平达到一定的境界；我可以做多次不求回报的志愿者；我可以走遍千山万水，拍下别人只能在电视前看到的美景（比如抖音的<strong>韩船长</strong>）；  </p>
<p>我的理想生活，必须要与美食同行，我要吃遍大江南北的特色小吃，品尝奇特的酸甜苦辣咸，就像生活的各种滋味一样；  </p>
<p>我的理想生活，必须要见一见我的好兄弟们，和他们敞开心扉畅聊三天三夜，大口吃肉大口喝酒大声嚷嚷，因为我TM心里憋了一肚子气，已经太久没有大声说过话了…  </p>
<p>我的理想生活，必须要去尝试极限运动，即使不小心发生了事故，我也无憾，因为我将长眠于我热爱的事业上，与其等着死，不如忙着生；  </p>
<p>我的理想生活，必须要在离开这个世界之前，写出一本自传，告诉这个世界，我曾经来过，并带走了美好的回忆。  </p>
<p>最后引用《死亡诗社》里的一首诗作为结束：  </p>
<p><strong>我步入丛林</strong>  </p>
<p><strong>因为我希望活得随意</strong>  </p>
<p><strong>我希望活得深刻</strong>  </p>
<p><strong>吸取生命所有的精华</strong>  </p>
<p><strong>把非生命的一切都击溃</strong>  </p>
<p><strong>以免我在弥留之际</strong>  </p>
<p><strong>发现自己从未真正活过。</strong>  </p>
<p><img src="/2020/10/21/my-dream-life-first/1.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title>我的老师们</title>
    <url>/2020/01/01/my-teachers/</url>
    <content><![CDATA[<p>从小学，中学到大学，我遇到过许多各式各样的老师，此文写于我遇到的老师，以及从他们身上学习到的东西。  </p>
<h2 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h2><p>小学的老师没什么印象，只记得我小学三年级时，肚子疼的走不动路，然后班主任就在冬天一步一步把我背回了家，当时让我的父母很感动，然后老师嘱咐了我父母几句，就冒着风雪又走回了学校。  </p>
<p>小学五年级的时候，数学老师要做一个观摩课，需要用到乒乓球，问谁家有，而我天真的以为我父母是开店的，这些都有，于是就说我有，明天给你带来。然而回家后我爸说乒乓球卖完了，然后我就忘记这件事了，结果第二天中午我父亲给我带饭时，老师气汹汹的问我为什么没有带乒乓球过来，眼睛瞪得贼大，吓坏了我，只见我父亲小心翼翼的说“孩子也是作业多，忘记了，老师您是下午有课吧，我中午去买”。于是下午我父亲带着买好的乒乓球，才让老师的课继续讲了下去。  </p>
<p>这件事，让我明白了<strong>既然许诺要做的事，就一定要做到，即使做不到，也要提前告知对方。</strong>  </p>
<p>（然而，我事后觉得这位数学老师小题大做，全程我就没看你从箱子里取出乒乓球，唉…总之，最后这些乒乓球有些是我在打乒乓球时打烂的。）  </p>
<h2 id="中学"><a href="#中学" class="headerlink" title="中学"></a>中学</h2><p>初中的班主任，性格还好，很年轻，教我们思想品德课。  </p>
<p>记得初一时，太顽皮，经常被老师叫到办公室去谈话，然而第一次月考，我竟然考到了全班第二，把我给开心坏了，然而老师告诉我，你高兴什么，你全年级才排第30名。我当时心想，天呐，我竟然排这么高的名次，但表面上还得装作惋惜的样子。  </p>
<p>初中还有个语文老师，个子比较矮，上课只口述，很少写板书，问其原因，说是粉笔灰对身体有害，可笑，既然知道有害，你为什么要选择来当老师呢？  </p>
<p>高中的班主任是个语文老师，有次她让我们对一个诗人的情感进行扩写，我扩写到停不住笔变成想象了，结果把这份作业上交了，次日中午全班的作业都发了，唯独我的没有发，我以为老师要当众表扬我，结果等我坐到座位上，老师把昨天要求扩写的作业像废纸一样扔到了我面前，并说我要基于事实扩写，我受够了被要求，想掌握一次主动权，于是说出了“老师，请不要扼杀我的才华”。这句话很奏效，直接把老师怼回去了，然而，她后面直接当着全班的面批评我，让我无地自容。  </p>
<p>后来高二分班，我被分配进了一个男老师的班级。  </p>
<p>而我这个班主任，我觉得很有商业头脑，我的女同桌告诉我，这个老师利用寒暑假在自己的客厅搭了一个小教室，让20个左右的学生挤进家里补物理课，一个寒假下来赚好几万，而我有次在班里去问他物理题，他爱理不理的样子让我很生气，于是我后来有物理上的问题，直接跑到高一带我物理的张老师那里去问了。  </p>
<h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>大学碰到过各式各样的老师，对以下几个老师印象极为深刻  </p>
<ul>
<li><p>班主任<code>S</code>：很感谢他大学四年的指导，虽然我很反感他上课老讲他在长安大学怎么怎么样，毕业后在北京怎么怎么样（遇到这种情况我一般私底下看小说或算法书），但我至今记得他大二时给我说<strong>不要把眼光局限在学校里，多向优秀的人去学习</strong>，以及大三时告诫我<strong>想要在这个世界生存下来，先适应这个世界的生存法则，再寻求转机</strong>。毕业前也感谢他私底下给我签了请假条上的字，让我赶上了大城市校招的末班车。  </p>
</li>
<li><p>编译原理老师<code>L</code>：这个老师是我大学学院里最讨厌的老师之一，没有本事，却天天上课吹牛逼，有时还要和我做算法竞赛交易，例如指导老师报他的名字，到时得奖了给我奖励100元，呵呵，谁稀罕你那点钱，于是我果断拒了。  </p>
</li>
<li><p>学院的一位副教授<code>G</code>：这位老师是我另外讨厌的一个人，虽然没有和他正面接触过，但那大大的脸上镶着一双小小的眼睛令我印象深刻，他会在其他学院的计算机基础课上吹牛说写程序的人是多么多么牛逼，你们这些文科生是进不来的，我当时听到我朋友说这些话我就想骂一句 放屁，他（指<code>G</code>）算什么东西，有什么资格评价你们学文科的！后来又听说班级聚餐时逼迫那些女生喝酒，我就对他的厌恶又加深的一分。他带队<code>acm</code>去参加比赛，为了多捞点学校的钱，把学生的毕设答辩全不当一回事。  </p>
</li>
<li><p>学院数据结构老师<code>W</code>：这位老师印象深刻的一幕是，上了一节数据结构课，念<code>PPT</code>，后来为了嘚瑟自己写一个单链表删除的程序，结果硬是卡了大半节课还没找到<code>bug</code>，最后被我身边一位高中打信息学奥赛的湖南朋友分分钟解决。大三时看他因为贪污学校公款被举报，登上了学校的首页，我很高兴。</p>
</li>
</ul>
<h2 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h2><p>进入了社会，我发现我进入了另外一种学校，这里的许多人都是我的老师，有毕业刚进入公司带我做项目的导师，有我敬佩的同事，以及<code>leader</code>。  </p>
<p>我想，未来我还会在这所社会学校中学到更多的东西。  </p>
]]></content>
      <categories>
        <category>Remind-sth</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>老师</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一款MacBook Pro</title>
    <url>/2023/07/20/my-first-mbp/</url>
    <content><![CDATA[<p>7月，终于下定决心给自己买一台MacBook Pro，购买的原因如下：</p>
<ul>
<li>之前笔记本电脑是装的Ubuntu 20.04 + Mac皮肤，编码没问题，但有时需要微信、Office办公套件的时候，会很麻烦，各种中转；</li>
<li>Mac一直想买，但也一直下不定决心，有的人买来很实在，有的人买来是为了装逼 hhh；</li>
<li>尝试做自媒体剪一些视频；  </li>
<li>苹果软件生态丰富…</li>
</ul>
<p>于是乎，开始看各种测评，官网看报价，最终决定上一款 M1 Max + 64G + 2T的配置，当然保险起见买了AC+。</p>
<p>上手3天，觉得MacOS做的还是很细心的，运行软件基本都是秒开，硬件方面给我最大的感触就是屏幕+音响效果，非常棒，看视频有一种在电影院的感觉呢。</p>
<p>软件的话我全部选择了JetBrains系列。</p>
<p>总体感觉很满意，也体会到高配置的便捷。</p>
<p>GOOC LUCK~</p>
]]></content>
      <categories>
        <category>MacNote</category>
      </categories>
      <tags>
        <tag>电脑</tag>
        <tag>mbp</tag>
      </tags>
  </entry>
  <entry>
    <title>Nebula Graph 使用常用 nGQL（CRUD 命令）</title>
    <url>/2022/01/23/nebula-graph-db-usual-cmd/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Nebula Graph 是一款开源的、分布式的、易扩展的原生图数据库，能够承载数千亿个点和数万亿条边的超大规模数据集，并且提供毫秒级查询。  </p>
<p><img src="/2022/01/23/nebula-graph-db-usual-cmd/nebula-graph.png">  </p>
<p>图数据库是专门存储庞大的图形网络并从中检索信息的数据库。它可以将图中的数据高效存储为点（Vertex）和边（Edge），还可以将属性（Property）附加到点和边上。  </p>
<p><img src="/2022/01/23/nebula-graph-db-usual-cmd/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93.png">  </p>
<h1 id="图数据库概念"><a href="#图数据库概念" class="headerlink" title="图数据库概念"></a>图数据库概念</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li><p>图空间（Space）：用于隔离不同团队或者项目的数据。不同图空间的数据是相互隔离的，可以指定不同的存储副本数、权限、分片等。  </p>
</li>
<li><p>点（Vertex）：来保存实体对象，特点是点是用点标识符（VID）标识的。VID在同一图空间中唯一。VID 是一个 int64，或者 fixed_string(N)；点必须有至少一个 Tag，也可以有多个 Tag。但不能没有 Tag。  </p>
</li>
<li><p>边（Edge）：用来连接点的，表示两个点之间的关系或行为，特点如下<br>两点之间可以有多条边。<br>边是有方向的，不存在无向边。<br>四元组 &lt;起点 VID、Edge type、边排序值 (Rank)、终点 VID&gt; 用于唯一标识一条边。边没有 EID。<br>一条边有且仅有一个 Edge type。<br>一条边有且仅有一个 rank。其为 int64，默认为 0。  </p>
</li>
<li><p>标签（Tag）：Tag 由一组事先预定义的属性构成。  </p>
</li>
<li><p>边类型（Edge type）：Edge type 由一组事先预定义的属性构成。  </p>
</li>
<li><p>属性（Properties）：属性是指以键值对（Key-value pair）形式存储的信息。</p>
</li>
</ul>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径是指一个有限或无限的边序列，这些边连接着一系列点。  </p>
<h3 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h3><p><img src="/2022/01/23/nebula-graph-db-usual-cmd/walk.jpeg" alt="示例图">  </p>
<p>walk类型的路径由有限或无限的边序列构成。遍历时点和边可以重复。<br>查看示例图，由于 C、D、E 构成了一个环，因此该图包含无限个路径，例如A-&gt;B-&gt;C-&gt;D-&gt;E、A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C、A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;D。  </p>
<p>注：GO语句采用的是walk类型路径。  </p>
<h3 id="trail"><a href="#trail" class="headerlink" title="trail"></a>trail</h3><p><img src="/2022/01/23/nebula-graph-db-usual-cmd/trail.jpeg">  </p>
<p>trail类型的路径由有限的边序列构成。遍历时只有点可以重复，边不可以重复。柯尼斯堡七桥问题的路径类型就是trail。<br>查看示例图，由于边不可以重复，所以该图包含有限个路径，最长路径由 5 条边组成：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C。  </p>
<p>注：MATCH、FIND PATH和GET SUBGRAPH语句采用的是trail类型路径。  </p>
<p>在 trail 类型中，还有cycle和circuit两种特殊的路径类型  </p>
<p><img src="/2022/01/23/nebula-graph-db-usual-cmd/cycle-circuit.jpeg">  </p>
<ul>
<li><p>cycle<br>是封闭的 trail 类型的路径，遍历时边不可以重复，起点和终点重复，并且没有其他点重复。在此示例图中，最长路径由三条边组成：A-&gt;B-&gt;C-&gt;A或C-&gt;D-&gt;E-&gt;C  </p>
</li>
<li><p>circuit<br>是封闭的 trail 类型的路径，遍历时边不可以重复，除起点和终点重复外，可能存在其他点重复。在此示例图中，最长路径为：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;A。</p>
</li>
</ul>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path类型的路径由有限的边序列构成。遍历时点和边都不可以重复。<br>查看示例图，由于点和边都不可以重复，所以该图包含有限个路径，最长路径由 4 条边组成：A-&gt;B-&gt;C-&gt;D-&gt;E。  </p>
<h2 id="点-VID"><a href="#点-VID" class="headerlink" title="点 VID"></a>点 VID</h2><p>在 Nebula Graph 中，一个点由点的 ID 唯一标识，即 VID 或 Vertex ID。  </p>
<h3 id="VID-的特点"><a href="#VID-的特点" class="headerlink" title="VID 的特点"></a>VID 的特点</h3><ul>
<li>VID 数据类型只可以为定长字符串FIXED_STRING(<N>)或INT64；一个图空间只能选用其中一种 VID 类型。  </N></li>
<li>VID 在一个图空间中必须唯一，其作用类似于关系型数据库中的主键（索引+唯一约束）。但不同图空间中的 VID 是完全独立无关的。  </li>
<li>点 VID 的生成方式必须由用户自行指定，系统不提供自增 ID 或者 UUID。  </li>
<li>VID 相同的点，会被认为是同一个点。  </li>
<li>VID 通常会被（LSM-tree 方式）索引并缓存在内存中，因此直接访问 VID 的性能最高。</li>
</ul>
<h3 id="VID-使用建议"><a href="#VID-使用建议" class="headerlink" title="VID 使用建议"></a>VID 使用建议</h3><ul>
<li>ebula Graph 1.x 只支持 VID 类型为INT64，2.x 支持INT64和FIXED_STRING(<N>)。在CREATE SPACE中通过参数vid_type可以指定 VID 类型。  </N></li>
<li>可以使用id()函数，指定或引用该点的 VID；  </li>
<li>可以使用LOOKUP或者MATCH语句，来通过属性索引查找对应的 VID;  </li>
<li>性能上，直接通过 VID 找到点的语句性能最高，例如DELETE xxx WHERE id(xxx) &#x3D;&#x3D; “player100”，或者GO FROM “player100”等语句。通过属性先查找 VID，再进行图操作的性能会变差，例如LOOKUP | GO FROM $-.ids等语句，相比前者多了一次内存或硬盘的随机读（LOOKUP）以及一次序列化（|）。</li>
</ul>
<h3 id="VID-生成建议"><a href="#VID-生成建议" class="headerlink" title="VID 生成建议"></a>VID 生成建议</h3><ul>
<li>（最优）通过有唯一性的主键或者属性来直接作为 VID；属性访问依赖于 VID;  </li>
<li>通过有唯一性的属性组合来生成 VID，属性访问依赖于属性索引。  </li>
<li>通过 snowflake 等算法生成 VID，属性访问依赖于属性索引；  </li>
<li>如果个别记录的主键特别长，但绝大多数记录的主键都很短的情况，不要将FIXED_STRING(<N>)的N设置成超大，这会浪费大量内存和硬盘，也会降低性能。此时可通过 BASE64，MD5，hash 编码加拼接的方式来生成。  </N></li>
<li>如果用 hash 方式生成 int64 VID：在有 10 亿个点的情况下，发生 hash 冲突的概率大约是 1&#x2F;10。边的数量与碰撞的概率无关。</li>
</ul>
<h3 id="定义和修改-VID-的数据类型"><a href="#定义和修改-VID-的数据类型" class="headerlink" title="定义和修改 VID 的数据类型"></a>定义和修改 VID 的数据类型</h3><p>VID 的数据类型必须在创建图空间时定义，且一旦定义无法修改。  </p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="安装，启动，连接可参考官方文档"><a href="#安装，启动，连接可参考官方文档" class="headerlink" title="安装，启动，连接可参考官方文档"></a>安装，启动，连接可参考官方文档</h2><h2 id="使用常用-nGQL（CRUD-命令）"><a href="#使用常用-nGQL（CRUD-命令）" class="headerlink" title="使用常用 nGQL（CRUD 命令）"></a>使用常用 nGQL（CRUD 命令）</h2><h3 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nebula-console -addr 127.0.0.1 -port 9669 -u root -p 123456</span><br><span class="line"></span><br><span class="line">Welcome to Nebula Graph!</span><br><span class="line"></span><br><span class="line">(root@nebula) [(none)]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="图空间和-Schema"><a href="#图空间和-Schema" class="headerlink" title="图空间和 Schema"></a>图空间和 Schema</h3><p>一个 Nebula Graph 实例由一个或多个图空间组成。每个图空间都是物理隔离的，用户可以在同一个实例中使用不同的图空间存储不同的数据集。  </p>
<p><img src="/2022/01/23/nebula-graph-db-usual-cmd/%E5%9B%BE%E7%A9%BA%E9%97%B4.png">  </p>
<p>为了在图空间中插入数据，需要为图数据库定义一个 Schema。Nebula Graph 的 Schema 是由如下几部分组成。  </p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>点（Vertex）</td>
<td>表示现实世界中的实体。一个点可以有一个或多个标签。</td>
</tr>
<tr>
<td>标签（Tag）</td>
<td>点的类型，定义了一组描述点类型的属性。</td>
</tr>
<tr>
<td>边（Edge）</td>
<td>表示两个点之间有方向的关系。</td>
</tr>
<tr>
<td>边类型（Edge type）</td>
<td>边的类型，定义了一组描述边的类型的属性。</td>
</tr>
</tbody></table>
<h3 id="检查-Nebula-Graph-集群的机器状态"><a href="#检查-Nebula-Graph-集群的机器状态" class="headerlink" title="检查 Nebula Graph 集群的机器状态"></a>检查 Nebula Graph 集群的机器状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [(none)]&gt; SHOW HOSTS;</span><br><span class="line">+-------------+------+----------+--------------+--------------------------------------------------------------------+--------------------------------------------------------------------+</span><br><span class="line">| Host        | Port | Status   | Leader count | Leader distribution                                                | Partition distribution                                             |</span><br><span class="line">+-------------+------+----------+--------------+--------------------------------------------------------------------+--------------------------------------------------------------------+</span><br><span class="line">| &quot;127.0.0.1&quot; | 9779 | &quot;ONLINE&quot; | 230          | &quot;basketballplayer:15, hello:5, playerteam:100, test:10, test2:100&quot; | &quot;basketballplayer:15, hello:5, playerteam:100, test:10, test2:100&quot; |</span><br><span class="line">| &quot;Total&quot;     |      |          | 230          | &quot;basketballplayer:15, hello:5, playerteam:100, test:10, test2:100&quot; | &quot;basketballplayer:15, hello:5, playerteam:100, test:10, test2:100&quot; |</span><br><span class="line">+-------------+------+----------+--------------+--------------------------------------------------------------------+--------------------------------------------------------------------+</span><br><span class="line">Got 2 rows (time spent 2887/4142 us)</span><br><span class="line"></span><br><span class="line">Sun, 23 Jan 2022 21:15:19 CST</span><br></pre></td></tr></table></figure>

<h3 id="创建和选择图空间"><a href="#创建和选择图空间" class="headerlink" title="创建和选择图空间"></a>创建和选择图空间</h3><ul>
<li><p>执行如下语句创建名为basketballplayer的图空间。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nebula&gt; CREATE SPACE basketballplayer(partition_num=15, replica_factor=1, vid_type=fixed_string(30));</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令SHOW HOSTS检查分片的分布情况，确保平衡分布。  </p>
</li>
<li><p>选择图空间basketballplayer  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [(none)]&gt; USE basketballplayer;</span><br><span class="line">Execution succeeded (time spent 892/1250 us)</span><br><span class="line"></span><br><span class="line">Sun, 23 Jan 2022 21:19:42 CST</span><br><span class="line"></span><br><span class="line">(root@nebula) [basketballplayer]&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建-Tag-和-Edge-type"><a href="#创建-Tag-和-Edge-type" class="headerlink" title="创建 Tag 和 Edge type"></a>创建 Tag 和 Edge type</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nebula&gt; CREATE TAG player(name string, age int);</span><br><span class="line"></span><br><span class="line">nebula&gt; CREATE TAG team(name string);</span><br><span class="line"></span><br><span class="line">nebula&gt; CREATE EDGE follow(degree int);</span><br><span class="line"></span><br><span class="line">nebula&gt; CREATE EDGE serve(start_year int, end_year int);</span><br></pre></td></tr></table></figure>

<h3 id="插入点和边"><a href="#插入点和边" class="headerlink" title="插入点和边"></a>插入点和边</h3><ul>
<li>插入代表球员和球队的点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nebula&gt; INSERT VERTEX player(name, age) VALUES &quot;player100&quot;:(&quot;Tim Duncan&quot;, 42);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT VERTEX player(name, age) VALUES &quot;player101&quot;:(&quot;Tony Parker&quot;, 36);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT VERTEX player(name, age) VALUES &quot;player102&quot;:(&quot;LaMarcus Aldridge&quot;, 33);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT VERTEX team(name) VALUES &quot;team203&quot;:(&quot;Trail Blazers&quot;), &quot;team204&quot;:(&quot;Spurs&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>插入代表球员和球队之间关系的边。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nebula&gt; INSERT EDGE follow(degree) VALUES &quot;player101&quot; -&gt; &quot;player100&quot;:(95);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT EDGE follow(degree) VALUES &quot;player101&quot; -&gt; &quot;player102&quot;:(90);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT EDGE follow(degree) VALUES &quot;player102&quot; -&gt; &quot;player100&quot;:(75);</span><br><span class="line"></span><br><span class="line">nebula&gt; INSERT EDGE serve(start_year, end_year) VALUES &quot;player101&quot; -&gt; &quot;team204&quot;:(1999, 2018),&quot;player102&quot; -&gt; &quot;team203&quot;:(2006,  2015);</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><ul>
<li>从 VID 为player101的球员开始，沿着边follow找到连接的球员。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; GO FROM &quot;player101&quot; OVER follow;</span><br><span class="line">+-------------+</span><br><span class="line">| follow._dst |</span><br><span class="line">+-------------+</span><br><span class="line">| &quot;player100&quot; |</span><br><span class="line">| &quot;player102&quot; |</span><br><span class="line">| &quot;player125&quot; |</span><br><span class="line">+-------------+</span><br><span class="line">Got 3 rows (time spent 4979/5521 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>从 VID 为player101的球员开始，沿着边follow查找年龄大于或等于 35 岁的球员，并返回他们的姓名和年龄，同时重命名对应的列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; GO FROM &quot;player101&quot; OVER follow WHERE $$.player.age &gt;= 35 \</span><br><span class="line">                               -&gt;         YIELD properties($$).name AS Teammate, properties($$).age AS Age;</span><br><span class="line">+-----------------+-----+</span><br><span class="line">| Teammate        | Age |</span><br><span class="line">+-----------------+-----+</span><br><span class="line">| &quot;Tim Duncan&quot;    | 42  |</span><br><span class="line">| &quot;Manu Ginobili&quot; | 41  |</span><br><span class="line">+-----------------+-----+</span><br><span class="line">Got 2 rows (time spent 3876/4400 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>从 VID 为player101的球员开始，沿着边follow查找连接的球员，然后检索这些球员的球队。为了合并这两个查询请求，可以使用管道符或临时变量。</li>
</ul>
<p>使用管道符  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; GO FROM &quot;player101&quot; OVER follow YIELD dst(edge) AS id | \</span><br><span class="line">                               -&gt;         GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \</span><br><span class="line">                               -&gt;         properties($^).name AS Player;</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">| Team            | Player              |</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">| &quot;Trail Blazers&quot; | &quot;LaMarcus Aldridge&quot; |</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">Got 1 rows (time spent 1647/1896 us)</span><br></pre></td></tr></table></figure>

<p>使用临时变量<br><strong>当复合语句作为一个整体提交给服务器时，其中的临时变量会在语句结束时被释放。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; $var = GO FROM &quot;player101&quot; OVER follow YIELD dst(edge) AS id; \</span><br><span class="line">                               -&gt;         GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \</span><br><span class="line">                               -&gt;         properties($^).name AS Player;</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">| Team            | Player              |</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">| &quot;Trail Blazers&quot; | &quot;LaMarcus Aldridge&quot; |</span><br><span class="line">+-----------------+---------------------+</span><br><span class="line">Got 1 rows (time spent 3838/4340 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>FETCH语句示例</li>
</ul>
<p>查询 VID 为player100的球员的属性。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; FETCH PROP ON player &quot;player100&quot;;</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">| vertices_                                          |</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">| (&quot;player100&quot; :player&#123;age: 42, name: &quot;Tim Duncan&quot;&#125;) |</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">Got 1 rows (time spent 1377/1883 us)</span><br></pre></td></tr></table></figure>

<h3 id="修改点和边"><a href="#修改点和边" class="headerlink" title="修改点和边"></a>修改点和边</h3><p>用户可以使用UPDATE语句或UPSERT语句修改现有数据。  </p>
<p>UPSERT是UPDATE和INSERT的结合体。当使用UPSERT更新一个点或边，如果它不存在，数据库会自动插入一个新的点或边。  </p>
<p>注：每个 partition 内部，UPSERT 操作是一个串行操作，所以执行速度比执行 INSERT 或 UPDATE 慢很多。其仅在多个 partition 之间有并发。  </p>
<ul>
<li>用UPDATE修改 VID 为player100的球员的name属性，然后用FETCH语句检查结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; UPDATE VERTEX &quot;player100&quot; SET player.name = &quot;Tim&quot;;</span><br><span class="line">Execution succeeded (time spent 2902/3267 us)</span><br><span class="line"></span><br><span class="line">(root@nebula) [basketballplayer]&gt; FETCH PROP ON player &quot;player100&quot;;</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| vertices_                                   |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| (&quot;player100&quot; :player&#123;age: 42, name: &quot;Tim&quot;&#125;) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">Got 1 rows (time spent 1426/1899 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>用UPDATE修改某条边的degree属性，然后用FETCH检查结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; UPDATE EDGE &quot;player101&quot; -&gt; &quot;player100&quot; OF follow SET degree = 96;</span><br><span class="line">Execution succeeded (time spent 2304/2675 us)</span><br><span class="line"></span><br><span class="line">(root@nebula) [basketballplayer]&gt; FETCH PROP ON follow &quot;player101&quot; -&gt; &quot;player100&quot;;</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">| edges_                                             |</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">| [:follow &quot;player101&quot;-&gt;&quot;player100&quot; @0 &#123;degree: 96&#125;] |</span><br><span class="line">+----------------------------------------------------+</span><br><span class="line">Got 1 rows (time spent 1515/2031 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>用INSERT插入一个 VID 为player111的点，然后用UPSERT更新它。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; INSERT VERTEX player(name,age) values &quot;player111&quot;:(&quot;David West&quot;, 38);</span><br><span class="line">Execution succeeded (time spent 1084/1475 us)</span><br><span class="line"></span><br><span class="line">(root@nebula) [basketballplayer]&gt; UPSERT VERTEX &quot;player111&quot; SET player.name = &quot;David&quot;, player.age = $^.player.age + 11 \</span><br><span class="line">                               -&gt;         WHEN $^.player.name == &quot;David West&quot; AND $^.player.age &gt; 20 \</span><br><span class="line">                               -&gt;         YIELD $^.player.name AS Name, $^.player.age AS Age;</span><br><span class="line">+---------+-----+</span><br><span class="line">| Name    | Age |</span><br><span class="line">+---------+-----+</span><br><span class="line">| &quot;David&quot; | 49  |</span><br><span class="line">+---------+-----+</span><br><span class="line">Got 1 rows (time spent 1737/2310 us)</span><br></pre></td></tr></table></figure>

<h3 id="删除点和边"><a href="#删除点和边" class="headerlink" title="删除点和边"></a>删除点和边</h3><ul>
<li>删除点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; DELETE VERTEX &quot;player111&quot;, &quot;team203&quot;;</span><br><span class="line">Execution succeeded (time spent 3258/3630 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除边</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; DELETE EDGE follow &quot;player101&quot; -&gt; &quot;team204&quot;;</span><br><span class="line">Execution succeeded (time spent 1214/1623 us)</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>用户可以通过 CREATE INDEX 语句为 Tag 和 Edge type 增加索引。  </p>
<ul>
<li>为 name 属性创建索引 player_index_1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; CREATE TAG INDEX player_index_1 ON player(name(20));</span><br><span class="line">Execution succeeded (time spent 3786/4138 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>重建索引确保能对已存在数据生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; REBUILD TAG INDEX player_index_1</span><br><span class="line">+------------+</span><br><span class="line">| New Job Id |</span><br><span class="line">+------------+</span><br><span class="line">| 6          |</span><br><span class="line">+------------+</span><br><span class="line">Got 1 rows (time spent 1398/1833 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 LOOKUP 语句检索点的属性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; LOOKUP ON player WHERE player.name == &quot;Tony Parker&quot; \</span><br><span class="line">                               -&gt;         YIELD properties(vertex).name AS name, properties(vertex).age AS age;</span><br><span class="line">+-------------+---------------+-----+</span><br><span class="line">| VertexID    | name          | age |</span><br><span class="line">+-------------+---------------+-----+</span><br><span class="line">| &quot;36&quot;        | &quot;Tony Parker&quot; | 36  |</span><br><span class="line">| &quot;player101&quot; | &quot;Tony Parker&quot; | 36  |</span><br><span class="line">+-------------+---------------+-----+</span><br><span class="line">Got 2 rows (time spent 2121/2697 us)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 MATCH 语句检索点的属性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(root@nebula) [basketballplayer]&gt; MATCH (v:player&#123;name:&quot;Tony Parker&quot;&#125;) RETURN v;</span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">| v                                                                       |</span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">| (&quot;36&quot; :team&#123;name: &quot;Tony Parker&quot;&#125; :player&#123;age: 36, name: &quot;Tony Parker&quot;&#125;) |</span><br><span class="line">| (&quot;player101&quot; :player&#123;age: 36, name: &quot;Tony Parker&quot;&#125;)                     |</span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">Got 2 rows (time spent 3162/3744 us)</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是Nebula Graph数据库的常用操作，后续我会再根据研究方向做深入的研究。  </p>
]]></content>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/2023/03/01/network-programming-base/</url>
    <content><![CDATA[<h1 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h1><p><img src="/2023/03/01/network-programming-base/osi7.png">  </p>
<h1 id="经典协议与数据包"><a href="#经典协议与数据包" class="headerlink" title="经典协议与数据包"></a>经典协议与数据包</h1><h2 id="TCP数据包构成"><a href="#TCP数据包构成" class="headerlink" title="TCP数据包构成"></a>TCP数据包构成</h2><p><img src="/2023/03/01/network-programming-base/TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84.png">  </p>
<p><img src="/2023/03/01/network-programming-base/TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%842.png">  </p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><img src="/./network-programming-base/http%E5%8D%8F%E8%AE%AE.png">  </p>
<h2 id="WebSocket握手协议"><a href="#WebSocket握手协议" class="headerlink" title="WebSocket握手协议"></a>WebSocket握手协议</h2><p><img src="/2023/03/01/network-programming-base/Webscoket%E5%8D%8F%E8%AE%AE.png">  </p>
<h2 id="WebSocket-Data协议"><a href="#WebSocket-Data协议" class="headerlink" title="WebSocket Data协议"></a>WebSocket Data协议</h2><p><img src="/2023/03/01/network-programming-base/Webscoket-Data%E5%8D%8F%E8%AE%AE.png">  </p>
<h1 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h1><ul>
<li>三次握手的最主要目的是保证连接是双工（发送和接收可以同时执行）的，可靠更多的是通过重传机制来保证的。  </li>
<li>因为连接是全双工的，双方必须都收到对方的<code>FIN</code>包及确认才可以关闭。</li>
</ul>
<h2 id="三次握手连接"><a href="#三次握手连接" class="headerlink" title="三次握手连接"></a>三次握手连接</h2><p><img src="/2023/03/01/network-programming-base/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">  </p>
<h2 id="四次回收关闭"><a href="#四次回收关闭" class="headerlink" title="四次回收关闭"></a>四次回收关闭</h2><p><img src="/2023/03/01/network-programming-base/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%85%B3%E9%97%AD.png">  </p>
<ul>
<li>主动关闭方发送<code>FINISH</code>包请求关闭；  </li>
<li>被动关闭方回复<code>ACK</code>包表示已经收到这个请求；  </li>
<li>被动关闭方完成关闭操作后，回复<code>FINISH</code>包，表示可以关闭了；  </li>
<li>主动关闭方再发送一次<code>ACK</code>包表示确认关闭；  </li>
<li>两方都进入了<code>CLOSE</code>状态。</li>
</ul>
<h2 id="为什么time-wait需要等待2MSL？"><a href="#为什么time-wait需要等待2MSL？" class="headerlink" title="为什么time_wait需要等待2MSL？"></a>为什么time_wait需要等待2MSL？</h2><ul>
<li>MSL：Maximum Segment Lifetime，30秒-1分钟  </li>
<li>保证TCP协议的全双工连接能够可靠关闭  </li>
<li>保证这次连接的重复数据段从网络中消失</li>
</ul>
<h2 id="为什么会出现大量close-wait？"><a href="#为什么会出现大量close-wait？" class="headerlink" title="为什么会出现大量close_wait？"></a>为什么会出现大量close_wait？</h2><ul>
<li>首先<code>close_wait</code>一般出现在被动关闭方  </li>
<li>并发请求太多导致  </li>
<li>被动关闭方未及时释放端口资源导致</li>
</ul>
<p>代码  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1、监听端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;0.0.0.0:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;listen fail, err: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.建立套接字连接</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;accept fail, err: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3. 创建处理协程</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">			<span class="comment">//defer conn.Close() //<span class="doctag">TODO:</span>思考-这里不填写会有啥问题？</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> buf [<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">				n, err := conn.Read(buf[:])</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;read from connect failed, err: %v\n&quot;</span>, err)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				str := <span class="type">string</span>(buf[:n])</span><br><span class="line">				fmt.Printf(<span class="string">&quot;receive from client, data: %v\n&quot;</span>, str)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP的拥塞控制和流量控制"><a href="#TCP的拥塞控制和流量控制" class="headerlink" title="TCP的拥塞控制和流量控制"></a>TCP的拥塞控制和流量控制</h1><h2 id="TCP为什么需要流量控制？"><a href="#TCP为什么需要流量控制？" class="headerlink" title="TCP为什么需要流量控制？"></a>TCP为什么需要流量控制？</h2><ul>
<li>由于通讯双方网速不同，通讯任一方发送过快都会导致对方的消息处理不过来，所以就需要把数据放到缓冲区中；  </li>
<li>如果缓冲区已经满了，发送方还在疯狂发送，那接收方只能把数据包丢弃。因此我们需要控制发送速率。  </li>
<li>我们缓冲区剩余大小称之为接收窗口，用变量<code>win</code>表示。如果<code>win=0</code>，则发送方停止发送。</li>
</ul>
<p><img src="/2023/03/01/network-programming-base/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png">  </p>
<h2 id="TCP为什么需要拥塞控制？"><a href="#TCP为什么需要拥塞控制？" class="headerlink" title="TCP为什么需要拥塞控制？"></a>TCP为什么需要拥塞控制？</h2><ul>
<li>流量控制与拥塞控制是两个概念，拥塞控制是调整网络的负载；  </li>
<li>接收方网络资源繁忙，因未及时响应<code>ACK</code>导致发送方重传大量数据，这样将会导致网络更加拥堵  </li>
<li>拥塞控制是动态调整<code>win</code>大小，不只是依赖缓冲区大小确定窗口大小。</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul>
<li>慢开始和拥塞避免  </li>
<li>快速重传和快速恢复</li>
</ul>
<p><img src="/2023/03/01/network-programming-base/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png">  </p>
<p><img src="/2023/03/01/network-programming-base/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D2.png">  </p>
<h2 id="优化：快重传和快恢复"><a href="#优化：快重传和快恢复" class="headerlink" title="优化：快重传和快恢复"></a>优化：快重传和快恢复</h2><p><img src="/2023/03/01/network-programming-base/%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D.png">  </p>
<h1 id="为什么会出现粘包、拆包，如何处理"><a href="#为什么会出现粘包、拆包，如何处理" class="headerlink" title="为什么会出现粘包、拆包，如何处理"></a>为什么会出现粘包、拆包，如何处理</h1><h1 id="基于Golang实现TCP、UDP、HTTP服务器与客户端"><a href="#基于Golang实现TCP、UDP、HTTP服务器与客户端" class="headerlink" title="基于Golang实现TCP、UDP、HTTP服务器与客户端"></a>基于Golang实现TCP、UDP、HTTP服务器与客户端</h1>]]></content>
      <categories>
        <category>LearnComputerNetwork</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>网络</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2019/01/14/new-begin/</url>
    <content><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>大家好，我的网名叫不会飞的章鱼（Zoctopus Zhang），活跃在简书、豆瓣、博客园和Github上，之前在博客园上坚持写技术博客长达两年半，截止目前已发布了两百多篇文章共23万人+的访问量，同时在简书上写文章积累了有十二万余字。然而，我一直很想创建一个自己的Blog，记录一些平时工作和生活上的收获和心得。<br>今天这个愿望终于实现了，在此我很感谢我的好友冰水鉴心的远程帮助。  </p>
<h2 id="接下来准备做什么"><a href="#接下来准备做什么" class="headerlink" title="接下来准备做什么"></a>接下来准备做什么</h2><p>我本科学的专业是计算机科学与技术，2018年6月毕业后在一家上市游戏公司做了三个月的游戏服务器开发，之后因工作原因转行，目前主要做流媒体服务和与视音频相关的图形图像。<br>我想把我在工作中的学习心得和生活上的感悟记录下来。  </p>
<h2 id="那么，现在就开始吧"><a href="#那么，现在就开始吧" class="headerlink" title="那么，现在就开始吧"></a>那么，现在就开始吧</h2><p>我不知道这条路我会走多远，但我至今不后悔我做出的每一个选择。因为我知道：念念不忘，必有回响。 </p>
<p><img src="/2019/01/14/new-begin/%E5%85%89%E6%99%95.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>开始</tag>
      </tags>
  </entry>
  <entry>
    <title>没有Bug的项目</title>
    <url>/2020/10/20/no-bug-project/</url>
    <content><![CDATA[<p>这个世界上，永远不存在——没有Bug的项目。  </p>
<p>从2019年开始至今，在一个项目上做了快一年了，<strong>永远不存在——没有Bug的项目</strong>，这是我最终顿悟的。  </p>
<p>从最初的服务架构设计-&gt;编码-&gt;调试-&gt;单元测试-&gt;联调测试-&gt;加大压力测试-&gt;改Bug-&gt;改需求-&gt;改代码-&gt;继续测试，不断循环往复，像一个永远不会<code>break</code>的循环语句，我慢慢体会到了时间流逝的太快，不知不觉我已经是一个工作经验有两年的职场人了。  </p>
<p>这两年带给我最大的变化就是来自心态的变化，我仍记得我初入公司时，那种兴奋和好奇占据了我的灵魂，什么都想做，什么都想尝试，到慢慢的这具皮囊被迷茫和空虚所填满。  </p>
<p>我一直想写出一个没有Bug的项目，然而当我发现，原来曾经的功能可以转化为现在的错误的时候，那么剩下我所做的一切都不重要了。  </p>
<p>这个世界上，永远不存在没有Bug的项目，除非————我可以和这个项目永久地切断联系！  </p>
<p><img src="/2020/10/20/no-bug-project/1.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>项目</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>一天掌握Docker</title>
    <url>/2022/02/27/one-day-to-know-docker/</url>
    <content><![CDATA[<h1 id="Docker介绍与安装"><a href="#Docker介绍与安装" class="headerlink" title="Docker介绍与安装"></a>Docker介绍与安装</h1><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><ul>
<li>使用最广泛的开源容器引擎  </li>
<li>一种操作系统级的虚拟化技术  </li>
<li>依赖于Linux内核特性：Namespace（资源隔离）和Cgroups（资源限制）  </li>
<li>一个简单的应用程序打包工具</li>
</ul>
<h2 id="Docker设计目标"><a href="#Docker设计目标" class="headerlink" title="Docker设计目标"></a>Docker设计目标</h2><ul>
<li>提供简单的应用程序打包工具  </li>
<li>开发人员和运维人员职责逻辑分离  </li>
<li>多环境保持一致性</li>
</ul>
<h2 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h2><ul>
<li>Docker Client：客户端  </li>
<li>Docker Daemon：守护进程  </li>
<li>Docker Images：镜像  </li>
<li>Docker Container：容器  </li>
<li>Docker Registry：镜像仓库</li>
</ul>
<p><img src="/2022/02/27/one-day-to-know-docker/docker%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png">  </p>
<h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><p><img src="/2022/02/27/one-day-to-know-docker/%E5%AE%B9%E5%99%A8vs%E8%99%9A%E6%8B%9F%E6%9C%BA.png">  </p>
<table>
<thead>
<tr>
<th></th>
<th>Container</th>
<th>VM</th>
</tr>
</thead>
<tbody><tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>运行性能</td>
<td>接近原生</td>
<td>5%左右损失</td>
</tr>
<tr>
<td>磁盘占用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>数量</td>
<td>成百上千</td>
<td>一般几十台</td>
</tr>
<tr>
<td>隔离性</td>
<td>进程级别</td>
<td>系统级（更彻底）</td>
</tr>
<tr>
<td>操作系统</td>
<td>主要支持Linux</td>
<td>几乎所有</td>
</tr>
<tr>
<td>封装程度</td>
<td>只打包项目代码和依赖关系，共享宿主机内核</td>
<td>完整的操作系统</td>
</tr>
</tbody></table>
<h2 id="Docker应用场景"><a href="#Docker应用场景" class="headerlink" title="Docker应用场景"></a>Docker应用场景</h2><ul>
<li>应用程序打包和发布  </li>
<li>应用程序隔离  </li>
<li>持续集成  </li>
<li>部署微服务  </li>
<li>快速搭建测试环境  </li>
<li>提供PaaS产品（平台即服务）</li>
</ul>
<h2 id="Linux安装Docker"><a href="#Linux安装Docker" class="headerlink" title="Linux安装Docker"></a>Linux安装Docker</h2><h3 id="Docker版本"><a href="#Docker版本" class="headerlink" title="Docker版本"></a>Docker版本</h3><ul>
<li>社区版（Community Edition，CE）  </li>
<li>企业版（Enterprise Edition，EE）</li>
</ul>
<h3 id="支持平台"><a href="#支持平台" class="headerlink" title="支持平台"></a>支持平台</h3><ul>
<li>Linux（CentOS,Debian,Fedora,Oracle Linux,RHEL,SUSE和Ubuntu）  </li>
<li>Mac  </li>
<li>Windows</li>
</ul>
<h3 id="CentOS7-x安装Docker"><a href="#CentOS7-x安装Docker" class="headerlink" title="CentOS7.x安装Docker"></a>CentOS7.x安装Docker</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># 添加Docker软件包源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="comment"># 启动Docker服务并设置开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h1 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h1><h2 id="什么是镜像？"><a href="#什么是镜像？" class="headerlink" title="什么是镜像？"></a>什么是镜像？</h2><p>简单说，Docker镜像是一个不包含Linux内核而又精简的Linux操作系统。  </p>
<h2 id="镜像从哪里来？"><a href="#镜像从哪里来？" class="headerlink" title="镜像从哪里来？"></a>镜像从哪里来？</h2><p>Docker Hub是由Docker公司负责维护的公共注册中心，包含大量的容器镜像，Docker工具默认从这个公共镜像库下载镜像。  </p>
<p><a href="https://hub.docker.com/explore">https://hub.docker.com/explore</a>默认是国外的源，下载会慢，建议配置国内镜像仓库：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="镜像与容器联系"><a href="#镜像与容器联系" class="headerlink" title="镜像与容器联系"></a>镜像与容器联系</h2><p>镜像不是一个单一的文件，而是有多层构成。我们可以通过<code>docker history &lt;ID/NAME&gt;</code>查看镜像中各层内容及大小，每层对应着Dockerfile中的一条指令。Docker镜像默认存储在<code>/var/lib/docker/&lt;storage-driver&gt;</code>中。<br>容器其实是在镜像的最上面加了一层读写层，在运行容器里做的任何文件改动，都会写到这个读写层。如果容器删除了，最上面的读写层也就删除了，改动也就丢失了。<br>Docker使用存储驱动管理镜像每层内容及可读写层的容器层。  </p>
<p><img src="/2022/02/27/one-day-to-know-docker/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E8%81%94%E7%B3%BB.png">  </p>
<h2 id="存储驱动"><a href="#存储驱动" class="headerlink" title="存储驱动"></a>存储驱动</h2><p><img src="/2022/02/27/one-day-to-know-docker/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8.png">  </p>
<h2 id="镜像管理指令"><a href="#镜像管理指令" class="headerlink" title="镜像管理指令"></a>镜像管理指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>Container</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>列出镜像</td>
</tr>
<tr>
<td>build</td>
<td>构建镜像来自Dockerfile</td>
</tr>
<tr>
<td>history</td>
<td>查看镜像历史</td>
</tr>
<tr>
<td>inspect</td>
<td>显示一个或多个镜像详细信息</td>
</tr>
<tr>
<td>pull</td>
<td>从镜像仓库拉取镜像</td>
</tr>
<tr>
<td>push</td>
<td>推送一个镜像到镜像仓库</td>
</tr>
<tr>
<td>rm</td>
<td>移除一个或多个镜像</td>
</tr>
<tr>
<td>prune</td>
<td>移除未使用的镜像。没有被标记或被任何容器引用的</td>
</tr>
<tr>
<td>tag</td>
<td>创建一个引用源镜像标记目标镜像</td>
</tr>
<tr>
<td>export</td>
<td>导出容器文件系统到tar归档文件</td>
</tr>
<tr>
<td>import</td>
<td>导入容器文件系统tar归档文件创建镜像</td>
</tr>
<tr>
<td>save</td>
<td>保存一个或多个镜像到一个tar归档文件</td>
</tr>
<tr>
<td>load</td>
<td>加载镜像来自tar归档或标准输入</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker</span><br><span class="line"></span><br><span class="line">Usage:	docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default</span><br><span class="line">                           &quot;/home/neo/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to connect to the</span><br><span class="line">                           daemon (overrides DOCKER_HOST env var and</span><br><span class="line">                           default context set with &quot;docker context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level</span><br><span class="line">                           (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;)</span><br><span class="line">                           (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default</span><br><span class="line">                           &quot;/home/neo/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default</span><br><span class="line">                           &quot;/home/neo/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default</span><br><span class="line">                           &quot;/home/neo/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  engine      Manage the docker engine</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  images      List images</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  info        Display system-wide information</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  login       Log in to a Docker registry</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure>

<h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><h2 id="创建容器常用选项"><a href="#创建容器常用选项" class="headerlink" title="创建容器常用选项"></a>创建容器常用选项</h2><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>资源限制指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-i, –interactive</td>
<td>交互式</td>
<td>-m，–memory</td>
<td>容器可以使用的最大内存量</td>
</tr>
<tr>
<td>-t, –tty</td>
<td>分配一个伪终端</td>
<td>–memory-swap</td>
<td>允许交换到磁盘的内存量</td>
</tr>
<tr>
<td>-d, –detach</td>
<td>运行容器到后台</td>
<td>–memory-swappiness&#x3D;&lt;0-100&gt;</td>
<td>容器使用SWAP分区交换的百分比（0-100，默认为-1）</td>
</tr>
<tr>
<td>-a, –attach list</td>
<td>附加到运行的容器</td>
<td>–memory-reservation</td>
<td>内存软限制，Docker检测主机容器争用或内存不足时所激活的软限制，使用此选项，值必须设置低于—memory，以使其优先</td>
</tr>
<tr>
<td>–dns list</td>
<td>设置DNS服务器</td>
<td>–oom-kill-disable</td>
<td>当宿主机内存不足时，内核会杀死容器中的进程。建议设置了-memory选项再禁用OOM。如果没有设置，主机可能会耗尽内存</td>
</tr>
<tr>
<td>-e, –env list</td>
<td>设置环境变量</td>
<td>–cpus</td>
<td>限制容器可以使用多少可用的CPU资源</td>
</tr>
<tr>
<td>–env-file list</td>
<td>从文件读取环境变量</td>
<td>–cpuset-cpus</td>
<td>限制容器可以使用特定的CPU</td>
</tr>
<tr>
<td>-p, –publish list</td>
<td>发布容器端口到主机</td>
<td>–cpu-shares</td>
<td>此值设置为大于或小于默认1024值，以增加或减少容器的权重，并使其可以访问主机CPU周期的更大或更小比例</td>
</tr>
<tr>
<td>-P, –publish-all</td>
<td>发布容器所有EXPOSE的端口到宿主机随机端口</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h, –hostname string</td>
<td>设置容器主机名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–ip string</td>
<td>指定容器IP，只能用于自定义网络</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–link list</td>
<td>添加连接到另一个容器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–network</td>
<td>连接容器到一个网络</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-v, –volume list</td>
<td>挂载宿主机目录到容器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–restart string</td>
<td>容器退出时重启策略，默认no[always</td>
<td>on-failure]</td>
<td></td>
</tr>
<tr>
<td>–add-host list</td>
<td>添加其他主机到容器中&#x2F;etc&#x2F;hosts</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="管理容器常用命令"><a href="#管理容器常用命令" class="headerlink" title="管理容器常用命令"></a>管理容器常用命令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>列出容器</td>
</tr>
<tr>
<td>attach</td>
<td>附加本地标准输入，输出和错误到一个运行的容器</td>
</tr>
<tr>
<td>exec</td>
<td>在运行容器中执行命令</td>
</tr>
<tr>
<td>inspect</td>
<td>显示一个或多个容器详细信息</td>
</tr>
<tr>
<td>commit</td>
<td>创建一个新镜像来自一个容器</td>
</tr>
<tr>
<td>cp</td>
<td>拷贝文件&#x2F;文件夹到一个容器</td>
</tr>
<tr>
<td>logs</td>
<td>获取一个容器日志</td>
</tr>
<tr>
<td>port</td>
<td>列出或指定容器端口映射</td>
</tr>
<tr>
<td>stats</td>
<td>显示容器资源使用统计</td>
</tr>
<tr>
<td>top</td>
<td>显示一个容器运行的进程</td>
</tr>
<tr>
<td>update</td>
<td>更新一个或多个容器配置</td>
</tr>
<tr>
<td>stop&#x2F;start</td>
<td>停止&#x2F;启动一个或多个容器</td>
</tr>
<tr>
<td>rm</td>
<td>删除一个或多个容器</td>
</tr>
</tbody></table>
<h1 id="管理应用程序数据"><a href="#管理应用程序数据" class="headerlink" title="管理应用程序数据"></a>管理应用程序数据</h1><h2 id="将Docker主机数据挂载到容器"><a href="#将Docker主机数据挂载到容器" class="headerlink" title="将Docker主机数据挂载到容器"></a>将Docker主机数据挂载到容器</h2><p>Docker提供三种不同的方式将数据从宿主机挂载到容器中：volumes，bind mounts和tmpfs。<br>volumes：Docker管理宿主机文件系统的一部分（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes）。<br>bind mounts：可以存储在宿主机系统的任意位置。<br>tmpfs：挂载存储在宿主机系统的内存中，而不会写入宿主机的文件系统。  </p>
<p><img src="/2022/02/27/one-day-to-know-docker/%E5%B0%86docker%E4%B8%BB%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8.png">  </p>
<h2 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管理卷：</span><br><span class="line"># docker volume create nginx-vol</span><br><span class="line"># docker volume ls</span><br><span class="line"># docker volume inspect nginx-vol</span><br><span class="line">用卷创建一个容器：</span><br><span class="line"># docker run -d -it --name=nginx-test --mount src=nginx-vol,dst=/usr/share/nginx/html nginx</span><br><span class="line"># docker run -d -it --name=nginx-test -v nginx-vol:/usr/share/nginx/html nginx</span><br><span class="line">清理：</span><br><span class="line"># docker container stop nginx-test</span><br><span class="line"># docker container rm nginx-test </span><br><span class="line"># docker volume rm nginx-vol</span><br></pre></td></tr></table></figure>

<p>注意：  </p>
<ul>
<li>如果没有指定卷，自动创建。  </li>
<li>建议使用<code>mount</code>，更通用。</li>
</ul>
<p><a href="https://docs.docker.com/engine/admin/volumes/volumes/#start-a-container-with-a-volume">官方文档</a>  </p>
<h2 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用卷创建一个容器：</span><br><span class="line"># docker run -d -it --name=nginx-test --mount type=bind,src=/app/wwwroot,dst=/usr/share/nginx/html nginx</span><br><span class="line"># docker run -d -it --name=nginx-test -v /app/wwwroot:/usr/share/nginx/html nginx</span><br><span class="line">验证绑定：</span><br><span class="line"># docker inspect nginx-test</span><br><span class="line">清理：</span><br><span class="line"># docker container stop nginx-test </span><br><span class="line"># docker container rm nginx-test </span><br></pre></td></tr></table></figure>

<p>注意：  </p>
<ul>
<li>如果源文件&#x2F;目录没有存在，不会自动创建，会抛出一个错误。  </li>
<li>如果挂载目标在容器中非空目录，则该目录现有内容将被隐藏。</li>
</ul>
<p><a href="https://docs.docker.com/engine/admin/volumes/bind-mounts/#start-a-container-with-a-bind-mount">官方文档</a>  </p>
<h2 id="搭建LNMP（Linux-Nginx-MySQL-PHP）网站平台"><a href="#搭建LNMP（Linux-Nginx-MySQL-PHP）网站平台" class="headerlink" title="搭建LNMP（Linux+Nginx+MySQL+PHP）网站平台"></a>搭建LNMP（Linux+Nginx+MySQL+PHP）网站平台</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、自定义网络</span><br><span class="line">docker network create lnmp</span><br><span class="line">2、创建Mysql数据库容器</span><br><span class="line">docker run -itd \</span><br><span class="line">--name lnmp_mysql \</span><br><span class="line">--net lnmp \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--mount src=mysql-vol,dst=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.7 --character-set-server=utf8</span><br><span class="line"></span><br><span class="line">3、创建所需数据库 </span><br><span class="line">docker exec lnmp_mysql sh \</span><br><span class="line">-c &#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot; -e&quot;create database wp&quot;&#x27; </span><br><span class="line"></span><br><span class="line">4、创建PHP环境容器</span><br><span class="line">docker run -itd \</span><br><span class="line">--name lnmp_web \</span><br><span class="line">--net lnmp \</span><br><span class="line">-p 88:80 \</span><br><span class="line">--mount type=bind,src=/app/wwwroot,dst=/var/www/html richarvey/nginx-php-fpm</span><br><span class="line"></span><br><span class="line">5、以wordpress博客为例测试</span><br><span class="line">wget https://cn.wordpress.org/wordpress-4.7.4-zh_CN.tar.gz</span><br><span class="line">tar zxf wordpress-4.7.4-zh_CN.tar.gz -C /app/wwwroot</span><br><span class="line"># 浏览器测试访问</span><br><span class="line">http://IP:88/wordpress</span><br></pre></td></tr></table></figure>


<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p>Docker支持5种网络模式  </p>
<ul>
<li>bridge:默认网络，Docker启动后默认创建一个docker0网桥，默认创建的容器也是添加到这个网桥中。  </li>
<li>host:容器不会获得一个独立的network namespace，而是与宿主机共用一个。  </li>
<li>none:获取独立的network namespace，但不为容器进行任何网络配置。  </li>
<li>container:与指定的容器使用同一个network namespace，网卡配置也都是相同的。  </li>
<li>自定义:自定义网桥，默认与bridge网络一样。</li>
</ul>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>构建的新镜像是基于哪个镜像。例如：FROM centos:6</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者姓名或邮箱地址。例如：MAINTAINER lizhenliang</td>
</tr>
<tr>
<td>RUN</td>
<td>构建镜像时运行的Shell命令。例如：RUN [“yum”, “install”, “httpd”]，RUN yum install httpd</td>
</tr>
<tr>
<td>CMD</td>
<td>运行容器时执行的Shell命令。例如：CMD [“-c”, “&#x2F;start.sh”]，CMD [“&#x2F;usr&#x2F;sbin&#x2F;sshd”, “-D”]，CMD &#x2F;usr&#x2F;sbin&#x2F;sshd –D</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明容器运行的服务端口。例如：EXPOSE 80 443</td>
</tr>
<tr>
<td>ENV</td>
<td>设置容器内环境变量。例如：ENV MYSQL_ROOT_PASSWORD 123456</td>
</tr>
<tr>
<td>ADD</td>
<td>拷贝文件或目录到镜像，如果是URL或压缩包会自动下载或自动解压。ADD <src>… <dest>，ADD <a href="https://xxx.com/html.tar.gz">https://xxx.com/html.tar.gz</a> &#x2F;var&#x2F;www&#x2F;html</dest></src></td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝文件或目录到镜像。例如：COPY .&#x2F;start.sh &#x2F;start.sh</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>运行容器时执行的Shell命令。例如：例如：ENTRYPOINT [“&#x2F;bin&#x2F;bash”, “-c”, “&#x2F;start.sh”]，ENTRYPOINT &#x2F;bin&#x2F;bash -c ‘&#x2F;start.sh’</td>
</tr>
<tr>
<td>VOLUME</td>
<td>指定容器挂载点到宿主机自动生成的目录或其他容器。例如：例如：VOLUME [“&#x2F;var&#x2F;lib&#x2F;mysql”]</td>
</tr>
<tr>
<td>USER</td>
<td>为RUN、CMD和ENTRYPOINT执行命令指定运行用户为RUN、CMD和ENTRYPOINT执行命令指定运行用户USER <user>[:<group>] or USER <UID>[:<GID>]。例如：USER neozhang</GID></UID></group></user></td>
</tr>
<tr>
<td>WORKDIR</td>
<td>为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录。例如：WORKDIR &#x2F;data</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查。HEALTHCHECK –interval&#x3D;5m –timeout&#x3D;3s –retries&#x3D;3 \ CMD curl -f <a href="http://localhost/">http://localhost/</a></td>
</tr>
<tr>
<td>ARG</td>
<td>在构建镜像时指定一些参数。例如：FROM centos:6，ARG user # ARG user&#x3D;root，USER $user ，# docker build –build-arg user&#x3D;lizhenliang Dockerfile .</td>
</tr>
</tbody></table>
<h2 id="Build镜像命令"><a href="#Build镜像命令" class="headerlink" title="Build镜像命令"></a>Build镜像命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:  docker image build [OPTIONS] PATH | URL | -</span><br><span class="line">Options:</span><br><span class="line">-t, --tag list     # 镜像名称</span><br><span class="line">-f, --file string  # 指定Dockerfile文件位置</span><br></pre></td></tr></table></figure>

<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build .</span><br><span class="line">docker build -t shykes/myapp .</span><br><span class="line">docker build -t shykes/myapp -f /path/Dockerfile /path</span><br></pre></td></tr></table></figure>

<h2 id="构建PHP网站环境镜像"><a href="#构建PHP网站环境镜像" class="headerlink" title="构建PHP网站环境镜像"></a>构建PHP网站环境镜像</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">centos:7</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">www.aliangedu.com</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">gcc</span> <span class="string">gcc-c++</span> <span class="string">make</span> <span class="string">openssl-devel</span> <span class="string">pcre-devel</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">nginx-1.12.1.tar.gz</span> <span class="string">/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">cd</span> <span class="string">/tmp/nginx-1.12.1</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">./configure</span> <span class="string">--prefix=/usr/local/nginx</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">-j</span> <span class="number">2</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/nginx-1.12.1*</span> <span class="string">&amp;&amp;</span> <span class="string">yum</span> <span class="string">clean</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">nginx.conf</span> <span class="string">/usr/local/nginx/conf</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/usr/local/nginx</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="string">CMD</span> [<span class="string">&quot;./sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">centos:7</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">www.aliangedu.com</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">gcc</span> <span class="string">gcc-c++</span> <span class="string">make</span> <span class="string">gd-devel</span> <span class="string">libxml2-devel</span> <span class="string">libcurl-devel</span> <span class="string">libjpeg-devel</span> <span class="string">libpng-devel</span> <span class="string">openssl-devel</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">php-5.6.31.tar.gz</span> <span class="string">/tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">cd</span> <span class="string">/tmp/php-5.6.31</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">./configure</span> <span class="string">--prefix=/usr/local/php</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--with-config-file-path=/usr/local/php/etc</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--with-mysql</span> <span class="string">--with-mysqli</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--with-openssl</span> <span class="string">--with-zlib</span> <span class="string">--with-curl</span> <span class="string">--with-gd</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--with-jpeg-dir</span> <span class="string">--with-png-dir</span> <span class="string">--with-iconv</span> <span class="string">\</span></span><br><span class="line">    <span class="string">--enable-fpm</span> <span class="string">--enable-zip</span> <span class="string">--enable-mbstring</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">-j</span> <span class="number">4</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">cp</span> <span class="string">/usr/local/php/etc/php-fpm.conf.default</span> <span class="string">/usr/local/php/etc/php-fpm.conf</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/127.0.0.1/0.0.0.0/&quot;</span> <span class="string">/usr/local/php/etc/php-fpm.conf</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;21a \daemonize = no&quot;</span> <span class="string">/usr/local/php/etc/php-fpm.conf</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">php.ini</span> <span class="string">/usr/local/php/etc</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/php-5.6.31*</span> <span class="string">&amp;&amp;</span> <span class="string">yum</span> <span class="string">clean</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/usr/local/php</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">9000</span></span><br><span class="line"><span class="string">CMD</span> [<span class="string">&quot;./sbin/php-fpm&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/usr/local/php/etc/php-fpm.conf&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network create lnmp</span><br></pre></td></tr></table></figure>

<h3 id="创建PHP容器"><a href="#创建PHP容器" class="headerlink" title="创建PHP容器"></a>创建PHP容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name lnmp_php \</span><br><span class="line">--net lnmp \</span><br><span class="line">--mount type=bind,src=/app/wwwroot/,dst=/usr/local/nginx/html \</span><br><span class="line">php:v1</span><br></pre></td></tr></table></figure>

<h3 id="创建Nginx容器"><a href="#创建Nginx容器" class="headerlink" title="创建Nginx容器"></a>创建Nginx容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name lnmp_nginx \</span><br><span class="line">--net lnmp \</span><br><span class="line">--mount type=bind,src=/app/wwwroot/,dst=/usr/local/nginx/html \</span><br><span class="line">nginx:v1</span><br></pre></td></tr></table></figure>

<h3 id="创建MySQL容器"><a href="#创建MySQL容器" class="headerlink" title="创建MySQL容器"></a>创建MySQL容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name lnmp_mysql \</span><br><span class="line">--net lnmp \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--mount src=mysql-vol,dst=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql --character-set-server=utf8</span><br></pre></td></tr></table></figure>

<h2 id="构建JAVA网站环境镜像"><a href="#构建JAVA网站环境镜像" class="headerlink" title="构建JAVA网站环境镜像"></a>构建JAVA网站环境镜像</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">centos:7</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">www.aliangedu.com</span> </span><br><span class="line"></span><br><span class="line"><span class="string">ADD</span> <span class="string">jdk-8u45-linux-x64.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">JAVA_HOME</span> <span class="string">/usr/local/jdk1.8.0_45</span></span><br><span class="line"></span><br><span class="line"><span class="string">ADD</span> <span class="string">apache-tomcat-8.0.46.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">server.xml</span> <span class="string">/usr/local/apache-tomcat-8.0.46/conf</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">/usr/local/*.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/usr/local/apache-tomcat-8.0.46</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="string">ENTRYPOINT</span> [<span class="string">&quot;./bin/catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name=tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">--mount type=bind,src=/app/webapps/,dst=/usr/local/apache-tomcat-8.0.46/webapps \</span><br><span class="line">tomcat:v1</span><br></pre></td></tr></table></figure>

<h1 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h1><p>Harbor是VMware公司开源的企业级Docker Registry项目  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.docker.com/">Docker官方文档</a><br>阿里云源:<a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a>  </p>
]]></content>
      <categories>
        <category>LearnDocker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>一天入门Kubernetes</title>
    <url>/2022/02/27/one-day-to-know-kubernetes/</url>
    <content><![CDATA[<h1 id="快速搭建一个Kubernetes集群"><a href="#快速搭建一个Kubernetes集群" class="headerlink" title="快速搭建一个Kubernetes集群"></a>快速搭建一个Kubernetes集群</h1><p><a href="https://"></a>  </p>
<h2 id="kubectl命令行管理工具"><a href="#kubectl命令行管理工具" class="headerlink" title="kubectl命令行管理工具"></a>kubectl命令行管理工具</h2><p>基础命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>通过文件名或标准输入创建资源</td>
</tr>
<tr>
<td>expose</td>
<td>将一个资源公开为一个新的Service</td>
</tr>
<tr>
<td>run</td>
<td>在集群中运行一个特定的镜像</td>
</tr>
<tr>
<td>set</td>
<td>在对象上设置特定的功能</td>
</tr>
<tr>
<td>get</td>
<td>显示一个或多个资源</td>
</tr>
<tr>
<td>explain</td>
<td>文档参考资料</td>
</tr>
<tr>
<td>edit</td>
<td>使用默认的编辑器编辑一个资源</td>
</tr>
<tr>
<td>delete</td>
<td>通过文件名、标准输入、资源名称或标签选择器来删除资源</td>
</tr>
</tbody></table>
<p>部署命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rollout</td>
<td>管理资源的发布</td>
</tr>
<tr>
<td>rolling-update</td>
<td>对给定的复制控制器滚动更新</td>
</tr>
<tr>
<td>scale</td>
<td>扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td>
</tr>
<tr>
<td>autoscale</td>
<td>创建一个自动选择扩容或缩容并设置Pod数量</td>
</tr>
</tbody></table>
<p>集群管理命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>certificate</td>
<td>修改证书资源</td>
</tr>
<tr>
<td>cluster-info</td>
<td>显示集群信息</td>
</tr>
<tr>
<td>top</td>
<td>显示资源（CPU&#x2F;Memory&#x2F;Storage使用，需要Heapster运行</td>
</tr>
<tr>
<td>cordon</td>
<td>标记节点不可调度</td>
</tr>
<tr>
<td>uncordon</td>
<td>标记节点可调度</td>
</tr>
<tr>
<td>drain</td>
<td>驱逐节点上的应用，准备下线维护</td>
</tr>
<tr>
<td>taint</td>
<td>修改节点taint标记</td>
</tr>
</tbody></table>
<p>故障诊断和调试命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>describe</td>
<td>显示特定资源或资源组的详细信息</td>
</tr>
<tr>
<td>logs</td>
<td>在一个Pod中打印一个容器日志。如果Pod只有一个容器，容器名称是可选的</td>
</tr>
<tr>
<td>attach</td>
<td>附加到一个运行的容器</td>
</tr>
<tr>
<td>exec</td>
<td>执行命令到容器</td>
</tr>
<tr>
<td>port-forward</td>
<td>转发一个或多个本地端口到一个pod</td>
</tr>
<tr>
<td>uncordon</td>
<td>标记节点可调度</td>
</tr>
<tr>
<td>proxy</td>
<td>运行一个proxy到Kubernetes API server</td>
</tr>
<tr>
<td>cp</td>
<td>拷贝文件或目录到容器中</td>
</tr>
<tr>
<td>auth</td>
<td>检查授权</td>
</tr>
</tbody></table>
<p>高级命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>apply</td>
<td>通过文件名或标准输入对资源应用配置</td>
</tr>
<tr>
<td>patch</td>
<td>使用补丁修改、更新资源的字段</td>
</tr>
<tr>
<td>replace</td>
<td>通过文件名或标准输入替换一个资源</td>
</tr>
<tr>
<td>convert</td>
<td>不同的API版本之间转换配置文件</td>
</tr>
</tbody></table>
<p>设置命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>更新资源上的标签</td>
</tr>
<tr>
<td>annotate</td>
<td>更新资源上的注释</td>
</tr>
<tr>
<td>completion</td>
<td>用于实现kubectl工具自动补全</td>
</tr>
</tbody></table>
<p>其他命令  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>api-versions</td>
<td>打印受支持的API版本</td>
</tr>
<tr>
<td>config</td>
<td>修改kubeconfig文件（用于访问API，比如配置认证信息</td>
</tr>
<tr>
<td>help</td>
<td>所有命令帮助</td>
</tr>
<tr>
<td>plugin</td>
<td>运行一个命令行插件</td>
</tr>
<tr>
<td>version</td>
<td>打印客户端和服务版本信息</td>
</tr>
</tbody></table>
<h1 id="在Kubernetes中部署Java应用"><a href="#在Kubernetes中部署Java应用" class="headerlink" title="在Kubernetes中部署Java应用"></a>在Kubernetes中部署Java应用</h1><h2 id="项目迁移到K8S平台是怎样的流程"><a href="#项目迁移到K8S平台是怎样的流程" class="headerlink" title="项目迁移到K8S平台是怎样的流程"></a>项目迁移到K8S平台是怎样的流程</h2><ul>
<li>1，制作镜像  </li>
<li>2，控制器管理Pod  </li>
<li>3，暴露应用  </li>
<li>4，对外发布应用  </li>
<li>5，日志监控</li>
</ul>
<h2 id="Kubernetes基本概念"><a href="#Kubernetes基本概念" class="headerlink" title="Kubernetes基本概念"></a>Kubernetes基本概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul>
<li>最小部署单元  </li>
<li>一组容器的集合  </li>
<li>一个Pod中的容器共享网络命名空间  </li>
<li>Pod是短暂的</li>
</ul>
<h3 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h3><ul>
<li>Deployment：无状态应用部署  </li>
<li>StatefulSet：有状态应用部署  </li>
<li>DaemonSet：确保所有Node运行同一个Pod  </li>
<li>Job：一次性任务  </li>
<li>Cronjob：定时任务</li>
</ul>
<p>更高级层次对象，部署和管理Pod  </p>
<ul>
<li>Label：标签，附加到某个资源上，用于关联对象、查询和筛选  </li>
<li>Namespaces：命名空间，将对象逻辑上隔离</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul>
<li>防止Pod失联  </li>
<li>定义一组Pod的访问策略</li>
</ul>
<h2 id="构建项目镜像"><a href="#构建项目镜像" class="headerlink" title="构建项目镜像"></a>构建项目镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: docker build [OPTIONS] PATH | URL | - [flags]</span><br><span class="line">Options:</span><br><span class="line">-t, --tag list</span><br><span class="line"># 镜像名称</span><br><span class="line">-f, --file string # 指定Dockerfile文件位置</span><br><span class="line"># docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure>

<p>例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">LABEL maintalner lizhenliang</span><br><span class="line">RUN yum install gcc -y</span><br><span class="line">COPY run.sh /usr/bin</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [“run.sh”]</span><br></pre></td></tr></table></figure>

<h2 id="在Kubernetes中部署应用"><a href="#在Kubernetes中部署应用" class="headerlink" title="在Kubernetes中部署应用"></a>在Kubernetes中部署应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx:1.16 -o yaml --dry-run&gt; deploy.yaml</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort -o yaml --dry-run &gt; svc.yaml</span><br></pre></td></tr></table></figure>

<h1 id="理解Pod对象"><a href="#理解Pod对象" class="headerlink" title="理解Pod对象"></a>理解Pod对象</h1><h2 id="Pod基本概念"><a href="#Pod基本概念" class="headerlink" title="Pod基本概念"></a>Pod基本概念</h2><ul>
<li>最小部署单元  </li>
<li>一组容器的集合  </li>
<li>一个Pod中的容器共享网络命名空间与存储  </li>
<li>Pod是短暂的</li>
</ul>
<h2 id="Pod存在的意义"><a href="#Pod存在的意义" class="headerlink" title="Pod存在的意义"></a>Pod存在的意义</h2><p>Pod为亲密性应用而存在。  </p>
<p>亲密性应用场景：  </p>
<ul>
<li>两个应用之间发生文件交互  </li>
<li>两个应用需要通过127.0.0.1或者socket通信  </li>
<li>两个应用需要发生频繁的调用</li>
</ul>
<h2 id="Pod实现机制"><a href="#Pod实现机制" class="headerlink" title="Pod实现机制"></a>Pod实现机制</h2><ul>
<li>共享网络  </li>
<li>共享存储</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">write</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">centos</span></span><br><span class="line"><span class="attr">command:</span> [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in &#123;1..100&#125;;do echo $i &gt;&gt; /data/hello;sleep 1;done&quot;</span>]</span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">read</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">centos</span></span><br><span class="line"><span class="attr">command:</span> [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /data/hello&quot;</span>]</span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pod容器分类与设计模式"><a href="#Pod容器分类与设计模式" class="headerlink" title="Pod容器分类与设计模式"></a>Pod容器分类与设计模式</h2><ul>
<li><p>Infrastructure Container：基础容器<br>维护整个Pod网络空间  </p>
</li>
<li><p>InitContainers：初始化容器<br>先于业务容器开始执行  </p>
</li>
<li><p>Containers：业务容器<br>并行启动</p>
</li>
</ul>
<h2 id="Pod-Template常用功能字段解析"><a href="#Pod-Template常用功能字段解析" class="headerlink" title="Pod Template常用功能字段解析"></a>Pod Template常用功能字段解析</h2><ul>
<li>变量  </li>
<li>拉取镜像  </li>
<li>资源限制  </li>
<li>健康检查</li>
</ul>
<h1 id="最常用的控制器-Deployment"><a href="#最常用的控制器-Deployment" class="headerlink" title="最常用的控制器 Deployment"></a>最常用的控制器 Deployment</h1><h2 id="Pod与controllers的关系"><a href="#Pod与controllers的关系" class="headerlink" title="Pod与controllers的关系"></a>Pod与controllers的关系</h2><ul>
<li>controllers：在集群上管理和运行容器的对象  </li>
<li>通过label-selector相关联  </li>
<li>Pod通过控制器实现应用的运维，如伸缩，滚动升级等</li>
</ul>
<p><img src="/2022/02/27/one-day-to-know-kubernetes/pod%E4%B8%8Econtrollers%E7%9A%84%E5%85%B3%E7%B3%BB.png">  </p>
<h2 id="Deployment功能与应用场景"><a href="#Deployment功能与应用场景" class="headerlink" title="Deployment功能与应用场景"></a>Deployment功能与应用场景</h2><ul>
<li>部署无状态应用  </li>
<li>管理Pod和ReplicaSet  </li>
<li>具有上线部署、副本设定、滚动升级、回滚等功能  </li>
<li>提供声明式更新，例如只更新一个新的Image</li>
</ul>
<p>应用场景：Web服务，微服务  </p>
<h2 id="YAML字段解析"><a href="#YAML字段解析" class="headerlink" title="YAML字段解析"></a>YAML字段解析</h2><p><img src="/2022/02/27/one-day-to-know-kubernetes/yaml%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90.png">  </p>
<h2 id="使用Deployment部署一个应用"><a href="#使用Deployment部署一个应用" class="headerlink" title="使用Deployment部署一个应用"></a>使用Deployment部署一个应用</h2><p>创建  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=nginx:1.14</span><br><span class="line">kubectl get deploy,pods</span><br></pre></td></tr></table></figure>

<p>发布  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment web --port=80 --type=NodePort --target-port=80 --name=web</span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>

<h2 id="升级与回滚"><a href="#升级与回滚" class="headerlink" title="升级与回滚"></a>升级与回滚</h2><p>升级  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/web nginx=nginx:1.15</span><br><span class="line"># 查看升级状态</span><br><span class="line">kubectl rollout status deployment/web</span><br></pre></td></tr></table></figure>

<p>回滚  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout history deployment/web</span><br><span class="line">kubectl rollout undo deployment/web</span><br><span class="line">kubectl rollout undo deployment/web --revision=2</span><br></pre></td></tr></table></figure>

<h2 id="应用弹性伸缩"><a href="#应用弹性伸缩" class="headerlink" title="应用弹性伸缩"></a>应用弹性伸缩</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas=10</span><br></pre></td></tr></table></figure>

<h1 id="Service-统一入口访问应用"><a href="#Service-统一入口访问应用" class="headerlink" title="Service 统一入口访问应用"></a>Service 统一入口访问应用</h1><h2 id="Service-存在的意义"><a href="#Service-存在的意义" class="headerlink" title="Service 存在的意义"></a>Service 存在的意义</h2><ul>
<li>防止Pod失联（服务发现）  </li>
<li>定义一组Pod的访问策略（负载均衡）</li>
</ul>
<h2 id="Pod与Service的关系"><a href="#Pod与Service的关系" class="headerlink" title="Pod与Service的关系"></a>Pod与Service的关系</h2><ul>
<li>通过label-selector相关联  </li>
<li>通过Service实现Pod的负载均衡（ TCP&#x2F;UDP 4层）</li>
</ul>
<p><img src="/2022/02/27/one-day-to-know-kubernetes/pod%E4%B8%8Eservice%E5%85%B3%E7%B3%BB.png">  </p>
<h2 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h2><p><img src="/2022/02/27/one-day-to-know-kubernetes/service%E7%B1%BB%E5%9E%8B.png">  </p>
<ul>
<li><p>ClusterIP：分配一个内部集群IP地址，只能在集群内部访问（同Namespace内的Pod），默认ServiceType。<br>ClusterIP 模式的 Service 为你提供的，就是一个 Pod 的稳定的 IP 地址，即 VIP。  </p>
</li>
<li><p>NodePort：分配一个内部集群IP地址，并在每个节点上启用一个端口来暴露服务，可以在集群外部访问。<br>访问地址：<NodeIP>:<NodePort>  </NodePort></NodeIP></p>
</li>
<li><p>LoadBalancer：分配一个内部集群IP地址，并在每个节点上启用一个端口来暴露服务。<br>除此之外，Kubernetes会请求底层云平台上的负载均衡器，将每个Node（[NodeIP]:[NodePort]）作为后端添加进去。</p>
</li>
</ul>
<h1 id="Ingress-对外暴露你的应用"><a href="#Ingress-对外暴露你的应用" class="headerlink" title="Ingress 对外暴露你的应用"></a>Ingress 对外暴露你的应用</h1><h2 id="Pod与Ingress的关系"><a href="#Pod与Ingress的关系" class="headerlink" title="Pod与Ingress的关系"></a>Pod与Ingress的关系</h2><ul>
<li>通过Service关联Pod  </li>
<li>基于域名访问  </li>
<li>通过Ingress Controller实现Pod的负载均衡  </li>
<li>支持TCP&#x2F;UDP 4层和HTTP 7层</li>
</ul>
<p><img src="/2022/02/27/one-day-to-know-kubernetes/pod%E4%B8%8Eingress%E5%85%B3%E7%B3%BB.png">  </p>
<h2 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h2><p><img src="/2022/02/27/one-day-to-know-kubernetes/ingress-controller.png">  </p>
<ul>
<li>部署Ingress Controller  </li>
<li>创建Ingress规则</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">example.ctnrs.com</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line"><span class="attr">serviceName:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LearnKubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>OneX部署</title>
    <url>/2024/04/04/onex-deploy/</url>
    <content><![CDATA[<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>确定机器上已具备以下部署条件：  </p>
<ul>
<li>2c4g  </li>
<li>Docker</li>
</ul>
<h1 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h1><p>在Debian 12环境下  </p>
<h2 id="下载-OneX-源码"><a href="#下载-OneX-源码" class="headerlink" title="下载 OneX 源码"></a>下载 OneX 源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/superproj/onex</span><br></pre></td></tr></table></figure>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入onex目录</span></span><br><span class="line">cd onex/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器部署</span></span><br><span class="line">make docker-install</span><br></pre></td></tr></table></figure>

<p>成功标志<br><img src="/2024/04/04/onex-deploy/onex-deploy.jpg">  </p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h2 id="kubectl安装超时"><a href="#kubectl安装超时" class="headerlink" title="kubectl安装超时"></a>kubectl安装超时</h2><p>原因是墙的问题，可以换成国内源，再安装kubectl即可，onex部署程序会检测是否安装kubectl，如果已安装kubectl，就跳过执行下一步。<br>参考<a href="https://octopuslian.github.io/2022/02/27/deploy-a-kubernetes-cluster-in-30-minnutes/">安装部署一个kubernetes集群-添加源这一章节</a></p>
<h2 id="无法安装mongodb"><a href="#无法安装mongodb" class="headerlink" title="无法安装mongodb"></a>无法安装mongodb</h2><p>参考- <a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/">在 Debian 上安装 MongoDB 社区版</a>  ，执行命令即可。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/superproj/onex">Github OneX</a>  </li>
<li><a href="https://konglingfei.com/onex/installation/docker.html">如何使用 Docker 快速部署 OneX 项目？</a>  </li>
<li><a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/">在 Debian 上安装 MongoDB 社区版</a></li>
</ul>
]]></content>
      <categories>
        <category>LearnOneX</category>
      </categories>
      <tags>
        <tag>onex</tag>
      </tags>
  </entry>
  <entry>
    <title>在噩梦中睁眼</title>
    <url>/2021/07/25/open-eyes-in-nightmare/</url>
    <content><![CDATA[<p>如果在噩梦中睁眼  </p>
<p>直面着残忍的世界  </p>
<p>风拨动了谁的心弦  </p>
<p>留恋却来不及告别  </p>
<p>如果结局仅剩惨烈  </p>
<p>无惧在逆风中破茧  </p>
<p>就算那羽翼被撕裂  </p>
<p>重回到十九层深渊  </p>
<p>  ——张韶涵《破茧》  </p>
<h2 id="社会大学的一堂课"><a href="#社会大学的一堂课" class="headerlink" title="社会大学的一堂课"></a>社会大学的一堂课</h2><p>这两周，社会大学在我的职场生涯里上了很重要的一课。  </p>
<p>简单来说，就是如何在试用期的时候最大化榨取其剩余价值，并在即将转正的时候，及时止损，然后以其他理由迅速解除劳动关系。操作行云流水，不得不服。  </p>
<p>而我当时有两条路可以选择；(1)走劳动仲裁；(2)赶紧找下家。  </p>
<p>走(1)，就要想好离开这座城市的打算，毕竟企业有时间和你耗，而我要考虑社保断缴、公积金断缴、职场生涯的重新规划等等；走(2)就方便许多，只是确实累。我记得，从上周二到这周二，是我有史以来跳槽效率最高的一次，一天时间写简历、回顾常考技术面试题，做好自我介绍，两天时间边投简历边沟通约面试时间，剩下两天就争取先拿个<code>offer</code>保底，总计用时4.5天。  </p>
<p>下面我就来总结一下这次面试的收获吧。  </p>
<ul>
<li>关于写简历：最好黑白，推荐用<a href="https://www.wondercv.com/">超级简历</a>来做，同时最好在每个工作经历附上工作业绩，项目后也附上项目业绩，最好有数字支撑，让招聘者一目了然。在此非常感谢好友<code>lzd</code>的耐心指导。  </li>
<li>关于筛选公司：想好自己要去什么样的公司，如果没想好，就先排除自己一定不去什么样的公司，比如离家15km以上的、外包需要出差驻场的、薪资低于最低期望的等等，这样可以有效节约面试的时间。  </li>
<li>关于约面试：我基本上是上午一场、下午一场，上午的一般选择小公司来热身，下午的是需要正常甚至要超常发挥的面试，所以分清主次，如果可能要迟到，提前给招聘者说明原因即可。  </li>
<li>关于技术面试：由于我面试的是<code>Golang</code>后端和云原生方向，所以编程语言基础、数据库、网络、基础算法是常考的，然后可能会问一些<code>Docker</code>和<code>k8s</code>的使用，最后会问一些项目上的问题，感觉要是提前好好准备，卡的概率不大。  </li>
<li>关于非技术面试：非技术面试，主要考察你对这个岗位的稳定性，以及后续是否能产生期望的价值，这就需要平时想想自己未来的职业规划啊、以及技术的沉淀了。</li>
</ul>
<h2 id="这次跳槽的收获"><a href="#这次跳槽的收获" class="headerlink" title="这次跳槽的收获"></a>这次跳槽的收获</h2><ul>
<li>一定要做好<code>Plan B</code>，即使你已经有90%的把握了；  </li>
<li>如果遇到最坏的情况，一定不要慌，冷静分析，及时止损；  </li>
<li>工作了，要将自己做的事情，时刻与项目、公司做好关联，从中找到可以体现的价值，就是所谓的核心竞争力，只有你能做，别人做不了的事情；  </li>
<li>保持好心态，虽然有时候生活确实会打的自己措手不及。</li>
</ul>
<h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>我记得小时候，我在外面打架，回来会告诉父母，让他们护着我，有时候把别人打哭了，我也会跑回家，让父母跟别人道歉，自己则认为是正确的。  </p>
<p>长大了，才愈加发觉父母当时管孩子的艰辛，一个小时没有回家，就着急的满巷子找我，至今记得父亲的大嗓门，方圆方圆3公里基本都能听得到…找到你了，是又气又怕，气的是你让我们找了老半天，怕的是你被坏人拐跑，也许这就是爱吧。  </p>
<p>2021年3月，我去见了我的高中物理老师，她说，七年了，感觉你肩膀宽了，能承事了，我笑了笑说有吗？我记得，高三那会，还是一个做不出压轴题、排名升不上年级前100的中等生，只是，七年，足以改变一个人。  </p>
<p>当我被卸磨杀驴式的告知试用期不合适(即使业务都已经熟练，负责的功能模块也没问题)，我算了下，呀，还有不到十天的时间找下家，来得及吗？晚上父亲打来视频电话，还问我工作顺利不，应该快转正了吧，，我咬着牙说：是的。因为我知道，即使告诉他们我不能转正，他们也帮助不了我什么，顶多就是那句：要不别上班了，回家呆上几个月，我们养着你…  </p>
<p>也许，我就是要试试突破这该死的诅咒呢。幸运的是，我成功了。  </p>
<p>从投简历后的第三天，拿到<code>offer</code>，到后面一些大厂抛来的橄榄枝，我知道，我还是有些价值是上家公司看不到的，也许这才是我可以和他们拉开差距的关键吧。  </p>
<h2 id="绝处逢生见招拆招"><a href="#绝处逢生见招拆招" class="headerlink" title="绝处逢生见招拆招"></a>绝处逢生见招拆招</h2><p>新工作，告别增删改查似的<code>Web</code>后端开发，去做一个全新的领域——云存储，虽然不知前路坎坷有多少，但打不死我的终将会让我变的更强。  </p>
<p>感谢这次经历，是你让我变得更加理性，由浪漫主义逐渐向现实主义做切换，我想这才是一个合格职场人所具备的一个<code>BUFF</code>。  </p>
<p>最后：感谢女友精湛的拍照技术和<code>PS</code>，让我在简历上一下子感觉精神了许多；感谢川大学长<code>lzd</code>的简历指导意见，很实用，基本改完后一投递就约面试；感谢自己的不放弃不妥协的精神，让我顺利在简历的加持下拿上一个满意的<code>Offer</code>。  </p>
<p>GOOD LUCK~</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>职场</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>痛并成长着</title>
    <url>/2019/03/18/pain-and-growth/</url>
    <content><![CDATA[<p>三月，对我来说是一个特殊的月份，特殊在:  </p>
<ul>
<li>转正通过，开始接手公司项目;  </li>
<li>月底我将23岁，每当这个时候，我都会感到莫名其妙的沉默寡言。</li>
</ul>
<p>上一周感觉过得很艰难，很充实，因为自己不会的很多，得一个个去补。  </p>
<p>杨说叫我把B站上的20小时快速入门Go语言课程从新再系统学习一遍，虽然我觉得之前都接触过，但我还是欣然接受。现在课程已经过半，让我真正意识到，忘记自己曾经以为对的东西，推到重来，反而会有新的收获，也许这就是温故而知新吧。  </p>
<p>这周很荣幸加入了Go语言中文网创始人创办的知识星球，与无闻，轩辕刃这些大佬一起学习Go语言，探究底层的本质。  </p>
<p>技术文章我仍旧会继续坚持写下去，但我会逐渐摒弃数量，追求质量。  </p>
<p>上周六和一位朋友去看漫展，然后去逛街，疯玩了一天，身心放松了下来，很是开心，让我忘却了工作上的烦恼。  </p>
<p>我一直坚信，天将降大任于斯人也，必先苦其心智，饿其筋骨，劳其体肤…  </p>
<p>加油!扛过去，胜利就在前方。  </p>
<p><img src="/2019/03/18/pain-and-growth/whale.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>工作</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>Open Horizon 快速入门</title>
    <url>/2024/03/04/open-horizon-quick-start/</url>
    <content><![CDATA[<h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><p>两台服务器，配置如下：  </p>
<ul>
<li>4GB以上的内存  </li>
<li>20GB以上的存储  </li>
<li>Ubuntu Server 18.04 LTS</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>确保是<code>root</code>权限  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">curl -sSL https://raw.githubusercontent.com/open-horizon/devops/master/mgmt-hub/deploy-mgmt-hub.sh | bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当出现以下信息，表示安装成功</span></span><br><span class="line">----------- Summary of what was done:</span><br><span class="line">  1. Started Horizon management hub services: Agbot, CSS, Exchange, FDO, Mongo DB, Postgres DB, Postgres DB FDO, Vault</span><br><span class="line">  2. Created exchange resources: system organization (IBM) admin user, user organization (myorg) and admin user, and agbot</span><br></pre></td></tr></table></figure>

<h2 id="查看-CLI-和代理版本号"><a href="#查看-CLI-和代理版本号" class="headerlink" title="查看 CLI 和代理版本号"></a>查看 CLI 和代理版本号</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn version</span></span><br><span class="line">Horizon CLI version: 2.30.0-1491</span><br><span class="line">Horizon Agent version: 2.30.0-1491</span><br></pre></td></tr></table></figure>

<h1 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h1><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test-mgmt-hub.sh</span><br></pre></td></tr></table></figure>

<h2 id="查看边缘节点的状态"><a href="#查看边缘节点的状态" class="headerlink" title="查看边缘节点的状态"></a>查看边缘节点的状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn node list</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;node1&quot;,</span><br><span class="line">  &quot;organization&quot;: &quot;myorg&quot;,</span><br><span class="line">  &quot;pattern&quot;: &quot;&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;node1&quot;,</span><br><span class="line">  &quot;nodeType&quot;: &quot;device&quot;,</span><br><span class="line">  &quot;clusterNamespace&quot;: null,</span><br><span class="line">  &quot;token_last_valid_time&quot;: &quot;2024-03-11 02:17:27 +0000 UTC&quot;,</span><br><span class="line">  &quot;token_valid&quot;: true,</span><br><span class="line">  &quot;ha_group&quot;: &quot;&quot;,</span><br><span class="line">  &quot;configstate&quot;: &#123;</span><br><span class="line">    &quot;state&quot;: &quot;configured&quot;,</span><br><span class="line">    &quot;last_update_time&quot;: &quot;2024-03-11 02:17:27 +0000 UTC&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;configuration&quot;: &#123;</span><br><span class="line">    &quot;exchange_api&quot;: &quot;http://192.168.1.208:3090/v1/&quot;,</span><br><span class="line">    &quot;exchange_version&quot;: &quot;2.122.0&quot;,</span><br><span class="line">    &quot;required_minimum_exchange_version&quot;: &quot;2.90.1&quot;,</span><br><span class="line">    &quot;preferred_exchange_version&quot;: &quot;2.110.1&quot;,</span><br><span class="line">    &quot;mms_api&quot;: &quot;http://192.168.1.208:9443&quot;,</span><br><span class="line">    &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">    &quot;horizon_version&quot;: &quot;2.31.0-1498&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看为运行-helloworld-边缘服务示例而达成的协议"><a href="#查看为运行-helloworld-边缘服务示例而达成的协议" class="headerlink" title="查看为运行 helloworld 边缘服务示例而达成的协议"></a>查看为运行 helloworld 边缘服务示例而达成的协议</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn agreement list</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Policy for myorg/node1 merged with myorg/policy-ibm.helloworld_1.0.0&quot;,</span><br><span class="line">    &quot;current_agreement_id&quot;: &quot;be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff&quot;,</span><br><span class="line">    &quot;consumer_id&quot;: &quot;IBM/agbot&quot;,</span><br><span class="line">    &quot;agreement_creation_time&quot;: &quot;2024-03-11 02:17:39 +0000 UTC&quot;,</span><br><span class="line">    &quot;agreement_accepted_time&quot;: &quot;2024-03-11 02:17:43 +0000 UTC&quot;,</span><br><span class="line">    &quot;agreement_finalized_time&quot;: &quot;2024-03-11 02:17:43 +0000 UTC&quot;,</span><br><span class="line">    &quot;agreement_execution_start_time&quot;: &quot;2024-03-11 02:17:45 +0000 UTC&quot;,</span><br><span class="line">    &quot;agreement_data_received_time&quot;: &quot;&quot;,</span><br><span class="line">    &quot;agreement_protocol&quot;: &quot;Basic&quot;,</span><br><span class="line">    &quot;workload_to_run&quot;: &#123;</span><br><span class="line">      &quot;url&quot;: &quot;ibm.helloworld&quot;,</span><br><span class="line">      &quot;org&quot;: &quot;IBM&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">      &quot;arch&quot;: &quot;amd64&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="查看Horizo启动的边缘服务容器"><a href="#查看Horizo启动的边缘服务容器" class="headerlink" title="查看Horizo启动的边缘服务容器"></a>查看Horizo启动的边缘服务容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                                         COMMAND                  CREATED          STATUS                    PORTS                                                                                  NAMES</span><br><span class="line">b6f00808639f   openhorizon/ibm.helloworld_amd64              &quot;/bin/sh -c /service…&quot;   25 minutes ago   Up 25 minutes                                                                                                    be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff-ibm.helloworld</span><br><span class="line">676698c249c6   openhorizon/fdo-owner-services:testing        &quot;/bin/sh -c $WORKDIR…&quot;   29 minutes ago   Up 29 minutes (healthy)   0.0.0.0:8042-&gt;8042/tcp, :::8042-&gt;8042/tcp, 0.0.0.0:9008-&gt;9008/tcp, :::9008-&gt;9008/tcp   fdo-owner-services</span><br><span class="line">3ca1dc37e978   openhorizon/amd64_agbot:latest                &quot;/bin/sh -c /usr/hor…&quot;   29 minutes ago   Up 29 minutes (healthy)   127.0.0.1:3110-&gt;8080/tcp, 192.168.1.208:3111-&gt;8083/tcp                                 agbot</span><br><span class="line">90265cba1f70   openhorizon/amd64_cloud-sync-service:latest   &quot;/usr/edge-sync-serv…&quot;   29 minutes ago   Up 29 minutes (healthy)   192.168.1.208:9443-&gt;8080/tcp                                                           css-api</span><br><span class="line">a49f896ac063   openhorizon/amd64_vault:latest                &quot;entrypoint.sh server&quot;   29 minutes ago   Up 29 minutes (healthy)   192.168.1.208:8200-&gt;8200/tcp                                                           vault</span><br><span class="line">3c99de720e83   postgres:13                                   &quot;docker-entrypoint.s…&quot;   29 minutes ago   Up 29 minutes (healthy)   0.0.0.0:5433-&gt;5432/tcp, :::5433-&gt;5432/tcp                                              postgres-fdo-owner-service</span><br><span class="line">ec4293468239   openhorizon/amd64_exchange-api:latest         &quot;/bin/sh -c &#x27;/usr/bi…&quot;   29 minutes ago   Up 29 minutes (healthy)   8083/tcp, 192.168.1.208:3090-&gt;8080/tcp                                                 exchange-api</span><br><span class="line">a45538b25f34   mongo:4.0.6                                   &quot;docker-entrypoint.s…&quot;   32 minutes ago   Up 32 minutes (healthy)   27017/tcp                                                                              mongo</span><br><span class="line">5765c53f43be   postgres:13                                   &quot;docker-entrypoint.s…&quot;   32 minutes ago   Up 32 minutes (healthy)   0.0.0.0:5432-&gt;5432/tcp, :::5432-&gt;5432/tcp                                              postgres</span><br></pre></td></tr></table></figure>


<h2 id="查看helloworld边缘服务的日志"><a href="#查看helloworld边缘服务的日志" class="headerlink" title="查看helloworld边缘服务的日志"></a>查看helloworld边缘服务的日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn service <span class="built_in">log</span> -f ibm.helloworld</span></span><br><span class="line">Found service ibm.helloworld with service id be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff.</span><br><span class="line">Displaying log messages of container ibm.helloworld for service ibm.helloworld with service id be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff.</span><br><span class="line">Use ctrl-C to terminate this command.</span><br><span class="line">Mar 11 02:17:45 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br><span class="line">Mar 11 02:17:48 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br><span class="line">Mar 11 02:17:51 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br><span class="line">Mar 11 02:17:54 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br><span class="line">Mar 11 02:17:57 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br><span class="line">Mar 11 02:18:00 oh-3 workload-be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff_ibm.helloworld[3807]: node1 says: Hello from the EDGE!!!</span><br></pre></td></tr></table></figure>

<h2 id="查看Horizon配置"><a href="#查看Horizon配置" class="headerlink" title="查看Horizon配置"></a>查看Horizon配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/default/horizon</span></span><br><span class="line">HZN_EXCHANGE_URL=http://192.168.1.208:3090/v1</span><br><span class="line">HZN_FSS_CSSURL=http://192.168.1.208:9443/</span><br><span class="line">HZN_AGBOT_URL=http://192.168.1.208:3111</span><br><span class="line">HZN_FDO_SVC_URL=http://192.168.1.208:9008/api</span><br><span class="line">HZN_DEVICE_ID=node1</span><br><span class="line">ANAX_LOG_LEVEL=3</span><br></pre></td></tr></table></figure>

<h2 id="查看Horizon代理守护程序状态"><a href="#查看Horizon代理守护程序状态" class="headerlink" title="查看Horizon代理守护程序状态"></a>查看Horizon代理守护程序状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemctl status horizon</span></span><br><span class="line">● horizon.service - Service for Horizon control system</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/horizon.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2024-03-11 02:14:11 UTC; 34min ago</span><br><span class="line"> Main PID: 11686 (anax)</span><br><span class="line">    Tasks: 10 (limit: 4915)</span><br><span class="line">   CGroup: /system.slice/horizon.service</span><br><span class="line">           └─11686 /usr/horizon/bin/anax -v 3 -logtostderr -config /etc/horizon/anax.json</span><br><span class="line"></span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.181841   11686 changes.go:270] Exchange RPC getting 1000 changes since change ID 100 in orgs []</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.196471   11686 changes.go:308] Exchange RPC found 0 changes since ID 100 with latest change ID 99 in orgs []</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.196560   11686 exchange_changes.go:82] Successfully saved exchange change state: Change State ID: 100, last updated: 2024-03-11T02:49:00Z[UTC]</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.197466   11686 changes_worker.go:307] Exchange Changes Worker: done looking for changes</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.197499   11686 worker.go:363] CommandDispatcher: ExchangeChanges command processor non-blocking for commands</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.858885   11686 governance.go:1478] GovernanceWorker: GovernanceWorker dispatching no work handler.</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.858928   11686 governance.go:405] GovernanceWorker: governing agreements</span><br><span class="line">Mar 11 02:49:00 oh-3 anax[11686]: I0311 02:49:00.861252   11686 worker.go:363] CommandDispatcher: Governance command processor non-blocking for commands</span><br><span class="line">Mar 11 02:49:02 oh-3 anax[11686]: I0311 02:49:02.514702   11686 worker.go:480] CommandDispatcher: Running subworker SurfaceExchErrors</span><br><span class="line">Mar 11 02:49:02 oh-3 anax[11686]: I0311 02:49:02.516143   11686 worker.go:484] CommandDispatcher: Finished run of subworker SurfaceExchErrors</span><br></pre></td></tr></table></figure>

<h2 id="查看协议协商过程中执行的步骤"><a href="#查看协议协商过程中执行的步骤" class="headerlink" title="查看协议协商过程中执行的步骤"></a>查看协议协商过程中执行的步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn eventlog list</span></span><br><span class="line">  &quot;2024-03-11 02:17:27:   Start node configuration/registration for node node1.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:27:   Complete node configuration/registration for node node1.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:39:   Node received Proposal message using agreement be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff for service IBM/ibm.helloworld from the agbot IBM/agbot.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:43:   Agreement reached for service ibm.helloworld. The agreement id is be397e12deb1651d278739fefa9ff2780436878c3a9fc4f2c12b5ee4857ef5ff.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:43:   Start dependent services for IBM/ibm.helloworld.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:43:   Start workload service for IBM/ibm.helloworld.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:44:   Image loaded for IBM/ibm.helloworld.&quot;,</span><br><span class="line">  &quot;2024-03-11 02:17:45:   Workload service containers for IBM/ibm.helloworld are up and running.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看导致部署-helloworld-服务的节点策略设置"><a href="#查看导致部署-helloworld-服务的节点策略设置" class="headerlink" title="查看导致部署 helloworld 服务的节点策略设置"></a>查看导致部署 helloworld 服务的节点策略设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn policy list</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.example&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;helloworld&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.hardwareId&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;36d3acd26462630855c99dedd33a56c04e443927&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.operatingSystem&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;ubuntu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.containerized&quot;,</span><br><span class="line">      &quot;value&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.cpu&quot;,</span><br><span class="line">      &quot;value&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.arch&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;amd64&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.memory&quot;,</span><br><span class="line">      &quot;value&quot;: 7976</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;openhorizon.allowPrivileged&quot;,</span><br><span class="line">      &quot;value&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;constraints&quot;: [],</span><br><span class="line">  &quot;deployment&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: null,</span><br><span class="line">    &quot;constraints&quot;: null</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;management&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: null,</span><br><span class="line">    &quot;constraints&quot;: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看-Horizon-Exchange-中的资源"><a href="#查看-Horizon-Exchange-中的资源" class="headerlink" title="查看 Horizon Exchange 中的资源"></a>查看 Horizon Exchange 中的资源</h2><p>首先导出环境变量<code>HZN_ORG_ID</code>和<code>HZN_EXCHANGE_USER_AUTH</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置ORG_ID 为 myorg</span></span><br><span class="line">export HZN_ORG_ID=myorg</span><br><span class="line">export HZN_EXCHANGE_USER_AUTH=admin:&lt;password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="查看所有hzn-exchange可用的子命令"><a href="#查看所有hzn-exchange可用的子命令" class="headerlink" title="查看所有hzn exchange可用的子命令"></a>查看所有hzn exchange可用的子命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange --<span class="built_in">help</span></span></span><br><span class="line">usage: hzn exchange | ex [&lt;flags&gt;] &lt;command&gt; [&lt;args&gt; ...]</span><br><span class="line"></span><br><span class="line">List and manage Horizon Exchange resources.</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help             Show context-sensitive help (also try --help-long and --help-man).</span><br><span class="line">  -v, --verbose          Verbose output.</span><br><span class="line">      --dry-run          When calling the Horizon or Exchange API, do GETs, but don&#x27;t do PUTs, POSTs, or DELETEs.</span><br><span class="line">  -o, --org=ORG          The Horizon exchange organization ID. If not specified, HZN_ORG_ID will be used as a default.</span><br><span class="line">  -u, --user-pw=USER:PW  Horizon Exchange user credentials to query and create exchange resources. If not specified, HZN_EXCHANGE_USER_AUTH will be used as a default. If you don&#x27;t prepend it with the user&#x27;s org, it will automatically be prepended with the -o value. As an alternative to using</span><br><span class="line">                         -o, you can set HZN_ORG_ID with the Horizon exchange organization ID</span><br></pre></td></tr></table></figure>

<h3 id="查看边缘服务示例"><a href="#查看边缘服务示例" class="headerlink" title="查看边缘服务示例"></a>查看边缘服务示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange service list IBM/</span></span><br><span class="line">[</span><br><span class="line">  &quot;IBM/ibm.cpu2evtstreams_1.4.3_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-mms_1.1.0_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.helloworld_1.0.0_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.cpu2evtstreams_1.4.3_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.cpu_1.2.7_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.nginx-operator_2.0.0_ppc64le&quot;,</span><br><span class="line">  &quot;IBM/ibm.helloworld_1.0.0_ppc64le&quot;,</span><br><span class="line">  &quot;IBM/ibm.nginx-operator_2.0.0_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-secret_1.0.0_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-mms_1.1.0_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.helloworld_1.0.0_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.cpu_1.2.7_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-mms_1.1.0_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-secret_1.0.0_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.cpu_1.2.7_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.gps_2.1.4_amd64&quot;,</span><br><span class="line">  &quot;IBM/ibm.gps_2.1.4_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.gps_2.1.4_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.hello-secret_1.0.0_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.helloworld_1.0.0_arm&quot;,</span><br><span class="line">  &quot;IBM/ibm.cpu2evtstreams_1.4.3_arm64&quot;,</span><br><span class="line">  &quot;IBM/ibm.helloworld_1.0.0_s390x&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="查看示例模式"><a href="#查看示例模式" class="headerlink" title="查看示例模式"></a>查看示例模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange pattern list IBM/</span></span><br><span class="line">[</span><br><span class="line">  &quot;IBM/pattern-ibm.cpu2evtstreams&quot;,</span><br><span class="line">  &quot;IBM/pattern-ibm.helloworld&quot;,</span><br><span class="line">  &quot;IBM/pattern-ibm.nginx-operator&quot;,</span><br><span class="line">  &quot;IBM/pattern-ibm.hello-secret&quot;,</span><br><span class="line">  &quot;IBM/pattern-ibm.hello-mms&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="查看部署策略示例"><a href="#查看部署策略示例" class="headerlink" title="查看部署策略示例"></a>查看部署策略示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange deployment listpolicy</span></span><br><span class="line">[</span><br><span class="line">  &quot;myorg/policy-ibm.nginx-operator_2.0.0&quot;,</span><br><span class="line">  &quot;myorg/policy-ibm.cpu2evtstreams_1.4.3&quot;,</span><br><span class="line">  &quot;myorg/policy-ibm.helloworld_1.0.0&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="验证导致部署-helloworld-服务的策略匹配"><a href="#验证导致部署-helloworld-服务的策略匹配" class="headerlink" title="验证导致部署 helloworld 服务的策略匹配"></a>验证导致部署 helloworld 服务的策略匹配</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn deploycheck all -b policy-ibm.helloworld_1.0.0</span></span><br><span class="line">Neither node id nor node policy is specified. Getting node policy from the local node.</span><br><span class="line">Neither node id nor node user input file is specified. Getting node user input from the local node.</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compatible&quot;: true,</span><br><span class="line">  &quot;reason&quot;: &#123;</span><br><span class="line">    &quot;IBM/ibm.helloworld_1.0.0_amd64&quot;: &quot;Compatible&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看您的节点"><a href="#查看您的节点" class="headerlink" title="查看您的节点"></a>查看您的节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange node list</span></span><br><span class="line">[</span><br><span class="line">  &quot;myorg/node1&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="查看您组织中的用户"><a href="#查看您组织中的用户" class="headerlink" title="查看您组织中的用户"></a>查看您组织中的用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange user list</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;myorg/admin&quot;: &#123;</span><br><span class="line">    &quot;password&quot;: &quot;********&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;not@used&quot;,</span><br><span class="line">    &quot;admin&quot;: true,</span><br><span class="line">    &quot;hubAdmin&quot;: false,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:14:01.119884994Z[UTC]&quot;,</span><br><span class="line">    &quot;updatedBy&quot;: &quot;root/root&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-verbose-标志查看hzn命令调用的交换-REST-API"><a href="#使用-verbose-标志查看hzn命令调用的交换-REST-API" class="headerlink" title="使用 verbose 标志查看hzn命令调用的交换 REST API"></a>使用 verbose 标志查看hzn命令调用的交换 REST API</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange user list -v</span></span><br><span class="line">[verbose] Reading configuration file: /etc/horizon/hzn.json</span><br><span class="line">[verbose] Reading configuration file: /etc/default/horizon</span><br><span class="line">[verbose] Config file does not exist: /root/.hzn/hzn.json.</span><br><span class="line">[verbose] No project level configuration file found.</span><br><span class="line">[verbose] The exchange url: http://192.168.1.208:3090/v1</span><br><span class="line">[verbose] GET http://192.168.1.208:3090/v1/admin/version</span><br><span class="line">[verbose] HTTP request timeout set to 30 seconds</span><br><span class="line">[verbose] HTTP code: 200</span><br><span class="line">[verbose] The exchange url: http://192.168.1.208:3090/v1</span><br><span class="line">[verbose] GET http://192.168.1.208:3090/v1/orgs/myorg/users/admin</span><br><span class="line">[verbose] HTTP request timeout set to 30 seconds</span><br><span class="line">[verbose] HTTP code: 200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;myorg/admin&quot;: &#123;</span><br><span class="line">    &quot;password&quot;: &quot;********&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;not@used&quot;,</span><br><span class="line">    &quot;admin&quot;: true,</span><br><span class="line">    &quot;hubAdmin&quot;: false,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:14:01.119884994Z[UTC]&quot;,</span><br><span class="line">    &quot;updatedBy&quot;: &quot;root/root&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="agent-install-sh查看CSS中可用于在边缘节点上安装-x2F-注册代理的公共文件"><a href="#agent-install-sh查看CSS中可用于在边缘节点上安装-x2F-注册代理的公共文件" class="headerlink" title="agent-install.sh查看CSS中可用于在边缘节点上安装&#x2F;注册代理的公共文件"></a>agent-install.sh查看CSS中可用于在边缘节点上安装&#x2F;注册代理的公共文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn mms -o IBM -u <span class="string">&quot;<span class="variable">$HZN_ORG_ID</span>/<span class="variable">$HZN_EXCHANGE_USER_AUTH</span>&quot;</span> object list -d -t agent_files</span></span><br><span class="line">Listing objects in org IBM:</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;objectID&quot;: &quot;agent-install.cfg&quot;,</span><br><span class="line">    &quot;objectType&quot;: &quot;agent_files&quot;,</span><br><span class="line">    &quot;objectStatus&quot;: &quot;ready&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="创建彩信-MMS-文件"><a href="#创建彩信-MMS-文件" class="headerlink" title="创建彩信(MMS)文件"></a>创建彩信(MMS)文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; mms-meta.json</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#123;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">  &quot;objectID&quot;: &quot;mms-file&quot;,</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">  &quot;objectType&quot;: &quot;stuff&quot;,</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">  &quot;destinationOrgID&quot;: &quot;$HZN_ORG_ID&quot;,</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">  &quot;destinationType&quot;: &quot;pattern-ibm.helloworld&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#125;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">EOF</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;foo\nbar&quot;</span> &gt; mms-file</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> mms-file</span> </span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> mms-meta.json</span> </span><br><span class="line">&#123;</span><br><span class="line">  &quot;objectID&quot;: &quot;mms-file&quot;,</span><br><span class="line">  &quot;objectType&quot;: &quot;stuff&quot;,</span><br><span class="line">  &quot;destinationOrgID&quot;: &quot;myorg&quot;,</span><br><span class="line">  &quot;destinationType&quot;: &quot;pattern-ibm.helloworld&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn mms object publish -m mms-meta.json -f mms-file</span></span><br><span class="line">Digital sign with SHA1 will be performed for data integrity. It will delay the MMS object publish.</span><br><span class="line">Start hashing the file...</span><br><span class="line">Data hash is generated. Start digital signing with the data hash...</span><br><span class="line">Digital sign finished.</span><br><span class="line">Object mms-file added to org myorg in the Model Management Service</span><br></pre></td></tr></table></figure>

<h3 id="查看文件的元数据"><a href="#查看文件的元数据" class="headerlink" title="查看文件的元数据"></a>查看文件的元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn mms object list -d</span></span><br><span class="line">Listing objects in org myorg:</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;objectID&quot;: &quot;mms-file&quot;,</span><br><span class="line">    &quot;objectType&quot;: &quot;stuff&quot;,</span><br><span class="line">    &quot;objectStatus&quot;: &quot;ready&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;objectID&quot;: &quot;test-mgmt-hub-mms-file&quot;,</span><br><span class="line">    &quot;objectType&quot;: &quot;test-mgmt-hub&quot;,</span><br><span class="line">    &quot;objectStatus&quot;: &quot;ready&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn mms object download -t stuff -i mms-file -f mms-file.downloaded</span></span><br><span class="line">Verifying data with digital signature....</span><br><span class="line">Downloading: 100.00 %Verifying digital signature is done.</span><br><span class="line">Data of object mms-file saved to file mms-file.downloaded</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> mms-file.downloaded</span> </span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<h2 id="切换到该组织中的管理员用户"><a href="#切换到该组织中的管理员用户" class="headerlink" title="切换到该组织中的管理员用户"></a>切换到该组织中的管理员用户</h2><p>通过切换到该组织中的管理员用户来查看系统组织中的更多资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置ORG_ID 为 IBM</span></span><br><span class="line">export HZN_ORG_ID=IBM</span><br><span class="line">export HZN_EXCHANGE_USER_AUTH=admin:&lt;password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="查看系统组织中的用户"><a href="#查看系统组织中的用户" class="headerlink" title="查看系统组织中的用户"></a>查看系统组织中的用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange user list</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;IBM/admin&quot;: &#123;</span><br><span class="line">    &quot;password&quot;: &quot;********&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;not@used&quot;,</span><br><span class="line">    &quot;admin&quot;: true,</span><br><span class="line">    &quot;hubAdmin&quot;: false,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:45.607816433Z[UTC]&quot;,</span><br><span class="line">    &quot;updatedBy&quot;: &quot;root/root&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看-agbot"><a href="#查看-agbot" class="headerlink" title="查看 agbot"></a>查看 agbot</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot list</span></span><br><span class="line">[</span><br><span class="line">  &quot;IBM/agbot&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="查看-agbot-正在服务的部署策略"><a href="#查看-agbot-正在服务的部署策略" class="headerlink" title="查看 agbot 正在服务的部署策略"></a>查看 agbot 正在服务的部署策略</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot listdeploymentpol agbot</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;myorg_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;businessPolOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;businessPol&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.974503620Z[UTC]&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看-agbot-正在服务的模式"><a href="#查看-agbot-正在服务的模式" class="headerlink" title="查看 agbot 正在服务的模式"></a>查看 agbot 正在服务的模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot listpattern agbot</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;IBM_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.830249995Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;IBM&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;myorg_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.892474770Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;myorg&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切换到中心管理员"><a href="#切换到中心管理员" class="headerlink" title="切换到中心管理员"></a>切换到中心管理员</h2><p>中心管理员可以管理 <code>Horizon</code> 组织（创建、读取、更新和删除它们）。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HZN_ORG_ID=root</span><br><span class="line">export HZN_EXCHANGE_USER_AUTH=hubadmin:&lt;password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="列出组织"><a href="#列出组织" class="headerlink" title="列出组织"></a>列出组织</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange org list</span></span><br><span class="line">[</span><br><span class="line">  &quot;root&quot;,</span><br><span class="line">  &quot;IBM&quot;,</span><br><span class="line">  &quot;myorg&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="创建一个新组织"><a href="#创建一个新组织" class="headerlink" title="创建一个新组织"></a>创建一个新组织</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange org create -d <span class="string">&#x27;my new org&#x27;</span> -a IBM/agbot myneworg</span></span><br><span class="line">Organization myneworg is successfully added to the Exchange.</span><br><span class="line">Agbot IBM/agbot is responsible for deploying services in org myneworg</span><br><span class="line">Organization myneworg is successfully added to MMS.</span><br></pre></td></tr></table></figure>

<h3 id="配置-agbot-使其能够使用该组织的示例服务"><a href="#配置-agbot-使其能够使用该组织的示例服务" class="headerlink" title="配置 agbot 使其能够使用该组织的示例服务"></a>配置 agbot 使其能够使用该组织的示例服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot addpattern IBM/agbot IBM <span class="string">&#x27;*&#x27;</span> myneworg</span></span><br></pre></td></tr></table></figure>

<h3 id="查看-agbot-正在服务的模式-1"><a href="#查看-agbot-正在服务的模式-1" class="headerlink" title="查看 agbot 正在服务的模式"></a>查看 agbot 正在服务的模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot listpattern IBM/agbot</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;IBM_*_myneworg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T03:25:26.840611649Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myneworg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;IBM&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;IBM_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.830249995Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;IBM&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;myneworg_*_myneworg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T03:24:53.886134418Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myneworg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;myneworg&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;myorg_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.892474770Z[UTC]&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;patternOrgid&quot;: &quot;myorg&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看-agbot-正在服务的部署策略-1"><a href="#查看-agbot-正在服务的部署策略-1" class="headerlink" title="查看 agbot 正在服务的部署策略"></a>查看 agbot 正在服务的部署策略</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange agbot listdeploymentpol IBM/agbot</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;myneworg_*_myneworg&quot;: &#123;</span><br><span class="line">    &quot;businessPolOrgid&quot;: &quot;myneworg&quot;,</span><br><span class="line">    &quot;businessPol&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myneworg&quot;,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T03:24:53.894147006Z[UTC]&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;myorg_*_myorg&quot;: &#123;</span><br><span class="line">    &quot;businessPolOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;businessPol&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;nodeOrgid&quot;: &quot;myorg&quot;,</span><br><span class="line">    &quot;lastUpdated&quot;: &quot;2024-03-11T02:13:48.974503620Z[UTC]&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加更多边缘设备"><a href="#添加更多边缘设备" class="headerlink" title="添加更多边缘设备"></a>添加更多边缘设备</h2><p>在每个边缘节点上执行以下命令  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HZN_ORG_ID=myorg</span><br><span class="line">export HZN_EXCHANGE_USER_AUTH=admin:&lt;admin-pw&gt;</span><br><span class="line">export HZN_FSS_CSSURL=http://&lt;mgmt-hub-ip&gt;:9443/</span><br><span class="line">export HZN_EXCHANGE_URL=http://&lt;mgmt-hub-ip&gt;:3090/v1</span><br><span class="line">curl -sSL https://github.com/open-horizon/anax/releases/latest/download/agent-install.sh | bash -s -- -i anax: -k css: -c css: -p IBM/pattern-ibm.helloworld -w &#x27;*&#x27; -T 120</span><br></pre></td></tr></table></figure>

<p>命令执行完成后，会在当前边缘节点下启动一个服务  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                              COMMAND                  CREATED        STATUS        PORTS     NAMES</span><br><span class="line">0b2c31b05629   openhorizon/ibm.helloworld_amd64   &quot;/bin/sh -c /service…&quot;   24 hours ago   Up 24 hours             049af567e902ee6eb89ee574f9bd9e25ebb90ce7d89f0ffd9a96dd90db5254b8-ibm.helloworld</span><br></pre></td></tr></table></figure>

<p>查看节点列表  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hzn exchange node list</span></span><br><span class="line">[</span><br><span class="line">  &quot;myorg/node1&quot;,</span><br><span class="line">  &quot;myorg/oh-2&quot;  # 新注册进来的边缘节点</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="尝试FDO"><a href="#尝试FDO" class="headerlink" title="尝试FDO"></a>尝试FDO</h2><p>运行 FDO 测试脚本  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://github.com/open-horizon/devops">open-horizon-devops</a></p>
]]></content>
      <categories>
        <category>LearnOpenHorizon</category>
      </categories>
      <tags>
        <tag>OpenHorizon</tag>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>你这么一棒子把人打死,难道不嫌太武断了吗?</title>
    <url>/2021/02/06/please-dont-discriminate-geographically/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/3420392/">《武林高手在校园》</a>这本穿越小说我高中&amp;大学时读了很多遍，也算是我读的第一本穿越小说，有一处印象比较深的情节，在此记录并抒发一下自己的感受。  </p>
<p>内容应该在73-74节之间，当时油老鼠和林逸飞在街上走着，突然碰到一个人骑自行车钱包掉了出来，立马有人过来说见者有份，要平分赃款，而林逸飞早已识破骗局，于是油老鼠也跟着走了，并说了一句“可恶的河南人”，而林逸飞就说出了我印象最深的话： <em>林逸飞叹息道:“哪个地方都有好人,都会有骗子,你这么一棒子把人打死,难道不嫌太武断了吗?”</em>  </p>
<p>为什么我会对这句话印象极其深刻呢？——因为我见过太多的地域歧视。  </p>
<p>上大学那会，我的本科舍友们偶尔会在宿舍关灯后还是唠嗑，这时候我就会闭嘴，因为话题真的很无语，比如——他们一直认为四川人的个子都很矮（我只想说如果都很矮那难道像CBA这种篮球比赛四川队都垫底吗？）；偷井盖子的都是河南人；广东人做的东西不要吃；….等等这种带着地域的偏见。  </p>
<p>然而，当我毕业后，在成都拿了一家互联网公司的offer后，我发现四川当地人并不矮，地铁上、公交车上到处都是高个子；我在部门认识的河南同事都非常乐于助人，有时会停下手里的活帮我来看代码问题；广东的肠粉路边摊到处都是…所以，我学会了怀疑别人说的话，同时也建立了一个前提：哪个地方都有好人,都会有骗子，不能因为这地方出现了这件事情，就把这个地方的人一棍子打死。  </p>
<p>而我也分析了为什么会出现这种现象呢？我罗列了以下原因：  </p>
<ul>
<li>读书少，没有自己的思想，都是道听途说，别人说什么就信什么；  </li>
<li>媒体作用，总是喜欢把一个地方发生的事件扩大影响，然后再举例子说前多少年也发生类似事件以及水军的无脑附和；  </li>
<li>推荐算法的作用，你倾向于看到什么，算法就会帮你搜集你想看到的，久而久之内心就会产生一种潜意识；</li>
</ul>
<p>我很庆幸我生活在一个交通便利的时代，可以到处旅游，见识各地的饮食和风土人情以及方言，所以——写这篇文章也是项表达自己的心声：没事千万不要给不熟悉的地域打上标签，你这么一棒子把人打死,难道不嫌太武断了吗?  </p>
<p>最后引用一下这句话的完整内容，我非常喜欢这段^_^  </p>
<blockquote>
<p>“可恶的河南人。”油老鼠摇头晃脑的来了这么一句。<br>林逸飞一愣,“为什么这么说?”<br>“刚才那两个就是本地人,可不就是河南人,他们专找外地的旅客下手行骗的。”油老鼠恨恨的说道:“我对河南人向来没有什么好感,再说现在社会也有很多关于河南人的劣迹。” 林逸飞叹息道:“哪个地方都有好人,都会有骗子,你这么一棒子把人打死,难道不嫌太武断了吗?”<br>油老鼠本来想要反驳,突然看到林逸飞的脸色有些沉郁,终于还是嘴边的话咽了回去,点头装作同意道:“林老弟说的是。”<br>看着油老鼠言不由衷的样子,林逸飞苦笑一声,也不再说什么,油老鼠当然不知道,萧别离最尊敬的一个人就是岳元帅,而岳飞偏偏就是河南汤阴人! 从文化意义上来讲,河南实在是一块中国人无法忽视的地域,泱泱大国,千年的华夏文明,正是从这块黄土地发源流淌。<br>这里有着道家的先祖老庄,“外示会儒术,内尊黄道”八个字,为无数的统治者心照不暄的运用,有着墨家的创始人墨翟。提出了意义非凡的‘兼爱’,‘非攻’口号,可以算是最早地和平主义倡导者,有着:;风萧萧兮易水寒,壮士一去兮不复返‘伯侠士荆轲。差一点就凭借手中的宝剑改写了历史,更有着千古传诵,万人景仰的尽忠报国的岳武穆,凭借一腔热血扛起了那面风雨飘摇中地反金大旗! 以悲凉的歌声唱出‘新鬼烦冤旧鬼哭,天阴雨湿声啾啾’这等同情孤苦百姓诗词的杜甫是河南人,写出‘春心莫共花争发,一寸相思一寸灰!’这等华美语句的李商隐也是河南人,那个千百年来的造福苍生的医圣张仲景还是河南人! 而这些不过是河南数不胜数名人中的几个。河南,实在在中国的文明史上留下了不可磨灭地重重烙印,可是如今的人们记住了什么?! 河南人这个本来应该让人骄傲自豪的三个字。正在让人肆无忌惮地嘲笑,毫无顾忌的践踏。这实在是一种文化地悲哀,也是一种‘流言运动’的恶果,更是我们民族整体的悲哀! 在这里,新闻媒体,网络媒介无疑要深刻的反省一下,那些网络推波助澜的也应该停止这种可悲的附和的附和。当你在践踏嘲笑地时候,无疑那点仅存的文明也被你亲手摧毁。<br>“没有谁会比别人高出一等!”林逸飞突然叹息道:“<em>每个人都有尊严,当你认为高出别人一等的时候,我认为,那才是可悲的事情</em>。”<br>油老鼠咀嚼着林逸飞的话,一时竟然有些出神,这难道仅仅是个学生,他实在有着太多当代学生缺乏的东西。</p>
</blockquote>
]]></content>
      <categories>
        <category>Review-book</category>
      </categories>
      <tags>
        <tag>歧视</tag>
        <tag>地域</tag>
        <tag>武断</tag>
      </tags>
  </entry>
  <entry>
    <title>幻光</title>
    <url>/2020/08/09/phantom-light/</url>
    <content><![CDATA[<p>曾经我以为所有的生命都是被束缚的  </p>
<p>只有终结才是自由的开始  </p>
<p>可明明不想死  </p>
<p>却没有活下去的理由  </p>
<p>明明很想活着  </p>
<p>却害怕活着的感觉  </p>
<p>也许成为光照亮别人只是她跟我开的一个玩笑  </p>
<p>你越想去忘记一切  </p>
<p>却反而记得更清楚  </p>
<p>那时的我是那么孤独又毫无价值  </p>
<p>死对我来说  </p>
<p>是那么的黑暗  </p>
<p>又让人害怕  </p>
<p>也许  </p>
<p>有时帮你解开枷锁的并不是希望  </p>
<p>也许绝望的尽头才是真正的新生  </p>
<p>后来 我终于来到世界尽头  </p>
<p>那里是最后一个光点  </p>
<p>再过去就是深渊  </p>
<p>它像一面镜子  </p>
<p>我看到镜中的自己化为恶龙  </p>
<p>纵然一切都是骗局  </p>
<p>但我知道  </p>
<p>凝视深渊  </p>
<p>深渊必将回应凝视  </p>
<p>谁也无法看到最初的世界  </p>
<p>而真正的先知早就给特殊的灵魂准备了下达深远的梯子  </p>
<p>是否 只有变成怪物，才能战胜怪物  </p>
<p>是否 只有抛弃“我”才能变成光  </p>
<p>只有活下去  </p>
<p>才能知道答案  </p>
<p>无论人们怎么变坏  </p>
<p>世界都会照常运行  </p>
<p>罪魁祸首玩弄着为希望献身的人们  </p>
<p>一心只想冲破黑暗  </p>
<p>却不知这一切 皆是枉然  </p>
<p>无论弱者 如何哀叹鄙夷自己的软弱  </p>
<p>终究无法逃离 悲惨的末路  </p>
<p>没有人生来就拥有自由  </p>
<p>假如无法挣脱  </p>
<p>那就毁灭吧！  </p>
<p>毁灭束缚你的一切  </p>
<p>所有人都对黑暗的未来心存恐惧  </p>
<p>但不到那一刻 又如何能知道  </p>
<p>生也是“我”  </p>
<p>死也是“我”  </p>
<p>彻悟是“我”  </p>
<p>答案是“我”  </p>
<p>“我”才是救赎  </p>
<p>“我”即是毁灭！  </p>
]]></content>
      <categories>
        <category>Review-film</category>
      </categories>
      <tags>
        <tag>疯味英雄</tag>
      </tags>
  </entry>
  <entry>
    <title>转正才是工作的开始</title>
    <url>/2019/03/04/positive-is-work-begin/</url>
    <content><![CDATA[<p>转正通过，也算是对我这六个月的一次认可吧。  </p>
<p>然后有一老哥的流媒体服务相关的项目移交给我负责了，还有视音频编码，放佛之前是在过家家，现在才是正式工作的开始。  </p>
<p>加油，机遇与挑战并存！  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>开始</tag>
        <tag>转正</tag>
      </tags>
  </entry>
  <entry>
    <title>四川省都江堰市青城后山一日游</title>
    <url>/2021/04/21/qing-cheng-hou-shan-one-day-trip/</url>
    <content><![CDATA[<p>上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。</p>
<h2 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h2><p>出发之前，我和袁准备了一个背包，想着先爬到山上再去补给。  </p>
<p>我和袁住在成都市，早上7点半约好见面，吃过早餐坐地铁到犀浦，然后转城际列车(10元&#x2F;人)到青城山下车即可。建议如果去青城山最好直接上车前买直达，不然到车上补票还需要另外收费。  </p>
<p>到了青城山车站出来，由于我们是要去的后山，自然景观丰富，空气清新，因此我们两人打了个车，一个人15（景区要16，还有等一会，小车直接走）。在此需要提醒：由于是上山的路且弯道众多，因此可能会晕车。  </p>
<p>到了泰安古镇，也就是景区的入口处，我们吃了顿午饭（还是有些小贵），买了20元&#x2F;人的门票，就开始爬山了。  </p>
<h2 id="上山过程"><a href="#上山过程" class="headerlink" title="上山过程"></a>上山过程</h2><p>我们白天爬，感觉都还好，不是很热，沿途有各种卖饮料的，不过价格稍贵，水5元、饮料10元，棒棒糖3元一根。  </p>
<p>爬到半山腰大概3个小时，然后有缆车可以往返，不过我们年轻小伙子想着多运动，于是就没有坐缆车（这是我最后悔的决定）。接着就开始体力不支，因为大多是上坡，很累，爬一会就得休息一下，不过还好在5点的时候（用了两个小时）爬到了白云寺，拜了拜佛，然后准备下山，这时候从卖饮料的大妈口中得知，5点半缆车停运！！！  </p>
<h2 id="下山过程"><a href="#下山过程" class="headerlink" title="下山过程"></a>下山过程</h2><p>下山稍微轻松，但腿开始软了，感到走不动路，看着手机上还有几百米的距离到达缆车地点，我真想飞过去。结果我们5点20到那里后，人家告诉我缆车工作人员早就下班了，我不甘心，下去看了一眼，果然都停了，于是在想怎么办。有个姐姐告诉我下山大概一个小时可以坐船，坐上船后再走一个小时就下山了，我们一看时间，嗯，争取赶晚上8点下山，然后坐列车回成都。  </p>
<p>结果坐船说过了运营时间，要涨价，5元&#x2F;人（正常是2元&#x2F;人）。行吧，就这样，结果坐完船就开始晕，恶心，头晕，心跳的贼快，于是朋友叫我先休息，最后休息到7点往下走，还是感到不舒服，没办法，直接叫救援。  </p>
<h2 id="救援过程"><a href="#救援过程" class="headerlink" title="救援过程"></a>救援过程</h2><p>首先打完救援电话后，被告知救援费要1000元，我在犹豫间朋友已经替我答应了，挂了电话对我说，钱花了可以挣，但一定要保证你的安全。于是，我们在夜幕降临的过程中，用手机闪光灯照着周围环境，防止有蛇、虫子之类的靠近，同时我们也看到草丛里有一双泛着黄光的动物眼睛盯着我们。  </p>
<p>等了大概一个小时，救援队上来，把我抬了下去，最后由120救护车把我送到医院做检查。</p>
<p>身体没有大碍，就心跳的太快了，于是开了一些降心率的药，叮嘱我回成都市了要好好检查。</p>
<p>就这样，在一天中结束了自己跌宕起伏的青城的后山爬山之旅。</p>
<h2 id="此次旅行感悟"><a href="#此次旅行感悟" class="headerlink" title="此次旅行感悟"></a>此次旅行感悟</h2><ul>
<li>有时候不能硬撑，实在走不动了，就用钱代替交通；</li>
<li>钱没了可以再挣，身体是最重要的；</li>
<li>出发前做好旅行规划很重要；</li>
<li>体检有不舒服的就赶紧去查，防止小病拖成大病；  </li>
<li>不要把问题想的太严重，总会有解决之道。</li>
</ul>
]]></content>
      <categories>
        <category>Travel-notes</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>青城山</tag>
        <tag>都江堰</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员10x工作法</title>
    <url>/2019/06/23/programmer-10x-work/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>01：面对问题时，用思考框架问问自己，现状、目标和路径。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Where are we?（我们现在在哪？）</span><br><span class="line">Where are we going?（我们要到哪儿去？）</span><br><span class="line">How can we get there?（我们如何到达那里？）</span><br></pre></td></tr></table></figure></li>
<li>02：遇到事情，倒着想。  </li>
<li>03：在做任何事之前，先定义完成的标准。  </li>
<li>04：在做任何需求或任务之前，先定好验收标准。  </li>
<li>05：尽早提交代码去集成。  </li>
<li>06：默认所有需求都不做，直到弄清楚为什么要做这件事。  </li>
<li>07：扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。  </li>
<li>08：在动手做一件事之前，先推演一番。 </li>
<li>09：问一下自己，我的工作是不是可以用数字衡量。  </li>
<li>10：设计你的迭代0清单，给自己的项目做体检。  </li>
<li>11：动手做一个工作之前，请先对它进行任务分解。  </li>
<li>12：多写单元测试。  </li>
<li>13：我们应该编写可测的代码。  </li>
<li>14：将任务拆小，越小越好。  </li>
<li>15：按照完整实现一个需求的顺序去安排分解出来的任务。  </li>
<li>16：要想写好测试，就要写简单的测试。  </li>
<li>17：想要管理好需求，先把需求拆小。  </li>
<li>18：尽量做最重要的事。  </li>
<li>19：做好产品开发，最可行的方式是采用 MVP（最小可行产品）。  </li>
<li>20：通过沟通反馈，不断升级自己的编解码能力。  </li>
<li>21：用业务的语言写代码。  </li>
<li>22：多面对面沟通，少开会。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我昨天做了什么？  </span><br><span class="line">我今天打算做什么？  </span><br><span class="line">我在过程中遇到了什么问题，需要请求帮助。  </span><br></pre></td></tr></table></figure></li>
<li>23：多尝试用可视化的方式进行沟通。  </li>
<li>24：做好持续集成的关键在于，快速反馈。  </li>
<li>25：定期复盘，找准问题根因，不断改善。  </li>
<li>26：多走近用户。  </li>
<li>27：事情往前做，有问题尽早暴露。  </li>
<li>28：多输出，让知识更有结构。  </li>
<li>29：请谨慎地将工作自动化。  </li>
<li>30：将你的工作过程自动化。  </li>
<li>31：有体系地学习运维知识。  </li>
<li>32：将部署纳入开发的考量。  </li>
<li>33：将验收测试自动化。  </li>
<li>34：把函数写短。  </li>
<li>35：构建好你的领域模型。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">万维钢有期节目里提到芯片设计时讲到了分层以及模型的概念。分层或模型，实质是因为人的认知能力有</span><br><span class="line">限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深</span><br><span class="line">奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质</span><br><span class="line">却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。</span><br><span class="line">在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单</span><br><span class="line">的开关，实现所有逻辑运算。</span><br><span class="line">逻辑运算层次之上，就是我们所知道的CPU模型。再往上，就是我们所熟悉的信息世界</span><br></pre></td></tr></table></figure></li>
<li>36：用简单技术解决问题，直到问题变复杂。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一方面，有人会因为对业务量级理解不足，盲目低估其他人系统的复杂度；另一方面，也有人会盲目应用技</span><br><span class="line">术，给系统引入不必要的复杂度，让自己陷入泥潭。</span><br><span class="line">作为拥有技术能力的程序员，我们都非常在意个人技术能力的提升，但却对在什么样情形下，什么样的技术</span><br><span class="line">更加适用考虑得不够。采用恰当的技术，解决当前的问题，是每个程序员都应该仔细考虑的问题。</span><br></pre></td></tr></table></figure></li>
<li>37：学习领域驱动设计。  </li>
<li>38：了解一个项目，从大图景开始。  </li>
<li>39：小步改造遗留系统，不要回到老路上。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建测试防护网，保证新老模块功能一致；</span><br><span class="line">分成小块，逐步替换；</span><br><span class="line">构建好领域模型；</span><br><span class="line">寻找行业中关于系统构建的最新理解。</span><br></pre></td></tr></table></figure></li>
<li>40：在学习区工作和成长。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从目前的发展来看，IT 行业依然是一个非常有前景的行业，但想在这条路上走好，需要我们成为 “T ”型</span><br><span class="line">人才，也就是“一专多能”。一专多能的前提是“一专”，让自己成为某个方面的专家。这个专家要放在行</span><br><span class="line">业的标准去看，这才能降低因为一个公司的波动而造成的影响。</span><br><span class="line">成为行业专家，要向行业的大师学习，给自己定下一个高的目标，然后是脚踏实地，找适合自己的问题去解</span><br><span class="line">决，让自己一直在学习区成长。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><h3 id="单元测试做不好，是否会影响到-CI-的效果？"><a href="#单元测试做不好，是否会影响到-CI-的效果？" class="headerlink" title="单元测试做不好，是否会影响到 CI 的效果？"></a>单元测试做不好，是否会影响到 CI 的效果？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CI 作为一个单独的实践，本身是很简单的，但它可以成为提纲挈领的主线，帮助团队不断改善自己</span><br><span class="line">的开发过程。</span><br></pre></td></tr></table></figure>

<h3 id="老板参加复盘，不敢说真话怎么办？"><a href="#老板参加复盘，不敢说真话怎么办？" class="headerlink" title="老板参加复盘，不敢说真话怎么办？"></a>老板参加复盘，不敢说真话怎么办？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题，是改进的前提条件。</span><br></pre></td></tr></table></figure>

<h3 id="国内的技术信息落后吗？"><a href="#国内的技术信息落后吗？" class="headerlink" title="国内的技术信息落后吗？"></a>国内的技术信息落后吗？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">国内程序员真正落后的不是信息，而是观念。</span><br></pre></td></tr></table></figure>

<h3 id="如何管理上级？"><a href="#如何管理上级？" class="headerlink" title="如何管理上级？"></a>如何管理上级？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一，管理上级的预期。</span><br><span class="line">第二，帮助上级丰富知识。</span><br><span class="line">第三，说出你的想法。</span><br></pre></td></tr></table></figure>

<h3 id="面对不了解的技术，我该如何分解任务？"><a href="#面对不了解的技术，我该如何分解任务？" class="headerlink" title="面对不了解的技术，我该如何分解任务？"></a>面对不了解的技术，我该如何分解任务？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先把它变成你熟悉的技术。</span><br></pre></td></tr></table></figure>

<h3 id="项目时间紧，该怎么办？"><a href="#项目时间紧，该怎么办？" class="headerlink" title="项目时间紧，该怎么办？"></a>项目时间紧，该怎么办？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">混淆了目标与现状。</span><br><span class="line">目标是应该怎么做，现状是我们正在怎么做。我们都知道</span><br><span class="line">现状是什么样的，问题是，你对现状满意吗？如果每个人都对现状是满意的，就不会有人探索更好的做法。</span><br><span class="line">假设现在不忙了，你知道该怎么改进吗？</span><br><span class="line"></span><br><span class="line">自动糊改进：</span><br><span class="line">把测试覆盖率检查加入到工程里，得到现有的测试覆盖率。</span><br><span class="line">将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标，不许提交代码。</span><br><span class="line">每周将测试覆盖率调高，比如，5%或10%，直到测试覆盖率达到100%。</span><br></pre></td></tr></table></figure>

<h3 id="多个功能同时开发，怎么办？"><a href="#多个功能同时开发，怎么办？" class="headerlink" title="多个功能同时开发，怎么办？"></a>多个功能同时开发，怎么办？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在主分支开发模型中，有一些常见的解决多功能并行开发的方法，其中，Feature Toggle 是最常用的一个，</span><br><span class="line">也就是通过开关，决定哪个功能是对外可用的。</span><br></pre></td></tr></table></figure>

<h3 id="如何在实际工作中推行新观念？"><a href="#如何在实际工作中推行新观念？" class="headerlink" title="如何在实际工作中推行新观念？"></a>如何在实际工作中推行新观念？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到愿意和你一起改变的人，做一件具体的事。</span><br></pre></td></tr></table></figure>

<h3 id="测试怎么写？"><a href="#测试怎么写？" class="headerlink" title="测试怎么写？"></a>测试怎么写？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于外部系统的测试，你可以先通过接口隔离开来，然后，通过模拟服务或本地可控的方式进行</span><br><span class="line">测试。</span><br></pre></td></tr></table></figure>

<h3 id="IntelliJ-IDEA-怎么学？"><a href="#IntelliJ-IDEA-怎么学？" class="headerlink" title="IntelliJ IDEA 怎么学？"></a>IntelliJ IDEA 怎么学？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。</span><br><span class="line">遇到问题就去找相应的解决方案。</span><br><span class="line">也有一些辅助的方法可以帮助我们练习，</span><br><span class="line">比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；</span><br><span class="line">再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，</span><br><span class="line">如果你用鼠标操作，它会给你提示，帮你记住快捷键</span><br></pre></td></tr></table></figure>

<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations">使用功能开关更好地实现持续部署</a>  </li>
<li><a href="https://martinfowler.com/articles/feature-toggles.html">Feature Toggles (aka Feature Flags)</a>  </li>
<li><a href="https://www.unixhot.com/page/ops">运维知识体系</a>  </li>
<li><a href="https://www.unixhot.com/page/cache">Web缓存知识体系</a></li>
</ul>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>工作</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>高级研发工程师&amp;架构师成长计划</title>
    <url>/2021/08/16/senior-rd-and-architect-plan/</url>
    <content><![CDATA[<p>转眼间新工作已经入职了三周，接手了一个没有文档没有注释的项目，不过<code>bug</code>较少，前期先熟悉。  </p>
<p>写这篇文章也算是梳理一下目前的资源，以及对未来半年做一个简单的规划。  </p>
<p>目前个人终于可以<code>hold</code>住一些中小型的项目（代码量大概在一万行以下），但高并发、分布式、微服务、消息队列、云原生这块还是很薄弱的，正好入职的新公司在研发分布式云存储系统，可以好好提升一下。在保质保量完成工作的同事，计划跟一些实战项目，以及一些有深度的技术专栏，在学习完它们之后，提炼自己的感受，做好总结。  </p>
<h2 id="目前的规划"><a href="#目前的规划" class="headerlink" title="目前的规划"></a>目前的规划</h2><p>核心就三点：算法+系统设计+英语。  </p>
<ul>
<li>慕课网上和<code>Go</code>相关的实战项目；  </li>
<li>极客时间、拉勾教育上有关<strong>高并发、分布式、微服务、消息队列、云原生</strong>的专栏和训练营；  </li>
<li>有关系统设计的课程学习；  </li>
<li>经典技术书籍研读，例如《算法第四版》、《CSAPP》、《UNP》；  </li>
<li>坚持刷<code>LeetCode</code>，后期要切到全球站，参考国外大佬的解法；  </li>
<li>一周至少要在<code>Medium</code>看2-4篇技术文章；  </li>
<li>刷英文原版技术书籍，练习听力和口语；  </li>
<li>两周做一次总结。</li>
</ul>
<p>以上计划持续半年。  </p>
<h2 id="目前已经完成的内容"><a href="#目前已经完成的内容" class="headerlink" title="目前已经完成的内容"></a>目前已经完成的内容</h2><h3 id="极客大学QC的《算法训练营》"><a href="#极客大学QC的《算法训练营》" class="headerlink" title="极客大学QC的《算法训练营》"></a>极客大学QC的《算法训练营》</h3><p>说实话，感觉蛮水的，我觉得只要会Google，会看得懂英文，经常去leetcode(切记是全球的，不是国内的力扣)，基本就ok了，算法还是要多刷题，多总结，然后慢慢提升，不要死记硬背所谓的解题模板。  </p>
<h3 id="极客时间专栏《数据结构与算法之美》"><a href="#极客时间专栏《数据结构与算法之美》" class="headerlink" title="极客时间专栏《数据结构与算法之美》"></a>极客时间专栏《数据结构与算法之美》</h3><p>挺不错的算法入门课程，当时花了60多买的，作者很用心，从基础数据结构到高级算法的讲解，以及准备的对应练习题，都很Nice，入门可以看这个就行，不过听说作者后期还为此出了一本书，我就觉得没必要买了，当然如果是为了收藏或支持作者，可以的。  </p>
<h3 id="极客时间专栏《Go语言36讲》"><a href="#极客时间专栏《Go语言36讲》" class="headerlink" title="极客时间专栏《Go语言36讲》"></a>极客时间专栏《Go语言36讲》</h3><p>作者写的很用心，但大段的文字确实有些让初学者难以理解，不过也算是把Go的方方面面都介绍到了，可以配合Go语言圣经一起学习。  </p>
<h3 id="极客时间专栏《如何设计一个秒杀系统》"><a href="#极客时间专栏《如何设计一个秒杀系统》" class="headerlink" title="极客时间专栏《如何设计一个秒杀系统》"></a>极客时间专栏《如何设计一个秒杀系统》</h3><p>讲的很细了，介绍了设计秒杀系统很多需要考虑的点，但个人觉得需要提炼一下关键有用信息，方便面试的时候直击要害。  </p>
<h3 id="极客时间专栏《趣谈网络协议》"><a href="#极客时间专栏《趣谈网络协议》" class="headerlink" title="极客时间专栏《趣谈网络协议》"></a>极客时间专栏《趣谈网络协议》</h3><p>大学刚毕业的时候看的，算是对各种网络协议做了个初步入门。  </p>
<h4 id="极客时间专栏《10x程序员工作法》"><a href="#极客时间专栏《10x程序员工作法》" class="headerlink" title="极客时间专栏《10x程序员工作法》"></a>极客时间专栏《10x程序员工作法》</h4><p>程序员职场的效率提升指南。  </p>
<h3 id="极客时间专栏《软件工程之美》"><a href="#极客时间专栏《软件工程之美》" class="headerlink" title="极客时间专栏《软件工程之美》"></a>极客时间专栏《软件工程之美》</h3><p>一步步介绍软件工程的方方面面，适合做业务开发的时候看看，提炼相关的信息内化为自己的能力。  </p>
<h3 id="极客时间专栏《程序员进阶攻略》"><a href="#极客时间专栏《程序员进阶攻略》" class="headerlink" title="极客时间专栏《程序员进阶攻略》"></a>极客时间专栏《程序员进阶攻略》</h3><p>程序员职场的十万个为什么，遇到困惑的时候可以看看。  </p>
<h3 id="极客时间专栏《白话法律42讲》"><a href="#极客时间专栏《白话法律42讲》" class="headerlink" title="极客时间专栏《白话法律42讲》"></a>极客时间专栏《白话法律42讲》</h3><p>职场人的法律入门书籍，基本涉及到工作时涉及的大部分法律知识。  </p>
<h3 id="极客时间专栏《人人都能学会的编程入门课》"><a href="#极客时间专栏《人人都能学会的编程入门课》" class="headerlink" title="极客时间专栏《人人都能学会的编程入门课》"></a>极客时间专栏《人人都能学会的编程入门课》</h3><p>用C语言讲解常用的数据结构，培养编程思维，最后再以两个小demo结束，还是挺有收获的。  </p>
<h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>工作越久，越感到心难以静下来，虽然目前才三年工作经验，但感觉仿佛过了三十年，很想早点退休，但现实又把我从梦境拽了回来，每天群里推送的各种技术文章，各种转发，信息量极大，内卷太厉害，真的懒得争了，写这篇文章也算是对我近期学习情况的一个简单梳理，后期就按自己的进度一步步来学习，有收获了就记录下来。  </p>
<p>曾经我也羡慕大佬的生活，有天突然明白，我其实是在羡慕未来的那个自己，只要自己坚持一步一个脚印，少吹牛皮多做实事，我相信那一天会早点到来的。  </p>
<p>加油！</p>
]]></content>
      <categories>
        <category>Tech-Growing</category>
      </categories>
      <tags>
        <tag>架构师</tag>
        <tag>计划</tag>
        <tag>研发</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端漫游</title>
    <url>/2019/04/14/server-roam/</url>
    <content><![CDATA[<p>注：本文内容源自<code>polaris</code>在知识星球<strong>Go项目实战</strong>中的直播，已获得本人许可。  </p>
<h1 id="第一站：穿梭于Internet"><a href="#第一站：穿梭于Internet" class="headerlink" title="第一站：穿梭于Internet"></a>第一站：穿梭于Internet</h1><p><img src="/2019/04/14/server-roam/internet.png">  </p>
<h1 id="第二站：协议"><a href="#第二站：协议" class="headerlink" title="第二站：协议"></a>第二站：协议</h1><p>重点掌握  </p>
<ul>
<li>TCP&#x2F;UDP  </li>
<li>HTTP</li>
</ul>
<p>常考面试题  </p>
<ul>
<li>TCP的三次握手过程  </li>
<li>TCP的四次挥手过程</li>
</ul>
<h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul>
<li>《图解http协议》  </li>
<li>《图解TCP协议》</li>
</ul>
<p>建议用<code>wireshark</code>抓包软件进行分析。  </p>
<h1 id="第三站：Unix-x2F-Linux操作系统"><a href="#第三站：Unix-x2F-Linux操作系统" class="headerlink" title="第三站：Unix&#x2F;Linux操作系统"></a>第三站：Unix&#x2F;Linux操作系统</h1><p>掌握对<code>Unix/Linux</code>操作系统的常用操作指令操作，例如  </p>
<ul>
<li><code>shell</code>脚本  </li>
<li><code>vim</code>编辑器的使用  </li>
<li><code>sed</code>  </li>
<li><code>awk</code></li>
</ul>
<p>多练习，多总结  </p>
<p>网络编程方面需掌握  </p>
<ul>
<li>Socket、Unix Domain Socket  </li>
<li>进程间通讯</li>
</ul>
<h4 id="推荐书籍-1"><a href="#推荐书籍-1" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul>
<li>《UNIX网络编程卷一：套接字》  </li>
<li>《UNIX环境高级编程》  </li>
<li>《Linux&#x2F;Unix设计思想》</li>
</ul>
<h1 id="第四站：Nginx、Apache、Caddy、等Web-Server和核心功能"><a href="#第四站：Nginx、Apache、Caddy、等Web-Server和核心功能" class="headerlink" title="第四站：Nginx、Apache、Caddy、等Web Server和核心功能"></a>第四站：Nginx、Apache、Caddy、等Web Server和核心功能</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2019/04/14/server-roam/server.png">  </p>
<h2 id="Web-Server核心功能"><a href="#Web-Server核心功能" class="headerlink" title="Web Server核心功能"></a>Web Server核心功能</h2><ul>
<li>HTTP解析  </li>
<li>HTTPS支持  </li>
<li>虚拟主机(一个端口，多个域名)  </li>
<li>静态资源  </li>
<li>URL重写  </li>
<li>gzip压缩  </li>
<li>作为反向代理，和其他进程常用通讯协议的支持</li>
</ul>
<p>推荐学习了解下<code>Caddy</code>  </p>
<h1 id="第五站：常用的支持Web开发的语言"><a href="#第五站：常用的支持Web开发的语言" class="headerlink" title="第五站：常用的支持Web开发的语言"></a>第五站：常用的支持Web开发的语言</h1><ul>
<li>PHP(LAMP、LNMP)  </li>
<li>Java  </li>
<li>Python  </li>
<li>Ruby  </li>
<li>Go  </li>
<li>C#(.NET)</li>
</ul>
<p>另外常用的数据结构和算法要有了解  </p>
<h1 id="第六站：数据库"><a href="#第六站：数据库" class="headerlink" title="第六站：数据库"></a>第六站：数据库</h1><ul>
<li>关系数据库：SQLite,MySQL,Postgresql,SQL Server,Oracle  </li>
<li>NoSQL：Redis,Mongodb,Cassandra,HBase  </li>
<li>缓存：Redis,Memcached  </li>
<li>其他：Go BoltDB,dgraph,CockroachDB</li>
</ul>
<p>入门数据库推荐使用<code>MySQL</code>  </p>
<h4 id="推荐书籍-2"><a href="#推荐书籍-2" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul>
<li>《高性能MySQL》  </li>
<li>《MySQL技术内幕InnoDB引擎》  </li>
<li>《Redis实战》</li>
</ul>
<h1 id="第七站：架构"><a href="#第七站：架构" class="headerlink" title="第七站：架构"></a>第七站：架构</h1><ul>
<li>高可用，高性能，可扩展  </li>
<li>分布式，CAP理论  </li>
<li>分布式消息队列：Redis,ActiveMQ,RabbitMQ,ZeroMQ,Kafka,MetaMQ,RocketMQ等  </li>
<li>常用的应用场景：异步处理，应用解耦，流量削峰和消息通讯  </li>
<li>微服务</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>直播后有个答疑环节，我将此次答疑的收货整理如下：  </p>
<h4 id="关于服务端面试"><a href="#关于服务端面试" class="headerlink" title="关于服务端面试"></a>关于服务端面试</h4><p>面试考语言的分量比较小，因为服务端涉及的面比较广，需要学习的东西很多，有时候原理比语言更重要。  </p>
<h4 id="关于承压"><a href="#关于承压" class="headerlink" title="关于承压"></a>关于承压</h4><p>在项目研发过程中，无论是测试还是上线跑，服务端会经常背锅，所以在压力上要及时调整好心态，做好和其他岗位人员的及时有效沟通。  </p>
<h4 id="关于未来发展"><a href="#关于未来发展" class="headerlink" title="关于未来发展"></a>关于未来发展</h4><p>努力去大公司，做一些大项目，最好流量是千万级别以上的。  </p>
<p>学无止境，一起努力！  </p>
]]></content>
      <categories>
        <category>Learn-server</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>数据库</tag>
        <tag>服务端</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>放假归来上班综合症</title>
    <url>/2019/02/12/return-to-work-after-vacation/</url>
    <content><![CDATA[<p>春节结束，放假归来，已在公司上班两天。  </p>
<p>向公司行政部申请买了块8G台式机内存条，额头上又隐约在冒痘痘了，半年过去了，难道还没有适应南方的气候？  </p>
<p>伶儿说她明天早上七点就到乌鲁木齐了，距离我们下次见面就是她在学校答辩完，五月底六月初的样子。下次重逢，不要再分开了好吗？  </p>
<p>哈哈，突然觉得自己好矫情，说这些。  </p>
<p>昨天浑身酸痛，什么也不想做。今天试着看了些技术书，看不进去里面的概念，试着刷了几道LeetCode关于数组的题目，收获还行。  </p>
<p>又要开始程序化的生活了，早起-骑车-工作-看书-下班-玩&#x2F;学习-睡觉，如此循环。  </p>
<p>好想做一些白日梦骗自己几分钟，又感到幼稚。</p>
<p>乱七八糟的写了些话，记录放假归来后内心烦躁的情绪。  </p>
<p>不管怎样，生活还得继续，世界还等着我创造奇迹。  </p>
<p><img src="/2019/02/12/return-to-work-after-vacation/dark.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>放假</tag>
      </tags>
  </entry>
  <entry>
    <title>妹妹的中考</title>
    <url>/2020/07/30/sister-zhong-kao/</url>
    <content><![CDATA[<p>这两周一直在忙妹妹的中考，这个月底总算尘埃落定。  </p>
<p>由于今年疫情原因，取消中考体育，所以总分只有750分，妹妹说她考了670分，全市排名1700左右，我觉得可以冲下排名第二、三，保底是排名第四和第五的学校。  </p>
<p>然而最终录取分数线出来后，排名第三的乌鲁木齐市八一中学分数线比妹妹的成绩高了5分，最终被排名第四的乌鲁木齐市八中录取了。  </p>
<p>父母觉得有些遗憾，但只能接受，好在乌鲁木齐市八中也离家比较近，耗时近两周的中考录取终于结束了。  </p>
<p>然而，我突然回想起我的中考，跌跌撞撞中被乌鲁木齐市高级中学实验班录取，巨大的校园和先进的设备吸引了我，还有各种兴趣小组可以参加，邻居们之前还对我家不屑一顾，突然听说我考到了乌鲁木齐市高级中学的时候，羡慕、嫉妒纷至沓来。从那时起我突然明白，原来好学校有时候就像一种荣誉的象征，不光是给自己争气，也是给父母脸上增光。  </p>
<p>时隔多年，我依然庆幸，在高中里遇到的良师益友，影响了我的高考乃至大学生涯。  </p>
<p>中考差5分也算是一次警醒，希望妹妹可以在乌鲁木齐市八中里茁壮成长，期待三年后的高考，也能取得一个满意的结果。  </p>
<p><img src="/2020/07/30/sister-zhong-kao/light.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>中考</tag>
      </tags>
  </entry>
  <entry>
    <title>七年前的高考</title>
    <url>/2021/06/07/seven-years-ago-china-gao-kao/</url>
    <content><![CDATA[<p><strong>本以为自己离开了地狱走向天堂，却不知离开的才是天堂，走向的才是地狱。</strong>  </p>
<h2 id="什么是地狱、什么是天堂？"><a href="#什么是地狱、什么是天堂？" class="headerlink" title="什么是地狱、什么是天堂？"></a>什么是地狱、什么是天堂？</h2><p>在我看来，只要是愿意将时光定格在某个时刻，并且保持身心愉悦，它就是天堂，反之即是地狱。  </p>
<p>曾经的我非常怀念高三那段时光，虽然有成堆的试卷要做，但老班说做不完就别做了，睡眠要紧，每一章前几道题一眼就看出答案的就别做了…哈哈哈，这句话至今印象深刻。  </p>
<p>那时候的我，单纯且乐观，对待一切事物都是尽力就好，不留遗憾。心情不好的时候，约上一个朋友操场散心，亦或是放学留下来打球释放压力，大家开开心心的数着高考的倒计时日历…  </p>
<p>然后，高考结束，从此各奔东西。  </p>
<h2 id="散"><a href="#散" class="headerlink" title="散"></a>散</h2><p>曾经我以为，只要心在，无论身处何方，我们一定还会再见的。  </p>
<p>然而，我忽视了物理学中对原子的质量和动量的描述，即使我一直按照自己的轨迹往前走，但还是无法预测同伴们的轨迹，以至于感到渐行渐远的无奈。  </p>
<h2 id="关于死亡与疾病"><a href="#关于死亡与疾病" class="headerlink" title="关于死亡与疾病"></a>关于死亡与疾病</h2><p>曾经我以为，死亡跟我们这些20岁左右的没关系，直到大三那年回去，一位朋友说有个和我们一届毕业的去年得癌症去世了，我哦了一下，刚毕业一年，我的高中好牛油<code>S</code>因为肺结核，各种吃药化疗瘦了好几圈，我的大学好朋友<code>Y</code>得了甲状腺癌，甲状腺切掉了一半，今年和我一起入职的新同事，去医院检查出早期肺癌，庆幸于自己捡了一条命回来，我的高中物理老师告诉我，曾经带我的英语李老师得了癌症去世…  </p>
<p>原来，死亡一直围绕在我身边，随时找到身体防御系统的漏洞准备入侵，只是我并不知情。</p>
<h2 id="关于我的高考"><a href="#关于我的高考" class="headerlink" title="关于我的高考"></a>关于我的高考</h2><p>我是2014年参加的高考，犹记得高考前一天晚上，父亲开车带我去爬山，让我把心里的气大声吼出来，妹妹在旁边送给我美好的祝福，我看着夕阳西下，微风吹拂过脸庞，带着阵阵凉意，我在山上站了一会，然后对父亲说，走吧，明天考试。  </p>
<p>第一天的考试，感觉发挥还行，语文作文字写飘了；第二天考完数学，去上卫生间的时候听旁边人说“有个人太紧张，复读了一年来考试，竟然考完忘记把选择题答案涂上去”，吓的我赶紧回忆了一下，哦还好，我涂了；下午考完理综，没有想象中如脱缰野马飞奔而出，而是静静的走出校园，坐上公交回学校拿答案，然后再看一眼自己的母校，再见了，我的中学时光。  </p>
<h2 id="录取通知到了"><a href="#录取通知到了" class="headerlink" title="录取通知到了"></a>录取通知到了</h2><p><strong>潜伏在波涛下寂静无声，跃升于惊涛上乘风化龙。</strong>  </p>
<p>录取通知到的那天，我记得很清楚，家里人很开心，我也感到幸运，被喜欢的专业录取。  </p>
<p>四年后，我毕业了，参加工作，入职、成长、离职，跳槽，认识了各个阶级的人，看到曾经的一个个目标在逐步实现，小时候对大人世界的困惑和迷茫也慢慢散去。  </p>
<p>回想起这七年来，让我明白了两件事：  </p>
<ul>
<li>永远不要做一个被一眼就看透的人；  </li>
<li>韩信的胯下之辱确实让人难以忍受，但当一个人的心中有着更高的山峰想去攀登时，他就不会在意脚下的泥沼。</li>
</ul>
<p>曾经的我如同一个无知且单纯的少年，害怕考试，害怕身边的人离我远去。感谢这七年的成长，当我回首自己的中学时光，我确实虚度了它，没有把精力全部放在做题上，但如果时光倒流，我想我依旧会去选择逃课、看小说，选择去追喜欢的女生，选择去做一些刺激的事情…如今那个少年已经不在。  </p>
<h2 id="梦醒、破茧"><a href="#梦醒、破茧" class="headerlink" title="梦醒、破茧"></a>梦醒、破茧</h2><p>前几天做梦，梦见高中好基友凡儿在高考前终于肾结石好了，排出了一个拳头大的石头，然后明天是高考，结果我的准考证还没有打印，路过车站时看到了她那扎着马尾的侧颜，我心中默念高考加油，结果准备打印准考证时手机都碎了，这是铁了心不让我高考啊，凡儿还问我该怎么办，考场座位号都晓得不，但我随即淡定的笑了笑，说道没事，以后还有的是机会…  </p>
<p><img src="/2021/06/07/seven-years-ago-china-gao-kao/gao.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>高考</tag>
        <tag>回忆</tag>
        <tag>初心</tag>
      </tags>
  </entry>
  <entry>
    <title>6次提交完善Github个人简介</title>
    <url>/2021/02/01/six-github-commits-update-my-github-readme/</url>
    <content><![CDATA[<p>半年前意外看到了阿里巴巴半霜大佬的<code>Github</code>个人界面，甚是喜欢，今天晚上我利用了一个半小时的时间查资料分析代码，，地址点<a href="https://github.com/OctopusLian">这里</a>  </p>
<p>个人觉得一个好的<code>Github</code>页面应该包含以下内容：  </p>
<ul>
<li>简短的个人介绍  </li>
<li>最近的学习情况和期待完成的事  </li>
<li>社交&amp;其他技术网站链接  </li>
<li>常用的软件和编程语言  </li>
<li><code>Github</code>信息，包括star数、commit次数、PRs等  </li>
<li>项目列表</li>
</ul>
<p>以上，是我完成这次个人<code>README</code>的动力。  </p>
<p>最后我想说，前端还是很有趣的，有空一定要系统学习一下^_^  </p>
<p><a href="https://www.cnblogs.com/xueweihan/p/13441511.html">【译】10 款国外实用、有趣的 GitHub 简介 README</a></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>简介</tag>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次皮肤护理体验记录</title>
    <url>/2020/06/27/skin79-ba-wang-can-first-skin-care-notes/</url>
    <content><![CDATA[<p>上周六用霸王餐去体验了一次皮肤护理，现将学习到的知识记录下来。  </p>
<h2 id="皮肤检测"><a href="#皮肤检测" class="headerlink" title="皮肤检测"></a>皮肤检测</h2><p>首先，因为是第一次做护理，需要对皮肤做一次检测。  </p>
<p>店长会拿一个仪器，类似放大镜，但又可以检测到皮肤下面的情况，于是在检测了一定时间后，得到如下结论：  </p>
<ul>
<li>皮肤年龄，正常；  </li>
<li>皮肤黑头，在T字区比较多；  </li>
<li>皮肤干燥程度，脸颊两侧较严重；  </li>
<li>皮肤红血丝，脸面有些多。</li>
</ul>
<p>之后给出方案，建议7-10天做一次皮肤清理，大概要做8次；皮肤修复大概做4-5次。  </p>
<p>平时少吃辣，别熬夜，最晚11点就需要入睡，护肤品尽量选择氨基酸的，面膜选择医用蒸馏水面膜。  </p>
<p>最后店长还说，你这情况不算严重，至少你每天早晚都用洗面奶水乳霜，保护的还不错。  </p>
<p>接着便体验皮肤清理了。  </p>
<h2 id="皮肤清理"><a href="#皮肤清理" class="headerlink" title="皮肤清理"></a>皮肤清理</h2><p>躺在一张床上，先用卸妆水摸遍全脸，然后用一种可以喷出热气的机器将脸上的毛孔打开，</p>
<p>接着用小气泡（感觉是利用大气压强原理，在皮肤和玻璃罩内构建一个压强，然后将皮肤里面的脏东西洗出来，再用蒸馏水清理掉，继续吸）清理一遍脸，</p>
<p>接着用铲鼻机（超声波震动原理，我是感觉不到震动的，然后将黑头震出来，再用铲鼻机头铲掉）清除黑头，这个过程有些长，</p>
<p>接着就是补水阶段，需要敷面膜，然后有姐姐帮你涂精华液，  </p>
<p>然后就是用一种类似喷头的机器收缩毛孔，  </p>
<p>接着敷医用蒸馏水面膜，还有泥浆软膜。  </p>
<p>流程结束。  </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>做完之后感觉脸清爽许多，不过姐姐建议我晚上还得用补水面膜敷一下，不然脸太干会起皮（不过我还好，就敷了一次）。  </p>
<p>这次体验让我学到了一些护肤上的知识（其实女朋友也在给我讲），还有见识了各种仪器的操作和作用，顺便用我仅存的高中物理化学和生物知识去理解他们的原理，还是很开心的。  </p>
<p>最后办了一张价格还挺实惠的皮肤护理修复体验卡，估计可以用上半年，到时再多学习学习，积累护肤经验。  </p>
<p><img src="/2020/06/27/skin79-ba-wang-can-first-skin-care-notes/hufu.jpg">  </p>
]]></content>
      <categories>
        <category>skin-care</category>
      </categories>
      <tags>
        <tag>皮肤</tag>
        <tag>护理</tag>
        <tag>skin79</tag>
        <tag>黑头</tag>
        <tag>清理</tag>
      </tags>
  </entry>
  <entry>
    <title>爱笑的眼睛</title>
    <url>/2020/10/20/smiling-eyes/</url>
    <content><![CDATA[<p>“离开你我才发现自己，那爱笑的眼睛，流过泪，像躲不过的暴风雨….” ————林俊杰《爱笑的眼睛》  </p>
<h2 id="离开学校"><a href="#离开学校" class="headerlink" title="离开学校"></a>离开学校</h2><p>虽然离开学校已经两年了，但我偶尔还是会规划自己的暑假生活，想着7月去哪玩，8月去吃什么…等等，我不能做梦了，我已经没有寒暑假，oh shit !  </p>
<p>我时常还是怀念上学的时光，没有人打扰的实验室 &amp; 图书馆四楼的计算机专业书架和三楼的文学小说书架 &amp; 800一年的宿舍和食堂5元的两荤一素一汤 &amp; 良师益友…  </p>
<h2 id="离开家人"><a href="#离开家人" class="headerlink" title="离开家人"></a>离开家人</h2><p>远离故乡，远离家人，来到一座陌生的城市求职生存，我突然算了下，从大学到现在六年时间里，我们相处的时间竟然不足100天。  </p>
<p>我时常想念母亲做的新疆拌面和岐山臊子面，父亲做的红烧肉和手抓饭，和妹妹抢电脑打拳皇，经常2:3她赢，殊不知其实是我故意摁错了几个发绝招的键位，哈哈哈…  </p>
<h2 id="离开家乡"><a href="#离开家乡" class="headerlink" title="离开家乡"></a>离开家乡</h2><p>有得必有失，有舍必有得，这是我小时候时常听到的一句话。  </p>
<p>我失去了熟悉的环境，失去了和父母相处的日子，失去了学校安逸的时光，换来了两年时间的反思和顿悟，以及见识了最真实的自己。  </p>
<h2 id="你有没有自己的忍道？"><a href="#你有没有自己的忍道？" class="headerlink" title="你有没有自己的忍道？"></a>你有没有自己的忍道？</h2><p>我时常回忆起《火影忍者》里的李洛克和旋涡鸣人的场景，为了贯彻自己的忍道，李洛克开了八门遁甲，鸣人不断学习忍术和挨打，最终李洛克得到老师认可，鸣人当上火影。有时我在想，这样的场景我可以复现吗？  </p>
<h2 id="那爱笑的眼睛"><a href="#那爱笑的眼睛" class="headerlink" title="那爱笑的眼睛"></a>那爱笑的眼睛</h2><p>眼睛是心灵的窗户，我喜欢正视对方的眼睛，因为可以发现很多内在不易表现的东西。  </p>
<p>而我也喜欢对着镜子看自己，有时看到乐观和坚毅，有时看到伤感和迷茫，也许这才是真实的我，热泪与梦想交织，在希望和失望，在迷茫和坚定自己的过程中，螺旋式缓慢成长。  </p>
<p><strong>离开你我才找回自己，那爱笑的眼睛，再见到你，我一定让自己假装很坚定。</strong>  </p>
<p><img src="/2020/10/20/smiling-eyes/1.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>一点小挫折</title>
    <url>/2019/03/23/some-setbacks/</url>
    <content><![CDATA[<p>终于迎来了最难受的时期，流媒体收录服务，逻辑很杂，但不难，就是tmd理不清楚。  </p>
<p>下周五要发版，现在东西搞定不了，该如何是好？  </p>
<p>父母说，遇到困难就去解决，不要逃避，他们也说，这个东西以后就交给我来负责了！  </p>
<p>可是，我真的能扛起这个重任吗？我反复问自己。  </p>
<p>明天还有一天的时间，我想重新用dlv调试把每个流程弄懂。  </p>
<p>希望可以来得及！</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>单人旅途-通向梦想的路</title>
    <url>/2016/08/25/solo-journey-the-road-to-dreams/</url>
    <content><![CDATA[<p><img src="/2016/08/25/solo-journey-the-road-to-dreams/road.jpeg">  </p>
<h2 id="说走就走的旅行"><a href="#说走就走的旅行" class="headerlink" title="说走就走的旅行"></a>说走就走的旅行</h2><p>每一学期的期末考试，无疑是最让人激动人心的，因为它不光标志着这一学期的结束，也意味着漫长假期的来临。  </p>
<p>回想起这学期，每天最开心的三件事：晨读、午休、夜跑。期末考试结束的那天晚上，我破例喝了许多酒，它如盗版的孟婆汤一样，勾起了我这两年里所有的回忆。  </p>
<p>人生最遗憾的事情，就是对于当初自己信誓旦旦许下的诺言，没有尽到履行的义务，只能捶胸顿足，悔不当初。  </p>
<p>我到底是谁？我为什么会在这里？我到底想要什么？这是我在喝了N多酒后，脑子里仅存留的三个问题。  </p>
<p>回到家后，我没有再触碰过关于专业的书籍，也没有刷OJ找快感，而是陪着妹妹做一些小手工，或者约上朋友去公园锻炼身体。<br>一直很想出去看看，在经过父母的同意后，我准备开始一段说走就走的旅行…  </p>
<h2 id="乌鲁木齐市"><a href="#乌鲁木齐市" class="headerlink" title="乌鲁木齐市"></a>乌鲁木齐市</h2><p>7月13日 乌鲁木齐市：出发前一天，我和朋友在公园打篮球，逛书店，去新疆大学看望还在为课设发愁的朋友。  </p>
<p>7月14日：和家人道别后，我独自一人前往火车站，即将离开这座城市，前方是未知的…紧张而又激动。  </p>
<h2 id="兰州市"><a href="#兰州市" class="headerlink" title="兰州市"></a>兰州市</h2><p>7月15日 兰州市：在兰州中转，本想去兰大会见朋友，结果他因临时有事来不了，而我又赶上暑假旅游旺季，房价贵的吓人。又因为出省忘记开漫游，导致手机无信号，打不成电话上不了网，于是我毅然决定晚上出发去西安。  </p>
<h2 id="西安市"><a href="#西安市" class="headerlink" title="西安市"></a>西安市</h2><p>7月16日 西安市：经历了一晚上的煎熬，我终于抵达了古城西安。由于手机没有信号，我在车站用公用电话联系到了亲戚，然后他们带着我，逛了大雁塔，参观陕西省博物馆，晚上去看音乐喷泉，我漫步于大唐芙蓉街。在经历了两天两夜的旅途的奔波后，我也终于在这美丽的夜晚中感受到了心灵上的满足。  </p>
<h2 id="杨凌市"><a href="#杨凌市" class="headerlink" title="杨凌市"></a>杨凌市</h2><p>7月18日 杨凌市 雨：去西北农林科技大学去找我亲戚。那天下着雨，路上人少。我有幸看到实验室里一位外籍教授与几位中国研究生用英语讨论研究课题时的情景，听着他们流利地对话、相互交换着想法，我感到有些熟悉。美丽的校园里开满了各种奇花异草，嗅着花香，逛遍了整个校园。<br>这是一座小城市，在我眼里相当于世外桃源。  </p>
<h2 id="西安市-1"><a href="#西安市-1" class="headerlink" title="西安市"></a>西安市</h2><p>7月19日 西安市：很幸运，我在西安遇到了暑假在校实习的高中校友。和她一起去了三所男女比例失衡的大学，但可惜的是现在正是暑假期间，并没有看到百花齐放的景象。后来我们去广场看轮滑表演和广场舞，在热闹的夜市上品尝新疆的烤肉，东北的熏肉大饼和陕南地区的冒菜。<br>想要了解一个地区的文化，可以从他们的特色小吃入手。比如西安的牛羊肉泡馍；杨陵的蘸水面和岐山的臊子面等等。  </p>
<p>7月21日： 西安市：一大早先喝了一碗河南的胡辣汤，再吃了几张饼子。然后坐车赶往西安市中心的钟楼和鼓楼。站在楼上，整个西安尽收眼底。后来，我正好赶上了钟楼的古乐器表演和鼓楼的大鼓表演，听着那激动人心的音乐，我仿佛回到了当年的战场上，与战友们一起喝酒吃肉杀敌。期间联系到了一位在西安电子科技大学上学的朋友，下午我便倒车去了那里。在西安电子科技大学的宿舍里，我和他畅聊了一些编程感受和算法心得。最后还讨论了“为什么工科男单身汉多”？归结起来原因就是：工作比爱情更重要；周围可利用资源太少；不懂得浪漫；时间分散；用计算机的思维去谈恋爱。                             当你想要找学计算机的孩子聊天时，他们不是不在就是聊几句就说有事，但你会发现，他们会经常发动态说说，你会误以为他们时间充足而生气。请理解我们的身不由己，我们的时间都是零碎的，没有大段的时间来聊天，所以只能通过动态阐述我们的酸甜苦辣，也因此，如果哪个IT男主动找你聊天，这说明你对他真的很重要。  </p>
<p>7月22日 西安市：所有的放不下，都是不愿直视那段不愿回忆的曾经。  </p>
<p>7月23日 西安市翠华山：在西安的最后一天，我选择了去爬山。<br>从进入密林深处开始一步步地向上爬，到站在高处感受一览无遗的美，还有自然风吹着，那一刻我仿佛放空了自己，什么荣誉名利，背后的勾心斗角，都与我无关。此刻的我只愿站在这里，享受片刻的宁静，心灵的沉淀。<br>下山时我选择了人迹罕至的一条路，听着林间清鸣的鸟叫声，看着在眼前飞来飞去的奇异昆虫，加上各种巧夺天工的美景，我终于体会到了大自然的美丽与奇妙。<br>黄色的树林，前路分为两股，可惜我不能兼顾。我站立良久，形影孤独，远远眺望塔门向远处延伸，直到转入树林深处。岁月流逝，将来的某时某处，我会在叹息中想起。两条路在林间分开，而我——选择了人迹罕至之途，从那一刻起，一切差别已成定铸。  </p>
<h2 id="绥德"><a href="#绥德" class="headerlink" title="绥德"></a>绥德</h2><p>7月24日 陕北绥德县：人世间最幸福的事情，莫过于亲人的团聚。<br>既然已经到了陕西，怎能不去看看我的爷爷奶奶呢？奶奶看到了我来她，高兴得合不拢嘴。<br>在陕北我品尝了美味的羊杂碎，刀刀碗托和凉皮；和小朋友们一起用自制的弓箭玩，仿佛自己也回到了童年；晚上坐在山上，看着满天的星星闪烁不断，静静地聆听草丛中的鸟叫和虫叫声，当然也要忍受着蚊虫的肆意叮咬。此情此景，让我不禁想起了一句古文：无丝竹之乱耳，无案牍之劳形，何陋之有？<br>旅行本身就是一次重新认识自我的过程。  </p>
<h2 id="南阳市"><a href="#南阳市" class="headerlink" title="南阳市"></a>南阳市</h2><p>7月27日 河南南阳市：“臣本布衣，躬耕于南阳，苟全性命于乱世…”-诸葛亮 《出师表》<br>凌晨抵达的南阳。和搞ACM的朋友早上吃了几个水煎包，喝了一碗胡辣汤后，就去看了汉画馆，武侯祠，府衙，晚上在白河桥旁找个空地坐下，吃着台湾的小吃，畅谈在IT路上的各种奇遇。<br>有时候生活要像计算机中的二进制一样简简单单，不是0，那就是1.  </p>
<h2 id="济南市"><a href="#济南市" class="headerlink" title="济南市"></a>济南市</h2><p>7月28日 山东济南市 闷热：我从远方赶来，为赴你一面之约。</p>
<p>7月30日 济南市：虽然持续的桑拿天气让人不敢出门，但这还是挡不住我们出去玩乐的愿望。今天和她去了大明湖，拜访了八极阁和铁公祠（铁铉，明朝时期我最钦佩的人之一）。下午气温有所下降，我们去了济南有名的芙蓉街，品尝了山东的煎饼卷大葱，黄焖鸡米饭和老济南酸梅汤；四川的臭豆腐；东北的烤冷面；挑战了我的味觉：烤蚂蚱和知了猴；还有从没见过的菠萝饭和虾扯蛋。晚上到泉城广场看喷泉表演，我俩坐在石凳上边吃边聊。人来人往，这样的夜景，还有佳人相伴，我在济南的心愿也终于实现了！</p>
<h2 id="衡水市"><a href="#衡水市" class="headerlink" title="衡水市"></a>衡水市</h2><p>8月1日 河北衡水市：衡水下了一晚上的雨，中午出门感觉好极了！和一位四年没有会面的老朋友去吃了一顿美味的石锅鱼，下午在衡水湖中的桥上散步，然后度过在河北静谧的第一天。</p>
<p>8月3日 衡水市：在衡水的最后一天，我的朋友借了两辆捷安特自行车去骑行。我们绕着衡水湖；路过高考工厂——衡水中学；去了荷花园；最后沿着无人的小道抵达了目的地。<br>朋友，时光不老，你我不散。<br>（已在外游玩20天，还记得早上老爸打来电话，让我早点回家免得影响报到。其实我想说，我还没玩够！）  </p>
<h2 id="北京市"><a href="#北京市" class="headerlink" title="北京市"></a>北京市</h2><p>8月4日 北京市：唱着歌儿，踏着轻快的步伐，我来到了此次旅途的终点站。幸运的我在刚出火车站就遭遇了地铁站的晚高峰时期。<br>而且今晚我估计是要失眠了，因为是和一名矿业大学校辩论队员的朋友住在一起，有许多话题可以畅聊至深夜。  </p>
<p>8月5日 北京市：晚上准备去清华园，过去的时候遇到一位北京语言大学的老师给我指路；回来的时候因为做错了车，又受到了一位首都师范大学学生的帮助这才顺利回到了宿舍；在未名湖畔旁，我还偶遇了一位作家在卖自己创作的诗集；在这里，我感觉处处都能遇到一些卧虎藏龙的人物。  </p>
<p>8月6日 北京市：参观了圆明园被毁灭后的遗址，我可以想象出以前繁华时多么宏伟壮观的景象。下午去北大科技园听了北大毕业生的演讲；晚上和朋友一起去吃火锅，和在北科大上学的高中校友在天桥上跳街舞，后来我俩坐在喷泉旁的空地上，在调侃与回忆高中趣事的美好过程中度过。<br>我们都已不再是小孩子，而是逐渐走向理性与成熟，在各自的生活中挣扎、学习并学会生存。愿命运女神会眷顾那些坚持不懈、依然追逐自己梦想的人。  </p>
<p>8月7日 北京市：独自顶着大太阳，倒车倒地铁来到我梦寐以求的天安门广场，还有毛主席纪念堂和人民英雄纪念碑。这里有来自世界各地慕名而来的游客，当然包括满怀赤子之心的中国人。      后来我到南锣鼓巷看各种奇葩并富有创意的店名，或者因为嘴馋而尝一尝各种美味的小吃。晚上插着耳机，借着什刹海美丽的夜景，一路走下去。<br>每个人，都是海面上的一个船只，要想去往自己喜欢的方向，就要不断尝试各种未知的可能，在迷茫与未知中探索出一条新的且符合自己的道路。  </p>
<p>8月8日 北京市：不要把时间浪费在日常琐碎，不要纠结于无关紧要的细节，因为这些终将在崎岖时光里淡去，化为灰烬。   好好生活，开阔心胸。你活在这世上应活在当下。“当下”一词对已死之人是最大的奢侈。  </p>
<p>8月9日 北京市：去了一次国家图书馆，琳琅满目的图书和硕大的自习室，齐全的设施条件和服务，看着这里的人孜孜不倦的看书，记笔记，让我明白了我以后应该以什么样的态度对待自己的人生，才不会到最后有所遗憾！     </p>
<p>夜幕降临，我约上朋友一起去1898咖啡厅过七夕，幸运地邂逅了一位在北化工上学的女孩。<br>夜晚独自走在回学校的路上，不经意间想起了那尘封多年的往事，远方的她还过得好吗？过去的我总是生活在你待我如初的阴影里，直到现在我才明白：幸福就是该结束的时候不再强求，在我应该珍惜的时候学会别无所求。<br>我和你不会再联系，希望你不要介意，要怪就怪当初我们没有选择在一起。<br>谢谢你，再见。  </p>
<p>8月10日 北京市：晚上的火车，要离开北京了。<br>白天去国家博物馆的主题为“古代中国”的展厅参观了一下，回顾了历史，然后去王府井商业街买了京城小吃。我在这里呆了一周，深刻感触到北京是一块人才汇集的地方。谢谢你们：陪我畅聊心理学、哲学、军事政治至深夜的矿大舍友；给我在专业领域进行一些指导的手抓饼哥；晚上一起在天桥跳街舞的校友。           </p>
<p>我相信，这里将是我人生的新起点。<br>再见，北京。   </p>
<h2 id="曲阜市"><a href="#曲阜市" class="headerlink" title="曲阜市"></a>曲阜市</h2><p>8月11日 山东曲阜市：在草丛中遇到一只马蜂绕着我飞来飞去，于是我一巴掌把它扇飞了。可是下一秒，它就迅速飞到我的额头上，给我狠狠的蛰了一下！<br>第一次被马蜂蜇了……<br>以后再遇到这种情况，我就明白了为什么那些人见到马蜂面露难色，要么躲开，要么就站着不动。都是被蛰过的啊！</p>
<p>8月12日 曲阜市：既然来到了大圣人孔子的故乡，当然要去参观下这里有名的景点：孔庙、孔府、孔林。<br>先在孔庙里逛了三个半小时，在大成殿前看着小孩子们拜孔子。它带给我的是庄重且具有崇高的敬意。<br>孔府展示了一种大户人家的气派，尤其是纪晓岚在孔府大门口写的一副对联，主要想表达的意思是“富贵无头，文章通天”。后来因为有些困，我便插着耳机，坐在孔府的后花园里小憩了一会儿。 最后去的是孔林，这里号称是全世界最大的家族坟墓。我在孔林里徒步8公里，闻着树木花草的清香，心旷神怡。<br>晚上当地的朋友带着我，两人各骑着一辆电动车绕城狂飙，直呼过瘾。<br>在曲阜玩了两天，这里虽然没有大城市的繁华，却让我体会了一种深厚 的文化气息在孕育，在成长。</p>
<h2 id="济南市-1"><a href="#济南市-1" class="headerlink" title="济南市"></a>济南市</h2><p>8月13日 济南市：已经在外漂泊了一个月，还记得上个月的今天，一人一个登山包，外加一个小书包，就此踏上了未知的旅途，从此经历了各种人生百态。<br>还记得上次到济南的时候是晚上，一位在山师大上学的傻女孩来接我，因为和她相遇后，我先是被她带到了错误的车站，后来她自己忘了回学校的路。让我一阵担心，可是他的那份心意我却一直看在眼里，记在心里。<br>今天是我独自一人在济南转车，回想起上次和她在济南游玩时的点点滴滴，心中不免多了些许欢笑与满足。<br>而这次，我是因为想见一位朋友，一位素未谋面，却在网络上对我帮助很大的朋友。<br>可是，我到了她所在的学校，在看台上坐了三个多小时，也没有等到她。而她最后给我发了条消息“等我变到足够优秀，自会主动与你相见”。<br>如果还能相遇，就让我们彼此都更好一点，愿我们在彼此看不到的岁月里熠熠生辉。<br>再见泉城济南，再见山东！</p>
<h2 id="通向梦想最快的路"><a href="#通向梦想最快的路" class="headerlink" title="通向梦想最快的路"></a>通向梦想最快的路</h2><p>8月17日 新疆乌鲁木齐市：13张火车票，畅游33天，穿过9000公里，有过无家可归的漂泊感，有过浪子回头的悔意。在路上，被坑过，也被好心人帮助过。在这场一个人的旅途中，我品尝了寂寞的滋味，也享受了完全支配自己生活的自由自在的感觉。</p>
<p>曾经，在高中的时候，我为了考上自己心目中的学校，疯狂刷题。为了那个目标，我尝试过走捷径；我忽视过走捷径；我忽视过我最好朋友的感受；我瞧不起我好朋友身边的女生；我伤害过关心我的人；我甚至都没有真正了解过自己的家人。以前，我以为成功了才能得到自由，可是后来我才明白，只有真正地面对自我才能自由。我渴望做一个表里如一的人，所以我厌恶大学里的阿谀奉承，鄙夷背后给别人捅刀子。</p>
<p>当那些无话不谈，渐渐变成无话可说。我的老朋友，你是否理解我的频频举杯，或偶尔的沉默。</p>
<p>很久以后我才明白：所有人来到你生命里自有他的意义。人最难的就是学会怎么平静地面对离别。我希望我们都能记住那些在你生命中留下一笔的人，那些在深夜陪你聊天，那些默默陪在你身边，那些生病时在你左右，那些你难过时会想起的人。   </p>
<p>正是因为这些人的陪伴，你才变成了现在的你。好好珍惜身边的每一个人，一如你珍惜自己一样，即使你们终究会面临离别。<br>这些年我总是在怀念过去，是的，不可预知的未来让我感到恐惧，只有那既成事实的过去，才能让我有安全感。      </p>
<p>但是过去不全是美好，未来也不总是黑的，当命运划过天际，连接过去和未来的现在，才是我真真切切所拥有的。</p>
<p>从前的我想通过捷径走向成功，后来我懂了：它就像是一面巨大的墙，我是墙上的爬山虎，越爬越高，对墙也就越来越依赖。却忘了，离开墙，我什么都不是。如果有可能，我想做一棵树，靠自己的力量扎根。每一口光合作用都是用力呼吸后的结果。大口大口地呼吸，充盈，沉淀属于自己的幸福。</p>
<p>我想，那应该就是通向梦想最快的路。  </p>
]]></content>
      <categories>
        <category>Travel-notes</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>单人旅途</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体收录流程</title>
    <url>/2019/07/06/stream-media-collection-process/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为工作相关，所以写篇文章记录下这整体的业务流程。  </p>
<h2 id="收录"><a href="#收录" class="headerlink" title="收录"></a>收录</h2><h3 id="文字简述"><a href="#文字简述" class="headerlink" title="文字简述"></a>文字简述</h3><p>收录，简单来说就是将视频流保存成视频文件，比如后缀名为mp4,flv,ts等。那么需要哪些模块呢  </p>
<ul>
<li>前端：展示给用户看的，同时将用户点击的请求数据发送给后端做处理；  </li>
<li>数据中转服务：在前端传给调度服务的数据格式可能会有误，所以中间要经过这个服务，对数据进行加工（一般是<code>json</code>封装）后发送给对方；  </li>
<li>调度服务：负责所有数据库表的创建，记录的添加，修改，删除的操作；将要收录的源流分发给空闲的收录服务器；如果源流的码率较高，需要用转码服务器转成低码文件后收录；  </li>
<li>源流和设备信息检测服务：检测源流的状态是否异常，如果异常就反馈给前端；检测设备的<code>CPU</code>，物理存储，内存的使用占比情况；  </li>
<li>收录服务：开始收录时，由调度服务发给收录服务一个信号，收录服务开始工作，如果不需要收录了，也是由调度服务发给收录服务一个信号，收录服务停止工作；  </li>
<li>转码服务：如果源流的码率过高，例如有8000k，而用户那边的网速又很差，这样会导致视频收录下来播放给用户会显得很卡，影响用户体验，因此需要经过转码服务将高码率的源流转成低码率后，再由收录服务进行收录；  </li>
<li>迁移服务：收录下来后，其他模块可能也会需要，这时需要做迁移。  </li>
<li>适配服务：如果添加的流类型是收录服务器不支持的，需要通过适配服务转换成收录服务支持的，再进行收录。  </li>
<li>定时删除服务：收录的视频文件过多，极其占用物理存储资源，所以需要定时删除。这个定时删除服务就是做这样的事情。</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2019/07/06/stream-media-collection-process/streamsystem_o.png">  </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最开始做这个我不知道是干嘛用的，直到部门老哥给我讲了下<code>Youtube</code>的视频播放过程，让我看到当你的网速不好时，为了保证视频的流畅，画质会差一些，等你网速好了画质再变得高清点。<br>而我这个原理和它类似。<br>注意，收录服务器和转码服务器在图示为了简洁只画了一台，实际上现场要部署很多台。</p>
]]></content>
      <categories>
        <category>Learn-streaming-media</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
        <tag>视音频</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>开始学习一项新技术</title>
    <url>/2019/02/27/start-learn-new-technology/</url>
    <content><![CDATA[<p>今天部门老哥说，周五会开始做一个新东西，会用到<code>Docker</code>，叫我先下载下来，后面要用。  </p>
<p><code>Docker</code>这东西有段时间听过，是个容器，把应用放在里面跑，还是<code>Golang</code>的开源项目，对此我一直很好奇它和虚拟机相比究竟优点在哪里？  </p>
<p>现在终于要开始接触它了！  </p>
<p>加油，这两天先把手上的<code>flv</code>时移推进一下进度。  </p>
<p><img src="/2019/02/27/start-learn-new-technology/docker.png"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Docker</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_面试题1_赋值运算符函数</title>
    <url>/2019/01/17/sword-to-offer-01/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">const</span> CMystring &amp;str);</span><br><span class="line">    ~<span class="built_in">CMyString</span>(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>关注点如下：  </p>
<ul>
<li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。  </li>
<li>是否把传入的参数的类型声明为常量引用。  </li>
<li>是否释放实例自身已有的内存。  </li>
<li>判断传入的参数和当前的实例(*this)是不是同一个实例。</li>
</ul>
<h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><h3 id="经典，初级解法"><a href="#经典，初级解法" class="headerlink" title="经典，初级解法"></a>经典，初级解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="type">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回实例自身的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>C++基础语法，如运算符函数、常量引用；  </li>
<li>对内存泄露的理解</li>
</ul>
<p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/tree/master/01_AssignmentOperator">本题源代码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cplusplus.com/reference/cstring/strcpy/">cpp函数_strcpy</a></li>
</ul>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计_秒杀系统和订票系统</title>
    <url>/2021/11/17/system-design-second-kill-and-booking/</url>
    <content><![CDATA[<h1 id="系统设计分析"><a href="#系统设计分析" class="headerlink" title="系统设计分析"></a>系统设计分析</h1><h2 id="Scenario-场景"><a href="#Scenario-场景" class="headerlink" title="Scenario 场景"></a>Scenario 场景</h2><p>秒杀系统场景  </p>
<p>2020 年6 月18 日 0 点开始，京东自营限量 100台，以 4000 元的价格，抢购 iPhone 11 64G 版本，先到先得，一人限购一台，售完即止。<br>微信抢红包<br>抢春运火车票<br>抢购小米手机  </p>
<h3 id="QPS-分析"><a href="#QPS-分析" class="headerlink" title="QPS 分析"></a>QPS 分析</h3><p>平日每秒 1000 人访问该页面。<br>秒杀时每秒数10万人访问该页面。<br>QPS 增加 100 倍以上。  </p>
<h3 id="商品购买和下单流程"><a href="#商品购买和下单流程" class="headerlink" title="商品购买和下单流程"></a>商品购买和下单流程</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E5%95%86%E5%93%81%E8%B4%AD%E4%B9%B0%E5%92%8C%E4%B8%8B%E5%8D%95%E6%B5%81%E7%A8%8B.png">  </p>
<h3 id="秒杀系统需要解决问题"><a href="#秒杀系统需要解决问题" class="headerlink" title="秒杀系统需要解决问题"></a>秒杀系统需要解决问题</h3><ul>
<li>瞬时大流量高并发：服务器、数据库等能承载的 QPS 有限，如数据库一般是单机 1000 QPS。需要根据业务预估并发量。  </li>
<li>有限库存，不能超卖：库存是有限的，需要精准地保证，就是卖掉了 N 个商品。不能超卖，当然也不能少卖了。  </li>
<li>黄牛恶意请求：使用脚本模拟用户购买，模拟出十几万个请求去抢购。  </li>
<li>固定时间开启：时间到了才能购买，提前一秒都不可以（以商家「京东」「淘宝」的时间为准）。  </li>
<li>严格限购：一个用户，只能购买 1 个或 N 个。</li>
</ul>
<h3 id="需求拆解"><a href="#需求拆解" class="headerlink" title="需求拆解"></a>需求拆解</h3><p>商家侧（京东自营、淘宝天猫店家）：新建秒杀活动，配置秒杀活动。  </p>
<p>用户侧：商品秒杀页面（前端或客户端），购买，下单，付款。  </p>
<h2 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h2><h3 id="服务结构设计-单体架构"><a href="#服务结构设计-单体架构" class="headerlink" title="服务结构设计 - 单体架构"></a>服务结构设计 - 单体架构</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png">  </p>
<ul>
<li>前后端耦合，服务压力较大。  </li>
<li>各功能模块耦合严重。  </li>
<li>系统复杂，一个模块的升级需要导致整个服务都升级。  </li>
<li>扩展性差，难以针对某个模块单独扩展。  </li>
<li>开发协作困难，各个部门的人都在开发同一个代码仓库。  </li>
<li>级联故障，一个模块的故障导致整个服务不可用。  </li>
<li>陷入某种单一技术和语言中。  </li>
<li>数据库崩溃导致整个服务崩溃。</li>
</ul>
<h3 id="服务结构设计-微服务"><a href="#服务结构设计-微服务" class="headerlink" title="服务结构设计 - 微服务"></a>服务结构设计 - 微服务</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png">  </p>
<ul>
<li>各功能模块解耦，保证单一职责。  </li>
<li>系统简单，升级某个服务不影响其他服务。  </li>
<li>扩展性强。可对某个服务进行单独扩容或缩容。  </li>
<li>各个部门协作明晰。  </li>
<li>故障隔离。某个服务出现故障不完全影响其他服务。  </li>
<li>可对不同的服务选用更合适的技术架构或语言。  </li>
<li>数据库独立，互不干扰。</li>
</ul>
<h2 id="Storage-存储"><a href="#Storage-存储" class="headerlink" title="Storage 存储"></a>Storage 存储</h2><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>商品信息表<code>commodity_info</code>  </p>
<table>
<thead>
<tr>
<th>商品id-id</th>
<th>商品名称-name</th>
<th>商品描述-desc</th>
<th>价格-price</th>
</tr>
</thead>
<tbody><tr>
<td>189</td>
<td>iPhone 11 64G</td>
<td>xxxx</td>
<td>5999</td>
</tr>
</tbody></table>
<p>库存信息表<code>stock_info</code>  </p>
<table>
<thead>
<tr>
<th>库存id-id</th>
<th>商品id-commodity_id</th>
<th>活动id-seckill_id</th>
<th>库存-stock</th>
<th>锁定-lock</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>189</td>
<td>0</td>
<td>100000</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>189</td>
<td>28</td>
<td>100</td>
<td>5</td>
</tr>
</tbody></table>
<p>秒杀活动表<code>seckill_info</code>  </p>
<table>
<thead>
<tr>
<th>秒杀id-id</th>
<th>秒杀名称-name</th>
<th>商品id-commodity_id</th>
<th>价格-price</th>
<th>数量-number</th>
</tr>
</thead>
<tbody><tr>
<td>28</td>
<td>iPhone 11 64G</td>
<td>189</td>
<td>4000</td>
<td>100</td>
</tr>
</tbody></table>
<p>订单信息表<code>order_info</code>  </p>
<table>
<thead>
<tr>
<th>订单id-id</th>
<th>商品id-commodity_id</th>
<th>活动id-seckill_id</th>
<th>用户id-user_id</th>
<th>是否付款-paid</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>189</td>
<td>28</td>
<td>Jack</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E6%95%B0%E6%8D%AE%E6%B5%81.png">  </p>
<h3 id="秒杀操作"><a href="#秒杀操作" class="headerlink" title="秒杀操作"></a>秒杀操作</h3><h4 id="扣减库存"><a href="#扣减库存" class="headerlink" title="扣减库存"></a>扣减库存</h4><p>读取判断库存，然后扣减库存：  </p>
<ol>
<li><p>查询库存余量  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> `stock_info`</span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扣减库存  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `stock_info` <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>读取和判断过程中加上事务：  </p>
<p>1，事务开始  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>查询库存余量，并锁住数据  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> `stock_info`</span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扣减库存  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `stock_info` <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务提交</p>
</li>
</ol>
<p>使用 UPDATE 语句自带的行锁：  </p>
<ol>
<li><p>查询库存余量  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> `stock_info`</span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扣减库存  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `stock_info` <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> commodity_id <span class="operator">=</span> <span class="number">189</span> <span class="keyword">AND</span> seckill_id <span class="operator">=</span> <span class="number">28</span> <span class="keyword">AND</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>超卖问题解决了，其他问题呢？  </p>
<ol>
<li>大量请求都访问 MySQL，导致 MySQL 崩溃。<br>对于抢购活动来说，可能几十万人抢 100 台 iPhone，实际大部分请求都是无效的，不需要下沉到 MySQL。</li>
</ol>
<h4 id="库存预热"><a href="#库存预热" class="headerlink" title="库存预热"></a>库存预热</h4><p>秒杀的本质，就是对库存的抢夺。<br>每个秒杀的用户来都去数据库查询库存校验库存，然后扣减库存，导致数据库崩溃。  </p>
<p>MySQL 数据库单点能支撑 1000 QPS，但是 Redis 单点能支撑 10万 QPS，可以考虑将库存信息加载到 Redis 中。直接通过 Redis 来判断并扣减库存。  </p>
<p>什么时候进行预热 (Warm-up)？  </p>
<p>活动开始前：  </p>
<p><img src="/2021/11/17/system-design-second-kill-and-booking/%E9%A2%84%E7%83%AD2.png">  </p>
<h4 id="通过-Redis-扣减库存"><a href="#通过-Redis-扣减库存" class="headerlink" title="通过 Redis 扣减库存"></a>通过 Redis 扣减库存</h4><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E9%80%9A%E8%BF%87redis%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98.png">  </p>
<p>语法: GET KEY<br>作用: 获取 key 存储的值<br>GET seckill:28:commodity:189:stock  </p>
<p>语法: DECR KEY<br>作用: 将 key 中储存的数字值减一<br>DECR seckill:28:commodity:189:stock  </p>
<p>大部分请求都被 Redis 挡住了，实际下沉到 MySQL 的理论上应该就是能创建的订单了。比如只有 100 台 iPhone，那么到MySQL 的请求量理论上是 100。  </p>
<p>这个流程有没有问题？<br>1.检查 Redis 库存和扣减 Redis 库存是两步操作。<br>2.有并发问题仍然会导致超卖。  </p>
<p>解决方案<br>哪怕 Redis 侧放行，可以创建订单了，到MySQL 的时候也需要再检查一次。  </p>
<p>新的问题<br>如果并发量超高，Redis 侧实际超卖的量过大，如 100万个请求同时到达，Redis 全部放行。再到 MySQL 去检测，那 Redis 作用等于没有。  </p>
<p>通过 Lua 脚本执行原子操作<br>Lua 脚本功能是 Reids 在 2.6 版本中推出， 通过内嵌对 Lua 环境的支持，Redis 解决了长久以来不能高效地处理 CAS （check-and-set）命令的缺点， 并且可以通过组合使用多个命令， 轻松实现以前很难实现或者不能高效实现的模式。<br>Lua 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，可以完成一些 Redis 事务性的操作。<br><img src="/2021/11/17/system-design-second-kill-and-booking/lua.png">  </p>
<p>如果秒杀数量是1万台，或者10万台呢？<br>因为 Redis 和 MySQL 处理能力的巨大差异。实际下沉到MySQL 的量还是巨大，MySQL 无法承受。  </p>
<p>解决思路<br>可不可以在通过 Redis 扣库存后，到 MySQL 的请求慢一点？  </p>
<p>解决方案<br>通过消息队列（Message Queue，MQ）进行削峰(Peak Clipping)操作。  </p>
<h4 id="通过消息队列异步地创建订单"><a href="#通过消息队列异步地创建订单" class="headerlink" title="通过消息队列异步地创建订单"></a>通过消息队列异步地创建订单</h4><p>如果消息队列出现部分投递失败怎么办？<br>Redis 中的库存量，可以比实际的库存量多一点，比如 1.5 倍或者 2倍。  </p>
<h3 id="库存扣减时机"><a href="#库存扣减时机" class="headerlink" title="库存扣减时机"></a>库存扣减时机</h3><h4 id="下单时立即减库存。"><a href="#下单时立即减库存。" class="headerlink" title="下单时立即减库存。"></a>下单时立即减库存。</h4><p>用户体验最好，控制最精准，只要下单成功，利用数据库锁机制，用户一定能成功付款。<br>可能被恶意下单。下单后不付款，别人也买不了了。  </p>
<h4 id="先下单，不减库存。实际支付成功后减库存。"><a href="#先下单，不减库存。实际支付成功后减库存。" class="headerlink" title="先下单，不减库存。实际支付成功后减库存。"></a>先下单，不减库存。实际支付成功后减库存。</h4><p>可以有效避免恶意下单。<br>对用户体验极差，因为下单时没有减库存，可能造成用户下单成功但无法付款。  </p>
<h4 id="下单后锁定库存，支付成功后，减库存。"><a href="#下单后锁定库存，支付成功后，减库存。" class="headerlink" title="下单后锁定库存，支付成功后，减库存。"></a>下单后锁定库存，支付成功后，减库存。</h4><h3 id="如何限购"><a href="#如何限购" class="headerlink" title="如何限购"></a>如何限购</h3><h4 id="MySQL-数据校验"><a href="#MySQL-数据校验" class="headerlink" title="MySQL 数据校验"></a>MySQL 数据校验</h4><p><img src="/2021/11/17/system-design-second-kill-and-booking/mysql%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C.png">  </p>
<h4 id="Redis-数据校验"><a href="#Redis-数据校验" class="headerlink" title="Redis 数据校验"></a>Redis 数据校验</h4><p><img src="/2021/11/17/system-design-second-kill-and-booking/redis%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C.png">  </p>
<h3 id="付款和减库存的数据一致性"><a href="#付款和减库存的数据一致性" class="headerlink" title="付款和减库存的数据一致性"></a>付款和减库存的数据一致性</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E4%BB%98%E6%AC%BE%E5%87%8F%E5%BA%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png">  </p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>保证多个存在于不同数据库的数据操作，要么同时成功，要么同时失败。主要用于强一致性的保证。  </p>
<p>三阶段提交，有超时机制  </p>
<p><img src="/2021/11/17/system-design-second-kill-and-booking/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png">  </p>
<h2 id="Sacle-拓展"><a href="#Sacle-拓展" class="headerlink" title="Sacle 拓展"></a>Sacle 拓展</h2><h3 id="是否有遗漏什么功能？"><a href="#是否有遗漏什么功能？" class="headerlink" title="是否有遗漏什么功能？"></a>是否有遗漏什么功能？</h3><p>可能十万人抢购 100 台 iPhone，大部分请求是无效的。<br>Redis 能力高过 MySQL，但能力还是有限。<br><strong>Redis 库存扣减完毕后，是否后面的请求可以直接拒绝了？</strong>  </p>
<h3 id="防止刷爆商品页面"><a href="#防止刷爆商品页面" class="headerlink" title="防止刷爆商品页面"></a>防止刷爆商品页面</h3><p><img src="/2021/11/17/system-design-second-kill-and-booking/cdn.png">  </p>
<p>CDN 的全称是 Content Delivery Network，即内容分发网络。<br>CDN 是依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。  </p>
<p>前端限流：点击一次后，按钮短时间内置灰；部分请求直接跳转到「繁忙页」。  </p>
<p>未开始抢购时，禁用抢购按钮。  </p>
<p>如何计算倒计时？  </p>
<ol>
<li>打开页面获取活动开始时间，然后前端页面开始倒计时  </li>
<li>打开页面获取距离活动开始的时间差，然后前端页面开始倒计时  </li>
<li>前端轮询 (Poll) 服务器的时间，并获取距离活动开始的时间差</li>
</ol>
<h3 id="秒杀服务器挂掉，怎么办？"><a href="#秒杀服务器挂掉，怎么办？" class="headerlink" title="秒杀服务器挂掉，怎么办？"></a>秒杀服务器挂掉，怎么办？</h3><p><strong>尽量不要影响其他服务，尤其是非秒杀商品的正常购买。</strong>  </p>
<h4 id="服务雪崩-Avalanche"><a href="#服务雪崩-Avalanche" class="headerlink" title="服务雪崩 (Avalanche)"></a>服务雪崩 (Avalanche)</h4><p>多个微服务之间调用的时候，假设 微服务A 调用 微服务B 和 微服务C，微服务B 和微服务C 又调用其他的微服务，这就是所谓的”扇出 (Fan-out)”，如扇出的链路上某个微服务的调用响应式过长或者不可用，对 微服务A 的调用就会占用越来越多的系统资源，进而引起系统雪崩，所谓的”雪崩效应”。<br>服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费着”的不可用并将这种不可用逐渐放大的过程。  </p>
<h4 id="服务熔断-Fuse-or-Circuit-breaker"><a href="#服务熔断-Fuse-or-Circuit-breaker" class="headerlink" title="服务熔断 (Fuse or Circuit-breaker)"></a>服务熔断 (Fuse or Circuit-breaker)</h4><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务不可用或者响应时间太长时，熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路。  </p>
<h3 id="防止恶意刷请求或者爬虫请求"><a href="#防止恶意刷请求或者爬虫请求" class="headerlink" title="防止恶意刷请求或者爬虫请求"></a>防止恶意刷请求或者爬虫请求</h3><h4 id="验证码机制Verification-Code-Mechanism"><a href="#验证码机制Verification-Code-Mechanism" class="headerlink" title="验证码机制Verification Code Mechanism"></a>验证码机制Verification Code Mechanism</h4><p>抢购-&gt;填写验证码-&gt;进入抢购服务  </p>
<h4 id="限流机制Ratelimit-Mechanism"><a href="#限流机制Ratelimit-Mechanism" class="headerlink" title="限流机制Ratelimit Mechanism"></a>限流机制Ratelimit Mechanism</h4><p><img src="/2021/11/17/system-design-second-kill-and-booking/%E9%99%90%E6%B5%81%E6%9C%BA%E5%88%B6.png">  </p>
<h4 id="黑名单机制Blacklist-Mechanism"><a href="#黑名单机制Blacklist-Mechanism" class="headerlink" title="黑名单机制Blacklist Mechanism"></a>黑名单机制Blacklist Mechanism</h4><p>1.黑名单 IP 地址<br>2.黑名单用户ID  </p>
<h1 id="秒杀系统-vs-订票系统"><a href="#秒杀系统-vs-订票系统" class="headerlink" title="秒杀系统 vs 订票系统"></a>秒杀系统 vs 订票系统</h1><p>在业务上，他们有哪些差异？<br>100 台 iPhone 没有区别<br>但是 100 张同一车次的火车票，有座位的区别（暂时忽略一等座二等座等）  </p>
<p><img src="/2021/11/17/system-design-second-kill-and-booking/%E8%AE%A2%E7%A5%A8%E6%95%B0%E6%8D%AE%E8%A1%A8.png">  </p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ol>
<li><p>microservice⾥，db基本上不都是⼀个吗？都host在⼀个database的service⾥？<br>基本原则是每个微服务都有⾃⼰单独的数据库，⽽且只有微服务本⾝可以访问这个数据库。微服务之间的数据共享可以通过服务调⽤，或者主、从表的⽅式实现。</p>
</li>
<li><p>为啥不能做成串⾏的单⼀职责系统？毕竟秒杀过不了的话，也就没必要提供商品信息&#x2F;库存或者订单服务是吧？<br>可以做成单⼀串⾏，使⽤微服务的设计思想，然后再⽤分布式的部署⽅式。  </p>
</li>
<li><p>怎么理解事务提交的同时失败？万⼀两个⼈都通过服务器提交，同时失败就说俩⼈都没秒成？<br>⼀个事务中可能有许多的操作，⽐如修改库存信息，修改订单信息，修改⽀付信息等等，假设修改库存信息和修改订单信息都成功了，但是最有修改⽀付信息失败了，那么之前成功的操作都要回滚。  </p>
</li>
<li><p>对于库存预热Redis,具体是如何更新对应object呢？在query时候，是同时更新SQL和Redis吗？<br>先更新redis，再异步更新mysql</p>
</li>
<li><p>假如这时候苹果还有两个，那为⼩明锁定库存的时候，另⼀个⼈还可以买其中另⼀个吗?锁定库存是锁定所有，还是锁住其中⼀个？<br>如果⼩明买了⼀个，那就只会锁定⼀个，另⼀个还是可以购买。  </p>
</li>
<li><p>在数据库⾥怎么实现timer计时锁定？<br>下⾯⼀种通过数据库来实现，我们加上⼀个定时任务表，字段有执⾏时间，version字段，每个定时任务对应表中的⼀条记录，通过update…whereversion&#x3D;and update_date&#x3D;做CAS操作。  </p>
</li>
<li><p>所以Redis在这⼉只是当做cache来⽤吗？<br>是的  </p>
</li>
<li><p>⽣产者如果⽣产速度⽐消费者快，消息队列是不是会⽆限延⻓？<br>是的  </p>
</li>
<li><p>在Redis⾥的库存是1.5-2倍的话也就是有⼈会在最后付钱的时候db库存不够⽽失败是吧？<br>不会，Redis这边只是做初步校验，通过Redis后还需要在数据库中进⾏判断，如果库存还有余，才能创建订单。Redis的作⽤只是拦截⼤部分的请求，只有少部分请求才会落到数据库。  </p>
</li>
<li><p>前端校准时间怎么平衡poll服务器时请求的roundtrip时间。不然离服务器更近的⽤⼾就会⽐更远的⽤⼾有优势？<br>前端是可以获取服务端到客⼾端响应时间的。  </p>
</li>
<li><p>前端poll的时间是哪台服务器的时间？难道有⼀个clockservice?<br>对，后端会有⼀个专⻔做时间校准的服务器。  </p>
</li>
<li><p>为什么Redis上的并发不会使得redis上的库存出现超卖？<br>因为redis是单线程的，串⾏执⾏，再加上lua脚本事务来解决这个问题  </p>
</li>
<li><p>如果这个系统需要多个服务那在哪个S聊服务之间的通讯？<br>系统设计中呢不同的s聊代表了不同的服务，具体是要要看场景业务服务还是存储服务等需求。</p>
</li>
<li><p>querypersecond<br>⼀般4S分析法中Scale服务涉及到性能优化，所以⼀般QPS涉及到查询效率问题会⽤Scale服务。</p>
</li>
<li><p>⾯试中这些需要解决的问题是⾯试官提出的吗？<br>⼤部分的浅显的问题是⾯试官提问的，但是呢你在进⾏设计思考的时候如果可以将⾯试官注意不到的问题考虑在内的话，然后对问题进⾏解答，那么⾯试官⼀定会很欣赏你。  </p>
</li>
<li><p>⼀个模块⼀个服务器流量分流？<br>模块和服务器不⼀定要⼀对⼀，因为可以⼀对多，多对⼀。  </p>
</li>
<li><p>⾯试的时候需要把流程图和这些优缺点对⽐都要体现出来吗？<br>⾯试的时候设计的优缺点你都考虑在内的话当然对你⾯试更加有利呀  </p>
</li>
<li><p>什么情况下会⽤单体架构呢？<br>简单的项⽬，单体可以满⾜就⽤单体  </p>
</li>
<li><p>如果某⼀个服务变的很复杂，然后⾃⼰变成了⼀个⼤单体怎么办？<br>增加这个服务的机器数量  </p>
</li>
<li><p>就是⽤Redis做缓存吧<br>也可以将数据持久化存储到磁盘上的  </p>
</li>
<li><p>nosql就是cache系统吗？Redis和memcache怎么选呢？<br>nosql是数据库，不是缓存，只是基于内存的nosql很快，可以⽤做缓存。redis更强⼤，memcached更快  </p>
</li>
<li><p>nosql都是内存存储吗，那断电了怎么办<br>不是，redis是内存的，但是可以持久化，mencached是内存的，但是不能持久化，hbase是nosql，硬盘的。具体可以⾕歌搜索“nosql持久化”</p>
</li>
<li><p>redis扣减库存，如何保证和mysql中的库存保持⼀致，数据同步的时机和频率如何控制?redis宕机或数据丢失，如何保证库存的正确性?<br>现在数据库操作有读写⼀致的技术，所以我们的database数据变化了就可以使⽤读写⼀致来能保证redis数据⼀致性  </p>
</li>
<li><p>库存扣减以后，如何更新Redis的集群来反映更新后的库存呢？<br>使⽤redis实现扣减库存，由于是分布式环境下所以还需要⼀个分布式锁来控制只能有⼀个服务去初始化库存，需要提供⼀个回调函数，在初始化库存的时候去调⽤这个函数获取初始化库存，库存扣减完之后可以进⾏⼀个异步的更改数据库数据，保证⼀致性。  </p>
</li>
<li><p>“锁定”是指SELECTFORUPDATE⾏锁吗<br>看数据库和存储引擎，不是所有的数据库都⽀持⾏锁  </p>
</li>
<li><p>消息队列的最⼤容量是多少？可配置的吗？<br>最⼤容量是10000，可以配置的</p>
</li>
<li><p>如果使⽤了Lua脚本，假设Redis中只有100个库存，理论上只会有100个请求会通过库存扣减，下沉到数据库，为什么还需要消息队列呢？<br>消息队列可以解耦合，如果有些任务产⽣异常那么消息队列可以阻⽌我们的任务因为异常阻塞  </p>
</li>
<li><p>秒杀系统⼤概多少的latency是可以接受的？<br>我们在后台可以开启n个队列处理程序，不断的消费消息队列中的任务，然后校验库存接着下单等操作，现在由于我们是有限的队列处理线程在执⾏，所以最终落到数据库上的并发请求也是有限的。⽤⼾请求是可以在消息队列中短暂堆积的，当库存为零了，消息队列堆积的请求也就可以全部释放了。  </p>
</li>
<li><p>⽤⼾等待下单成功是同步操作吗？如果加了消息队列后，会不会由于消息过多，导致⽤⼾等待响应时间过⻓？<br>消息队列解耦合呀，不同的任务会异步执⾏，不会等待时间过⻓产⽣阻塞问题。  </p>
</li>
<li><p>消息队列，装不下了，就不接收了。<br>可以⽤分布式消息队列  </p>
</li>
<li><p>Redis真好⽤啊<br>众多语⾔都⽀持Redis，因为Redis交换数据快，所以在服务器中常⽤来存储⼀些需要频繁调取的数据，这样可以⼤⼤节省系统直接读取磁盘来获得数据的I&#x2F;O开销，更重要的是可以极⼤提升速度。</p>
</li>
<li><p>锁定库存是啥意思。。如果限制10个，有11个⼈抢，然⽽第⼀个⼈到最后也没付款，那在付款时间内15mins第11个⼈可以抢单吗(这个时候库存被锁定了)<br>下单后锁定库存，超时会释放库存  </p>
</li>
<li><p>这⾥本质上是想通过redis来隔离，避免直接访问数据库么<br>提⾼查询性能减少查询数据库效率  </p>
</li>
<li><p>锁定库存，就是⼀个客⼾把产品预订了。<br>是的，预定⼀个产品以后会锁定库存。</p>
</li>
<li><p>cdn节点间同步的时间延迟多久<br>CDN节点的缓存内容不是实时更新的，只有当缓存内容到期后才能回源拉取最新的内容并更新节点缓存。您可以通过设置缓存过期时间规则或者提交刷新请求来实现缓存内容的更新。  </p>
</li>
<li><p>有张slide,消息队列投递失败，然后⽼师给的答案是增⼤Redis容量到1.5倍。没看懂什么意思。可以解释下吗？<br>redis（key:value数据库，缓存，消息队列），redis不仅仅是缓存数据，也是消息队列的产物，所以如果消息队列投递失败，我们可以⽤增⼤redis容量来解决问题。</p>
</li>
<li><p>mysql库存加回去了，redis也要加回库存，刚才好像没有体现<br>redis缓存库存数据中，数据是和mysql数据库中保持⼀致的，如果库存变化了，那么redis当然是要变化的。</p>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>一种主要将数据存储于内存中的非关系型的键值对数据库 (NoSQL 的一种) ，但也可以将数据持久化(Data Persistence) 到磁盘中。<br>支持多种数据非关系型的数据结构。  </p>
<ul>
<li>1.字符串&#x2F;数字 (STRING)  </li>
<li>2.哈希表 (HASH)  </li>
<li>3.链表 (LIST)  </li>
<li>4.集合 (SET)  </li>
<li>5.有序集合 (ZSET)</li>
</ul>
<p>单线程的数据库。通过IO多路复用实现并发。<br>支持数据的主备容灾 (Disaster Tolerance) 存储。<br>所有单个指令操作都是原子的，即要么完全执行成功，要么完全执行失败。多个指令也可以通过 Lua 脚本事务操作实现原子性。<br>因为都在内存中操作，性能极高，单机一般可支撑 10万数量级的 QPS。<br>可用作数据缓存 (Cache)、数据持久存储和消息队列 (Message Queue)。  </p>
<h2 id="消息队列简介"><a href="#消息队列简介" class="headerlink" title="消息队列简介"></a>消息队列简介</h2><p>一类基于生产者&#x2F;消费者模型的组件。<br>用于实现两个不同的系统之间的解耦和异步操作。<br>生产者可以高速地向消息队列中投递（生产）消息。<br>消费者可以按照自己的节奏去消费生产者投递的消息。<br>消息队列一般带有重试的能力。可以持续投递，直到消费者消费成功。  </p>
]]></content>
      <categories>
        <category>Learn-SystemDesign</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>System-Design</tag>
        <tag>订票系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计_新鲜事系统</title>
    <url>/2021/11/11/system-design-news-feed/</url>
    <content><![CDATA[<h1 id="常见疑惑"><a href="#常见疑惑" class="headerlink" title="常见疑惑"></a>常见疑惑</h1><h2 id="什么是新鲜事-News-Feed？"><a href="#什么是新鲜事-News-Feed？" class="headerlink" title="什么是新鲜事 News Feed？"></a>什么是新鲜事 News Feed？</h2><ul>
<li>你登陆 Facebook &#x2F; Twitter &#x2F; 朋友圈 之后看到的信息流  </li>
<li>你的所有朋友发的信息的集合</li>
</ul>
<h2 id="有哪些典型的新鲜事系统？"><a href="#有哪些典型的新鲜事系统？" class="headerlink" title="有哪些典型的新鲜事系统？"></a>有哪些典型的新鲜事系统？</h2><ul>
<li>Facebook</li>
<li>Twitter</li>
<li>朋友圈</li>
<li>RSS Reader</li>
</ul>
<h2 id="新鲜事系统的核心因素？"><a href="#新鲜事系统的核心因素？" class="headerlink" title="新鲜事系统的核心因素？"></a>新鲜事系统的核心因素？</h2><ul>
<li>关注与被关注</li>
<li>每个人看到的新鲜事都是不同的</li>
</ul>
<h1 id="Storage-存储"><a href="#Storage-存储" class="headerlink" title="Storage 存储"></a>Storage 存储</h1><h2 id="Pull-Model"><a href="#Pull-Model" class="headerlink" title="Pull Model"></a>Pull Model</h2><p>Pull &#x3D; 主动撩Ta  </p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>在用户查看News Feed时，获取每个好友的前100条Tweets，合并出前100条News Feed  </li>
<li>K路归并算法 Merge K Sorted Arrays</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>News Feed &#x3D;&gt; 假如有N个关注对象，则为N次DB Reads的时间 + N路归并时间(可忽略)  </li>
<li>Post a tweet &#x3D;&gt; 1次DB Write的时间</li>
</ul>
<h2 id="Pull-原理图"><a href="#Pull-原理图" class="headerlink" title="Pull 原理图"></a>Pull 原理图</h2><p><img src="/2021/11/11/system-design-news-feed/pully.png">  </p>
<h2 id="Pull模型有什么缺陷么？"><a href="#Pull模型有什么缺陷么？" class="headerlink" title="Pull模型有什么缺陷么？"></a>Pull模型有什么缺陷么？</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">getNewsFeed(request)</span><br><span class="line"> followings = DB.getFollowings(user=request.user)</span><br><span class="line"> news_feed = empty</span><br><span class="line"> <span class="keyword">for</span> follow <span class="keyword">in</span> followings:</span><br><span class="line">    tweets = DB.getTweets(follow.to_user, <span class="number">100</span>) <span class="comment"># N次DB Reads非常慢，且发生在用户获得News Feed的请求过程中</span></span><br><span class="line">    news_feed.merge(tweets)</span><br><span class="line"> sort(news_feed)</span><br><span class="line"> <span class="keyword">return</span> news_feed[:<span class="number">100</span>] <span class="comment"># 返回前100条</span></span><br><span class="line"></span><br><span class="line">postTweet(request, tweet)</span><br><span class="line"> DB.insertTweet(request.user, tweet)</span><br><span class="line"> <span class="keyword">return</span> success</span><br></pre></td></tr></table></figure>

<h2 id="Push-Model"><a href="#Push-Model" class="headerlink" title="Push Model"></a>Push Model</h2><p>Push &#x3D; 坐等被撩  </p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul>
<li>为每个用户建一个List存储他的News Feed信息  </li>
<li>用户发一个Tweet之后，将该推文逐个推送到每个用户的News Feed List中  </li>
<li>关键词：Fanout  </li>
<li>用户需要查看News Feed时，只需要从该News Feed List中读取最新的100条即可</li>
</ul>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>News Feed &#x3D;&gt; 1次DB Read  </li>
<li>Post a tweet &#x3D;&gt; N个粉丝，需要N次DB Writes  </li>
<li>好处是可以用异步任务在后台执行，无需用户等待</li>
</ul>
<h2 id="Storage-存储-–-News-Feed-Table"><a href="#Storage-存储-–-News-Feed-Table" class="headerlink" title="Storage 存储 – News Feed Table"></a>Storage 存储 – News Feed Table</h2><p><img src="/2021/11/11/system-design-news-feed/nft.png">  </p>
<h2 id="Push-原理图"><a href="#Push-原理图" class="headerlink" title="Push 原理图"></a>Push 原理图</h2><p><img src="/2021/11/11/system-design-news-feed/pushy.png">  </p>
<h2 id="Push模型有缺陷么？"><a href="#Push模型有缺陷么？" class="headerlink" title="Push模型有缺陷么？"></a>Push模型有缺陷么？</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">getNewsFeed(request)</span><br><span class="line"> <span class="keyword">return</span> DB.getNewsFeed(request.user)</span><br><span class="line"></span><br><span class="line">postTweet(request, tweet_info)</span><br><span class="line"> tweet = DB.insertTweet(request.user, tweet_info)</span><br><span class="line"> AsyncService.fanoutTweet(request.user, tweet) <span class="comment">#异步执行</span></span><br><span class="line"> <span class="keyword">return</span> success</span><br><span class="line"></span><br><span class="line">AsyncService::fanoutTweet(user, tweet)</span><br><span class="line"> followers = DB.getFollowers(user)</span><br><span class="line"> <span class="keyword">for</span> follower <span class="keyword">in</span> followers:  <span class="comment">#followers的数目可能很大</span></span><br><span class="line">    DB.insertNewsFeed(tweet, follower)</span><br></pre></td></tr></table></figure>

<h2 id="Pull-vs-Push"><a href="#Pull-vs-Push" class="headerlink" title="Pull vs Push"></a>Pull vs Push</h2><h3 id="热门Social-App的模型"><a href="#热门Social-App的模型" class="headerlink" title="热门Social App的模型"></a>热门Social App的模型</h3><ul>
<li>Facebook – Pull</li>
<li>Instagram – Push + Pull</li>
<li>Twitter – Pull</li>
<li>朋友圈 - Push</li>
</ul>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ul>
<li>不坚定想法，摇摆不定</li>
<li>不能表现出Tradeoff的能力</li>
<li>无法解决特定的问题</li>
</ul>
<h1 id="4S分析"><a href="#4S分析" class="headerlink" title="4S分析"></a>4S分析</h1><h2 id="Scenario-场景"><a href="#Scenario-场景" class="headerlink" title="Scenario 场景"></a>Scenario 场景</h2><ul>
<li>和面试官讨论</li>
<li>搞清楚需要设计哪些功能</li>
<li>并分析出所设计的系统大概所需要支持的 Concurrent Users &#x2F; QPS &#x2F; Memory &#x2F; Storage 等</li>
</ul>
<h2 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h2><ul>
<li>合并需要设计功能，相似的功能整合为一个Service</li>
</ul>
<h2 id="Storage-存储-1"><a href="#Storage-存储-1" class="headerlink" title="Storage 存储"></a>Storage 存储</h2><p>对每个 Service 选择合适的存储结构<br>细化数据表单<br>画图展示数据存储和读取的流程  </p>
<p>得到一个 Work Solution 而不是 Perfect Solution  </p>
<p>这个Work Solution 可以存在很多待解决的缺陷  </p>
<h1 id="Scale-扩展"><a href="#Scale-扩展" class="headerlink" title="Scale 扩展"></a>Scale 扩展</h1><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><h3 id="第一步-Step-1-Optimize"><a href="#第一步-Step-1-Optimize" class="headerlink" title="第一步 Step 1: Optimize"></a>第一步 Step 1: Optimize</h3><ul>
<li>解决设计缺陷 Solve Problems：Pull vs Push  </li>
<li>更多功能设计 More Features：Like, Follow &amp; Unfollow, Ads  </li>
<li>一些特殊情况 Special Cases：xx搞挂微博, 僵尸粉</li>
</ul>
<h3 id="第二步-Step-2-Maintenance"><a href="#第二步-Step-2-Maintenance" class="headerlink" title="第二步 Step 2: Maintenance"></a>第二步 Step 2: Maintenance</h3><ul>
<li>鲁棒性 Robust：如果有一台服务器&#x2F;数据库挂了怎么办  </li>
<li>扩展性 Scalability：如果有流量暴增，如何扩展</li>
</ul>
<h2 id="解决Pull的缺陷"><a href="#解决Pull的缺陷" class="headerlink" title="解决Pull的缺陷"></a>解决Pull的缺陷</h2><p>最慢的部分发生在用户读请求时（需要耗费用户等待时间）  </p>
<p>1，在 DB 访问之前加入Cache  </p>
<p>2，Cache 每个用户的 Timeline<br>N次DB请求 → N次Cache请求 (N是你关注的好友个数)；<br>Trade off: Cache所有的？Cache最近的1000条？  </p>
<p>3，Cache 每个用户的 News Feed<br>没有Cache News Feed的用户：归并N个用户最近的100条Tweets，然后取出结果的前100条；<br>有Cache News Feed的用户༚ 归并N个用户的在某个时间戳之后的所有Tweets  </p>
<h2 id="解决Push的缺陷"><a href="#解决Push的缺陷" class="headerlink" title="解决Push的缺陷"></a>解决Push的缺陷</h2><p>1，浪费更多的存储空间 Disk  </p>
<ul>
<li>与Pull模型将News Feed存在内存(Memory)中相比  </li>
<li>Push模型将News Feed存在硬盘(Disk)里完全不是个事儿  </li>
<li>Disk is cheap</li>
</ul>
<p>2，不活跃用户 Inactive Users  </p>
<ul>
<li>粉丝排序 Rank followers by weight (for example, last login time)</li>
</ul>
<p>3，粉丝数目 followers &gt;&gt; 关注数目 following  </p>
<ul>
<li>Trade off: Pull + Push vs Pull</li>
</ul>
<h3 id="Push-结合-Pull-的优化方案"><a href="#Push-结合-Pull-的优化方案" class="headerlink" title="Push 结合 Pull 的优化方案"></a>Push 结合 Pull 的优化方案</h3><ul>
<li>普通的用户仍然 Push</li>
<li>将 Lady Gaga 这类的用户，标记为明星用户</li>
<li>对于明星用户，不 Push 到用户的 News Feed 中</li>
<li>当用户需要的时候，来明星用户的 Timeline 里取，并合并到 News Feed 里</li>
</ul>
<h2 id="如何定义明星"><a href="#如何定义明星" class="headerlink" title="如何定义明星"></a>如何定义明星</h2><ul>
<li>明星不能在线动态计算，要离线计算  </li>
<li>为 User 增加一个 is_superstar 的属性  </li>
<li>一个用户被标记为 superstar 之后，就不能再被取消标记</li>
</ul>
<p><img src="/2021/11/11/system-design-news-feed/user-table.png">  </p>
<h2 id="Push和Pull的使用场景"><a href="#Push和Pull的使用场景" class="headerlink" title="Push和Pull的使用场景"></a>Push和Pull的使用场景</h2><h3 id="什么时候用-Push？"><a href="#什么时候用-Push？" class="headerlink" title="什么时候用 Push？"></a>什么时候用 Push？</h3><p>资源少<br>想偷懒，少写代码<br>实时性要求不高<br>用户发帖比较少<br>双向好友关系，没有明星问题（比如朋友圈）    </p>
<h3 id="什么时候用-Pull"><a href="#什么时候用-Pull" class="headerlink" title="什么时候用 Pull ?"></a>什么时候用 Pull ?</h3><p>资源充足<br>实时性要求高<br>用户发帖很多<br>单向好友关系，有明星问题  </p>
<h2 id="通用问题-Common-Questions"><a href="#通用问题-Common-Questions" class="headerlink" title="通用问题 Common Questions"></a>通用问题 Common Questions</h2><h4 id="数据库服务器挂了怎么办？How-to-maintenance"><a href="#数据库服务器挂了怎么办？How-to-maintenance" class="headerlink" title="数据库服务器挂了怎么办？How to maintenance?"></a>数据库服务器挂了怎么办？How to maintenance?</h4><h4 id="用户逐渐怎么怎么办？How-to-scale"><a href="#用户逐渐怎么怎么办？How-to-scale" class="headerlink" title="用户逐渐怎么怎么办？How to scale?"></a>用户逐渐怎么怎么办？How to scale?</h4><p>服务器顶不住压力怎么办？<br>数据库顶不住压力怎么办？  </p>
<h1 id="系统设计面试总结"><a href="#系统设计面试总结" class="headerlink" title="系统设计面试总结"></a>系统设计面试总结</h1><h2 id="4S"><a href="#4S" class="headerlink" title="4S"></a>4S</h2><p>Scenario, Service, Storage, Scale，从这四个角度来分析  </p>
<h2 id="Ask-before-design"><a href="#Ask-before-design" class="headerlink" title="Ask before design"></a>Ask before design</h2><p>问清楚再动手设计，不要一上来就冲着一个巨牛的方案去设计，切忌不要做关键词大师  </p>
<h2 id="No-more-no-less"><a href="#No-more-no-less" class="headerlink" title="No more no less"></a>No more no less</h2><p>不要总想着设计最牛的系统，要设计够用的系统  </p>
<h2 id="Work-solution-first"><a href="#Work-solution-first" class="headerlink" title="Work solution first"></a>Work solution first</h2><p>先设计一个基本能工作的系统，然后再逐步优化。  </p>
<p>Done is better than perfect! —— Mark Zuckerberg  </p>
<h2 id="Analysis-is-important-than-solution"><a href="#Analysis-is-important-than-solution" class="headerlink" title="Analysis is important than solution"></a>Analysis is important than solution</h2><p>系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊  </p>
<h1 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h1><h2 id="果取关问题"><a href="#果取关问题" class="headerlink" title="果取关问题"></a>果取关问题</h2><h3 id="如何实现-follow-与-unfollow"><a href="#如何实现-follow-与-unfollow" class="headerlink" title="如何实现 follow 与 unfollow?"></a>如何实现 follow 与 unfollow?</h3><ul>
<li>Follow 一个用户之后，异步地将他的 Timeline 合并到你的 News Feed 中  </li>
<li>Unfollow 一个用户之后，异步地将他发的 Tweets 从你的 News Feed 中移除</li>
</ul>
<h3 id="为什么需要异步-Async？"><a href="#为什么需要异步-Async？" class="headerlink" title="为什么需要异步 Async？"></a>为什么需要异步 Async？</h3><p>因为这个过程一点都不快  </p>
<h3 id="异步的好处？"><a href="#异步的好处？" class="headerlink" title="异步的好处？"></a>异步的好处？</h3><p>用户迅速得到反馈，似乎马上就 follow &#x2F; unfollow 成功了  </p>
<h3 id="异步的坏处？"><a href="#异步的坏处？" class="headerlink" title="异步的坏处？"></a>异步的坏处？</h3><ul>
<li>Unfollow 之后刷新 News Feed，发现好像他的信息还在  </li>
<li>不过最终还是会被删掉的</li>
</ul>
<h2 id="如何存储-Likes"><a href="#如何存储-Likes" class="headerlink" title="如何存储 Likes?"></a>如何存储 Likes?</h2><p><img src="/2021/11/11/system-design-news-feed/like-table.png">  </p>
<p>Normalize 获得点赞数的方式：<strong>SELECT COUNT * FROM like_table where tweet_id&#x3D;xxx;</strong><br>优点：标准化，最准确。<br>缺点：炒鸡慢，会增加 O(N) 个 SQL Queries（对于某一页的 Tweets，每个都得来这么一句查询）  </p>
<p>Denormalize 获得点赞数的方式：<br>当有人点赞的时候：<strong>UPDATE like_table SET num_of_likes &#x3D; num_of_likes + 1 where tweet_id &#x3D; xxx</strong><br>当有人取消赞的时候：<strong>UPDATE like_table SET num_of_likes &#x3D; num_of_likes - 1 where tweet_id &#x3D; xxx</strong><br>想要获得一个 Tweet 的点赞数时，因为 num_of_likes 就存在 tweet 里，故无需额外的 SQL Queries  </p>
<h2 id="惊群现象-Thundering-Herd"><a href="#惊群现象-Thundering-Herd" class="headerlink" title="惊群现象 Thundering Herd"></a>惊群现象 Thundering Herd</h2><h3 id="什么是惊群？"><a href="#什么是惊群？" class="headerlink" title="什么是惊群？"></a>什么是惊群？</h3><p>我们通常会使用缓存来作为数据库的“挡箭牌”，优化一些经常读取的数据的访问速度。即，在访问这些数据时，会先看看是否在缓存中，如果在，就直接读取缓存中的数据，如果不在，就从数据库中读取之后，写入缓存并返回。  </p>
<p>那么在高并发的情况下，如果一条非常热的数据，因为缓存过期或者被淘汰算法淘汰等原因，被踢出缓存之后，会导致短时间内（&lt;1s），大量的数据请求会出现缓存穿透(Cache miss)，因为数据从 DB回填到 Cache 需要时间。从而这些请求都会去访问数据库，导致数据库处理不过来而崩溃，从而影响到其他数据的访问而导致整个网站崩溃。  </p>
<h3 id="解决办法及参考资料"><a href="#解决办法及参考资料" class="headerlink" title="解决办法及参考资料"></a>解决办法及参考资料</h3><p>Memcache Lease Get - 《Scaling Memcache at Facebook》<a href="http://bit.ly/1jDzKZK">http://bit.ly/1jDzKZK</a><br>Facebook 如何解决惊群效应的：<a href="https://bit.ly/1Q3t3P7">https://bit.ly/1Q3t3P7</a><br>Redis 防雪崩架构设计 <a href="https://bit.ly/2KFneb5">https://bit.ly/2KFneb5</a>  </p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="Cache是什么？"><a href="#Cache是什么？" class="headerlink" title="Cache是什么？"></a>Cache是什么？</h2><ul>
<li>你可以认为相当于算法中的HashMap  </li>
<li>是Key-value的结构</li>
</ul>
<h2 id="Cache存在哪儿？"><a href="#Cache存在哪儿？" class="headerlink" title="Cache存在哪儿？"></a>Cache存在哪儿？</h2><ul>
<li>Cache存在内存里</li>
</ul>
<h2 id="常用的Cache工具-x2F-服务器有什么？"><a href="#常用的Cache工具-x2F-服务器有什么？" class="headerlink" title="常用的Cache工具&#x2F;服务器有什么？"></a>常用的Cache工具&#x2F;服务器有什么？</h2><ul>
<li>Memcached  </li>
<li>Redis</li>
</ul>
<h2 id="为什么需要用Cache"><a href="#为什么需要用Cache" class="headerlink" title="为什么需要用Cache?"></a>为什么需要用Cache?</h2><ul>
<li>Cache因为是内存里，所以存取效率比DB要高</li>
</ul>
<h2 id="为什么不全放Cache里？"><a href="#为什么不全放Cache里？" class="headerlink" title="为什么不全放Cache里？"></a>为什么不全放Cache里？</h2><ul>
<li>内存中的数据断电就会丢失  </li>
<li>Cache 比硬盘贵</li>
</ul>
<h2 id="News-Feed-和-Timeline-的定义和区别？"><a href="#News-Feed-和-Timeline-的定义和区别？" class="headerlink" title="News Feed 和 Timeline 的定义和区别？"></a>News Feed 和 Timeline 的定义和区别？</h2><h3 id="News-Feed：新鲜事，我朋友-我发的所有帖子按照某种顺序排列的整合（比如按照时间排序）"><a href="#News-Feed：新鲜事，我朋友-我发的所有帖子按照某种顺序排列的整合（比如按照时间排序）" class="headerlink" title="News Feed：新鲜事，我朋友+我发的所有帖子按照某种顺序排列的整合（比如按照时间排序）"></a>News Feed：新鲜事，我朋友+我发的所有帖子按照某种顺序排列的整合（比如按照时间排序）</h3><p>用户打开Twitter之后首先看到的界面就是News Feed界面，这些 tweets 来自你关注的用户  </p>
<h3 id="Timeline：某个用户发的所有帖子"><a href="#Timeline：某个用户发的所有帖子" class="headerlink" title="Timeline：某个用户发的所有帖子"></a>Timeline：某个用户发的所有帖子</h3><p>用户点开某个人的页面之后，看到这个人发的所有帖子  </p>
<h3 id="在有的系统中，这两个概念的定义会完全反过来，这里我们统一按照上面的定义。"><a href="#在有的系统中，这两个概念的定义会完全反过来，这里我们统一按照上面的定义。" class="headerlink" title="在有的系统中，这两个概念的定义会完全反过来，这里我们统一按照上面的定义。"></a>在有的系统中，这两个概念的定义会完全反过来，这里我们统一按照上面的定义。</h3><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><ul>
<li>简单的说就是一个先进先出的任务队列列表  </li>
<li>做任务的worker进程共享同一个列表  </li>
<li>Workers从列表中获得任务去做，做完之后反馈给队列服务器  </li>
<li>队列服务器是做异步任务必须有的组成部分</li>
</ul>
<h2 id="哪些工具可以做消息队列"><a href="#哪些工具可以做消息队列" class="headerlink" title="哪些工具可以做消息队列"></a>哪些工具可以做消息队列</h2><p>最常用的有 RabbitMQ, ZeroMQ, Redis, Kafka  </p>
<h2 id="NewsFeed-Table-中-Pull-Model-和-Push-Model-的区别？"><a href="#NewsFeed-Table-中-Pull-Model-和-Push-Model-的区别？" class="headerlink" title="NewsFeed Table 中 Pull Model 和 Push Model 的区别？"></a>NewsFeed Table 中 Pull Model 和 Push Model 的区别？</h2><p><a href="http://www.jiuzhang.com/qa/2074/">http://www.jiuzhang.com/qa/2074/</a><br><a href="http://www.jiuzhang.com/qa/2031/">http://www.jiuzhang.com/qa/2031/</a><br><a href="http://www.jiuzhang.com/qa/1741/">http://www.jiuzhang.com/qa/1741/</a>  </p>
<h2 id="NewsFeed-如何实现-Pagination"><a href="#NewsFeed-如何实现-Pagination" class="headerlink" title="NewsFeed 如何实现 Pagination?"></a>NewsFeed 如何实现 Pagination?</h2><p><a href="http://www.jiuzhang.com/qa/1839/">http://www.jiuzhang.com/qa/1839/</a>  </p>
<h2 id="Twitter-Pull-模型里用cache来存timeline时，关于保持实时性的问题"><a href="#Twitter-Pull-模型里用cache来存timeline时，关于保持实时性的问题" class="headerlink" title="Twitter Pull 模型里用cache来存timeline时，关于保持实时性的问题"></a>Twitter Pull 模型里用cache来存timeline时，关于保持实时性的问题</h2><p><a href="http://www.jiuzhang.com/qa/962/">http://www.jiuzhang.com/qa/962/</a></p>
]]></content>
      <categories>
        <category>Learn-SystemDesign</category>
      </categories>
      <tags>
        <tag>System-Design</tag>
        <tag>新鲜事系统</tag>
      </tags>
  </entry>
  <entry>
    <title>暂时停留</title>
    <url>/2019/04/21/temporary-stay/</url>
    <content><![CDATA[<p>前天，也就是星期五，我终于把我负责的流媒体收录系统上的<code>bug</code>和需求都清空了，成功打了<code>tag</code>号。  </p>
<p>可以暂时休息下，思考一下前方的路该如何走？  </p>
<p>有时候很好奇，大家都是24小时的时间，为什么有的人风生水起，有的人碌碌无为呢？  </p>
<p>昨天去现场咨询了一下成都落户，本科以上学历+无房，落的是集体户口。嗯，觉得这块得好好了解下。不然以后再落会比较麻烦。  </p>
<p>接下来要做的事情，似乎还有很多：  </p>
<ul>
<li><p>流媒体收录关于管道，并发，以及<code>nginx</code>的服务还要细看下；  </p>
</li>
<li><p>英语流利说的会员到期日还有80天，要抓紧时间了；  </p>
</li>
<li><p>极客专栏上有关<code>Linux</code>操作系统内核，网络协议和数据库原理的的内容也需要更新；  </p>
</li>
<li><p>给伶说好的画画，要在她五月底来成都前画完，虽然时间还很充裕，但不能再拖了。</p>
</li>
</ul>
<p>入职半年多，现在才真正感觉是在跟着大家一块做项目。  </p>
<p>加油，努力！</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>远方</tag>
      </tags>
  </entry>
  <entry>
    <title>Go代码安全指南</title>
    <url>/2023/01/01/tencent-secguide-golang/</url>
    <content><![CDATA[<!-- markdown="1" is required for GitHub Pages to render the TOC properly. -->

<details markdown="1">
  <summary>目录</summary>

<ul>
<li><p><a href="#1">1 通用类</a></p>
<ul>
<li><a href="#1.1">I. 代码实现</a><ul>
<li><a href="#1.1.1">1.1 内存管理</a></li>
<li><a href="#1.1.2">1.2 文件操作</a></li>
<li><a href="#1.1.3">1.3 系统接口</a></li>
<li><a href="#1.1.4">1.4 通信安全</a></li>
<li><a href="#1.1.5">1.5 敏感数据保护</a></li>
<li><a href="#1.1.6">1.6 加密解密</a></li>
<li><a href="#1.1.7">1.7 正则表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#2">2 后台类</a></p>
<ul>
<li><a href="#2.1">I. 代码实现</a><ul>
<li><a href="#2.1.1">1.1 输入校验</a></li>
<li><a href="#2.1.2">1.2 SQL操作</a></li>
<li><a href="#2.1.3">1.3 网络请求</a></li>
<li><a href="#2.1.4">1.4 服务器端渲染</a></li>
<li><a href="#2.1.5">1.5 Web跨域</a></li>
<li><a href="#2.1.6">1.6 响应输出</a></li>
<li><a href="#2.1.7">1.7 会话管理</a></li>
<li><a href="#2.1.8">1.8 访问控制</a></li>
<li><a href="#2.1.9">1.9 并发保护</a></li></ul></li></ul></li></ul></details>





<p><a id="1"></a></p>
<h1 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h1><p><a id="1.1"></a></p>
<h2 id="1-代码实现类"><a href="#1-代码实现类" class="headerlink" title="1. 代码实现类"></a>1. 代码实现类</h2><p><a id="1.1.1"></a></p>
<h3 id="1-1-内存管理"><a href="#1-1-内存管理" class="headerlink" title="1.1 内存管理"></a>1.1 内存管理</h3><h4 id="1-1-1【必须】切片长度校验"><a href="#1-1-1【必须】切片长度校验" class="headerlink" title="1.1.1【必须】切片长度校验"></a>1.1.1【必须】切片长度校验</h4><ul>
<li>在对slice进行操作时，必须判断长度是否合法，防止程序panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad: 未判断data的长度，可导致 index out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">&#x27;R&#x27;</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Bad&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: slice bounds out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Println(slice[:<span class="number">10</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 使用data前应判断长度是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">6</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">&#x27;R&#x27;</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Good&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2【必须】nil指针判断"><a href="#1-1-2【必须】nil指针判断" class="headerlink" title="1.1.2【必须】nil指针判断"></a>1.1.2【必须】nil指针判断</h4><ul>
<li>进行指针操作时，必须判断该指针是否为nil，防止程序panic，尤其在进行结构体Unmarshal时</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Packet <span class="keyword">struct</span> &#123;</span><br><span class="line">	PackeyType    <span class="type">uint8</span></span><br><span class="line">	PackeyVersion <span class="type">uint8</span></span><br><span class="line">	Data          *Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	Stat <span class="type">uint8</span></span><br><span class="line">	Len  <span class="type">uint8</span></span><br><span class="line">	Buf  [<span class="number">8</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Packet)</span></span> UnmarshalBinary(b []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> io.EOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.PackeyType = b[<span class="number">0</span>]</span><br><span class="line">	p.PackeyVersion = b[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若长度等于2，那么不会new Data</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="number">2</span> &#123;</span><br><span class="line">		p.Data = <span class="built_in">new</span>(Data)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 未判断指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	packet := <span class="built_in">new</span>(Packet)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Failed to unmarshal packet&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Stat: %v\n&quot;</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 判断Data指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	packet := <span class="built_in">new</span>(Packet)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Failed to unmarshal packet&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> packet.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Stat: %v\n&quot;</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3【必须】整数安全"><a href="#1-1-3【必须】整数安全" class="headerlink" title="1.1.3【必须】整数安全"></a>1.1.3【必须】整数安全</h4><ul>
<li><p>在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：</p>
<ul>
<li>确保无符号整数运算时不会反转</li>
<li>确保有符号整数运算时不会出现溢出</li>
<li>确保整型转换时不会出现截断错误</li>
<li>确保整型转换时不会出现符号错误</li>
</ul>
</li>
<li><p>以下场景必须严格进行长度限制：</p>
<ul>
<li>作为数组索引</li>
<li>作为对象的长度或者大小</li>
<li>作为数组的边界（如作为循环计数器）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad: 未限制长度，导致整数溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numInt <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	numInt = numControlByUser + <span class="number">1</span></span><br><span class="line">	<span class="comment">// 对长度限制不当，导致整数溢出</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, numInt)</span><br><span class="line">	<span class="comment">// 使用numInt，可能导致其他错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numInt <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	numInt = numControlByUser + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> numInt &lt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;integer overflow&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;integer ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4【必须】make分配长度验证"><a href="#1-1-4【必须】make分配长度验证" class="headerlink" title="1.1.4【必须】make分配长度验证"></a>1.1.4【必须】make分配长度验证</h4><ul>
<li>在进行make分配内存时，需要对外部可控的长度进行校验，防止程序panic。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="type">int</span>, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	size := lenControlByUser</span><br><span class="line">	<span class="comment">// 对外部传入的size，进行长度判断以免导致panic</span></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	<span class="built_in">copy</span>(buffer, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="type">int</span>, data []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	size := lenControlByUser</span><br><span class="line">	<span class="comment">// 限制外部可控的长度大小范围</span></span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;value too large&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	<span class="built_in">copy</span>(buffer, data)</span><br><span class="line">	<span class="keyword">return</span> buffer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用"><a href="#1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用" class="headerlink" title="1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用"></a>1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用</h4><ul>
<li>当一个对象从被GC选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被GC正确处理，但由于无法确定Finalizer依赖顺序，从而无法调用runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b Data</span><br><span class="line">	a.o = &amp;b</span><br><span class="line">	b.o = &amp;a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针循环引用，SetFinalizer()无法正常调用</span></span><br><span class="line">	runtime.SetFinalizer(&amp;a, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a %p final.\n&quot;</span>, d)</span><br><span class="line">	&#125;)</span><br><span class="line">	runtime.SetFinalizer(&amp;b, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;b %p final.\n&quot;</span>, d)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		foo()</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1-6【必须】禁止重复释放channel"><a href="#1-1-6【必须】禁止重复释放channel" class="headerlink" title="1.1.6【必须】禁止重复释放channel"></a>1.1.6【必须】禁止重复释放channel</h4><ul>
<li>重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放channel，则会触发运行时panic，从而造成DoS攻击。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">	err := processBusiness()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c &lt;- <span class="number">0</span></span><br><span class="line">		<span class="built_in">close</span>(c) <span class="comment">// 重复释放channel</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c) <span class="comment">// 使用defer延迟关闭channel</span></span><br><span class="line">	err := processBusiness()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c &lt;- <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-7【必须】确保每个协程都能退出"><a href="#1-1-7【必须】确保每个协程都能退出" class="headerlink" title="1.1.7【必须】确保每个协程都能退出"></a>1.1.7【必须】确保每个协程都能退出</h4><ul>
<li>启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad: 协程没有设置退出条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWaiter</span><span class="params">(name <span class="type">string</span>, second <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(second) * time.Second)</span><br><span class="line">		fmt.Println(name, <span class="string">&quot; is ready!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-8【推荐】不使用unsafe包"><a href="#1-1-8【推荐】不使用unsafe包" class="headerlink" title="1.1.8【推荐】不使用unsafe包"></a>1.1.8【推荐】不使用unsafe包</h4><ul>
<li>由于unsafe包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用unsafe操作指针，必须做好安全校验。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad: 通过unsafe操作原始指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafePointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">	foo := (*<span class="type">int</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(<span class="number">0xfffffffe</span>)))</span><br><span class="line">	fmt.Print(*foo + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1-9【推荐】不使用slice作为函数入参"><a href="#1-1-9【推荐】不使用slice作为函数入参" class="headerlink" title="1.1.9【推荐】不使用slice作为函数入参"></a>1.1.9【推荐】不使用slice作为函数入参</h4><ul>
<li>slice在作为函数入参时，函数内对slice的修改可能会影响原始数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="comment">// slice作为函数入参时包含原始数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 对入参slice的元素修改会影响原始数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array) <span class="comment">// output：[10 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// 数组作为函数入参，而不是slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传入数组，注意数组与slice的区别</span></span><br><span class="line">    array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a id="1.1.2"></a></p>
<h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2 文件操作"></a>1.2 文件操作</h3><h4 id="1-2-1【必须】-路径穿越检查"><a href="#1-2-1【必须】-路径穿越检查" class="headerlink" title="1.2.1【必须】 路径穿越检查"></a>1.2.1【必须】 路径穿越检查</h4><ul>
<li>在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad: 任意文件读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	path := r.URL.Query()[<span class="string">&quot;path&quot;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未过滤文件路径，可能导致任意文件读取</span></span><br><span class="line">	data, _ := ioutil.ReadFile(path)</span><br><span class="line">	w.Write(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名</span></span><br><span class="line">	data, _ = ioutil.ReadFile(filepath.Join(<span class="string">&quot;/home/user/&quot;</span>, path))</span><br><span class="line">	w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 任意文件写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzip</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	r, _ := zip.OpenReader(f)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">		p, _ := filepath.Abs(f.Name)</span><br><span class="line">		<span class="comment">// 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入</span></span><br><span class="line">		ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzipGood</span><span class="params">(f <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	r, err := zip.OpenReader(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read zip file fail&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(f.Name, <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">			p, _ := filepath.Abs(f.Name)</span><br><span class="line">			ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2【必须】-文件访问权限"><a href="#1-2-2【必须】-文件访问权限" class="headerlink" title="1.2.2【必须】 文件访问权限"></a>1.2.2【必须】 文件访问权限</h4><ul>
<li>根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：<code>-rw-r-----</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br></pre></td></tr></table></figure>

<p><a id="1.1.3"></a></p>
<h3 id="1-3-系统接口"><a href="#1-3-系统接口" class="headerlink" title="1.3 系统接口"></a>1.3 系统接口</h3><p><strong>1.3.1【必须】命令执行检查</strong></p>
<ul>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>、<code>syscall.StartProcess</code>、<code>os.StartProcess</code>等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入<code>bash</code>、<code>cmd</code>、<code>sh</code>等命令；</li>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>等函数时，通过<code>bash</code>、<code>cmd</code>、<code>sh</code>等创建shell，-c后的参数（arg）拼接外部输入，应过滤\n  $  &amp;  ;  |  ‘  “  ( )  &#96;等潜在恶意字符；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInputedVal := <span class="string">&quot;&amp;&amp; echo &#x27;hello&#x27;&quot;</span> <span class="comment">// 假设外部传入该变量值</span></span><br><span class="line">	cmdName := <span class="string">&quot;ping &quot;</span> + userInputedVal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入</span></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="type">string</span>(output))</span><br><span class="line"></span><br><span class="line">	cmdName := <span class="string">&quot;ls&quot;</span></span><br><span class="line">	<span class="comment">// 未判断外部输入是否是预期命令</span></span><br><span class="line">	cmd := exec.Command(cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="type">string</span>(output))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIllegal</span><span class="params">(cmdName <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(cmdName, <span class="string">&quot;&amp;&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;|&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;;&quot;</span>) ||</span><br><span class="line">		strings.Contains(cmdName, <span class="string">&quot;$&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;&#x27;&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;`&quot;</span>) ||</span><br><span class="line">		strings.Contains(cmdName, <span class="string">&quot;(&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;)&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;\&quot;&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInputedVal := <span class="string">&quot;&amp;&amp; echo &#x27;hello&#x27;&quot;</span></span><br><span class="line">	cmdName := <span class="string">&quot;ping &quot;</span> + userInputedVal</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> checkIllegal(cmdName) &#123; <span class="comment">// 检查传给sh的命令是否有特殊字符</span></span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 存在特殊字符直接return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="type">string</span>(output))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="1.1.4"></a></p>
<h3 id="1-4-通信安全"><a href="#1-4-通信安全" class="headerlink" title="1.4 通信安全"></a>1.4 通信安全</h3><h4 id="1-4-1【必须】网络通信采用TLS方式"><a href="#1-4-1【必须】网络通信采用TLS方式" class="headerlink" title="1.4.1【必须】网络通信采用TLS方式"></a>1.4.1【必须】网络通信采用TLS方式</h4><ul>
<li>明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少TLS的安全通信方式保证通信安全，例如gRPC&#x2F;Websocket都使用TLS1.3。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		w.Header().Add(<span class="string">&quot;Strict-Transport-Security&quot;</span>, <span class="string">&quot;max-age=63072000; includeSubDomains&quot;</span>)</span><br><span class="line">		w.Write([]<span class="type">byte</span>(<span class="string">&quot;This is an example server.\n&quot;</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器配置证书与私钥</span></span><br><span class="line">	log.Fatal(http.ListenAndServeTLS(<span class="string">&quot;:443&quot;</span>, <span class="string">&quot;yourCert.pem&quot;</span>, <span class="string">&quot;yourKey.pem&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2【推荐】TLS启用证书验证"><a href="#1-4-2【推荐】TLS启用证书验证" class="headerlink" title="1.4.2【推荐】TLS启用证书验证"></a>1.4.2【推荐】TLS启用证书验证</h4><ul>
<li>TLS证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span></span> *http.Response &#123;</span><br><span class="line">	tr := &amp;http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">	res, _ := client.Do(authReq)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span></span> *http.Response &#123;</span><br><span class="line">	tr := &amp;http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">false</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">	res, _ := client.Do(authReq)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="1.1.5"></a></p>
<h3 id="1-5-敏感数据保护"><a href="#1-5-敏感数据保护" class="headerlink" title="1.5 敏感数据保护"></a>1.5 敏感数据保护</h3><h4 id="1-5-1【必须】敏感信息访问"><a href="#1-5-1【必须】敏感信息访问" class="headerlink" title="1.5.1【必须】敏感信息访问"></a>1.5.1【必须】敏感信息访问</h4><ul>
<li>禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度</li>
<li>使用配置中心系统统一托管密钥等敏感信息</li>
</ul>
<h4 id="1-5-2【必须】敏感数据输出"><a href="#1-5-2【必须】敏感数据输出" class="headerlink" title="1.5.2【必须】敏感数据输出"></a>1.5.2【必须】敏感数据输出</h4><ul>
<li>只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露</li>
<li>不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息</li>
<li>对于必须输出的敏感信息，必须进行合理脱敏展示</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		r.ParseForm()</span><br><span class="line">		user := r.Form.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">		pw := r.Form.Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">&quot;Registering new user %s with password %s.\n&quot;</span>, user, pw)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		r.ParseForm()</span><br><span class="line">		user := r.Form.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">		pw := r.Form.Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">&quot;Registering new user %s.\n&quot;</span>, user)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		use(pw)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免通过GET方法、代码注释、自动填充、缓存等方式泄露敏感信息</li>
</ul>
<h4 id="1-5-3【必须】敏感数据存储"><a href="#1-5-3【必须】敏感数据存储" class="headerlink" title="1.5.3【必须】敏感数据存储"></a>1.5.3【必须】敏感数据存储</h4><ul>
<li>敏感数据应使用SHA2、RSA等算法进行加密存储</li>
<li>敏感数据应使用独立的存储层，并在访问层开启访问控制</li>
<li>包含敏感信息的临时文件或缓存一旦不再需要应立刻删除</li>
</ul>
<h4 id="1-5-4【必须】异常处理和日志记录"><a href="#1-5-4【必须】异常处理和日志记录" class="headerlink" title="1.5.4【必须】异常处理和日志记录"></a>1.5.4【必须】异常处理和日志记录</h4><ul>
<li>应合理使用panic、recover、defer处理系统异常，避免出错信息输出到前端</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Recovered in start()&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<ul>
<li>对外环境禁止开启debug模式，或将程序运行日志输出到前端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">dlv --listen=:2345 --headless=<span class="literal">true</span> --api-version=2 debug test.go</span><br><span class="line">// good</span><br><span class="line">dlv debug test.go</span><br></pre></td></tr></table></figure>

<p><a id="1.1.6"></a></p>
<h3 id="1-6-加密解密"><a href="#1-6-加密解密" class="headerlink" title="1.6 加密解密"></a>1.6 加密解密</h3><h4 id="1-6-1【必须】不得硬编码密码-x2F-密钥"><a href="#1-6-1【必须】不得硬编码密码-x2F-密钥" class="headerlink" title="1.6.1【必须】不得硬编码密码&#x2F;密钥"></a>1.6.1【必须】不得硬编码密码&#x2F;密钥</h4><ul>
<li>在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	user     = <span class="string">&quot;dbuser&quot;</span></span><br><span class="line">	password = <span class="string">&quot;s3cretp4ssword&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> *sql.DB &#123;</span><br><span class="line">	connStr := fmt.Sprintf(<span class="string">&quot;postgres://%s:%s@localhost/pqgotest&quot;</span>, user, password)</span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;postgres&quot;</span>, connStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	commonkey = []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncrypt</span><span class="params">(plaintext <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	block, err := aes.NewCipher(commonkey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2【必须】密钥存储安全"><a href="#1-6-2【必须】密钥存储安全" class="headerlink" title="1.6.2【必须】密钥存储安全"></a>1.6.2【必须】密钥存储安全</h4><ul>
<li>在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。</li>
</ul>
<h4 id="1-6-3【推荐】不使用弱密码算法"><a href="#1-6-3【推荐】不使用弱密码算法" class="headerlink" title="1.6.3【推荐】不使用弱密码算法"></a>1.6.3【推荐】不使用弱密码算法</h4><ul>
<li>在使用加密算法时，不建议使用加密强度较弱的算法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">crypto/des，crypto/md5，crypto/sha1，crypto/rc4等。</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">crypto/rsa，crypto/aes等。</span><br></pre></td></tr></table></figure>

<p><a id="1.1.7"></a></p>
<h3 id="1-7-正则表达式"><a href="#1-7-正则表达式" class="headerlink" title="1.7 正则表达式"></a>1.7 正则表达式</h3><h4 id="1-7-1【推荐】使用regexp进行正则表达式匹配"><a href="#1-7-1【推荐】使用regexp进行正则表达式匹配" class="headerlink" title="1.7.1【推荐】使用regexp进行正则表达式匹配"></a>1.7.1【推荐】使用regexp进行正则表达式匹配</h4><ul>
<li>正则表达式编写不恰当可被用于DoS攻击，造成服务不可用，推荐使用regexp包进行正则表达式匹配。regexp保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但regexp不支持以下正则表达式特性，如业务依赖这些特性，则regexp不适合使用。<ul>
<li>回溯引用<a href="https://www.regular-expressions.info/backref.html">Backreferences</a></li>
<li>查看<a href="https://www.regular-expressions.info/lookaround.html">Lookaround</a></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">matched, err := regexp.MatchString(<span class="string">`a.b`</span>, <span class="string">&quot;aaxbb&quot;</span>)</span><br><span class="line">fmt.Println(matched) <span class="comment">// true</span></span><br><span class="line">fmt.Println(err)     <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p><a id="2"></a></p>
<h1 id="后台类"><a href="#后台类" class="headerlink" title="后台类"></a>后台类</h1><p><a id="2.1"></a></p>
<h2 id="1-代码实现类-1"><a href="#1-代码实现类-1" class="headerlink" title="1 代码实现类"></a>1 代码实现类</h2><p><a id="2.1.1"></a></p>
<h3 id="1-1-输入校验"><a href="#1-1-输入校验" class="headerlink" title="1.1 输入校验"></a>1.1 输入校验</h3><h4 id="1-1-1【必须】按类型进行数据校验"><a href="#1-1-1【必须】按类型进行数据校验" class="headerlink" title="1.1.1【必须】按类型进行数据校验"></a>1.1.1【必须】按类型进行数据校验</h4><ul>
<li>所有外部输入的参数，应使用<code>validator</code>进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myEmail := <span class="string">&quot;abc@tencent.com&quot;</span></span><br><span class="line">	errs := validate.Var(myEmail, <span class="string">&quot;required,email&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(errs)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">		<span class="comment">//停止执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证通过，继续执行</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	validate = validator.New()</span><br><span class="line">	validateVariable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无法通过白名单校验的应使用<code>html.EscapeString</code>、<code>text/template</code>或<code>bluemonday</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行过滤或编码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestHTMLEscapeString HTML特殊字符转义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(inputValue <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	escapedResult := template.HTMLEscapeString(inputValue)</span><br><span class="line">	<span class="keyword">return</span> escapedResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="2.1.2"></a></p>
<h3 id="1-2-SQL操作"><a href="#1-2-SQL操作" class="headerlink" title="1.2 SQL操作"></a>1.2 SQL操作</h3><h4 id="1-2-1【必须】SQL语句默认使用预编译并绑定变量"><a href="#1-2-1【必须】SQL语句默认使用预编译并绑定变量" class="headerlink" title="1.2.1【必须】SQL语句默认使用预编译并绑定变量"></a>1.2.1【必须】SQL语句默认使用预编译并绑定变量</h4><ul>
<li>使用<code>database/sql</code>的prepare、Query或使用GORM等ORM执行SQL操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	Code  <span class="type">string</span></span><br><span class="line">	Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> product Product</span><br><span class="line">...</span><br><span class="line">db.First(&amp;product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用参数化查询，禁止拼接SQL语句，另外对于传入参数用于order by或表名的需要通过校验</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line">	q := fmt.Sprintf(<span class="string">&quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#x27;%s&#x27; ORDER BY PRICE&quot;</span>,</span><br><span class="line">		req.URL.Query()[<span class="string">&quot;category&quot;</span>])</span><br><span class="line">	db.Query(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerGood</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用?占位符</span></span><br><span class="line">	q := <span class="string">&quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#x27;?&#x27; ORDER BY PRICE&quot;</span></span><br><span class="line">	db.Query(q, req.URL.Query()[<span class="string">&quot;category&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="2.1.3"></a></p>
<h3 id="1-3-网络请求"><a href="#1-3-网络请求" class="headerlink" title="1.3 网络请求"></a>1.3 网络请求</h3><h4 id="1-3-1【必须】资源请求过滤验证"><a href="#1-3-1【必须】资源请求过滤验证" class="headerlink" title="1.3.1【必须】资源请求过滤验证"></a>1.3.1【必须】资源请求过滤验证</h4><ul>
<li><p>使用<code>&quot;net/http&quot;</code>下的方法<code>http.Get(url)</code>、<code>http.Post(url, contentType, body)</code>、<code>http.Head(url)</code>、<code>http.PostForm(url, data)</code>、<code>http.Do(req)</code>时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p>
</li>
<li><p>如请求资源域名归属固定的范围，如只允许<code>a.qq.com</code>和<code>b.qq.com</code>，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：</p>
<ul>
<li><p>第 1 步、只允许HTTP或HTTPS协议</p>
</li>
<li><p>第 2 步、解析目标URL，获取其HOST</p>
</li>
<li><p>第 3 步、解析HOST，获取HOST指向的IP地址转换成Long型</p>
</li>
<li><p>第 4 步、检查IP地址是否为内网IP，网段有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。</span><br><span class="line">10.0.0.0/8</span><br><span class="line">172.16.0.0/12</span><br><span class="line">192.168.0.0/16</span><br><span class="line">127.0.0.0/8</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 5 步、请求URL</p>
</li>
<li><p>第 6 步、如有跳转，跳转后执行1，否则绑定经校验的ip和域名，对URL发起请求</p>
</li>
</ul>
</li>
<li><p>官方库<code>encoding/xml</code>不支持外部实体引用，使用该库可避免xxe漏洞</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		XMLName  xml.Name <span class="string">`xml:&quot;person&quot;`</span></span><br><span class="line">		Id       <span class="type">int</span>      <span class="string">`xml:&quot;id,attr&quot;`</span></span><br><span class="line">		UserName <span class="type">string</span>   <span class="string">`xml:&quot;name&gt;first&quot;`</span></span><br><span class="line">		Comment  <span class="type">string</span>   <span class="string">`xml:&quot;,comment&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := &amp;Person&#123;Id: <span class="number">13</span>, UserName: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">	v.Comment = <span class="string">&quot; Need more details. &quot;</span></span><br><span class="line"></span><br><span class="line">	enc := xml.NewEncoder(os.Stdout)</span><br><span class="line">	enc.Indent(<span class="string">&quot;  &quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := enc.Encode(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="2.1.4"></a></p>
<h3 id="1-4-服务器端渲染"><a href="#1-4-服务器端渲染" class="headerlink" title="1.4 服务器端渲染"></a>1.4 服务器端渲染</h3><h4 id="1-4-1【必须】模板渲染过滤验证"><a href="#1-4-1【必须】模板渲染过滤验证" class="headerlink" title="1.4.1【必须】模板渲染过滤验证"></a>1.4.1【必须】模板渲染过滤验证</h4><ul>
<li>使用<code>text/template</code>或者<code>html/template</code>渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()</span><br><span class="line">	x := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">        First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line"></span><br><span class="line">	t := template.New(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">	t, _ = t.Parse(tmpl)</span><br><span class="line">	t.Execute(w, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line">validate = validator.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">(val)</span></span> &#123;</span><br><span class="line">	errs := validate.Var(val, <span class="string">&quot;gte=1,lte=100&quot;</span>) <span class="comment">// 限制必须是1-100的正整数</span></span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(errs)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()</span><br><span class="line">	x := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> validateVariable(x) &#123;</span><br><span class="line">		<span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">            First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line">		t := template.New(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">		t, _ = t.Parse(tmpl)</span><br><span class="line">		t.Execute(w, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a id="2.1.5"></a></p>
<h3 id="1-5-Web跨域"><a href="#1-5-Web跨域" class="headerlink" title="1.5 Web跨域"></a>1.5 Web跨域</h3><h4 id="1-5-1【必须】跨域资源共享CORS限制请求来源"><a href="#1-5-1【必须】跨域资源共享CORS限制请求来源" class="headerlink" title="1.5.1【必须】跨域资源共享CORS限制请求来源"></a>1.5.1【必须】跨域资源共享CORS限制请求来源</h4><ul>
<li>CORS请求保护不当可导致敏感信息泄漏，因此应当严格设置Access-Control-Allow-Origin使用同源策略进行保护。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">c := cors.New(cors.Options&#123;</span><br><span class="line">	AllowedOrigins:   []<span class="type">string</span>&#123;<span class="string">&quot;http://qq.com&quot;</span>, <span class="string">&quot;https://qq.com&quot;</span>&#125;,</span><br><span class="line">	AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">	Debug:            <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入中间件</span></span><br><span class="line">handler = c.Handler(handler)</span><br></pre></td></tr></table></figure>

<p><a id="2.1.6"></a></p>
<h3 id="1-6-响应输出"><a href="#1-6-响应输出" class="headerlink" title="1.6 响应输出"></a>1.6 响应输出</h3><h4 id="1-6-1-【必须】设置正确的HTTP响应包类型"><a href="#1-6-1-【必须】设置正确的HTTP响应包类型" class="headerlink" title="1.6.1 【必须】设置正确的HTTP响应包类型"></a>1.6.1 【必须】设置正确的HTTP响应包类型</h4><ul>
<li>响应头Content-Type与实际响应内容，应保持一致。如：API响应数据类型是json，则响应头使用<code>application/json</code>；若为xml，则设置为<code>text/xml</code>。</li>
</ul>
<h4 id="1-6-2-【必须】添加安全响应头"><a href="#1-6-2-【必须】添加安全响应头" class="headerlink" title="1.6.2 【必须】添加安全响应头"></a>1.6.2 【必须】添加安全响应头</h4><ul>
<li>所有接口、页面，添加响应头 <code>X-Content-Type-Options: nosniff</code>。</li>
<li>所有接口、页面，添加响应头<code>X-Frame-Options </code>。按需合理设置其允许范围，包括：<code>DENY</code>、<code>SAMEORIGIN</code>、<code>ALLOW-FROM origin</code>。用法参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">MDN文档</a></li>
</ul>
<h4 id="1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤"><a href="#1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤" class="headerlink" title="1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤"></a>1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤</h4><ul>
<li>应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉<code>\r</code>、<code>\n</code>等换行符，或者拒绝携带换行符号的外部输入。</li>
</ul>
<h4 id="1-6-4【必须】外部输入拼接到response页面前进行编码处理"><a href="#1-6-4【必须】外部输入拼接到response页面前进行编码处理" class="headerlink" title="1.6.4【必须】外部输入拼接到response页面前进行编码处理"></a>1.6.4【必须】外部输入拼接到response页面前进行编码处理</h4><ul>
<li>直出html页面或使用模板生成html页面的，推荐使用<code>text/template</code>自动编码，或者使用<code>html.EscapeString</code>或<code>text/template</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行编码。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outtemplate</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	param1 := r.URL.Query().Get(<span class="string">&quot;param1&quot;</span>)</span><br><span class="line">	tmpl := template.New(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	tmpl, _ = tmpl.Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">	tmpl.ExecuteTemplate(w, <span class="string">&quot;T&quot;</span>, param1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="2.1.7"></a></p>
<h3 id="1-7-会话管理"><a href="#1-7-会话管理" class="headerlink" title="1.7 会话管理"></a>1.7 会话管理</h3><h4 id="1-7-1【必须】安全维护session信息"><a href="#1-7-1【必须】安全维护session信息" class="headerlink" title="1.7.1【必须】安全维护session信息"></a>1.7.1【必须】安全维护session信息</h4><ul>
<li>用户登录时应重新生成session，退出登录后应清理session。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gorilla/handlers&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setToken</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	expireToken := time.Now().Add(time.Minute * <span class="number">30</span>).Unix()</span><br><span class="line">	expireCookie := time.Now().Add(time.Minute * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	cookie := http.Cookie&#123;</span><br><span class="line">		Name:     <span class="string">&quot;Auth&quot;</span>,</span><br><span class="line">		Value:    signedToken,</span><br><span class="line">		Expires:  expireCookie, <span class="comment">// 过期失效</span></span><br><span class="line">		HttpOnly: <span class="literal">true</span>,</span><br><span class="line">		Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">		Domain:   <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">		Secure:   <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.SetCookie(res, &amp;cookie)</span><br><span class="line">	http.Redirect(res, req, <span class="string">&quot;/profile&quot;</span>, <span class="number">307</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logout</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	deleteCookie := http.Cookie&#123;</span><br><span class="line">		Name:    <span class="string">&quot;Auth&quot;</span>,</span><br><span class="line">		Value:   <span class="string">&quot;none&quot;</span>,</span><br><span class="line">		Expires: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	http.SetCookie(res, &amp;deleteCookie)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-7-2【必须】CSRF防护"><a href="#1-7-2【必须】CSRF防护" class="headerlink" title="1.7.2【必须】CSRF防护"></a>1.7.2【必须】CSRF防护</h4><ul>
<li>涉及系统敏感操作或可读取敏感信息的接口应校验<code>Referer</code>或添加<code>csrf_token</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gorilla/csrf&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	r.HandleFunc(<span class="string">&quot;/signup&quot;</span>, ShowSignupForm)</span><br><span class="line">	r.HandleFunc(<span class="string">&quot;/signup/post&quot;</span>, SubmitSignupForm)</span><br><span class="line">	<span class="comment">// 使用csrf_token验证</span></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>,</span><br><span class="line">		csrf.Protect([]<span class="type">byte</span>(<span class="string">&quot;32-byte-long-auth-key&quot;</span>))(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="2.1.8"></a></p>
<h3 id="1-8-访问控制"><a href="#1-8-访问控制" class="headerlink" title="1.8 访问控制"></a>1.8 访问控制</h3><h4 id="1-8-1【必须】默认鉴权"><a href="#1-8-1【必须】默认鉴权" class="headerlink" title="1.8.1【必须】默认鉴权"></a>1.8.1【必须】默认鉴权</h4><ul>
<li><p>除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。</p>
</li>
<li><p>根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等</p>
</li>
<li><p>涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 伪代码</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span>:id <span class="keyword">and</span> userid<span class="operator">=</span>session.userid</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有独立账号体系的外网服务使用<code>QQ</code>或<code>微信</code>登录，内网服务使用<code>统一登录服务</code>登录，其他使用账号密码登录的服务需要增加验证码等二次验证</p>
</li>
</ul>
<p><a id="2.1.9"></a></p>
<h3 id="1-9-并发保护"><a href="#1-9-并发保护" class="headerlink" title="1.9 并发保护"></a>1.9 并发保护</h3><h4 id="1-9-1【必须】禁止在闭包中直接调用循环变量"><a href="#1-9-1【必须】禁止在闭包中直接调用循环变量" class="headerlink" title="1.9.1【必须】禁止在闭包中直接调用循环变量"></a>1.9.1【必须】禁止在闭包中直接调用循环变量</h4><ul>
<li>在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	<span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		group.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> group.Done()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%-2d&quot;</span>, i) <span class="comment">// 这里打印的i不是所期望的</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	group.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	<span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		group.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;Recovered in start()&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				group.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%-2d&quot;</span>, j) <span class="comment">// 闭包内部使用局部变量</span></span><br><span class="line">		&#125;(i) <span class="comment">// 把循环变量显式地传给协程</span></span><br><span class="line">	&#125;</span><br><span class="line">	group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9-2【必须】禁止并发写map"><a href="#1-9-2【必须】禁止并发写map" class="headerlink" title="1.9.2【必须】禁止并发写map"></a>1.9.2【必须】禁止并发写map</h4><ul>
<li>并发写map容易造成程序崩溃并异常退出，建议加锁保护<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 并发读写</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-9-3【必须】确保并发安全"><a href="#1-9-3【必须】确保并发安全" class="headerlink" title="1.9.3【必须】确保并发安全"></a>1.9.3【必须】确保并发安全</h4></li>
</ul>
<p>敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。</p>
<p>通过同步锁共享内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(lock *sync.Mutex)</span></span> &#123;</span><br><span class="line">	lock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">	count++</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">	lock.Unlock() <span class="comment">// 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock := &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Count(lock) <span class="comment">// 传递指针是为了防止函数内的锁和调用锁不一致</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		c := count</span><br><span class="line">		lock.Unlock()</span><br><span class="line">		runtime.Gosched() <span class="comment">// 交出时间片给协程</span></span><br><span class="line">		<span class="keyword">if</span> c &gt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>sync/atomic</code>执行原子操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> m atomic.Value</span><br><span class="line">	m.Store(<span class="built_in">make</span>(Map))</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex <span class="comment">// used only by writers</span></span><br><span class="line">	read := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> (val <span class="type">string</span>) &#123;</span><br><span class="line">		m1 := m.Load().(Map)</span><br><span class="line">		<span class="keyword">return</span> m1[key]</span><br><span class="line">	&#125;</span><br><span class="line">	insert := <span class="function"><span class="keyword">func</span><span class="params">(key, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		mu.Lock() <span class="comment">// 与潜在写入同步</span></span><br><span class="line">		<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">		m1 := m.Load().(Map) <span class="comment">// 导入struct当前数据</span></span><br><span class="line">		m2 := <span class="built_in">make</span>(Map)      <span class="comment">// 创建新值</span></span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">			m2[k] = v</span><br><span class="line">		&#125;</span><br><span class="line">		m2[key] = val</span><br><span class="line">		m.Store(m2) <span class="comment">// 用新的替代当前对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = read, insert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnGo</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文字直播：消息推送系统介绍</title>
    <url>/2019/06/09/text-live-introduction-message-push-system/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>直播内容:主要讨论周洋在360做的消息推送系统，主要分为以下几个部分：</p>
<ul>
<li>关于push系统对比与性能指标的讨论~  </li>
<li>消息系统架构介绍</li>
<li>哪些因素决定了推送系统的效果？</li>
<li>go语言开发问题与解决方案</li>
<li>消息系统的运维，测试</li>
</ul>
<h2 id="直播开始"><a href="#直播开始" class="headerlink" title="直播开始"></a>直播开始</h2><p>360消息系统更确切的说是长连接push系统，目前服务于360内部50多个产品，开发平台数千款app，也支持部分聊天业务场景，单通道多app复用，支持上行数据，提供接入方不同粒度的上行数据和用户状态回调服务。<br>目前整个系统按不同业务分成9个功能完整的集群，部署在10个idc上（每个集群覆盖不同的idc），实时在线2亿量级.<br>通常情况下，pc，手机，甚至是智能硬件上的360产品的push消息，基本上是从我们系统发出的，期望大家收到的push都是自己关心的… 如果不是，请相信，“我们不生产消息，我们只是消息的搬运工”~<br>很多同行比较关心go语言在实现push系统上的性能问题，单机性能究竟如何，能否和其他语言实现的类似系统做对比么？甚至问如果是创业,第三方云推送平台，推荐哪个?<br>其实各大厂都有类似的push系统，市场上也有类似功能的云服务。包括我们公司早期也有erlang，nodejs实现的类似系统，也一度被公司要求做类似的对比测试。<br>我感觉在讨论对比数据的时候，很难保证大家环境和需求的统一，我只能说下我这里的体会，数据是有的，但这个数据前面估计会有很多定语~</p>
<h2 id="一些重要指标"><a href="#一些重要指标" class="headerlink" title="一些重要指标"></a>一些重要指标</h2><h3 id="1，单机的连接数指标。"><a href="#1，单机的连接数指标。" class="headerlink" title="1，单机的连接数指标。"></a>1，单机的连接数指标。</h3><p>做过长连接的同行，应该有体会，如果在稳定连接情况下，连接数这个指标，在没有网络吞吐情况下对比，其实意义往往不大，维持连接消耗cpu资源很小，每条连接tcp协议栈会占约4k的内存开销，系统参数调整后，我们单机测试数据，最高也是可以达到单实例300w长连接。<br>但做更高的测试，我个人感觉意义不大。因为实际网络环境下，单实例300w长连接，从理论上算压力就很大：因为实际弱网络环境下，移动客户端的断线率很高，假设每秒有1000分之一的用户断线重连。300w长连接，每秒新建连接达到3w，这同时连入的3w用户，要进行注册，加载离线存储等对内rpc调用，另外300w长连接的用户心跳需要维持,假设心跳300s一次，心跳包每秒需要1w tps。<br>单播和多播数据的转发，广播数据的转发，本身也要响应内部的rpc调用，300w长连接情况下，gc带来的压力，内部接口的响应延迟能否稳定保障。<br>这些集中在一个实例中，可用性是一个挑战。所以线上单实例不会hold很高的长连接,实际情况也要根据接入客户端网络状况来决定。</p>
<h3 id="2，消息系统的内存使用量指标"><a href="#2，消息系统的内存使用量指标" class="headerlink" title="2，消息系统的内存使用量指标"></a>2，消息系统的内存使用量指标</h3><p>这一点上，使用go语言情况下，由于协程的原因，会有一部分额外开销。但是要做两个推送系统的对比，也有些需要确定问题。<br>比如系统从设计上是否需要全双工（即读写是否需要同时进行）如果半双工，理论上对一个用户的连接只需要使用一个协程即可（这种情况下，对用户的断线检测可能会有延时），如果是全双工，那读&#x2F;写各一个协程。两种场景内存开销是有区别的.</p>
<p>另外测试数据的大小往往决定我们对连接上设置的读写buffer是多大，是全局复用的，还是每个连接上独享的，还是动态申请的。另外是否全双工也决定buffer怎么开. 不同的策略，可能在不同情况的测试中表现不一样。</p>
<h3 id="3，每秒消息下发量"><a href="#3，每秒消息下发量" class="headerlink" title="3，每秒消息下发量"></a>3，每秒消息下发量</h3><p>这一点上，也要看我们对消息到达的QoS级别(回复ack策略区别），另外架构策略，每种策略有其更适用的场景，是纯粹推，还是推拉结合。甚至是否开启了消息日志，日志库的实现机制，缓冲开多大，flush策略,这些都影响整个系统的吞吐量。另外为了HA，增加了内部通信成本，为了避免一些小概率事件，提供闪断补偿策略，这些都要考虑进去。如果所有的都去掉，那就是比较基础库的性能了.</p>
<p>所以我只能给出大概数据，24核，64G的服务器上，在Qos为message at least，纯粹推的情况，消息体256B<del>1kB情况下，单个实例100w实际用户（200w+）协程，峰值可以达到2</del>5w的QPS…<br>内存可以稳定在25G左右，gc时间在200<del>800ms左右.（还有优化空间）  我们正常线上单实例用户控制在80w以内，单机最多两个实例</del><br>事实上，整个系统在推送的需求上，对高峰的输出不是提速，往往是进行限速，以防push系统瞬时的高吞吐量，转化成对接入方业务服务器的ddos攻击<br>所以对于性能上，我感觉大家可以放心使用，至少在我们这个量级上，经受过考验，go1.5到来后，确实有之前投资又增值了的感觉~<br>下面是对消息系统的大概介绍，之前一些同学可能在gopher china上可以看到分享，这里简单讲解下架构和各个组件功能，额外补充一些当时遗漏的信息：<br>架构图如下，所有的service都 written by golang.<br><img src="/content/images/2019/06/0b8323ed2b40742005a9a6b2010f85b.jpg" alt="0b8323ed2b40742005a9a6b2010f85b"></p>
<h2 id="几个大概重要组件介绍如下"><a href="#几个大概重要组件介绍如下" class="headerlink" title="几个大概重要组件介绍如下"></a>几个大概重要组件介绍如下</h2><h3 id="dispatcher-service"><a href="#dispatcher-service" class="headerlink" title="dispatcher service"></a>dispatcher service</h3><p>根据客户端请求信息，将应网络和区域的长连接服务器的，一组IP传送给客户端。客户端根据返回的IP，建立长连接，连接Room service.</p>
<h3 id="room-Service"><a href="#room-Service" class="headerlink" title="room Service"></a>room Service</h3><p>长连接网关，hold用户连接，并将用户注册进register service，本身也做一些接入安全策略、白名单、IP限制等</p>
<h3 id="coordinator-service"><a href="#coordinator-service" class="headerlink" title="coordinator service"></a>coordinator service</h3><p>用来转发用户的上行数据，包括接入方订阅的用户状态信息的回调，另外做需要协调各个组件的异步操作，比如kick用户操作,需要从register拿出其他用户做异步操作.</p>
<h3 id="saver-service"><a href="#saver-service" class="headerlink" title="saver service"></a>saver service</h3><p>是存储访问层，承担了对redis和mysql的操作，另外也提供部分业务逻辑相关的内存缓存，比如广播信息的加载可以在saver中进行缓存。另外一些策略，比如客户端sdk由于被恶意或者意外修改，每次加载了消息，不回复ack，那服务端就不会删除消息，消息就会被反复加载，形成死循环，可以通过在saver中做策略和判断。（客户端总是不可信的）</p>
<h3 id="center-service"><a href="#center-service" class="headerlink" title="center service"></a>center service</h3><p>提供给接入方的内部api服务器，比如单播或者广播接口，状态查询接口等一系列api,包括运维和管理的api.</p>
<h3 id="举两个常见例子，了解工作机制："><a href="#举两个常见例子，了解工作机制：" class="headerlink" title="举两个常见例子，了解工作机制："></a>举两个常见例子，了解工作机制：</h3><p>比如发一条单播给一个用户，center先请求Register获取这个用户之前注册的连接通道标识、room实例地址，通过room service下发给长连接。<br>Center Service比较重的工作如全网广播，需要把所有的任务分解成一系列的子任务，分发给所有center，然后在所有的子任务里，分别获取在线和离线的所有用户，再批量推到Room Service。通常整个集群在那一瞬间压力很大。<br>deployd&#x2F;agent service 用于部署管理各个进程，收集各组件的状态和信息,zookeeper和keeper用于整个系统的配置文件管理和简单调度</p>
<h2 id="关于推送的服务端架构"><a href="#关于推送的服务端架构" class="headerlink" title="关于推送的服务端架构"></a>关于推送的服务端架构</h2><p>常见的推送模型有长轮训拉取，服务端直接推送（360消息系统目前主要是这种），推拉结合（推送只发通知，推送后根据通知去拉取消息）.<br>拉取的方式不说了，现在并不常用了，早期很多是nginx+lua+redis，长轮训，主要问题是开销比较大，时效性也不好, 能做的优化策略不多。<br>直接推送的系统，目前就是360消息系统这种，消息类型是消耗型的，并且对于同一个用户并不允许重复消耗,如果需要多终端重复消耗，需要抽象成不同用户。<br>推的好处是实时性好，开销小，直接将消息下发给客户端，不需要客户端走从接入层到存储层主动拉取.<br>但纯推送模型，有个很大问题，由于系统是异步的，他的时序性无法精确保证。这对于push需求来说是够用的，但如果复用推送系统做im类型通信，可能并不合适。</p>
<h2 id="这里还有一个常见话题，哪些因素决定推送系统的效果？"><a href="#这里还有一个常见话题，哪些因素决定推送系统的效果？" class="headerlink" title="这里还有一个常见话题，哪些因素决定推送系统的效果？"></a>这里还有一个常见话题，哪些因素决定推送系统的效果？</h2><h3 id="首先是sdk的完善程度"><a href="#首先是sdk的完善程度" class="headerlink" title="首先是sdk的完善程度"></a>首先是sdk的完善程度</h3><p>sdk策略和细节完善度，往往决定了弱网络环境下最终推送质量.</p>
<p>1.SDK选路策略,最基本的一些策略如下：<br>有些开源服务可能会针对用户hash一个该接入区域的固定ip，实际上在国内环境下不可行，最好分配器（dispatcher）是返回散列的一组，而且端口也要参开，必要时候，客户端告知是retry多组都连不上，返回不同idc的服务器。因为我们会经常检测到一些case，同一地区的不同用户，可能对同一idc内的不同ip连通性都不一样，也出现过同一ip不同端口连通性不同，所以用户的选路策略一定要灵活，策略要足够完善.<br>另外在选路过程中，客户端要对不同网络情况下的长连接ip做缓存，当网络环境切换时候(wifi 2G,3G)，重新请求分配器，缓存不同网络环境的长连接ip.</p>
<p>2.客户端对于数据心跳和读写超时设置,完善断线检测重连机制<br>针对不同网络环境，或者客户端本身消息的活跃程度，心跳要自适应的进行调整并与服务端协商，来保证链路的连通性。并且在弱网络环境下，除了网络切换（wifi切3G）或者读写出错情况，什么时候重新建立链路也是一个问题。客户端发出的ping包，不同网络下，多久没有得到响应，认为网络出现问题，重新建立链路需要有个权衡。另外对于不同网络环境下，读取不同的消息长度，也要有不同的容忍时间，不能一刀切。好的心跳和读写超时设置，可以让客户端最快的检测到网络问题，重新建立链路，同时在网络抖动情况下也能完成大数据传输。</p>
<p>3.结合服务端做策略<br>另外系统可能结合服务端做一些特殊的策略，比如我们在选路时候，我们会将同一个用户尽量映射到同一个room service实例上。断线时，客户端尽量对上次连接成功的地址进行重试。主要是方便服务端做闪断情况下策略，会暂存用户闪断时实例上的信息，重新连入的时候，做单实例内的迁移，减少延时与加载开销.</p>
<p>4.客户端保活策略<br>很多创业公司愿意重新搭建一套push系统，确实不难实现，其实在协议完备情况下（最简单就是客户端不回ack不清数据），服务端会保证消息是不丢的。但问题是为什么在消息有效期内,到达率上不去？<br>往往因为自己app的push service存活能力不高。选用云平台或者大厂的，往往sdk会做一些保活策略，比如和其他app共生，互相唤醒，这也是云平台的push service更有保障原因~ 我相信很多云平台旗下的sdk，多个使用同样sdk的app，为了实现服务存活，是可以互相唤醒和保证活跃的~ 另外现在push sdk本身是单连接，多app复用的，这为sdk实现，增加了新的挑战~</p>
<p>综上，对我来说，选择推送平台，优先会考虑客户端sdk的完善程度~ 对于服务端，选择条件稍微简单，要求部署接入点（IDC）越要多，配合精细的选路策略，效果越有保证，至于想知道哪些云服务有多少点，这个群里来自各地的小伙伴们，可以合伙测测~</p>
<p>这个系统在开发过程中遇到挑战和优化策略，给大家看下当年的一张图，在第一版优化方案上线前一天截图~</p>
<p>可以看到，内存最高占用69G，GC时间单实例最高时候高达3<del>6s.这种情况下，试想一次悲剧的请求，经过了几个正在执行gc的组件，后果必然是超时… gc照成的接入方重试，又加重了系统的负担。遇到这种情况当时整个系统最差情况每隔2，3天就需要重启一次</del></p>
<p><img src="/content/images/2019/06/2b01512149c092fa9edf1e4023d7ed0.jpg" alt="2b01512149c092fa9edf1e4023d7ed0"></p>
<p>当时出现问题，现在总结起来，大概以下几点</p>
<p>1.散落在协程里的I&#x2F;O，Buffer和对象不复用。<br>当时由于对go的gc效率理解有限，比较奔放，程序里大量short live的协程，对内通信的很多io操作，由于不想阻塞主循环逻辑或者需要及时响应的逻辑，通过单独go协程来实现异步。这回会gc带来很多负担。</p>
<p>针对这个问题，应尽量控制协程创建，对于长连接这种应用，本身已经有几百万并发协程情况下，很多情况没必要在各个并发协程内部做异步io，因为程序的并行度是有限，理论上做协程内做阻塞操作是没问题。<br>如果有些需要异步执行，比如如果不异步执行，影响对用户心跳或者等待response无法响应，最好通过一个任务池，和一组常驻协程，来消耗，处理结果，通过channel再传回调用方. 使用任务池还有额外的好处，可以对请求进行打包处理，提高吞吐量，并且可以加入控量策略.</p>
<p>2.网络环境不好引起激增<br>go协程相比较以往高并发程序，如果做不好流控，会引起协程数量激增。早期的时候也会发现，时不时有部分主机内存会远远大于其他服务器，但发现时候，所有主要profiling参数都正常了。<br>后来发现，通信较多系统中，网络抖动阻塞是不可免的(即使是内网)，对外不停accept接受新请求，但执行过程中，由于对内通信阻塞，大量协程被创建，业务协程等待通信结果没有释放，往往瞬时会迎来协程暴涨. 但这些内存在系统稳定后，virt和res都并没能彻底释放，下降后，维持高位。<br>处理这种情况，需要增加一些流控策略，流控策略可以选择在rpc库来做，或者上面说的任务池来做，其实我感觉放在任务池里做更合理些，毕竟rpc通信库可以做读写数据的限流，但它并不清楚具体的限流策略，到底是重试还是日志还是缓存到指定队列。任务池本身就是业务逻辑相关的，它清楚针对不同的接口需要的流控限制策略。</p>
<p>3.低效和开销大的rpc框架<br>早期rpc通信框架比较简单，对内通信时候使用的也是短连接。这本来短连接开销和性能瓶颈超出我们预期，短连接io效率是低一些，但端口资源够，本身吞吐可以满足需要，用是没问题的，很多分层的系统，也有http短连接对内进行请求的。但早期go版本，这样写程序，在一定量级情况，是支撑不住的。短连接大量临时对象和临时buffer创建，在本已经百万协程的程序中，是无法承受的。所以后续我们对我们的rpc框架作了两次调整。</p>
<p>第二版的rpc框架，使用了连接池，通过长连接对内进行通信（复用的资源包括client和server的：编解码Buffer、Request&#x2F;response），大大改善了性能。</p>
<p>但这种在一次request和response还是占用连接的，如果网络状况ok情况下，这不是问题，足够满足需要了，但试想一个room实例要与后面的数百个的register，coordinator，saver，center，keeper实例进行通信，需要建立大量的常驻连接，每个目标机几十个连接，也有数千个连接被占用。</p>
<p>非持续抖动时候（持续逗开多少无解），或者有延迟较高的请求时候，如果针对目标ip连接开少了，会有瞬时大量请求阻塞，连接无法得到充分利用。第三版增加了Pipeline操作，Pipeline会带来一些额外的开销，利用tcp的全双特性，以尽量少的连接完成对各个服务集群的rpc调用。</p>
<p>4.GC时间过长<br>Go的Gc仍旧在持续改善中，大量对象和buffer创建，仍旧会给gc带来很大负担，尤其一个占用了25G左右的程序。之前go team的大咖邮件也告知我们，未来会让使用协程的成本更低，理论上不需要在应用层做更多的策略来缓解gc. （目前最新版本，Go 的 GC 已经有了很大的改进）</p>
<p>改善方式，一种是多实例的拆分，如果公司没有端口限制，可以很快部署大量实例，减少gc时长，最直接方法。不过对于360来说，外网通常只能使用80和433。因此常规上只能开启两个实例。当然很多人给我建议能否使用SO_REUSEPORT，不过我们内核版本确实比较低，并没有实践过。另外能否模仿nginx，fork多个进程监控同样端口，至少我们目前没有这样做，主要对于我们目前进程管理上，还是独立的运行的，对外监听不同端口程序，还有配套的内部通信和管理端口，实例管理和升级上要做调整。</p>
<p>解决gc的另两个手段，是内存池和对象池,不过最好做仔细评估和测试，内存池、对象池使用，也需要对于代码可读性与整体效率进行权衡。<br>这种程序一定情况下会降低并行度，因为用池内资源一定要加互斥锁或者原子操作做CAS，通常原子操作实测要更快一些。CAS可以理解为可操作的更细行为粒度的锁（可以做更多CAS策略，放弃运行，防止忙等）。这种方式带来的问题是，程序的可读性会越来越像C语言，每次要malloc，各地方用完后要free，对于对象池free之前要reset，我曾经在应用层尝试做了一个分层次结构的“无锁队列”</p>
<p>上图左边的数组实际上是一个列表，这个列表按大小将内存分块，然后使用atomic操作进行CAS。但实际要看测试数据了，池技术可以明显减少临时对象和内存的申请和释放，gc时间会减少，但加锁带来的并行度的降低，是否能给一段时间内的整体吞吐量带来提升，要做测试和权衡…</p>
<p><img src="/content/images/2019/06/d5fb44dcbb01cb30d4820ece2db74fb.jpg" alt="d5fb44dcbb01cb30d4820ece2db74fb"></p>
<p>在我们消息系统，实际上后续去除了部分这种黑科技，试想在百万个协程里面做自旋操作申请复用的buffer和对象，开销会很大，尤其在协程对线程多对多模型情况下，更依赖于golang本身调度策略，除非我对池增加更多的策略处理，减少忙等，感觉是在把runtime做的事情，在应用层非常不优雅的实现。普遍使用开销理论就大于收益。<br>但对于rpc库或者codec库，任务池内部，这些开定量协程，集中处理数据的区域，可以尝试改造~<br>对于有些固定对象复用，比如固定的心跳包什么的，可以考虑使用全局一些对象，进行复用，针对应用层数据，具体设计对象池，在部分环节去复用，可能比这种无差别的设计一个通用池更能进行效果评估.</p>
<h2 id="架构迭代和迭代经验"><a href="#架构迭代和迭代经验" class="headerlink" title="架构迭代和迭代经验"></a>架构迭代和迭代经验</h2><p>下面介绍消息系统的架构迭代和一些迭代经验，由于之前在其他地方有过分享，后面的会给出相关链接，下面实际做个简单介绍，感兴趣可以去链接里面看</p>
<h3 id="架构迭代"><a href="#架构迭代" class="headerlink" title="架构迭代"></a>架构迭代</h3><p>根据业务和集群的拆分，能解决部分灰度部署上线测试，减少点对点通信和广播通信不同产品的相互影响，针对特定的功能做独立的优化.<br>消息系统架构和集群拆分，最基本的是拆分多实例，其次是按照业务类型对资源占用情况分类，按用户接入网络和对idc布点要求分类（目前没有条件，所有的产品都部署到全部idc）</p>
<p><img src="/content/images/2019/06/3bd38ef89d953b4a38ee82d3883845a.jpg" alt="3bd38ef89d953b4a38ee82d3883845a"></p>
<h3 id="简要介绍下我们的运维系统"><a href="#简要介绍下我们的运维系统" class="headerlink" title="简要介绍下我们的运维系统"></a>简要介绍下我们的运维系统</h3><p>我们利用Go原生的profiling工具，做了些可视化工作。可以对比多次上线出现的问题，通过压测程序复现部分瓶颈。定位cpu或者内存消耗的瓶颈。</p>
<p><img src="/content/images/2019/06/9d20e7fc447c0934ede155cd7a1ca5f.jpg" alt="9d20e7fc447c0934ede155cd7a1ca5f"></p>
<p><img src="/content/images/2019/06/d582183dc3ccbbc15ae6203fcb08762.jpg" alt="d582183dc3ccbbc15ae6203fcb08762"></p>
<p>另外，我们也可以对基础库代码做内嵌，将RPC库，Redis库，内存池命中数据等，做可视化的展示，统计它的QPS、网络带宽占用、idle与working，各种出错情况。然后再通过各种压测手段，观察优化性能点，上线前后是否有影响。如果一个系统不可评估就无法优化，利用压测评估就会发现一些潜在的问题。</p>
<p><img src="/content/images/2019/06/fd90a02582647647c1631b71a570164.jpg" alt="fd90a02582647647c1631b71a570164"></p>
<h3 id="系统的测试"><a href="#系统的测试" class="headerlink" title="系统的测试"></a>系统的测试</h3><p>go语言在并发测试上有独特优势。<br>在功能测试上，系统分成两套，一套是我们针对自己的功能，自己设计并测试，但这样难免会有问题。另一套是公司的自动化测试部门（python实现的<del>）根据我们的功能来测试。双保险</del><br><img src="/content/images/2019/06/c1e3523ce678de3c2a5e0d763b6927a.jpg" alt="c1e3523ce678de3c2a5e0d763b6927a"></p>
<p>对于压力测试，目前主要针对指定的服务器，选定线上空闲的服务器做长连接压测。然后结合可视化，分析压测过程中的系统状态。但压测早期用的比较多，但实现的统计报表功能和我理想有一定差距。理论上压测完后，可以根据协议版本，汇总每一次压测进程详细数据，业务的QPS数量、每秒钟建立连接数量，极限状态下的cpu和内存消耗，等每一个考核细节。现在只是能看一个大概趋势.对于细微的性能提升，没法评估，我们后续准备结合自己写的中央管理组件keeper，做这个数据收集和展示~</p>
<p>对于go语言适用的场景。之前在gopher china上，有过我个人的理解和概括：适用于重逻辑的io密集型应用.</p>
<p>我觉得最近出的golang开源产品都符合这种场景， go写网络并发程序给大家带来的便利，让大家把以往为了降低复杂度，拆解或者分层协作的组件，又组合在了一起。</p>
<p>比如go的web框架是在做负责并发的webserver和负责业务处理cgi程序，放在了webserver中。新近的一些go写的“智能”代理或者中间件，把很多原先分层控制或者不同功能但类似的子系统，以各种形式组装起来，reborn一个新的中间件或者新产品<del>包括之前百度放出的go-bfe也是把重逻辑和io密集型很好结合的产物</del>（群里有bfe的同学么，求更多资料）</p>
<p>个人感觉在国内互联网创业公司爆发环境下，大厂的复杂设备，很多将被golang重新打包成适用在一定量级下的“全能”工具箱~<br>以上就是今天的go分享~ 谢谢大家，欢迎提问~</p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>架构设计和概要（ 1小时的分享 文字总结）<br><a href="http://blog.qiniu.com/archives/3720">http://blog.qiniu.com/archives/3720</a><br>关于基础库实现和性能参数对比表格：<br><a href="http://blog.golang.org/qihoo">http://blog.golang.org/qihoo</a></p>
<h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>提问：对比kafaka这些消息系统 有什么优点？<br>回答：我们是消息推送系统 指的对客户端的高并发推送的 面对场景不一样</p>
<p>提问：hadoop生态圈的大数据，算重逻辑和IO密集型应用不？<br>回答：不算 Hadoop主要是计算</p>
<p>提问：这种推送的方式如何保证消息是有序到达的？<br>回答：如果要保证有序 需要重新设计协议 对消息编号 先存储 后拉取 可以按人存储也可以按订阅关系 目前花椒的im系统 属于这种场景 有机会大家感兴趣可以分享升级版本聊天架构</p>
<p>提问：golang适不适合写web应用<br>回答：这个可以单独一讲回答 我的建议新的应用 大并发的场景可以考虑 老项目酌情改写替换</p>
<p>提问：推送的消息会有多级转发吗？还是说客户端直接跟一个server保持长链接就完事了？<br>回答：当流量大到一定程度 可以多级转发 类似cdn架构 目前花椒直播的推送系统支持这种场景 为idc流量做分级转发 普通场景不需要</p>
<p>提问：极光推送跟这种推送的应用场景就是差不多吧？<br>回答：方案都类似 协议复杂度会不同 比如为了保证一致性采取编号 先存储后发送</p>
<p>提问：多级之间也是长链接吧<br>回答：多级别只是rpc调用 rpc通常keepalive</p>
<p>提问：推送系统目前支持什么协议呢？ mqtt？web socket？<br>回答：分传输层和协议层 传输层web socket 没问题 mqtt是一个具体交互协议了 不具备通用可比性</p>
<p>提问：推送系统里面有用到epoll吗？有没有开源地址？<br>回答：用的golang； go原生就是对epoll封装…目前不开源 安全公司理解下</p>
]]></content>
      <categories>
        <category>Share-live</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>学习</tag>
        <tag>技术</tag>
        <tag>消息推送</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-面试题3-数组中重复的数字-题目一</title>
    <url>/2019/01/27/sword-to-offer-03/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="题目一：找出数组中重复的数字"><a href="#题目一：找出数组中重复的数字" class="headerlink" title="题目一：找出数组中重复的数字"></a>题目一：找出数组中重复的数字</h3><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。  </p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1，先把输入的数组排序；  </p>
<ul>
<li>从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。</li>
</ul>
<p>2，利用哈希表；  </p>
<p>3，根据数组下表找重复数字；(过程会在后面详细写出)  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换numbers[i]和numbers[numbers[i]]        </span></span><br><span class="line">            <span class="type">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li><p>对一维数组的理解。一维数组在内存中占据连续的空间，因此我们可以根据下标定位对应的元素。  </p>
</li>
<li><p>学会通过具体例子找出其中的规律。</p>
</li>
</ul>
<p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp">本题源代码</a></p>
]]></content>
      <categories>
        <category>SwordToOffer</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数组</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title>头可断血可流发型不可乱</title>
    <url>/2020/11/18/the-head-can-be-broken-and-blood-can-flow-but-the-hairstyle-can-not-be-messy/</url>
    <content><![CDATA[<p>最近新出了个抗日神剧叫《雷霆战将》，被人民日报点名批评，播出一周被下架，很好奇的我看了一些片段，直呼毁三观。  </p>
<p>《雷霆战将》约等于《亮剑3》，里面剧情和亮剑一模一样，就是名字变了，梳理了以下，糟点如下：  </p>
<ul>
<li>抗日时期住别墅；(请问都住别墅了还打什么仗)  </li>
<li>第二集就开始抛媚眼，把战争剧演成了偶像剧；  </li>
<li>抗战时期护士穿裙子；  </li>
<li>将军头上顶着发胶；  </li>
<li>打仗期间还不忘抽雪茄；<br>等等…</li>
</ul>
<p>真无力吐槽，从亮剑翻拍，手撕鬼子，到现在又出现了《雷霆战将》，演技真让我作呕，我不晓得导演编剧和审核的人是出于什么样的目的，就从战争这个角度来看这种剧就不该出现！！！  </p>
<p>经典不容超越和翻拍，那是我觉得不尊重的表现。  </p>
<p>最后引用李云龙的一段配音作为结束，讽刺那些想翻拍经典博得关注和票房的人————  </p>
<p>李云龙对赵政委说：<strong>我刚接手新一团的时候，部队发型乱，缺少护发经验，最重要的是缺少发胶，啫喱水全团不到十瓶，焗油一瓶都没有，发胶还是老牌发蜡，就这样，两个人还分不到一瓶发胶，我去找旅长要，你猜旅长怎么说，旅长说，要发胶没有，要命一条，你李云龙看我脑袋值多少发胶，就砍了去换发胶，你有能耐当团长，就想办法去弄发蜡，少拿这点破事烦我。——得嘞，我等的就是这句话，一年之后，新一团什么都有了，沙贝龙，海飞丝，焗油机，烫发机，还有几个漂亮的洗头妹，没有这些，我敢跟坂田联队硬碰硬PK发型，做梦去吧。</strong></p>
]]></content>
      <categories>
        <category>Review-film</category>
      </categories>
      <tags>
        <tag>神剧</tag>
        <tag>吐槽</tag>
        <tag>毁三观</tag>
        <tag>雷霆战将</tag>
      </tags>
  </entry>
  <entry>
    <title>暂时的停留，是为了走得更远_写给因生活节奏快而让内心脱轨的你</title>
    <url>/2016/01/01/the-temporary-stay-is-to-go-further/</url>
    <content><![CDATA[<h1 id="你心里的天鹅都去哪了？"><a href="#你心里的天鹅都去哪了？" class="headerlink" title="你心里的天鹅都去哪了？"></a>你心里的天鹅都去哪了？</h1><p>我一直深信人的心里也有一只天鹅，可以任思想和创造力无边地飞翔，许多人受到欲望的捆绑，或在生活中被剪去飞行的壮志，或由于起飞的湖泊太小，久而久之，失去了思想和创造的能力，同时也失去了自由和向往天空的心。  </p>
<h2 id="大学——大染缸"><a href="#大学——大染缸" class="headerlink" title="大学——大染缸"></a>大学——大染缸</h2><p>每个人在进入大学前，都是一张纯净的白纸，只是很容易被周围的环境所影响，被一些微不足道的流言蜚语所迷失方向，在这种环境的潜移默化下，我们变得越来越不像当初的自己。待到若干年后，你只能遗憾地对曾经的你说一声：“对不起，我没有成为那个最初你想成为的那个人。”   </p>
<h2 id="能不能晚点再谈喜欢和爱"><a href="#能不能晚点再谈喜欢和爱" class="headerlink" title="能不能晚点再谈喜欢和爱"></a>能不能晚点再谈喜欢和爱</h2><p>在提倡快速高效的今天，感情也在大家口中变得粗暴和功利。  </p>
<p>世上好姑娘千千万，一个不行咱就换。  </p>
<p>就这样，我们看着一些人急匆匆地闯进我们的生活，然后又目视着他们匆匆离开。  </p>
<p>似乎我们在大学认识了许多人，却又好像没有一个可以交心。相信很多人都有这样的感觉，在生活中大家聊得异常开心，见过一次面下次再见就是熟人，聊过两句就升级为朋友，于是熟人越来越多，朋友却越来越少。  </p>
<p>爱情就是这样，大家似乎都很急，忙着脱单，忙着在一起相处短暂的几个月，再慌忙的分开，从此老死不相往来。  </p>
<p>有好感就自动升级为喜欢，有点喜欢就被称为爱情，动了心就冲上去表白，失恋了大不了换个人重头再来。  </p>
<p>爱情其实就像一个系统，出现了漏洞要及时用心弥补，而不是老想着去换新的。否则你永远不知道，你的爱情能走多远。  </p>
<p>在别人匆匆表白的时候我选择默默站在你的身后，在你无助的时候总在身边。  </p>
<p>没有多轰动的场面，没有昂贵的礼物，可我却想用心——陪你到颠沛流离。  </p>
<p>我希望我们的相识慢一点，玩笑慢一点，告白慢一点，每一次和你一起散步时的步调慢一点…  </p>
<p>也希望能一起望天，我会慢慢地说着我的那些事情，当天边那雨雾消失，渐渐升起一架彩虹桥时，我会慢慢开始喜欢你。  </p>
<p>我会晚点再说爱，也请真正爱我的人可以慢下来等我，给我一场不赶时间的爱情。  </p>
<h2 id="功利化的学习氛围"><a href="#功利化的学习氛围" class="headerlink" title="功利化的学习氛围"></a>功利化的学习氛围</h2><p>不知从何时开始，我们看书不再是为了丰富自己，而是为了那所谓的期末考试；做课程设计不再是为了展现自己，而是为了获得那零星的学分；申报项目不是为了兴趣爱好，而是为了能申请到专利的荣誉和那看似丰富的经费支出。  </p>
<p>可笑！倘若地基都没建设好，那么一切都是白搭！  </p>
<h2 id="30°角的仰望"><a href="#30°角的仰望" class="headerlink" title="30°角的仰望"></a>30°角的仰望</h2><p>你在干什么？ -我在仰望星空。<br>30°角的仰望是什么？ -是我追逐梦想和思念爱人的角度。<br>为什么要把头抬到30°？ -是为了不让我的眼泪掉下来。  </p>
<p>不言放弃的人，总会在追梦的轨道上因为受一些诱惑所影响，而偏离了正确的方向。这时，请你记得停下自己正在奔跑的步伐，抬头仰望星空，当燥热的内心归于平静，你也会明白自己拥有什么？想成为什么？想提高什么？  </p>
<p>追梦就像一场旅行，途中会有汗水、泪水甚至血水，但你只要静下心来，不被周围喧嚣的环境左右了你的判断，那么将来的你，一定会感激当初选对方向的自己！  </p>
<h2 id="暂时的停留，是为了走得更远"><a href="#暂时的停留，是为了走得更远" class="headerlink" title="暂时的停留，是为了走得更远"></a>暂时的停留，是为了走得更远</h2><p>在这个浮躁的社会里，我们急于发泄，渴望被了解，炫耀、牢骚、无病呻吟、刷存在感…当所有的人对你知根知底，你便成了一张没有内容的白纸。我们都要学会对这个世界保留起30%，那个30%的你，不需要很厉害，但一定是一个隐忍，向上，丰富而有内容的人。  </p>
<p>眼前的我，在经历了短暂的停留后，目光明亮，笑容浅漾，70%的我们，不再对这个世界声色张扬，却美好得恰到好处。  </p>
<p>愿那些内心失去天鹅的人，在新的一年里，能找回自由和向往天空的心。让我们一起，在这快节奏的社会里：不忘初心，无遗憾的起航，越飞越高，越飞越远！  </p>
<p>早安，2016。  </p>
<p><img src="/2016/01/01/the-temporary-stay-is-to-go-further/good-morning-2016.jpeg"><br>2016年的第一场日出，拍摄于塔里木大桥。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>梦想</tag>
        <tag>大学</tag>
        <tag>停留</tag>
        <tag>步伐</tag>
      </tags>
  </entry>
  <entry>
    <title>代码之丑</title>
    <url>/2022/01/04/the-ugly-code/</url>
    <content><![CDATA[<h1 id="坏味道"><a href="#坏味道" class="headerlink" title="坏味道"></a>坏味道</h1><h2 id="缺乏业务含义的命名"><a href="#缺乏业务含义的命名" class="headerlink" title="缺乏业务含义的命名"></a>缺乏业务含义的命名</h2><h3 id="错误命名"><a href="#错误命名" class="headerlink" title="错误命名"></a>错误命名</h3><ul>
<li>宽泛的命名  </li>
<li>用技术术语命名</li>
</ul>
<h3 id="命名遵循的原则"><a href="#命名遵循的原则" class="headerlink" title="命名遵循的原则"></a>命名遵循的原则</h3><ul>
<li>描述意图，而非细节  </li>
<li>面向接口编程，接口是稳定的，实现是易变的  </li>
<li>命名中出现技术名词，往往是它缺少了一个模型  </li>
<li>使用业务语言</li>
</ul>
<h2 id="乱用英语"><a href="#乱用英语" class="headerlink" title="乱用英语"></a>乱用英语</h2><h3 id="英语使用不当"><a href="#英语使用不当" class="headerlink" title="英语使用不当"></a>英语使用不当</h3><ul>
<li>违反语法规则  </li>
<li>不准确的英语词汇  </li>
<li>英语单词拼写错误</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>制定代码规范  </li>
<li>建立团队词汇表  </li>
<li>经常性进行代码评审</li>
</ul>
<h2 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h2><h3 id="重复的代码"><a href="#重复的代码" class="headerlink" title="重复的代码"></a>重复的代码</h3><ul>
<li>复制粘贴的代码  </li>
<li>结构重复的代码  </li>
<li>if 和 else 代码块中的语句高度类似</li>
</ul>
<h3 id="消灭重复代码的原则"><a href="#消灭重复代码的原则" class="headerlink" title="消灭重复代码的原则"></a>消灭重复代码的原则</h3><ul>
<li>每一处知识都必须有单一、明确、权威地表述</li>
</ul>
<h2 id="长函数"><a href="#长函数" class="headerlink" title="长函数"></a>长函数</h2><h3 id="长函数的产生"><a href="#长函数的产生" class="headerlink" title="长函数的产生"></a>长函数的产生</h3><ul>
<li>以性能为由  </li>
<li>平铺直叙写代码  </li>
<li>一次增加一点点代码</li>
</ul>
<h3 id="消灭长函数的原则"><a href="#消灭长函数的原则" class="headerlink" title="消灭长函数的原则"></a>消灭长函数的原则</h3><ul>
<li>定义好函数长度的标准  </li>
<li>做好“分离关注点”</li>
</ul>
<h3 id="重构手法"><a href="#重构手法" class="headerlink" title="重构手法"></a>重构手法</h3><ul>
<li>提取函数</li>
</ul>
<h2 id="大类"><a href="#大类" class="headerlink" title="大类"></a>大类</h2><h3 id="产生大类的原因"><a href="#产生大类的原因" class="headerlink" title="产生大类的原因"></a>产生大类的原因</h3><ul>
<li>职责不单一  </li>
<li>字段未分组</li>
</ul>
<h3 id="软件设计的原则"><a href="#软件设计的原则" class="headerlink" title="软件设计的原则"></a>软件设计的原则</h3><ul>
<li>单一职责原则</li>
</ul>
<h3 id="极致的追求"><a href="#极致的追求" class="headerlink" title="极致的追求"></a>极致的追求</h3><ul>
<li>每个类不超过2个字段</li>
</ul>
<h2 id="长参数"><a href="#长参数" class="headerlink" title="长参数"></a>长参数</h2><h3 id="消除长参数"><a href="#消除长参数" class="headerlink" title="消除长参数"></a>消除长参数</h3><ul>
<li><p>参数数量多导致的长参数<br>变化频率相同，则封装成一个类；<br>变化频率不同：静态不变的，可以成为软件结构的一部分；多个变化频率的，可以封装成几个类。  </p>
</li>
<li><p>标记参数导致的长参数<br>根据标记参数，将函数拆分成多个函数。</p>
</li>
</ul>
<h3 id="重构的手法"><a href="#重构的手法" class="headerlink" title="重构的手法"></a>重构的手法</h3><ul>
<li>将参数列表封装成对象  </li>
<li>移除标记参数</li>
</ul>
<h2 id="滥用控制语句"><a href="#滥用控制语句" class="headerlink" title="滥用控制语句"></a>滥用控制语句</h2><h3 id="呈现形态"><a href="#呈现形态" class="headerlink" title="呈现形态"></a>呈现形态</h3><ul>
<li>嵌套的代码  </li>
<li>else语句  </li>
<li>重复的switch  </li>
<li>循环语句</li>
</ul>
<h3 id="编程原则"><a href="#编程原则" class="headerlink" title="编程原则"></a>编程原则</h3><ul>
<li>函数至多有一层缩进  </li>
<li>不要使用else关键字</li>
</ul>
<h3 id="重构的手法-1"><a href="#重构的手法-1" class="headerlink" title="重构的手法"></a>重构的手法</h3><ul>
<li>以卫语句取代嵌套的条件表达式  </li>
<li>多态取代条件表达式</li>
</ul>
<h2 id="缺乏封装"><a href="#缺乏封装" class="headerlink" title="缺乏封装"></a>缺乏封装</h2><h3 id="呈现形态-1"><a href="#呈现形态-1" class="headerlink" title="呈现形态"></a>呈现形态</h3><ul>
<li>火车残骸&#x2F;过长的消息链  </li>
<li>基本类型偏执</li>
</ul>
<h3 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h3><ul>
<li>遵循迪米特法则  </li>
<li>封装所有的基本类型和字符串  </li>
<li>使用一流的集合</li>
</ul>
<h3 id="重构的手法-2"><a href="#重构的手法-2" class="headerlink" title="重构的手法"></a>重构的手法</h3><ul>
<li>隐藏委托关系  </li>
<li>以对象取代基本类型</li>
</ul>
<h2 id="可变的数据"><a href="#可变的数据" class="headerlink" title="可变的数据"></a>可变的数据</h2><h3 id="呈现形态-2"><a href="#呈现形态-2" class="headerlink" title="呈现形态"></a>呈现形态</h3><ul>
<li>暴露的细节  </li>
<li>可变的数据  </li>
<li>全局数据</li>
</ul>
<h3 id="编程规则-1"><a href="#编程规则-1" class="headerlink" title="编程规则"></a>编程规则</h3><ul>
<li>限制变化  </li>
<li>尽可能编写不变类  </li>
<li>区分类的性质，实体对象要限制数据变化，而值对象就要设计成不变类</li>
</ul>
<h3 id="重构的手法-3"><a href="#重构的手法-3" class="headerlink" title="重构的手法"></a>重构的手法</h3><ul>
<li>移除设置函数</li>
</ul>
<h2 id="变量的声明与赋值分离"><a href="#变量的声明与赋值分离" class="headerlink" title="变量的声明与赋值分离"></a>变量的声明与赋值分离</h2><h3 id="编程规则-2"><a href="#编程规则-2" class="headerlink" title="编程规则"></a>编程规则</h3><ul>
<li>变量要一次性完成初始化</li>
</ul>
<h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><ul>
<li>在声明前面加上final，用不变性的限制约束代码  </li>
<li>用声明式的方式进行集合的初始化</li>
</ul>
<h2 id="依赖混乱"><a href="#依赖混乱" class="headerlink" title="依赖混乱"></a>依赖混乱</h2><h3 id="呈现形态-3"><a href="#呈现形态-3" class="headerlink" title="呈现形态"></a>呈现形态</h3><ul>
<li>缺少防腐层，业务与外部接口耦合  </li>
<li>业务代码中出现具体实现类</li>
</ul>
<h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a>应对策略</h3><ul>
<li>引入防腐层，将业务与内部接口隔离  </li>
<li>引入模型，将业务与具体实现隔离</li>
</ul>
<h3 id="编程规则-3"><a href="#编程规则-3" class="headerlink" title="编程规则"></a>编程规则</h3><ul>
<li>高层模块不应依赖于低层模块，二者应依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。</li>
</ul>
<h2 id="不一致的代码"><a href="#不一致的代码" class="headerlink" title="不一致的代码"></a>不一致的代码</h2><h3 id="呈现形态-4"><a href="#呈现形态-4" class="headerlink" title="呈现形态"></a>呈现形态</h3><ul>
<li>命名中的不一致  </li>
<li>方案中的不一致  </li>
<li>代码中的不一致</li>
</ul>
<h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a>应对策略</h3><ul>
<li>团队统一编码方案  </li>
<li>提取函数，将不同层次的内容放入不同函数中</li>
</ul>
<h2 id="落后的代码风格"><a href="#落后的代码风格" class="headerlink" title="落后的代码风格"></a>落后的代码风格</h2><h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><ul>
<li>Java8引入的Optional  </li>
<li>函数式编程</li>
</ul>
<h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><ul>
<li>引入Optional可以减少由于程序员的忽略而引发对空对象的问题  </li>
<li>懂得最基本的几个操作：map、filter和reduce，就可以把大部分集合操作转成列表转换</li>
</ul>
<h3 id="编程规则-4"><a href="#编程规则-4" class="headerlink" title="编程规则"></a>编程规则</h3><ul>
<li>声明式编程  </li>
<li>写短小的函数，不要在lambda中写过多代码</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>好的命名，是体现业务含义的命名  </li>
<li>编写符合英语语法规则的代码  </li>
<li>不要重复自己，不要复制粘贴  </li>
<li>把函数写短，越短越好  </li>
<li>把类写小，越小越好  </li>
<li>减小参数列表，越小越好  </li>
<li>循环和选择语句，可能都是坏味道  </li>
<li>构建模型，封装散落的代码  </li>
<li>限制可变的数据  </li>
<li>一次性完成变量的初始化  </li>
<li>代码应该向着稳定的方向依赖  </li>
<li>保持代码在各个层面上的一致性  </li>
<li>不断学习“新”的代码风格，不断改善自己的代码</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>时间的价值</title>
    <url>/2020/05/21/the-value-of-time/</url>
    <content><![CDATA[<p>今天，收到一位学弟发来的消息，他收到了北京字节的<code>offer</code>，薪资五位数，本科应届毕业生，看了他发的薪资，讲真我酸了&#x2F;(ㄒoㄒ)&#x2F;~~  </p>
<p>让我不禁想起上个月顿悟出的一件事：<strong>时间的价值，到底怎么体现时间的价值呢？</strong>  </p>
<p>我记得，我刚毕业入职一家公司，做图形学方面的研发，有一次下班，和我的导师并肩走向地铁站时，我说我多么喜欢这一份工作，他很好奇的问我：你真的喜欢做这个吗？别这么早下定论，至少我到现在还没有找到我喜欢做什么。  </p>
<p>也许只是他随口一说，但此时此景，他的话又放佛在我耳边清晰的回响起来：你真的喜欢做这个吗…  </p>
<p>在后面持续至少20个月的工作生涯里，我兴奋过，厌倦过，苦恼过，迷茫过，直到上个月我才突然顿悟出来：喜欢与不喜欢，无非就是觉得自己是否能体现其存在的价值，如果在他人眼来这份职业（或者是你正在做的事情）价值为0，但我自己却非常感兴趣，那它就是无价的；如果只是用来谋生，那么唯有<code>money</code>，才是检验你过的是否有价值的一个衡量标准。  </p>
<p>最后，希望我可以早日找到————让自己不惜一切也要拼命守护的东西。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>价值</tag>
        <tag>时间</tag>
        <tag>守护</tag>
      </tags>
  </entry>
  <entry>
    <title>世界又少了一个单纯善良的人</title>
    <url>/2019/11/14/the-world-has-lost-a-simple-and-kind-human/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前天女朋友回来告诉我，说她在下班途中碰到一个马来西亚的华人，来成都出差，在问路，于是她和那位华人多聊了几句，昨天回来后闷闷不乐，还流眼泪，我再三询问原因，她才告诉我说被骗了，自己怎么这么傻…被骗的过程我就不赘述了，网上搜关键字<strong>买烟骗局</strong>。  </p>
<p>而我写下这篇文章，一是阐述这样的一种骗局，二是感慨，世界上又少了一位单纯善良的人。  </p>
<h2 id="善良有错吗？"><a href="#善良有错吗？" class="headerlink" title="善良有错吗？"></a>善良有错吗？</h2><p>我记得，从小学，初中，高中这十二年的教育中，无论是从语文书，还是思想品德书上，都告诉我们要做一个正直善良的人，要孝敬父母，尊老爱幼，朋友有难要伸出援手，遇到困难学会忍受，相信雨过天晴这样大篇章的废话套话。  </p>
<p>但是，要做到这些的前提，就是你要有资本。</p>
<p>在这个星球上生活了二十三年，有一些本来需要遗忘又不经意回想的瞬间，让我不得不在此时此景下记录下来，例如  </p>
<ul>
<li>上高中时，在乌鲁木齐坐公交，碰到一个老头(这么称呼说明我并不尊重他)投了币，径直走向一个上面坐着小孩的座位，把他拉了起来，自己坐了下去，给老人让座没有错，但请对自己鲁莽的动作说一声抱歉，因为你确实吓到那位小孩了；  </li>
<li>去上大学，坐十三个小时的火车，想上卫生间，在门口排队时，有些大人不顾其他人的感受，直接插队；  </li>
<li>在大学里，帮助某些人，明明主动权在自己手上，却偏偏别人以为这是你必须帮我的义务(真是可笑)；  </li>
<li>晚上休息时，舍友外放看直播，我吵得睡不着，但当我练习吹口琴时旁边人就不耐烦，那一刻，我有了脑子一热砍人的想法；  </li>
<li>上大三时一位老师直接和我谈一笔和算法竞赛有关的交易，无奈我很讨厌他，委婉的拒绝了，结果那门科目我就挂了(当时我预测我的卷面分至少在80分以上)，原来，老师没有那么神圣，他们也是人，也有自己的七情六欲;  </li>
<li>去济南玩时，一天内碰到两个乞讨者，追着我叫我给他and她一点钱；  </li>
<li>大学毕业，独自去一座城市生活，在软件园遇到一个女子，问我借20元坐地铁，说明天给我，转账后第二天微信被拉黑；</li>
</ul>
<p>所以，善良有错吗？  </p>
<p>善良没有错，但是你要有资本，有承受贡献善良后的风险。  </p>
<p>如果没有资本，即使被所谓的社会道德谴责，我也会无动于衷。  </p>
<p>由于女朋友被骗的金额够不到2000，不构成诈骗罪，所以到公安局只是立案，不会调查，具体进展我会及时更新，而我只能在下班时在诈骗地点附近转悠，期待都找到骗女友钱的骗子，如果真能找到，我一定要给上一拳头，顺便补上几脚。  </p>
<p><strong>我可以一直保持善良，在心里立一尊佛，但是当佛倒了，我就会变成魔。</strong>  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/278929215/answer/404243094">知乎_被骗买两条中华烟？</a></li>
</ul>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>骗局</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年，我大一</title>
    <url>/2015/09/02/this-year-my-freshman-year/</url>
    <content><![CDATA[<p>这一年，我刚步入大一。耳边徘徊的不再是高中时的嬉笑声，取而代之的都是陌生的字眼，学分，学生会，班干部，团支部，奖学金，荣誉证书，挂科，协会，社团…仔细想想，似乎每个大学生每日都在为这些而奔波…。  </p>
<p>这一年，我大一。这一年，我懂了家人才是自己唯一的依靠。在外飘荡久了，想回家；在外碰了壁，想回家；在外没有人陪，想回家；在外没钱就寸步难行，想回家。但最终我知道了：成长本来就是一个人的旅行。  </p>
<p>这一年，我渐渐的学会了独立，因为我逐渐明白：自己不独立，没有人会替你坚强，更不会有人送上关怀。  </p>
<p>这一年，我大一。这一年，我明白了大学比高三还严厉，琐碎的事比每天吃的饭都多，挂不得看着你们每天都很疲惫。因为当你把身心埋在成堆的无关紧要的事情中时，也就渐渐迷失了自我。  </p>
<p>这一年，我大一。这一年，我体会到了老师们强大的心理承受能力。他们可以淡定到即使全班都不听课，也可以讲的滔滔不绝。然后等待着下课铃声的响起，转身离开..。  </p>
<p>这一年，我大一。这一年，我懂的了许多人面对讨厌的人不是不理不睬，而是依然微笑；这一年，我遇见了比男生还粗犷的女生，比女生还腼腆的男生，试想如果男性与女性的性格发生一次对调，那将会是一幅怎样的画面？！  </p>
<p>这一年，我大一。这一年，我习惯了被人忽冷忽热的对待，我习惯了孤单，我习惯了晚睡，我习惯了一个人骑着单车在黑夜中自由地穿梭在校园内。  </p>
<p>这一年，我大一。这一年，初来乍到的我什么都不懂，我问老师，问学长，问同学，答案都是那么苍白无力，那么千篇一律。我明白了，只有自己什么都学会才是真的，以后——问自己。  </p>
<p>这一年，我大一。这一年，我突然发现男孩找女朋友竟是件很容易的事。而他们恋爱的理由让我感到可笑，更多的是无奈。我只想说：如果爱，请深爱！  </p>
<p>这一年，我大一。这一年，我遇到了一些有眼无珠的人，他们陈旧的观念认为年龄与成熟呈正比例关系，以为自己比别人大一两届就很了不起。你知道吗？叫你一声学长，是出于一种礼貌与尊重，并不是羡慕，因为在我眼里，你没有那个被我羡慕的资本！  </p>
<p>如果把大学教育比喻成一把锋利的剃刀，而它正在不断剔除着学生们的勤奋，同时也在剔除着他们的独立思想和铮铮男儿的血性，那么，这就是一所大学最可悲的事！  </p>
<p>这一年，我大一。这一年，我总是想起以前的朋友，想起和他们在一起的点点滴滴。一起看夕阳落下，一起嬉笑着走在回家的路上，一起在外面吹着夜晚的凉风，看着这座城市车来车往，看着五彩的霓虹灯闪烁不断。那时的我们，性格单纯的如同一瓶矿泉水，有着淡淡的甜味。  </p>
<p>这一年，我大胆地做了许多不敢做的事：和校友15个小时的不间断骑行120公里；毅然去青藏高原支教40天的美好经历。有时也会为一些细节所感动：舍友的关心；陌生校友的关怀；学长学姐的宽容与帮助，还有在跳Breaking时所收获的友谊和快乐…  </p>
<p>谢谢你们，相遇便是一场缘分。我相信当若干年后，我把时光的指针跳回到此处，依旧可以看到美好在上演。  </p>
<p>这一年，生活告诉我，不是每个人都愿意陪你经历所有。所以，你不勇敢去面对现实，没有人会替你坚强！  </p>
<p>这一年，生活告诉我，人与人之间的亲近与否，除了血缘之外，不在距离而在心。即使相隔中国最长对角线的距离，只要真心相爱，幸福总会来敲门的。  </p>
<p>这一年，我懂了：世界上最珍贵的东西不是“得不到”和“已失去”，而是眼下我所能正在拥有的幸福。  </p>
<p>这一年，我刚刚结束了大一的生活，大二轻快的脚步声就已临近……  </p>
<p>而亲爱的你，也该苏醒了。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>大学</tag>
        <tag>大一</tag>
        <tag>社团</tag>
        <tag>学生会</tag>
      </tags>
  </entry>
  <entry>
    <title>致中考：有一种渴望叫挣脱束缚</title>
    <url>/2011/06/11/to-zhong-kao-there-is-a-desire-to-break-free/</url>
    <content><![CDATA[<p>中考前的日历正一张张撕去  </p>
<p>离宣判的日子愈来愈近  </p>
<p>或上天堂或入地狱  </p>
<p>我已感到我内心的那种紧迫感  </p>
<p>我正苦苦等待挣脱的那一天  </p>
<pre><code>                         ——题记  
</code></pre>
<p>考试成绩，历来为重点学校或求职的重要依据；也是各父母之间经常互相对比孩子“聪明程度”的主要参考数据。考试成绩，真的有那么重要吗？  </p>
<p>每天，醒来的时候，简单洗漱一下，吃完饭，就要去学校了。在学校里，上的最多的就是课，做的最多的就是题，读的最多的就是书。每次，上课要忍着睡觉的欲望去听课，下课后也要“浴血奋斗”，只有那午休的时间，才能放松一小会儿。一天又一天，我眼前的世界正变得越来越模糊。  </p>
<p>我们，都被“考试成绩”所束缚着。这种束缚，使我们眼前出现了一条比东海还深的“题海”，比泰山还高的“书山”，比监狱还小的“囚牢”。  </p>
<p>假如我有一副鱼鳃，我就可以游出题海，在溪流中嬉戏，与泉水伴舞，和瀑布赛跑。  </p>
<p>可是，我有一副鱼鳃吗？  </p>
<p>没有，所以目前我还在题海中苦战。  </p>
<p>假如我有一对翅膀，我就可以飞出书山，在天空中翱翔，与大雁为伍，与白云做伴。  </p>
<p>可是，我有一对翅膀吗？  </p>
<p>没有，所以至今我仍在书山中挣扎。  </p>
<p>假如我有一把利刃，我就可以砍掉枷锁，在大地上奔跑，与同学玩耍，和朋友“游山玩水”。  </p>
<p>可是，我有一把利刃吗？  </p>
<p>没有，所以我现在仍在囚牢中徘徊。  </p>
<p>中考前的日历正一张张撕去，离宣判的日子正一天天逼近，或玩“游戏”或进“深渊”，我已计划好考试完后所要做的事，所以我正苦苦等待挣脱的这一天。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>中考</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>今天我换了一个新头像</title>
    <url>/2020/07/13/today-i-changed-a-new-avatar/</url>
    <content><![CDATA[<p>今天我换了一个新头像，是妹妹亲自用数位板画的，看着蛮可爱的，最下面附带一行小字——“勇敢的去面对把！Neo Zhang”。  </p>
<p>我想这个头像未来会陪伴我几年，甚至十几年，希望未来有一天这个头像可以当做一个计算机大佬象征性的标志（在此先立一个长远的Flag）。  </p>
<p><img src="/2020/07/13/today-i-changed-a-new-avatar/neozhang.png">  </p>
<p>另外今天收到了煎鱼哥和徐大两位写的书，总共有5个<code>Go</code>语言相关的项目，还有一章关于<code>Go</code>工具的讲解，我已经迫不及待想要翻阅了。  </p>
<p><img src="/2020/07/13/today-i-changed-a-new-avatar/go-book.jpeg">  </p>
<p><img src="/2020/07/13/today-i-changed-a-new-avatar/go-book2.jpeg"></p>
<p>2020下半年，加油！  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>换新</tag>
        <tag>头像</tag>
      </tags>
  </entry>
  <entry>
    <title>T项目合作第一次感到不爽</title>
    <url>/2021/06/16/trs-career-first-feel-not-well/</url>
    <content><![CDATA[<p>今天是和<code>T</code>项目合伙人的第4or5次开线上腾讯会议，为了一个数据库表的问题争论了10几分钟，才发现问题原来出在我这里，我把问题想复杂了，导致<code>Th</code>童鞋进度慢了两周，额，好吧，在此说声抱歉….  </p>
<p>目前产品原型图、人员都固定了，就照着做就行。然而没想到还是会出现这样那样的问题，<code>Lzd</code>都感到无语了。  </p>
<p>但是，我想，也许这就是一个磨合的过程吧，如果不是这次项目合伙，我也不会频繁的和你沟通、从而了解你的野心、你的执行力，甚至不知道川大南门那附近的一家好吃的小笼包店，嘻嘻…  </p>
<p>后面的路，我想我得抓紧赶业务流程了，感谢目前公司带我的<code>leader</code>，耐心指导我的编码风格，让我一点一点的走上正轨，让我慢慢掌握了<code>gorm</code>和<code>gin</code>这两个主流后端框架。  </p>
<p>加油，办法总比困难多，迎难而上解决掉，让自己不断成长！</p>
]]></content>
      <categories>
        <category>Career-notes</category>
      </categories>
      <tags>
        <tag>合伙</tag>
        <tag>事业</tag>
        <tag>挫败</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山一日游</title>
    <url>/2019/09/15/travel-le-shan-one-day/</url>
    <content><![CDATA[<h2 id="启程准备"><a href="#启程准备" class="headerlink" title="启程准备"></a>启程准备</h2><p>启程时间：9月15日早上，从成都到乐山坐高铁只需要50分钟。<br>所需物品：手机，钱包（身份证，零钱，车票），充电宝，充电线，雨伞，水杯，零食  </p>
<h2 id="开始旅行"><a href="#开始旅行" class="headerlink" title="开始旅行"></a>开始旅行</h2><p>到乐山站后，先导航去芳芳家翘脚牛肉店吃午饭，然而到那时正好到了饭点，门口排起了长队，我预估到我至少要两个小时以上，于是放弃，买了个烧饼吃，接着前往下一个小吃街。  </p>
<span id="more"></span>

<p>然而去了下一个小吃街，甜皮鸭店门口排起了长队，我看甜皮鸭以斤算价（一斤最便宜要30元），基本是按一只起卖，女朋友说太腻了，不排了，于是去四方豆腐店（排了三十多人）和小豆海棠（排了八个人），结果也排起了队，放弃。最后去了一家豆腐脑店，店了一碗牛肉粉，一晚牛肉豆腐脑，一碗水果冰粉，很好吃。  </p>
<p>接下来坐车去乐山大佛，比较坑的是，乐山大佛的售票处离乐山大佛入口有一公里远，所以下次去的话，建议到乐山大佛入口处买票，成人价80元&#x2F;人。<br>进了乐山大佛入口后，先是一个大大的佛字映入眼帘，接着就是爬台阶，如果要听讲解的话，可以请个导游，或者扫旁边的二维码花10元买个语音讲解。爬了半个多小时到达山上，看大了乐山大佛的头，不得不说，场景确实让人震撼，不过更让我震撼的是许多人排队去走栈道，不知道是去干嘛，据说是近距离欣赏大佛，无奈我又选择了放弃。逛了一会，然后下山去吃晚饭。  </p>
<p>坐公交抵达另一处小吃街，比较出名的是叶婆婆和黄鸡肉两家钵钵鸡店，但是门口排着队，我换了一家档次也算不错的在吃，期间也品尝了下烧麦，个人觉得就是饺子的缩小版。吃了六分饱后，去了张公桥小吃街，买了酥肉咔饼（感觉就是肉夹馍），叶儿粑，味道不错。  </p>
<p>吃完这些已经是晚上八点，于是我和女朋友坐公交赶去乐山站坐回成都的高铁。结果在公交车上人太多，我转了个身发现一位老大爷从我后面快速把手缩了回去，我猜测可能是人太多把他手卡住了吧，但我觉得不对劲，把书包翻过来正手拿着，结果发现我书包被拉开了半个口，接着刚好到站了那位缩手回去的老大爷也下车了，我检查了下包内的东西，没有少。  </p>
<h2 id="旅行收获"><a href="#旅行收获" class="headerlink" title="旅行收获"></a>旅行收获</h2><ul>
<li>超过半小时需要步行到达的地方，最好选择共享单车或公交。  </li>
<li>去看景点时如果不想请导游可以下个语音讲解。  </li>
<li>防人之心不可无。  </li>
<li>学会拍照很重要。</li>
</ul>
]]></content>
      <categories>
        <category>Travel-notes</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>开心</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第一天_集合与函数的基本性质</title>
    <url>/2019/11/16/turing-read-introduce-to-calculus-day1/</url>
    <content><![CDATA[<h2 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h2><ul>
<li>1，集合的基本概念；  </li>
<li>2，交集、并集、补集、全集、子集、空集；  </li>
<li>3，函数的基本概念；  </li>
<li>4，映射与函数。</li>
</ul>
<h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><p>由确定的研究对象构成的总体叫做<strong>集合</strong>，集合的作用是归集（或归纳）与界定。  </p>
<p>集合的性质：<br>1，元素的确定性；<br>2，元素的互异性；<br>3，元素的无序性；-&gt; 暗示可以排序也可以不排序</p>
<p>共同特征，归集的条件，门槛  </p>
<p>E &#x3D; { x∈Z | x&#x3D;2k+1 k∈Z }</p>
<ul>
<li>x 表示这个集合中的元素一般形式，它表示的形式为整数集</li>
<li>| 起分界作用</li>
<li>{} 起界定作用</li>
</ul>
<h2 id="交集、并集、补集、全集、子集、空集；"><a href="#交集、并集、补集、全集、子集、空集；" class="headerlink" title="交集、并集、补集、全集、子集、空集；"></a>交集、并集、补集、全集、子集、空集；</h2><p>任意元素a∈集合A，都有元素a∈集合B，那么集合A是集合B的子集；  </p>
<p>任意集合A中的元素a 属于 集合B，且 任意集合B中的元素b 属于 集合A，那么集合A等于集合B（元素绝对相等）；  </p>
<p>集合的基数 &#x2F; 集合的势 ：一个集合中包含元素的个数。  </p>
<p>例如，A &#x3D; {1,2,3}，那么集合A的势为 |A| &#x3D; 3。  </p>
<p>空集：不含有任何元素的集合叫做<strong>空集</strong>，表示 A ≠ ∅；∅ &#x3D; {} &#x3D; {x| x≠x}  </p>
<p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/kongji.jpg">  </p>
<h3 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h3><p>证明：空集是任何集合的子集，是任何非空集合的真子集。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设 A是任意一个集合</span><br><span class="line">假设 ∅ 不是 集合A的子集</span><br><span class="line">那么至少有一个元素a∈∅，且a∉集合A</span><br><span class="line">不可能，因为空集中是不含任何元素的，所以假设不成立，因此证明了：</span><br><span class="line"></span><br><span class="line">空集是任何集合的子集，是任何非空集合的真子集。  </span><br></pre></td></tr></table></figure>

<h3 id="一个例子了解交集、并集和补集"><a href="#一个例子了解交集、并集和补集" class="headerlink" title="一个例子了解交集、并集和补集"></a>一个例子了解交集、并集和补集</h3><p>假设集合A表示会唱歌的同学，集合B表示会跳舞的同学，那么  </p>
<p>交集：既会唱歌又会跳舞，A∩B；  </p>
<h3 id="笛卡尔积-直积"><a href="#笛卡尔积-直积" class="headerlink" title="笛卡尔积(直积)"></a>笛卡尔积(直积)</h3><p>A&#x3D;{1,2,3}，B&#x3D;{a,b,c}<br>AxB&#x3D;{(a,b)| a∈A,b∈B}，构成一个有序的元素对-&gt;AxB的元素<br>AxB&#x3D;{(1,a)(1,b)(1,c)(2,a)(2,b)(2,c)(3,a)(3,b)(3,c)}</p>
<p>BxA&#x3D;{(a,1)(a,2)(a,3)(b,1)(b,2)(b,3)(c,1)(c,2)(c,3)}</p>
<p>所以通常情况下 AxB ≠ BxA  </p>
<p>所以笛卡尔积不满足交换律。  </p>
<h4 id="它有什么用？"><a href="#它有什么用？" class="headerlink" title="它有什么用？"></a>它有什么用？</h4><p>假设一个食堂提供主食A&#x3D;{馒头，包子，米饭，面条}<br>假设一个食堂提供饮料B&#x3D;{可乐，豆浆，奶茶，果汁}<br>假设一个食堂提供甜点C&#x3D;{土豆泥，冰淇淋，苹果派，蛋挞}</p>
<p>假设一个学生必须吃一种主食，一种饮料，一种甜点，所以  </p>
<p>AxBxC &#x3D; {(a,b,c)| a∈A,b∈B,c∈C}  </p>
<p>|A|&#x3D;4 * |B|&#x3D;4 * |C|&#x3D;4 -&gt; 64种吃法  </p>
<h2 id="函数与映射"><a href="#函数与映射" class="headerlink" title="函数与映射"></a>函数与映射</h2><p>函数在数学中为两不为空集的集合间的一种对应关系：输入值集合中的每项元素皆能对应​​唯一一项输出值集合中的元素。<br><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func1.jpg">  </p>
<p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func2.jpg">  </p>
<p>注：映射的范围包含于函数。  </p>
<p>假设 y &#x3D; f(x),x∈A<br>在集合A中任意一个元素x都与集合B中的f(x)一一对应  </p>
<p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func3.jpg">  </p>
<p>{(x,y)∈RxR|y&#x3D;f(x),x∈A} ——函数图像的集合表示法。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="集合中的符号"><a href="#集合中的符号" class="headerlink" title="集合中的符号"></a>集合中的符号</h3><p>Q-有理数集，Z-整数集，N-自然数集，R-实数集</p>
<p>通常大写拉丁字母表示集合，小写拉丁字母表示元素</p>
<p>集合相等的定义 -&gt; 元素必须绝对相等；  </p>
<p>任意—表示所有</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节课是图灵导读01期《微积分入门》的第一节课，主要重温了集合，函数、映射这些基础知识。  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/">hexo中插入数学公式</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/baike-%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF">维基百科_笛卡儿积</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E9%9B%86%E5%90%88">维基百科_集合</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%87%BD%E6%95%B0">维基百科_函数</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%98%A0%E5%B0%84">维基百科_映射</a></li>
</ul>
<p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/day1.jpg"></p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>数学</tag>
        <tag>映射</tag>
        <tag>集合</tag>
        <tag>TURING</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第二天_第一章实数_第一节序言</title>
    <url>/2019/11/18/turing-read-introduce-to-calculus-day2/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>集合的基本知识的具体应用；  </li>
<li>映射的初步知识；  </li>
<li>有理数的基本性质；  </li>
<li>无穷等比数列求和的方法；  </li>
<li>有理数的局限性</li>
</ul>
<h2 id="无穷等比数列求和的方法"><a href="#无穷等比数列求和的方法" class="headerlink" title="无穷等比数列求和的方法"></a>无穷等比数列求和的方法</h2><p>公比$q &#x3D; a_n &#x2F; a_n-1$</p>
<p>求和 $S_n &#x3D; a_1 + a_1<em>q^2 + a_1</em>q^3 + … + a_n*q^n-1$  (1)式</p>
<p>两边同时乘以<code>q</code>，q<em>S_n &#x3D; a_1</em>q^2 + a_1<em>q^3 + … + a_n</em>q^n-1 + a_n*q^n$  (2)式</p>
<p>令(2)式 - (1)式： q<em>S_n - Sn &#x3D; a_1</em>q^n - a_1<br>                 S_n*(q-1) &#x3D; a_1*(q^n - 1)<br>                    S_n &#x3D; a_1*(q^n - 1) &#x2F; q - 1  </p>
<p>当 n -&gt; 无穷大 ，q^n -&gt; 0， S_n ≈ a_1*(0-1)&#x2F;q - 1<br>                          S_n ≈ a_1 &#x2F; 1- q</p>
<p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/bi.jpg">  </p>
<h3 id="关于pai"><a href="#关于pai" class="headerlink" title="关于pai"></a>关于pai</h3><p>3 &lt; pai &lt;3 + 1<br>3 + 0.1 &lt; pai &lt; 3 + 0.2<br>3 + 0.1 + 0.04 &lt; pai &lt; 3 + 0.1 + 0.05<br>.<br>.<br>.<br>不足近似数列 &lt; pai &lt; 过剩近似数列  </p>
<p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/pai.jpg">  </p>
<h3 id="区间套理论"><a href="#区间套理论" class="headerlink" title="区间套理论"></a>区间套理论</h3><p>用两个端点都是有理数的区间，去一层套一层，直至到极限的情况下，定义出一个实数。  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>数轴是规定了原点，正方向和单位长度的直线</p>
<p>不是有理数的实数是无理数。  </p>
<p>有限小数的补集 -&gt; 无限小数  </p>
<p>循环小数都是有理数  </p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ul>
<li><p>本节收获了等比数列求和的推导过程（记得上高中那会这个公式可以出一道大题和一道选择或填空题）；  </p>
</li>
<li><p>对有理数和有理直线的定义。  </p>
</li>
<li><p>数的范围，就像下面这张图</p>
</li>
</ul>
<p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/youli.jpg">  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%97%A0%E7%90%86%E6%95%B0">维基百科_無理數</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/baike-%E6%9C%89%E7%90%86%E6%95%B0">维基百科_有理数</a></li>
</ul>
<p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/day2.jpg"></p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>有理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第三天_实数的定义（上）</title>
    <url>/2019/11/19/turing-read-introduce-to-calculus-day3/</url>
    <content><![CDATA[<h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul>
<li>集合知识在分析学中应用的最初步尝试；  </li>
<li>反证法的应用；  </li>
<li>形式逻辑学。</li>
</ul>
<h2 id="证明定理1-1"><a href="#证明定理1-1" class="headerlink" title="证明定理1.1"></a>证明定理1.1</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z1.jpg">  </p>
<p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z2.jpg">  </p>
<h2 id="证明定理1-3"><a href="#证明定理1-3" class="headerlink" title="证明定理1.3"></a>证明定理1.3</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z1.jpg">  </p>
<p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z2.jpg">  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>课后两点告诫：1，认真，反复阅读课文；2，以智商和毅力的极限去积极思考问题。  </p>
</li>
<li><p>定理1.2的证明方法，在 人教版数学必修一A第七面。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节主要讲解了有关实数的几个重要的定理证明，有难度，需要反复阅读，反复领悟。  </p>
<p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/day3.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第四天_实数的定义（下）</title>
    <url>/2019/11/20/turing-read-introduce-to-calculus-day4/</url>
    <content><![CDATA[<h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul>
<li>无理数性质的论证  </li>
<li>实数的连续性</li>
</ul>
<h2 id="实数的连续性"><a href="#实数的连续性" class="headerlink" title="实数的连续性"></a>实数的连续性</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu1.jpg">  </p>
<p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu2.jpg">  </p>
<h2 id="定理1-6"><a href="#定理1-6" class="headerlink" title="定理1.6"></a>定理1.6</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test1.jpg">  </p>
<p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test2.jpg">  </p>
<p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test3.jpg">  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>存在 &#x3D; 至少有一个。  </p>
</li>
<li><p>《微积分入门》第十面要精读，熟读。  </p>
</li>
<li><p>抽屉原理：三个球放两个抽屉，如果每个抽屉都要放的话，至少一个抽屉会放两个球。  </p>
</li>
<li><p>弧度制</p>
</li>
</ul>
<p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/hudu.jpg">  </p>
<h4 id="疑惑，为什么已经有角度制了，还要增加弧度制？"><a href="#疑惑，为什么已经有角度制了，还要增加弧度制？" class="headerlink" title="疑惑，为什么已经有角度制了，还要增加弧度制？"></a>疑惑，为什么已经有角度制了，还要增加弧度制？</h4><p>角度制存在两种进制：1，在度、分、秒间，是60进制；2，在度以上，秒以下为10进制。<br>在描述连续变化角的角度的时候是非常繁琐的，所以建议用<code>弧度制</code>。  </p>
<p>弧度制本质就是长度，可以用实数表示，而实数具有连续性。<br>弧长 除以 半径长，把单位约掉后它就是一个纯数量，而且只有一个10进制。  </p>
<h4 id="数学魅力，什么都没有，即拥有整个世界？！"><a href="#数学魅力，什么都没有，即拥有整个世界？！" class="headerlink" title="数学魅力，什么都没有，即拥有整个世界？！"></a>数学魅力，什么都没有，即拥有整个世界？！</h4><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/world.jpg">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次学习定理1.4，1.5和1.6的证明，需要细细品味；  </p>
<p>了解了弧度制、角度制和抽梯原理。  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wikipedia.hk.wjbk.site/baike-%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86">维基百科_鴿巢原理</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%BC%A7%E5%BA%A6">维基百科_弧度</a></li>
</ul>
<p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/day4.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
        <tag>无理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第五天_实数的加法</title>
    <url>/2019/11/21/turing-read-introduce-to-calculus-day5/</url>
    <content><![CDATA[<h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul>
<li>证明实数的加法</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>向量，既有大小，又有方向，具有平行四边形法则的量。  </p>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/6.jpg">  </p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ul>
<li>1，为什么不把S看成a&#x2F;2，t看成b&#x2F;2？</li>
</ul>
<p>s+t &#x3D; (a+b)&#x2F;2  则当a,b大于0时，(a+b)&#x2F;2 &lt; (a+b)成立  </p>
<p>若a,b &lt;0，则(a+b) &gt; (a+b)，不可取  </p>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/5.jpg">  </p>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/4.jpg"></p>
<h3 id="证明实数的加法"><a href="#证明实数的加法" class="headerlink" title="证明实数的加法"></a>证明实数的加法</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/3.jpg">  </p>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/2.jpg">  </p>
<h3 id="证明定理1-11"><a href="#证明定理1-11" class="headerlink" title="证明定理1.11"></a>证明定理1.11</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/dingli1-11.jpg">  </p>
<p>举例  </p>
<p>绝对值：在数轴上，代表一个数的点，与原点的距离，叫做这个数的<strong>绝对值</strong>，记作|α|。<br>那么|α|&#x3D;|α-0|。  </p>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/test.jpg">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节难度适中，主要需掌握证明实数加法的原理和思想。  </p>
<p>（反复阅读，不停思考）  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%90%91%E9%87%8F">维基百科_向量</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%8A%A0%E6%B3%95">维基百科_加法</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E7%BB%9D%E5%AF%B9%E5%80%BC">维基百科_绝对值</a></li>
</ul>
<p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/day5.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>加法</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第六天_数列极限的基本概念</title>
    <url>/2019/11/22/turing-read-introduce-to-calculus-day6/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/9.jpg">  </p>
<p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/8.jpg">  </p>
<p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/7.jpg">  </p>
<p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/6.jpg">  </p>
<p>4，不收敛数列  </p>
<h3 id="论证定理1-2"><a href="#论证定理1-2" class="headerlink" title="论证定理1.2"></a>论证定理1.2</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/4.jpg">  </p>
<h3 id="充分性的证明"><a href="#充分性的证明" class="headerlink" title="充分性的证明"></a>充分性的证明</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/1.jpg">  </p>
<p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/10.jpg">  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%95%B0%E5%88%97">维基百科_数列</a>  </li>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9E%81%E9%99%90">维基百科_极限</a></li>
</ul>
<p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/day6.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数列</tag>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>极限</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title>两天时间兼职运维从零搭建一套分布式云存储文件系统的收获</title>
    <url>/2021/08/24/two-days-build-distribute-cloud-storage-file-system-gains/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>部门的小<code>leader</code>C想让我熟悉整个业务，知道来龙去脉，让我从零开始搭建一套环境，也方便开发人员直接在上面进行测试，所以从这周一开始，我的工作就来了。  </p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>刚开始感觉这不是So easy嘛，一顿<code>apt install</code> 外加<code>vim</code>编辑配置配件，打完收工….</p>
<p>结果一上来，就说用<code>docker</code>来部署，去写个<code>docker-compose.yaml</code>文件吧，好的呢，花了不到一个小时，整会了，然后直接拉起<code>mysql</code>、<code>redis</code>、<code>nginx</code>三个<code>docker</code>容器，结果<code>nginx</code>一直启动报错，原因是我挂载了一个不存在的目录，好嘛，直接折腾了一个新的<code>docker</code>容器，搞定了。  </p>
<p>然后用<code>docker</code>命令启动一个<code>ipfs</code>容器，各种删除节点，改配置文件后，终于可以只在四个装<code>ipfs</code>的虚拟机里，相互共享文件。  </p>
<p>然后就是进入阿里云官网，做消息队列有关的添加，以及域名和证书的记录，这些都做完后，直接在用<code>Go</code>语言写的客户端修改其对应的配置文件，这样就实现了服务端、客户端和消息队列之间的相互通信。  </p>
<p>明天等待<code>Java</code>端和前端配置和部署完毕，整个系统就可以跑起来测试用了。</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul>
<li>任何一个任务，都要认真对待，不可掉以轻心；  </li>
<li>关于配置项的问题，一定要弄清楚它是做什么的，有没有关联项等；  </li>
<li>脑子不清楚的时候，出去散散步，回来继续；  </li>
<li>及时记录、及时总结、及时反馈。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外，我<code>Get</code>了一个新技能，当遇到只有一台机器的时候（物理存储5T，内存250G，处理器48核），可以适用<code>PVE</code>进行批量的虚拟机管理，节省系统资源。  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://cloud.tencent.com/developer/article/1787196">ProxmoxVE系列：上传系统镜像&amp;&amp;创建虚拟机</a>  </p>
<p><a href="https://www.10bests.com/install-proxmox-ve/">Proxmox VE（PVE）6.1安装保姆级图文教程</a>  </p>
<p><a href="https://www.jianshu.com/p/0c56cfffc2ee">分享一个mysql的docker-compose.yml</a></p>
]]></content>
      <categories>
        <category>Learn-Cloud-Storage</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>IPFS</tag>
        <tag>云存储</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第七天_柯西判别法</title>
    <url>/2019/11/23/turing-read-introduce-to-calculus-day7/</url>
    <content><![CDATA[<h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><p>本节定理的证明十分精彩，几乎把前面所学到的知识的板块，集训似的演练一遍。  </p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>（位置在书本的第十八面，定理1.13）  </p>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/1.jpg">  </p>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/2.jpg">  </p>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/3.jpg">  </p>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/4.jpg">  </p>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/5.jpg">  </p>
<h3 id="证明α是数列极限"><a href="#证明α是数列极限" class="headerlink" title="证明α是数列极限"></a>证明α是数列极限</h3><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/6.jpg">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>从定义上认真理解到位，很重要。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9F%AF%E8%A5%BF%E5%88%A4%E5%88%A5%E6%B3%95">维基百科_柯西判别法</a></li>
</ul>
<p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/day7.jpg">  </p>
]]></content>
      <categories>
        <category>Learn-math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装ClickHouse</title>
    <url>/2022/09/28/ubuntu-install-clickhouse/</url>
    <content><![CDATA[<h1 id="ClickHouse简介"><a href="#ClickHouse简介" class="headerlink" title="ClickHouse简介"></a>ClickHouse简介</h1><ul>
<li>ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS);  </li>
<li>列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍);</li>
</ul>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ sudp apt update</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ sudo apt-get install clickhouse-client clickhouse-server</span><br><span class="line"><span class="comment"># 开启服务</span></span><br><span class="line">$ sudo service clickhouse-server start</span><br><span class="line"><span class="comment"># 客户端连接</span></span><br><span class="line"><span class="comment"># 默认无密码，执行</span></span><br><span class="line">clickhouse-client </span><br><span class="line"><span class="comment"># 有密码的话，执行</span></span><br><span class="line">clickhouse-client --password 123456</span><br></pre></td></tr></table></figure>

<p>验证：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ clickhouse-client </span><br><span class="line">ClickHouse client version 18.16.1.</span><br><span class="line">Connecting to localhost:9000.</span><br><span class="line">Connected to ClickHouse server version 18.16.1 revision 54412.</span><br><span class="line">neo:)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LearnClickHouse</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境安装FFmpeg</title>
    <url>/2019/11/13/ubuntu1804-ffmpeg-install/</url>
    <content><![CDATA[<p>学习视音频技术，要了解<code>FFmpeg</code>，本文将介绍在<code>Linux</code>下安装官方<code>FFmpeg</code>的步骤。  </p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>使用<code>Git</code>下载  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br></pre></td></tr></table></figure>

<h3 id="使用configure命令"><a href="#使用configure命令" class="headerlink" title="使用configure命令"></a>使用configure命令</h3><ul>
<li>先下载<code>yasm</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install yasm    //这儿需要先安装yasm,否则configure会报错</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>configure</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=./ffmpeg_install</span><br></pre></td></tr></table></figure>

<p>注：<code>--prefix=./ffmpeg_install</code>的作用是将新编译的<code>FFmpeg</code>放入这个目录下，没有这一项将默认安装执行<code>configure</code>命令的位置。  </p>
<ul>
<li>使用<code>make</code>命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"></span><br><span class="line">或 make j8  //指定系统用8核来运行</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>make install</code>命令完成安装</li>
</ul>
<p>进入<code>ffmpeg_install</code>的<code>bin</code>目录下，运行<code>FFmpeg</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ./ffmpeg_install/bin</span><br><span class="line">$ ./ffmpeg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_31186123/article/details/81180918">ubuntu 编译安装ffmpeg</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu设置root账号登录</title>
    <url>/2019/06/04/ubuntu-set-up-root-login/</url>
    <content><![CDATA[<h2 id="这样做的原因"><a href="#这样做的原因" class="headerlink" title="这样做的原因"></a>这样做的原因</h2><p>如果你是用<code>root</code>权限去启动一个服务，而这个服务正在跑时，我又在根据它反馈的信息，对代码做调整，比如打日志，而修改完源代码后，你是无法保存文件的，原因是你用<code>root</code>执行它，而就应该用<code>root</code>权限去修改它，否则你的编辑是无效的，<code>push</code>上去的代码还是原来的。  </p>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul>
<li><p>使用<code>chown</code>命令修改文件或文件夹的拥有者，具体如下  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R 用户名 文件夹名或文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>chmod</code>命令直接开放代码所在目录的所有权限   </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 代码目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>root</code>账号登录。<br>不过一般<code>root</code>严格只用来管理服务器，只有少数人有该权限，所以在公司内不一定所有人都会有开启<code>root</code>的权限。<br>(在此感谢知识星球Go项目实战里的<code>Hy、per</code>提供的建议)</p>
</li>
</ul>
<h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>1，设置<code>root</code>用户密码  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<p>（注意：以下步骤必须在<code>root</code>权限下操作）<br>2，修改<code>/root/.profile</code>文件<br>用<code>vim</code>打开该文件内容  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.profile: executed by Bourne-compatible login shells.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BASH</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mesg n || <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>将最后一句<code>mesg n || true</code>修改为<code>tty -s&amp;&amp;mesg n || true</code>  </p>
<p>2，修改<code>/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf </code>文件<br>在文件中添加以下内容  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动输入登录系统的用户名和密码</span></span><br><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line"><span class="comment">#不允许guest登录</span></span><br><span class="line">all-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>3，修改<code>/etc/pam.d/gdm-autologin</code>文件<br>注释掉  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure>

<p>4，修改<code>/etc/pam.d/gdm-password</code>文件<br>注释掉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure>

<p>5，重新启动<code>ubuntu</code>系统，输入<code>root</code>名和密码登录即可。  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>用<code>root</code>账户登录相当于给你重新创建一个新的桌面，所以个人建议是重装系统后就立马设置以<code>root</code>账户登录最佳。</p>
]]></content>
      <categories>
        <category>Learn-linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>root</tag>
        <tag>登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04升级Go版本</title>
    <url>/2019/08/15/ubuntu1804-update-go-version/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为我本机系统上的Go版本是<code>10.4</code>的，不支持<code>Go Module</code>，想升级到最新的<code>go12.7</code>。  </p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1，先下载最新的源码文件"><a href="#1，先下载最新的源码文件" class="headerlink" title="1，先下载最新的源码文件"></a>1，先下载最新的源码文件</h3><p>上<a href="https://golang.org/dl/">https://golang.org/dl/</a>下载自己需要的源码文件，我需要的是<code>go1.12.7.linux-amd64.tar.gz</code>。  </p>
<h3 id="2，解压"><a href="#2，解压" class="headerlink" title="2，解压"></a>2，解压</h3><p>执行命令<code>tar -C /usr/local -zxvf go1.12.7.linux-amd64.tar.gz</code>,会覆盖到原先的<code>go</code>目录。  </p>
<h3 id="3，复制可执行文件"><a href="#3，复制可执行文件" class="headerlink" title="3，复制可执行文件"></a>3，复制可执行文件</h3><p>如果不是第一次安装，需要将<code>/usr/local/go/bin</code>目录下的文件复制到<code>/usr/bin</code>下。  </p>
<h3 id="4，检查环境配置"><a href="#4，检查环境配置" class="headerlink" title="4，检查环境配置"></a>4，检查环境配置</h3><p>打开<code>/etc/profile</code>文件检查环境配置参数  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/code/go</span><br><span class="line">PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure>
<p>命令<code>source /etc/profile</code>使环境生效。  </p>
<h3 id="5，检查版本号"><a href="#5，检查版本号" class="headerlink" title="5，检查版本号"></a>5，检查版本号</h3><p>执行<code>go version</code>命令，输出版本号为<code>go version go1.12.7 linux/amd64</code></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，Ubuntu18.04下完成Go版本升级。<br>后面如果版本有更新，可照此方法再升级一遍。</p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Linux</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境下安装Java</title>
    <url>/2019/11/10/ubuntu1804-install-java/</url>
    <content><![CDATA[<h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>在Ubuntu系统上安装以下两个软件：  </p>
<ul>
<li>Java运行时环境Java Runtime Environment（JRE）  </li>
<li>Java开发工具包Java Development Kit（JDK）</li>
</ul>
<p>命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装jre</span><br><span class="line">sudo apt install default-jre</span><br><span class="line"></span><br><span class="line">安装jdk</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure>

<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>创建一个<code>test.java</code>的文件  </p>
<p>在这个文件里写入以下代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存文件并关闭  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过Java编译器编译第一个程序</span><br><span class="line">javac test.java</span><br><span class="line"></span><br><span class="line">编译java源代码</span><br><span class="line">java test</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/freeking101/article/details/80522586">Ubuntu18.04安装和配置 Java JDK 和 JRE，并卸载自带OpenJDK</a>  </li>
<li><a href="https://www.linuxidc.com/Linux/2018-10/155020.htm">在Ubuntu终端中运行第一个Java程序</a></li>
</ul>
]]></content>
      <categories>
        <category>Learn-java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang进行字符串的替换</title>
    <url>/2019/04/07/use-golang-string-replace/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//转换为字符串后追加到字节数组</span></span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	slice = strconv.AppendBool(slice, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//第二个数为要追加的数，第三个数为指定10进制方式追加</span></span><br><span class="line">	slice = strconv.AppendInt(slice, <span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">	slice = strconv.AppendQuote(slice, <span class="string">&quot;abcgohello&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;slice = &quot;</span>, <span class="type">string</span>(slice))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//其它类型转换为字符串</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">	str = strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;str = &quot;</span>, str)</span><br><span class="line">	<span class="comment">//&#x27;f&#x27;指打印格式，以小数形式，-1指小数点位数，64以float64处理</span></span><br><span class="line">	str = strconv.FormatFloat(<span class="number">3.14</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;str = &quot;</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型转字符型</span></span><br><span class="line">	str = strconv.Itoa(<span class="number">6666</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;str = &quot;</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转其它类型</span></span><br><span class="line">	flag, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err = &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;flag = &quot;</span>, flag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转换为整型</span></span><br><span class="line">	a, _ := strconv.Atoi(<span class="string">&quot;56479&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出  </p>
<p><img src="/2019/04/07/use-golang-string-replace/str.png">  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>替换</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wireshark抓包并分析TCP的三次握手</title>
    <url>/2021/12/19/use-wireshark-to-capture-packets-and-analyze-tcp-three-way-handshake/</url>
    <content><![CDATA[<h1 id="安装wireshark"><a href="#安装wireshark" class="headerlink" title="安装wireshark"></a>安装wireshark</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加wireshark 下载链接地址，然后更新软件源</span><br><span class="line">sudo apt-add-repository ppa:wireshark-dev/stable</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 在命令行安装wireshark</span><br><span class="line">sudo apt-get install wireshark</span><br><span class="line"></span><br><span class="line"># 续配置，新建wireshark 用户组，把当前用户加入wireshark 用户组</span><br><span class="line">sudo groupadd wireshark  </span><br><span class="line">sudo chgrp wireshark /usr/bin/dumpcap  </span><br><span class="line">sudo chmod 4755 /usr/bin/dumpcap</span><br><span class="line">sudo gpasswd -a your_username wireshark</span><br></pre></td></tr></table></figure>

<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。  </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>TCP是面向连接的运输层协议  </li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的  </li>
<li>TCP提供可靠交付的服务  </li>
<li>TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号  </li>
<li>面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP应用程序交下来的数据仅仅是一连串的无结构的字节流</li>
</ul>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="抓包的关键"><a href="#抓包的关键" class="headerlink" title="抓包的关键"></a>抓包的关键</h2><ul>
<li>确认比特ACK： ACK &#x3D; 1时代表这是一个确认的TCP包，取值0则不是确认包。  </li>
<li>同步比特SYN： 在建立连接是用来同步序号。SYN&#x3D;1， ACK&#x3D;0表示一个连接请求报文段。SYN&#x3D;1，ACK&#x3D;1表示同意建立连接。  </li>
<li>推送比特PSH： 当发送端PSH&#x3D;1时，接收端尽快的交付给应用进程。  </li>
<li>终止比特FIN： FIN&#x3D;1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li>
</ul>
<p><img src="/2021/12/19/use-wireshark-to-capture-packets-and-analyze-tcp-three-way-handshake/wireshark1.png">  </p>
<p><img src="/2021/12/19/use-wireshark-to-capture-packets-and-analyze-tcp-three-way-handshake/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">  </p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号Seq&#x3D;x。<br>（其中，SYN&#x3D;1，ACK&#x3D;0，表示这是一个TCP连接请求数据报文；序号Seq&#x3D;X，表明传输数据时的第一个数据字节的序号是x）  </p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包。<br>（标识位SYN&#x3D;1，ACK&#x3D;1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号Seq(服务器)&#x3D;Y，以及服务器对客户端初始序号的确认号Ack(服务器)&#x3D;Seq(客户端)+1&#x3D;X+1）  </p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(Seq&#x3D;X+1)，确认号为Ack(客户端)&#x3D;Y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。  </p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><img src="/2021/12/19/use-wireshark-to-capture-packets-and-analyze-tcp-three-way-handshake/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">  </p>
<h2 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h2><p>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN&#x3D;1，序列号Seq&#x3D;X。  </p>
<h2 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h2><p>服务器收到这个FIN，它发送一个ACK，确认Ack为收到的序号加一(X+1)。  </p>
<h2 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h2><p>关闭服务器到客户端的连接，发送一个FIN给客户端。  </p>
<h2 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h2><p>客户端收到FIN后，并发回一个ACK报文确认，并将确认序号Seq设置为收到Ack序号。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://blog.csdn.net/MrKaj/article/details/110727747">使用wireshark抓包并分析tcp三次握手</a><br><a href="https://www.cnblogs.com/wicub/p/6879095.html">Wireshark抓包分析TCP 3次握手、4次挥手过程</a><br><a href="https://blog.csdn.net/xwmrqqq/article/details/110197815">通过Wireshark抓包分析TCP的三次握手和四次挥手</a>  </p>
]]></content>
      <categories>
        <category>Learn-Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>TCP三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode RESTClient 简单用法</title>
    <url>/2021/11/03/vscode-rest-client-simple-usage/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>总结一套模板  </p>
<p>第一种：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 注释</span><br><span class="line"></span><br><span class="line">HTTP请求动作 http://ip:port/url?x=1&amp;y=1</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>数据类型</span><br></pre></td></tr></table></figure>

<p>例如：  </p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 下载</span><br><span class="line">GET http://0.0.0.0:9902/download</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;key&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;sign&quot;:&quot;2&quot;,</span><br><span class="line">    &quot;id&quot;:1,</span><br><span class="line">    &quot;ype&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">curl --request HTTP请求动作 \</span><br><span class="line">  --url http://ip:port/download?id=1&amp;type=1 \</span><br><span class="line">  --header &#x27;key: &#x27;</span><br><span class="line">  --header &#x27;sign: &#x27;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --request POST \</span><br><span class="line">  --url http://0.0.0.0:9902/download?id=1&amp;type=1 \</span><br><span class="line">  --header &#x27;key: &#x27;</span><br><span class="line">  --header &#x27;sign: &#x27;</span><br></pre></td></tr></table></figure>

<h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>由于平时用<code>VSCode</code>开发，做接口测试的时候还要下载<code>Postman</code>，该插件的出现大大提升了自己的效率。  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a><br><a href="https://github.com/Huachao/vscode-restclient">github-vscode-restclient</a></p>
]]></content>
      <categories>
        <category>Backend-Notes</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>rest</tag>
        <tag>api测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我们这一代人面临的知识焦虑</title>
    <url>/2019/04/28/we-face-knowledge-anxiety/</url>
    <content><![CDATA[<h1 id="为什么要写这样一篇文章"><a href="#为什么要写这样一篇文章" class="headerlink" title="为什么要写这样一篇文章"></a>为什么要写这样一篇文章</h1><p>零点整，和远在三千公里外的女友互道晚安后，继续刷我在极客时间上订阅的关于操作系统的专栏，无意间看到微信群里有人谈到焦虑，我想是时候写一篇文章，来聆听下自己的心声，因为不知道下次又等到什么时候去了。  </p>
<h1 id="我的知识焦虑"><a href="#我的知识焦虑" class="headerlink" title="我的知识焦虑"></a>我的知识焦虑</h1><p>我最开始感到知识焦虑，是在我上大三的时候，当时下载了一个得到app，看到我尊敬的老师在里面建了专栏发文章，于是我咬牙拿出我半个月的伙食费，订阅了为期一年的专栏，于是我坚持早起打开app刷一篇文章，觉得不错还在下面进行留言。  </p>
<p>讲真，我到现在都没有记住里面的内容，只记得当时讲的各种人生经验、理论、方法都很高大上，让我这小白大开眼界。  </p>
<p>后来知识付费不知不觉就流行了起来，从得到app，到知识星球和小专栏，再到极客时间，于是美其名曰充分利用碎片化时间进行学习。  </p>
<h1 id="为什么要知识付费"><a href="#为什么要知识付费" class="headerlink" title="为什么要知识付费"></a>为什么要知识付费</h1><p>说说我为什么会对一些专栏进行付费的原因  </p>
<ul>
<li>得到某一领域技能的提点，从而提升在某领域的核心竞争力(主因)  </li>
<li>与大佬近距离接触，沟通，不是常说“近朱者赤，近墨者黑”嘛  </li>
<li>拓宽人脉，结识优秀的人  </li>
<li>督促自己主动学习(既然花钱了，肯定想要回本啊)</li>
</ul>
<h1 id="那为什么会有知识焦虑呢"><a href="#那为什么会有知识焦虑呢" class="headerlink" title="那为什么会有知识焦虑呢"></a>那为什么会有知识焦虑呢</h1><p>在这里让我想起了木心的一首诗  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记得早先少年时 大家诚诚恳恳 说一句是一句</span><br><span class="line"></span><br><span class="line">清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气</span><br><span class="line"></span><br><span class="line">从前的日色变得慢 车、马、邮件都慢 一生只够爱一个人</span><br><span class="line"></span><br><span class="line">从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了</span><br></pre></td></tr></table></figure>

<p>从前的交通很慢，父母要从陕西到乌鲁木齐，要坐七天七夜的绿皮车；从前的网速邮件很慢，话费很贵，见字如面，惜字如金，只要能半个月写封信或通个电话那头的人就已经心满意足了；从前的人想法很简单，只要学一个技能，能混个饭饱饿不死就行。  </p>
<p>然而那是二十年前的日子，现在是高速信息化时代，一切都在追寻快。  </p>
<p>交通如果慢一点，就着急跺脚；视频通话稍微卡顿，就说网速太差；一个技能还没有吃透，又想着吃另一个，然而精力时间有限。  </p>
<p>我一直在找寻产生知识焦虑的原因，如果让我追本溯源的话，我想，那就是当我们的野心还配不上我们的行动时，现实与理想的落差而造成的。  </p>
<h1 id="IT，一个特殊的行业"><a href="#IT，一个特殊的行业" class="headerlink" title="IT，一个特殊的行业"></a>IT，一个特殊的行业</h1><p>IT，我觉得它与传统行业的差别在于，更新迭代速度非常快，稍微慢一点，你就会感觉到掉队。  </p>
<p>比如新框架替换老框架，就像人体的新城代谢似的。  </p>
<p>所以，在我们入了这个行业的时候，就要抱着终身学习的方向去努力。  </p>
<h1 id="我曾如此焦虑过"><a href="#我曾如此焦虑过" class="headerlink" title="我曾如此焦虑过"></a>我曾如此焦虑过</h1><p>当我早上醒来时，去操场跑步，去食堂吃早饭，在校园的林荫小道上背半小时的新概念，看一会我订阅的专栏的更新，然后去教师上课，这时候视情况而定，如果老师在吹牛逼，就屏蔽掉，同时拿出自己到图书馆借阅的算法书或一些文学小说看；中午午休，下午没课去图书馆或实验室看书刷题写博客；晚饭过后继续做看书学习的循环。  </p>
<p>这样的日子持续了很长时间，因为我不知道未来我会遇到什么样的竞争对手，不知道我遇到的同事是否比我强，如果比我强，拖后腿就难受了。<br>未知是恐惧的，所有的这一切促使我紧张而又焦虑的度过生活的每一天。  </p>
<h1 id="战胜焦虑的过程"><a href="#战胜焦虑的过程" class="headerlink" title="战胜焦虑的过程"></a>战胜焦虑的过程</h1><p>这一切的改变源于一个人的出现。  </p>
<p>直到她的出现我的生活中，让我知道原来学校外还有一些好吃的餐馆，原来秋天学校里通往教学楼的路是如此美丽，原来梨花开的那一刻竟是如此浪漫，原来和喜欢的人安安静静的坐在小水池旁边，一人各抱着半个西瓜啃是如此美好。  </p>
<p>她说：<strong>生命苦短，及时行乐</strong>。  </p>
<h1 id="适当焦虑"><a href="#适当焦虑" class="headerlink" title="适当焦虑"></a>适当焦虑</h1><p>现在的我，有时会因为新出现的需求和<code>bug</code>而忙前忙后，和各个岗位负责人做沟通，但我依旧会挤出晚上宝贵的睡前半小时，静下心来写一写日记，听几首喜欢的音乐。培养着和艺术，音乐，书法方面的爱好。  </p>
<p>焦虑每一个人都会有，我也不例外。也许我们会为了自己道路远方的光而不断奔跑，但请别忘了适当停下来回首自己走过的路，因为那是属于你独一无二，不可替代的曾经。  </p>
<p><img src="/2019/04/28/we-face-knowledge-anxiety/weroad.png">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>焦虑</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>当我提完离职的时候</title>
    <url>/2020/11/09/when-i-mentioned-my-resignation/</url>
    <content><![CDATA[<p>第一次提离职，难免有些紧张，当我梳理好离职的话语，按下回车的那一刻，仿佛世界一下就安静了。  </p>
<p>这些天来我反复对比离职的利与弊，却往往忽略的最重要的一点————那就是我的内心所思所想。我当然想每个月看到自己有好几千的收入，但是为了这收入，我需要忍受，仿佛这些收入就是来慰藉我这个月的委屈。  </p>
<p>接下来就是交接工作，希望早点完成然后搬新家开始我自己的计划。  </p>
<p>朋友问我后面打算怎么办，我就说先把今年考研过了，然后回趟家陪陪父母，明年3月联系好友帮忙内推BAT等大厂，当然前提也要我自己做足准备才行。  </p>
<p>从小学-初中-高中-大学，我慢慢发现我的人生轨迹就是一个<code>sin</code>函数，在某一阶段会跌入低谷，陷入迷茫，无法自拔，然后等过上2-4个月就如同凤凰涅槃一样重获新生。  </p>
<p>加油，我的路还很长，但年轻的资本却只剩不多，我要将我有限的经历投入到有意义的事情中去。  </p>
<p>GOOD LUCK !</p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>离职</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>当你遇到公司裁员时...</title>
    <url>/2019/11/23/when-you-face-cut-down-staff/</url>
    <content><![CDATA[<p>今天看了一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIxNjkwMTk5Mg==&mid=2247483987&idx=1&sn=d43e49dfd71d5c60605e2159d1727f36&chksm=9780b254a0f73b422649f2abeca21e5f1eff5398384f37efba80e350879cca759696f86594ac&dt_dapp=1#rd">网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦！</a>，让我感到无比震惊。  </p>
<p>前些天，女朋友给我说，西瓜创客在裁员，结果第二天就有一堆西瓜创客的员工来她所在的公司面试。  </p>
<p>我没有经历过裁员，但也间接的和<code>HR</code>沟通办理过离职。记得当时刚毕业在一家游戏公司干了两个多月，被通知转正没有过，下午来办理离职手续，交还电脑，工牌等。当时<code>HR</code>还告诉我，叫我申请主动离职，这样不会在下一家公司求职时，简历上有污点。  </p>
<p>其实我现在很好奇，在这样一个充满利益纠纷的社会里，只要不放在档案里，那些所谓的评价真的有用吗？？？  </p>
]]></content>
      <categories>
        <category>Work-Career</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>裁员</tag>
      </tags>
  </entry>
  <entry>
    <title>当你孤单时你会想起谁</title>
    <url>/2019/02/22/when-you-lonely-remand-who/</url>
    <content><![CDATA[<p>这一周，我提前一天完成了我的任务，用<code>Golang</code>给视频转码写了个小工具，复习了二进制基础，文件操作和<code>Golang</code>基本语法。  </p>
<p>下午，一位朋友and他女友来看我，一起吃了顿冒菜，让我这平淡的周末多了份意料之外的喜悦。  </p>
<h2 id="亲爱的，你怎么不在我身边"><a href="#亲爱的，你怎么不在我身边" class="headerlink" title="亲爱的，你怎么不在我身边"></a>亲爱的，你怎么不在我身边</h2><p>距离上次会合已经过去一个月，却让我感觉如昨日。  </p>
<p>想起我们一起看过日出，站在塔里木大桥上看日落，在乌鲁木齐大冬天跑出去看电影吃麻辣小龙虾，去西安吃酿皮和肉夹馍，到成都看熊猫。  </p>
<p>可是，这个周末，亲爱的你为什么不在我身边。  </p>
<h2 id="当你孤单时你会想起谁"><a href="#当你孤单时你会想起谁" class="headerlink" title="当你孤单时你会想起谁"></a>当你孤单时你会想起谁</h2><p>想起远在乌鲁木齐的父母，从此养成了报喜不报忧的“好习惯”；  </p>
<p>想起远在厦门的凡儿，没事调侃两句，解解闷；  </p>
<p>想起远在家里蹲的羊纪元，吹吹牛释放下压力；  </p>
<p>想起远在西安做销售的魁拔，高中时教我弹吉他和护肤，在QQ炫舞上一同唱着《老男孩》；  </p>
<h2 id="我要你在我身旁"><a href="#我要你在我身旁" class="headerlink" title="我要你在我身旁"></a>我要你在我身旁</h2><p>你说你毕设答辩结束就坐飞机来成都，我想起去年我也说，我答完辩把论文材料提交完毕立马坐最近的一趟飞机去成都找你，顺便把offer拿了。  </p>
<p>现在过了一年，角色互换，我相信，我们的异地恋接近尾声。  </p>
<p>我在成都等你。</p>
<p><img src="/2019/02/22/when-you-lonely-remand-who/wait.jpg"></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>孤单</tag>
        <tag>思念</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要学习算法</title>
    <url>/2020/11/30/why-learn-algorithm/</url>
    <content><![CDATA[<p>开始这篇文章之前，我特别查了<code>learn</code>和<code>study</code>的区别，虽然两者都表示学习，但当我查了<a href="https://zhidao.baidu.com/question/176752757.html">learn 和study有什么区别？</a>的结果后，决定用<code>learn</code>，因为我们学习算法肯定是要学有所得，而不是重视学算法的过程！  </p>
<h2 id="引用一些大佬的话（持续更新）"><a href="#引用一些大佬的话（持续更新）" class="headerlink" title="引用一些大佬的话（持续更新）"></a>引用一些大佬的话（持续更新）</h2><h3 id="覃超"><a href="#覃超" class="headerlink" title="覃超"></a>覃超</h3><p><img src="/2020/11/30/why-learn-algorithm/qinchao.png">  </p>
<h3 id="亮老师"><a href="#亮老师" class="headerlink" title="亮老师"></a>亮老师</h3><p>大家好，我是陪伴大家7天学习的算法训练营助教，大家可以叫我亮老师，我学习算法多年，在大学阶段多次代表学校参加ACM竞赛，并取得铜奖，也曾获得过蓝桥杯个人赛国二，平常喜欢研究算法知识。7天的学习过程中有问题可以随时提问。  </p>
<p>在开始学习之前，我想结合我自身学习算法和参加竞赛的经验，以及作为助教期间的心得体会，和你一起聊一聊算法的重要性和如何高效学习算法，希望能对你的学习有所帮助。 算法为什么重要呢？  </p>
<p>我想一千个程序员有一千种理解，首先它是面试的敲门砖，每期训练营都有很多同学通过算法训练营的学习成功的进入了大厂，在座的各位我相信不少人也是基于此考虑报名参加。其次我想用以下几点说明算法的重要性:  </p>
<p>如果不熟悉复杂度分析，如何做容量规划？  </p>
<p>如果不清楚B+树, 又如何能够真正理解innodb的索引，并对查询过程了如指掌？  </p>
<p>如果不能理解hash算法帮助我们如何在O(N)时间复杂度解决两数和的问题，又怎么能有信心去理解redis的hash结构在短链接生成等各种场景下实践？  </p>
<p>等等  </p>
<p>其实比如mysql、redis、es等等这些开源项目中的很多核心细节，都能从leetcode算法题目中找到影子，如果我们有足够的理论知识，可以帮助我们比较快的理解，否则，将寸步难行甚至根本找不到重点。所以，我认为, 算法不仅仅是面试的敲门砖，更是理解优秀中间件，甚至有一天自己造轮子的，不可缺少的工具。  </p>
<p>反过来讲，学习好算法知识，才能帮助更快的真正理解优秀的开源实现，才有机会将这些宝贵的资源为我所用，而不是任其牵引，即使它也许并不是一个好的实现，我们仍然没有一个评价和拒绝的能力。相反可能会在写bug，解决bug的循环中悲壮前行。  </p>
<p>同时，这也提示我们如果觉得自己掌握了某个算法，可以回溯到相关的开源工程实践中，看看大牛们如何优化我们朴素的算法实现, 另外业界大牛又是如何做到物尽其用，有了这个过程我相信你再也不会怀疑算法的作用。所以，从今天起我们一起来学习算法，也是给自己一个向大牛们学习的机会，给自己一个真正掌控各种业务和技术要点的机会。  </p>
<p>说完为什么学算法，接下来我们聊聊怎样学习算法。条条道路通山顶，雄鹰可以直接飞过去，但是蜗牛也可以爬过去。我自认为是蜗牛，结合我见过的几届学员学习方法给大家分享以下几点：  </p>
<ul>
<li><p>第一，摆正态度，正视问题。目前我们接触到的算法虽然基本上都能在二三十行解决，这意味着它不难被跟踪甚至以为理解，当然我们可以在战略上藐视它，但是也因为如此，也更容易轻视它，觉得自己懂了，其实自己想的并不全面甚至是错误的，所以需要我们重视它，通过交流、通过集体的力量、通过反复回忆、通过挖掘相关题型、通过总结等等，最终，想全了、记深了、也理解透了;  </p>
</li>
<li><p>第二，理论和实践要两条腿走路。理论部分就是老师的视频，要反复听，每个知识点要十分熟悉，不明白的地方在群里提出来；实践部分就是老师讲过的经典习题和布置的作业要落地到实践，亲自做一做，同时千万不要忘了过遍数，另外平时经常回过头看看自己的代码，也很有效；  </p>
</li>
<li><p>第三，高质量的完成。开课之后，你会发现习题的数量很多，但是希望大家采用五毒神掌方法练习题目，题不在多，有精则灵，另外千万别死磕，给自己一个时间限制，好多学员“一副我最牛逼，这题目一定能拿下”从而花费大量时间，但如果你认真听老师的课程就知道这样是没有必要的；  </p>
</li>
<li><p>第四，多讨论多交流多提问。这个是融会贯通的机会，可以是组员，也可以是老师或者助教，有任何问题都不放过，一定要抓好班级群，小组群这个平台，跟大家一起交流相互学习提升，每期班主任都会组织学员做社群分享，也欢迎大家到时在群里分享你的学习经验、面试经验、工作心得等等；  </p>
</li>
<li><p>第五，蓦然回首那题却在 灯火阑珊处。曾经的你众里寻它千百度，所以来到这里。我坚信通过以上付出，通过7天的努力，养成刷题习惯不畏惧刷题，等到毕业以后，再来复盘这段时间的收获，一定不同往日。</p>
</li>
</ul>
<h2 id="我的各阶段学习算法的目的"><a href="#我的各阶段学习算法的目的" class="headerlink" title="我的各阶段学习算法的目的"></a>我的各阶段学习算法的目的</h2><ul>
<li>高中：没啥感觉，就是觉得有趣；  </li>
<li>大学：赚钱，因为学院非常鼓励那些参加竞赛的学生，省一会给4000元的奖金，所以我当时参加一次算法竞赛，把我一学年的学费+住宿费+伙食费全部付清了；  </li>
<li>职场（大学毕业五年内）：接触更牛逼的大佬&amp;更高的薪资。</li>
</ul>
]]></content>
      <categories>
        <category>Learn-algo</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冬至问候-当你孤单时你会想起谁</title>
    <url>/2016/12/21/winter-solstice-greetings-who-do-you-think-of-when-you-are-alone/</url>
    <content><![CDATA[<p>当你孤单你会想起谁，你想不想找个人来陪，你的快乐伤悲只有我能体会，让我再陪你走一回…  </p>
<p>记得那是一个早晨，窗外的天还是黑夜，我绕着半个学校跑了一圈。广播一直单曲循环着那首《当你孤单你会想起谁》。是啊，当我孤单时我会想起谁呢？  </p>
<p>高一前的那个暑假，毫无心理准备的我突然被拉到军营里接受五天的封闭式军事化管理。第一天晚上，泪水打湿了我的半条枕巾。我记得那天我只睡了3个多小时，却承受了一天的训练强度，我不知道这是哪里，所有的面孔都是那么陌生，我想那时候，我想起的是我的家人。  </p>
<p>高二时，因为学业与感情的压力，我时常与家人发生矛盾。那时我遇到了一个朋友，他如一个树洞，吞噬着我所有的烦恼与不愉快，让我重新振作起来。那时候，孤单无助的我想起的应该会是他。  </p>
<p>大学填报志愿时，我考虑过去东北的哈尔滨，想过去福建的厦门，总之离家越远越好。但最后阴差阳错地来到了千里之外的阿拉尔。从此我和家人的联系只有手机，我们会长达四个月看不到彼此的面容，我想那时候我应该自由了。我的耳边不再有人叮嘱我按时吃早中晚饭；晚上不再担心熬夜会不会遭到父亲的训斥；不会再担心和女孩子走在一起会不会遭遇父母的盘问。  </p>
<p>刚上大一时，我对周围的一切充满着好奇。我喜欢去那人山人海的晚会现场，喜欢和周围的人到处瞎跑，并以此乐此不疲。待到蓦然回首才发现，喜欢的书没有来得及看，想做的事情被耽搁了，恍恍惚惚间一个学期过完了。原来，那时候当我孤单时，我想到的是热闹的大街。  </p>
<p>记得那是一个灯光净白的冬夜，没有一丝风掠过这尘满的案几。我的心就在这时开始漫无目的地旅行，流浪在一个人的国度里，仿佛东风吹亮的千盏路灯仅为我一人独放。  </p>
<p>我喜欢上了一个人骑车在校园里兜兜转转，喜欢一个人在实验室里运行着自己写的程序，喜欢一个人在阅览室拿本书静静的欣赏，喜欢一个人在空档的实验室里唱歌吹口琴，喜欢一个人在空旷的篮球场上砸篮板，用尽全身的力气，那么决然地把篮球砸向篮板，听那篮球与篮板之间清脆的撞击声。  </p>
<p>我不再孤单，因为我找到了自己要做的事情，还有我想成为的人。  </p>
<p>中秋节那天，父母从远方打了个长途过来。还是那千篇一律的问候与关怀，我却没有丝毫地厌烦与无聊，因为我知道这是他们对我最直接的爱。不知从何时起，我开始有选择地给他们叙述我在学校的情况，不再把烦心的事告知他们，我想尽可能多地让他们感受到我在学校一切安好。  </p>
<p>有一种爱，叫做放手。从去年暑假父母极力阻止我去高原支教，到今年暑假同意我一个人去全国旅行，我感觉到从前一直抓着我不放的那双手正在逐渐松开。我理解你们很想把这一生所经历的事情与经验都告诉我的心情，但我知道有些事理只有自己经历了才会懂得。<br>谢谢亲爱的家人，包容过我的无知与任性，也见证了我的顽皮与成长。  </p>
<p>转眼到了今天的冬至，我仿佛回到了温暖的小家里，看着老妈专门为我包的芹菜肉馅饺子和老爸做的香香的蒜泥醋水酱，我在旁边拿着筷子，听着“开饭了”，于是盯着刚出锅的饺子顺手一夹，蘸上酱，放进早已饥饿不已的肚中，让幸福充盈在内心里。看着小妹因为饺子太烫而嘟起了嘴，我们的笑声响遍了家里的每个角落。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>孤单</tag>
        <tag>冬至</tag>
        <tag>家人</tag>
      </tags>
  </entry>
  <entry>
    <title>南方的冬天</title>
    <url>/2018/12/28/winter-in-the-south/</url>
    <content><![CDATA[<p><strong>我在南方的艳阳里大雪纷飞，你在北方的寒夜里四季如春。</strong>  </p>
<p>听天气预报说今天成都要下雪了，许多人巴在窗户跟前去看期待已久的雪花飘落。然而，对于我这个已经习惯生活在北方冬天里，靠着堆雪人和打雪仗带给我无限童年乐趣的人来说，这点雪花的效果约等于零。  </p>
<p>这是我在地球上度过的第二十二个冬天，与以前不一样的是，这次是我一个人独自来南方过冬。  </p>
<p>南方的冬天，与秋天类似，只是会更加湿冷，空气中夹杂着阵阵寒风。朋友说，你在北方，冬天是物理冷，而在南方是魔法冷。当时一直不明白这句话的含义，直到十一国庆过后，我发觉无论走到哪，空气都是冰凉冰凉的，而且屋子内居然没有暖气！白天需要裹着棉大衣在屋内抖腿取暖，晚上插上水暖电热毯才能睡着。就像身上裹了一层隐形的软绵绵的冰衣，只有靠不断补充热量才能抵御它的寒冷。  </p>
<p>十一月，我看着新疆的朋友把冬天的雪景分享在了朋友圈上，让我情不自禁地回忆起小时候和朋友在雪地里搭房子，堆雪人，扛着巨大的雪球往对方头上砸去，让他瞬间变雪人的喜悦，亦或是一个人站在操场中央，万籁俱寂，我静静的听着自己的心跳，聆听内心深处的声音。  </p>
<p>今年六月初，当我拿着去往成都的机票前往登机口时，我再次看了一眼那座让我生活了十八年的城市。它承载了我太多的记忆，看着我从一个顽皮的孩童成长为一名即将步入社会的成年人。  </p>
<p><strong>当你想要得到一样东西时，就要考虑牺牲一样东西，即使现在站在原地犹豫不决，但你最终也要作出选择。</strong>  s</p>
<p>记得刚到成都时，没有工作经验，学校学到的和企业用到的存在着断层，每天上班只能靠自己琢磨，咨询同事和请教大佬才能有所收获。前期踩了很多技术和工作效率上的坑，也使我更加迫切地想要提升自己的实力。九月中旬，幸运地拿到一家互联网公司图形图像音视频算法岗的offer，我将进入一个全新的领域学习。  </p>
<p>入职三个月，从熟悉大型项目编译流程到编译后台渲染引擎和视频编码，再到从零开始搭建一个定时删除的服务框架，受到的打击和请求支援的次数已经数不清了，而受到的关怀和帮助更是数不胜数。  </p>
<p>成都的冬天确实很冷，我也曾在这座城市哭泣过，但每一次哭过都会让我的眼泪化作冰柱，磨炼起我坚韧和勇敢的心。  </p>
<p>这个冬天没有雪，<strong>因为雪景已存在我的内心里，它载着我美好的记忆，支持着我在南方的艳阳里温暖前行。</strong>  </p>
<p>附朋友拍的乌鲁木齐雪景：  </p>
<p><img src="/2018/12/28/winter-in-the-south/1.jpg">  </p>
<p><img src="/2018/12/28/winter-in-the-south/2.jpg">  </p>
<p><img src="/2018/12/28/winter-in-the-south/3.jpg">  </p>
<p><img src="/2018/12/28/winter-in-the-south/4.jpg">  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>南方</tag>
        <tag>冬天</tag>
      </tags>
  </entry>
  <entry>
    <title>跨过这道被职场PUA的坎</title>
    <url>/2021/11/07/work-through-this-pain-from-the-pua/</url>
    <content><![CDATA[<p>本科毕业两年半，第一次在职场上彻彻底底的被否定，我曾想过是我的问题，但现在看来，并不在我这里。  </p>
<p>一个月以来，在家住了半个月，也感谢这半个月，让我重新振作起来，并一鼓作气在五天内拿下几个<code>offer</code>，获得了一些技术面试官的认可，不过我还是想把这段不堪痛苦的回忆记录下来。  </p>
<p>时间、地点、人物我都不会提及，只说经过…  </p>
<p>从某个时刻开始，我被时常叫去谈话，刚开始只是简单提醒，后面开始了各种被讽刺、被怀疑、被否定，以及被同事捅刀子，只是这次被桶的太深了…  </p>
<p>国庆放假前，早上，接到安恒的一位架构师打来的电话，聊到目前的现状，眼泪竟然不争气掉了下来，以及那鼻血，是的，我终于抑制不住自己的情绪，哭了出来。  </p>
<p><img src="/2021/11/07/work-through-this-pain-from-the-pua/boss-anhen.jpg">  </p>
<p>国庆节后，虽然安恒的面试通过了，但<code>hc</code>已经满了，所以没去成，最终去了另一家做网络安全的独角兽企业，也算是对自己这段惨痛的经历有了正向的回报。  </p>
<p>后面的路该如何走，我想，先把领导交代的任务，保质保量的完成，在大厂站稳脚跟，然后通过做一些项目，加深对<code>Go</code>底层原理的理解，同时开始慢慢接触架构的知识，争取成长到<code>P7</code>，2022上半年通过证劵、<code>CATTI</code>三笔、软考高级项目管理师的考试。  </p>
<p>国庆节放假期间，读了一些书，品尝了美味的烤全羊以及冰甜的西瓜，结识了几位大厂的技术面试官，我顿悟了，既然过去已成定局，就不要再过多纠结和放在心上，摧毁不了我的东西终将会战胜它，区区流言蜚语，日后在现实面前，自会不攻而破！  </p>
<p><img src="/2021/11/07/work-through-this-pain-from-the-pua/an.jpg">  </p>
]]></content>
      <categories>
        <category>Work-Career</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>痛苦</tag>
        <tag>pua</tag>
      </tags>
  </entry>
  <entry>
    <title>《工作细胞Black》第3集——或许是我见过的最好的性教育动画片</title>
    <url>/2021/01/25/work-cell-black-3-erection/</url>
    <content><![CDATA[<h2 id="第3集剧情简介"><a href="#第3集剧情简介" class="headerlink" title="第3集剧情简介"></a>第3集剧情简介</h2><p>周末跟完了《工作细胞 BLACK》的最新剧集，第三集的剧情给我留下了非常深刻的印象，因为它触碰到了我上小学和中学的知识禁区——性行为。  </p>
<p>第3集的大致剧情是一群红细胞收到了比运输氧气更重要的任务，就是这具身体因生殖行为而进行兴奋状态，需要红细胞使阴茎中的海绵组织（海绵体）勃起，完成射精！  </p>
<p><img src="/2021/01/25/work-cell-black-3-erection/wcell.png">  </p>
<p>但结果非常不顺：刚开始红细胞排成一队进入海绵体，把螺旋动脉张开，血液进去，进入勃起状态，看似一切顺利  </p>
<p><img src="/2021/01/25/work-cell-black-3-erection/tianchong.png">  </p>
<p>紧接着<strong>海绵体的环磷酸鸟苷值正在急剧下降，平滑肌的松弛状态已经解除了，原因是环磷酸鸟苷产量不足，似乎是性兴奋无法顺利通过神经传达到阴茎</strong>——感觉好多陌生名词哦，其实简单来说就是“还没有射精，勃起就停止了，这就是ED（勃起功能障碍）”，这样下去人体没办法勃起-&gt;没办法射精-&gt;精细胞和卵细胞就无法相遇形成受精卵-&gt;生命就无法延续下去。感觉情况很糟糕，就在系统都宣布这次勃起任务失败了，局势逆转了：  </p>
<p><strong>海绵体的环磷酸鸟苷值正在急剧上升，原因是外部投入了伟哥，使PDE5（能够分解环磷酸鸟苷的酶）遭到抑制。</strong>  </p>
<p><img src="/2021/01/25/work-cell-black-3-erection/weige.png">  </p>
<p>最终，血液填充率达到100%-&gt;静脉出口关闭-&gt;阴茎完全勃起了-&gt;收到射精中枢传来的信号，精子们做好射精准备-&gt;射精准备完毕-&gt;收缩尿道括约肌（尿液和精液就不会同时射出，精液进入前列腺后，尿道的出入口就会关闭，然后只打开出口，精液就会因猛烈的压力而射出）-&gt;收缩完毕-&gt;发射-&gt;射精完毕。  </p>
<p><img src="/2021/01/25/work-cell-black-3-erection/jz1.png"><br><img src="/2021/01/25/work-cell-black-3-erection/jz2.png">  </p>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>我依稀记得，我第一次接触性知识是初二的生物课上，课本上画了一幅男性性生殖器官构造图，女性的也有，但当时很害羞就直接盖上了，上课的时候老是讲到这也只是简单说男性的生殖器官是阴茎和睾丸，女性的是子宫，它们分别产生精细胞和暖细胞，好了记到这吧，考试不会超出这范围。  </p>
<p>我当时对生物非常感兴趣，总是好奇生命是如何产生的。  </p>
<p>直到有节健康课，老师放了一段受精卵形成的过程，好多精子奔向卵子，我才对理解了一些，高中对这块的知识会在受精后的变化加大考查和分值，而对于为什么有些人性行为的时候要用伟哥，射精前身体要做哪些准备，我都不知道，当然考试也不会考。  </p>
<p>非常感谢这部动漫，让我更形象的看到生命延续的全部过程，也让我更加爱惜自己的身体，拒绝修996福报！！！  </p>
<p>最后我想说，性不应该是洪水猛兽，如果对性这块懵懂的朋友，我非常推荐看这部剧，就从第3集来说，是我目前看到的非常棒的性教育动画片！  </p>
]]></content>
      <categories>
        <category>Review-film</category>
      </categories>
      <tags>
        <tag>工作细胞</tag>
        <tag>勃起</tag>
        <tag>性教育</tag>
      </tags>
  </entry>
  <entry>
    <title>职场求生攻略</title>
    <url>/2021/09/20/workplace-survival-strategy/</url>
    <content><![CDATA[<p>本文笔记源自专栏《职场求生攻略》  </p>
<h1 id="职业素养篇"><a href="#职业素养篇" class="headerlink" title="职业素养篇"></a>职业素养篇</h1><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="优先级为什么重要"><a href="#优先级为什么重要" class="headerlink" title="优先级为什么重要"></a>优先级为什么重要</h3><ul>
<li>手忙脚乱，工作不得法，往往是因为优先级没安排好；  </li>
<li>时间和精力有限；  </li>
<li>事情等不起；  </li>
<li>对事情的质量要求不同。</li>
</ul>
<h3 id="基于工作性质安排优先级"><a href="#基于工作性质安排优先级" class="headerlink" title="基于工作性质安排优先级"></a>基于工作性质安排优先级</h3><ul>
<li>公司发展计划相关  </li>
<li>安全相关  </li>
<li>生产相关</li>
</ul>
<h3 id="基于合作安排优先级"><a href="#基于合作安排优先级" class="headerlink" title="基于合作安排优先级"></a>基于合作安排优先级</h3><ul>
<li>日常工作的优先级要由经理确定  </li>
<li>经理安排的临时的急事  </li>
<li>需要别人配合的事  </li>
<li>阻塞别人的工作的事</li>
</ul>
<h3 id="做事情本身的优先级"><a href="#做事情本身的优先级" class="headerlink" title="做事情本身的优先级"></a>做事情本身的优先级</h3><ul>
<li>先沟通，后做事  </li>
<li>先外后内  </li>
<li>随时沟通</li>
</ul>
<h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><h3 id="邮件的特性"><a href="#邮件的特性" class="headerlink" title="邮件的特性"></a>邮件的特性</h3><ul>
<li>异步交流  </li>
<li>无法修改  </li>
<li>方便扩散</li>
</ul>
<h3 id="邮件是公司内部的合同"><a href="#邮件是公司内部的合同" class="headerlink" title="邮件是公司内部的合同"></a>邮件是公司内部的合同</h3><ul>
<li>邮件的确认功能  </li>
<li>邮件的证据链功能  </li>
<li>邮件的沟通协调功能  </li>
<li>邮件的防遗忘功能  </li>
<li>邮件的广而告之功能</li>
</ul>
<h3 id="邮件的魅力"><a href="#邮件的魅力" class="headerlink" title="邮件的魅力"></a>邮件的魅力</h3><ul>
<li>化语言，为责任  </li>
<li>化责任，为动力</li>
</ul>
<h3 id="邮件的小技巧"><a href="#邮件的小技巧" class="headerlink" title="邮件的小技巧"></a>邮件的小技巧</h3><ul>
<li>记得定期查看邮件  </li>
<li>发送邮件的小技巧：看清收件人，再决定说什么；学会抄送老板；用好邮件组；多检查一下标题和收件人  </li>
<li>写会议纪要</li>
</ul>
<h2 id="爱上交流"><a href="#爱上交流" class="headerlink" title="爱上交流"></a>爱上交流</h2><h3 id="为什么程序员普遍不喜欢交流"><a href="#为什么程序员普遍不喜欢交流" class="headerlink" title="为什么程序员普遍不喜欢交流"></a>为什么程序员普遍不喜欢交流</h3><ul>
<li>工作被打断严重影响效率  </li>
<li>交流不能直接帮程序员完成工作</li>
</ul>
<h3 id="爱上的第一步：正视和人交流"><a href="#爱上的第一步：正视和人交流" class="headerlink" title="爱上的第一步：正视和人交流"></a>爱上的第一步：正视和人交流</h3><ul>
<li>程序员需要信息的输入  </li>
<li>程序员需要输出自己的观点和成绩  </li>
<li>看到交流的好处，养成主动交流的好习惯</li>
</ul>
<h3 id="程序员交流的技巧"><a href="#程序员交流的技巧" class="headerlink" title="程序员交流的技巧"></a>程序员交流的技巧</h3><ul>
<li>换位思考，注意受众  </li>
<li>交流要带有足够的信息  </li>
<li>先说重点和结论</li>
</ul>
<h2 id="发挥主观能动性"><a href="#发挥主观能动性" class="headerlink" title="发挥主观能动性"></a>发挥主观能动性</h2><h3 id="为什么要发挥主观能动性"><a href="#为什么要发挥主观能动性" class="headerlink" title="为什么要发挥主观能动性"></a>为什么要发挥主观能动性</h3><ul>
<li>软件研发的复杂性，导致没有标准可以参考，也导致很多事情无法在设计之初预见  </li>
<li>现代软件研发快速迭代，导致需求和需要应对的问题也在变化，程序员不能固守之前的设计  </li>
<li>做完不等于做好，能用不等于好用</li>
</ul>
<h3 id="如何发挥主观能动性"><a href="#如何发挥主观能动性" class="headerlink" title="如何发挥主观能动性"></a>如何发挥主观能动性</h3><ul>
<li>交付思维：站在用户的角度，交付真正解决用户问题的软件系统  </li>
<li>注意时间：完成好过完没</li>
</ul>
<h2 id="对程序员的职责"><a href="#对程序员的职责" class="headerlink" title="对程序员的职责"></a>对程序员的职责</h2><h3 id="对自己的基本能力负责"><a href="#对自己的基本能力负责" class="headerlink" title="对自己的基本能力负责"></a>对自己的基本能力负责</h3><ul>
<li>持续精进技术能力  </li>
<li>熟悉公司的内部系统</li>
</ul>
<h3 id="对安排的工作负责"><a href="#对安排的工作负责" class="headerlink" title="对安排的工作负责"></a>对安排的工作负责</h3><ul>
<li>尽自己的努力完成工作  </li>
<li>发现自己无法完成工作时，尽早告诉经理</li>
</ul>
<h3 id="对工作时间负责"><a href="#对工作时间负责" class="headerlink" title="对工作时间负责"></a>对工作时间负责</h3><ul>
<li>解决问题时要在线  </li>
<li>准时参加会议</li>
</ul>
<h1 id="职业选择篇"><a href="#职业选择篇" class="headerlink" title="职业选择篇"></a>职业选择篇</h1><h2 id="选择公司考虑的角度"><a href="#选择公司考虑的角度" class="headerlink" title="选择公司考虑的角度"></a>选择公司考虑的角度</h2><h3 id="企业文化和价值观"><a href="#企业文化和价值观" class="headerlink" title="企业文化和价值观"></a>企业文化和价值观</h3><ul>
<li>文化和价值观不是虚头巴脑的东西  </li>
<li>如何选择适合自己的企业文化和价值观</li>
</ul>
<h3 id="行业势头"><a href="#行业势头" class="headerlink" title="行业势头"></a>行业势头</h3><ul>
<li>下降期的行业  </li>
<li>黄金发展期的行业  </li>
<li>风口期的行业</li>
</ul>
<h3 id="工资待遇"><a href="#工资待遇" class="headerlink" title="工资待遇"></a>工资待遇</h3><ul>
<li>基本工资最受法律保护  </li>
<li>奖金  </li>
<li>股票  </li>
<li>福利</li>
</ul>
<h3 id="公司规模"><a href="#公司规模" class="headerlink" title="公司规模"></a>公司规模</h3><ul>
<li>行业头部大公司</li>
</ul>
<h3 id="人才水平"><a href="#人才水平" class="headerlink" title="人才水平"></a>人才水平</h3><ul>
<li>决定了公司对人才的态度  </li>
<li>决定了公司内部合作与管理的风格</li>
</ul>
<h2 id="“跟对人”的表现"><a href="#“跟对人”的表现" class="headerlink" title="“跟对人”的表现"></a>“跟对人”的表现</h2><h3 id="认同彼此的价值观和人格"><a href="#认同彼此的价值观和人格" class="headerlink" title="认同彼此的价值观和人格"></a>认同彼此的价值观和人格</h3><ul>
<li>价值观和性格会被经理影响  </li>
<li>有担当  </li>
<li>优秀、真诚、公平</li>
</ul>
<h3 id="定期和你交流"><a href="#定期和你交流" class="headerlink" title="定期和你交流"></a>定期和你交流</h3><ul>
<li>和你有一对一的会议  </li>
<li>表扬做的优秀的地方  </li>
<li>指出做的不好的地方，并通过沟通，给出改进的方案  </li>
<li>给出让你发展到下一阶段的建议  </li>
<li>没有一对一会议该怎么办？</li>
</ul>
<h3 id="可以互相讨论甚至争论"><a href="#可以互相讨论甚至争论" class="headerlink" title="可以互相讨论甚至争论"></a>可以互相讨论甚至争论</h3><ul>
<li>发挥主观能动性的前提  </li>
<li>能够得到更好、更完整的结论</li>
</ul>
<h3 id="资源和利益的分配"><a href="#资源和利益的分配" class="headerlink" title="资源和利益的分配"></a>资源和利益的分配</h3><ul>
<li>给手下人新的机会  </li>
<li>给手下人发展的时间  </li>
<li>争取利益，并能公平分配</li>
</ul>
<h2 id="跟对人为什么更重要"><a href="#跟对人为什么更重要" class="headerlink" title="跟对人为什么更重要"></a>跟对人为什么更重要</h2><h3 id="奇葩的经历是存在的"><a href="#奇葩的经历是存在的" class="headerlink" title="奇葩的经历是存在的"></a>奇葩的经历是存在的</h3><ul>
<li>贬低控制型  </li>
<li>技术压制型  </li>
<li>极致压榨型  </li>
<li>性格缺陷型</li>
</ul>
<h3 id="别对公司抱有太多的幻想"><a href="#别对公司抱有太多的幻想" class="headerlink" title="别对公司抱有太多的幻想"></a>别对公司抱有太多的幻想</h3><ul>
<li>程序员被替代的代价并没有那么高  </li>
<li>如何做事是经理权限之内的事情  </li>
<li>公司不能传达按劳分配的信息  </li>
<li>惩罚经理对公司的损失大  </li>
<li>邮件的“广而告之”功能</li>
</ul>
<h3 id="跟对人，才能做对事"><a href="#跟对人，才能做对事" class="headerlink" title="跟对人，才能做对事"></a>跟对人，才能做对事</h3><ul>
<li>跟错人，观念不合，做事阻力大  </li>
<li>跟错人，事情做成了，利益也不会分配到这里  </li>
<li>程序员是无法无视自己的经历的</li>
</ul>
<h2 id="跳槽前的checklist"><a href="#跳槽前的checklist" class="headerlink" title="跳槽前的checklist"></a>跳槽前的checklist</h2><h3 id="为什么想跳槽"><a href="#为什么想跳槽" class="headerlink" title="为什么想跳槽"></a>为什么想跳槽</h3><h4 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h4><ul>
<li>是自己的问题，还是外部的问题  </li>
<li>换公司无法解决自身的问题</li>
</ul>
<h4 id="主动求变"><a href="#主动求变" class="headerlink" title="主动求变"></a>主动求变</h4><ul>
<li>新行业，新方向  </li>
<li>自己的兴趣</li>
</ul>
<h4 id="薪资待遇"><a href="#薪资待遇" class="headerlink" title="薪资待遇"></a>薪资待遇</h4><ul>
<li>不要让薪资待遇成为你跳槽的唯一原因  </li>
<li>稳定+合理</li>
</ul>
<h3 id="为什么不应该跳槽"><a href="#为什么不应该跳槽" class="headerlink" title="为什么不应该跳槽"></a>为什么不应该跳槽</h3><ul>
<li>公司不愿意聘用和培养频繁跳槽的人  </li>
<li>长期来看，在一个公司的积累和成长最值钱  </li>
<li>内部转岗</li>
</ul>
<h2 id="准备简历和面试"><a href="#准备简历和面试" class="headerlink" title="准备简历和面试"></a>准备简历和面试</h2><h3 id="面试的逻辑：与面试官合作，展示自己的优势和优秀之处"><a href="#面试的逻辑：与面试官合作，展示自己的优势和优秀之处" class="headerlink" title="面试的逻辑：与面试官合作，展示自己的优势和优秀之处"></a>面试的逻辑：与面试官合作，展示自己的优势和优秀之处</h3><h3 id="写简历"><a href="#写简历" class="headerlink" title="写简历"></a>写简历</h3><h4 id="精简工作经历"><a href="#精简工作经历" class="headerlink" title="精简工作经历"></a>精简工作经历</h4><ul>
<li>解决的问题  </li>
<li>自己的成长  </li>
<li>两页以内</li>
</ul>
<h4 id="经历倒叙"><a href="#经历倒叙" class="headerlink" title="经历倒叙"></a>经历倒叙</h4><h4 id="突出重点，强调自己的优势"><a href="#突出重点，强调自己的优势" class="headerlink" title="突出重点，强调自己的优势"></a>突出重点，强调自己的优势</h4><h4 id="排版工整"><a href="#排版工整" class="headerlink" title="排版工整"></a>排版工整</h4><h3 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h3><h4 id="针对公司面试风格，提前做准备"><a href="#针对公司面试风格，提前做准备" class="headerlink" title="针对公司面试风格，提前做准备"></a>针对公司面试风格，提前做准备</h4><h4 id="应届生"><a href="#应届生" class="headerlink" title="应届生"></a>应届生</h4><ul>
<li>CS基础  </li>
<li>刷算法与数据结构题目</li>
</ul>
<h4 id="工作1-2年"><a href="#工作1-2年" class="headerlink" title="工作1-2年"></a>工作1-2年</h4><ul>
<li>为什么换工作  </li>
<li>刷算法与数据结构题目</li>
</ul>
<h4 id="工作经历丰富"><a href="#工作经历丰富" class="headerlink" title="工作经历丰富"></a>工作经历丰富</h4><ul>
<li>弄清自己的优势  </li>
<li>突出工作成果  </li>
<li>梳理自己的技术，准备面试  </li>
<li>建议内推</li>
</ul>
<h3 id="面试中需要注意什么"><a href="#面试中需要注意什么" class="headerlink" title="面试中需要注意什么"></a>面试中需要注意什么</h3><ul>
<li>不要勉强  </li>
<li>注意反馈，交流通畅，表达清晰  </li>
<li>不推荐靠面经面试  </li>
<li>准时到，不要和面试官较劲</li>
</ul>
<h3 id="关于面试的世纪疑问"><a href="#关于面试的世纪疑问" class="headerlink" title="关于面试的世纪疑问"></a>关于面试的世纪疑问</h3><h4 id="为什么我感觉面试官就是在刁难我？"><a href="#为什么我感觉面试官就是在刁难我？" class="headerlink" title="为什么我感觉面试官就是在刁难我？"></a>为什么我感觉面试官就是在刁难我？</h4><h4 id="为什么面试中问到的问题比实际工作中用到的要难？"><a href="#为什么面试中问到的问题比实际工作中用到的要难？" class="headerlink" title="为什么面试中问到的问题比实际工作中用到的要难？"></a>为什么面试中问到的问题比实际工作中用到的要难？</h4><h4 id="学历重要吗？"><a href="#学历重要吗？" class="headerlink" title="学历重要吗？"></a>学历重要吗？</h4><h2 id="软件外包"><a href="#软件外包" class="headerlink" title="软件外包"></a>软件外包</h2><h3 id="什么是软件外包：大部分软件外包公司是帮甲方做“体力活”"><a href="#什么是软件外包：大部分软件外包公司是帮甲方做“体力活”" class="headerlink" title="什么是软件外包：大部分软件外包公司是帮甲方做“体力活”"></a>什么是软件外包：大部分软件外包公司是帮甲方做“体力活”</h3><h3 id="外包有哪些局限性？"><a href="#外包有哪些局限性？" class="headerlink" title="外包有哪些局限性？"></a>外包有哪些局限性？</h3><ul>
<li>难以获得完整地解决问题的能力  </li>
<li>外包公司不注重人才的技术成长，涨薪受限  </li>
<li>外包公司没有探索的环境  </li>
<li>可替代性强，可能无法完整参与一个项目</li>
</ul>
<h3 id="什么情况下可以考虑外包？"><a href="#什么情况下可以考虑外包？" class="headerlink" title="什么情况下可以考虑外包？"></a>什么情况下可以考虑外包？</h3><ul>
<li>通过外包快速积累经验  </li>
<li>希望进入一个新的行业  </li>
<li>为了眼前的苟且</li>
</ul>
<h2 id="软件外派"><a href="#软件外派" class="headerlink" title="软件外派"></a>软件外派</h2><h3 id="外派与外包的不同"><a href="#外派与外包的不同" class="headerlink" title="外派与外包的不同"></a>外派与外包的不同</h3><ul>
<li>外派在甲方工作，外包则在自己公司工作  </li>
<li>外派是要和甲方公司签订派遣协议的  </li>
<li>外派做的事情更贴近甲方公司员工自己做的事情，外包则是做甲方公司不做的事情</li>
</ul>
<h3 id="外派做的是甲方来不及做的事情，或是低技术含量的东西"><a href="#外派做的是甲方来不及做的事情，或是低技术含量的东西" class="headerlink" title="外派做的是甲方来不及做的事情，或是低技术含量的东西"></a>外派做的是甲方来不及做的事情，或是低技术含量的东西</h3><h3 id="外派的不足"><a href="#外派的不足" class="headerlink" title="外派的不足"></a>外派的不足</h3><ul>
<li>工作于此，却不属于此  </li>
<li>没有机会独立承担任务  </li>
<li>不稳定，终止派遣合同的代价远比终止劳动合同要低得多  </li>
<li>发展受限，不会有被甲方培养的机会</li>
</ul>
<h3 id="外派的优点"><a href="#外派的优点" class="headerlink" title="外派的优点"></a>外派的优点</h3><ul>
<li>增长见识  </li>
<li>和外包比，可以较早参与新项目  </li>
<li>证明自己的能力，赢得更多的机会  </li>
<li>现金收入较高</li>
</ul>
<h2 id="程序员转管理"><a href="#程序员转管理" class="headerlink" title="程序员转管理"></a>程序员转管理</h2><h3 id="转管理后的不同：管理岗要通过让手下创造更多的价值，来实现自己的价值"><a href="#转管理后的不同：管理岗要通过让手下创造更多的价值，来实现自己的价值" class="headerlink" title="转管理后的不同：管理岗要通过让手下创造更多的价值，来实现自己的价值"></a>转管理后的不同：管理岗要通过让手下创造更多的价值，来实现自己的价值</h3><h3 id="一线经理要做什么"><a href="#一线经理要做什么" class="headerlink" title="一线经理要做什么"></a>一线经理要做什么</h3><h4 id="对内"><a href="#对内" class="headerlink" title="对内"></a>对内</h4><ul>
<li>从IC视角转向管理视角，发挥团队的最大战斗力  </li>
<li>管理绩效，合理激励</li>
</ul>
<h4 id="对外"><a href="#对外" class="headerlink" title="对外"></a>对外</h4><ul>
<li>组织协调各种资源</li>
<li>计划和安排，争取资源  </li>
<li>进行各种交流，做出承诺和决策</li>
</ul>
<h4 id="对未来"><a href="#对未来" class="headerlink" title="对未来"></a>对未来</h4><ul>
<li>理解公司的发展方向  </li>
<li>培养人才，发展团队  </li>
<li>获取课后，赢得认可</li>
</ul>
<h3 id="什么样的人适合转管理"><a href="#什么样的人适合转管理" class="headerlink" title="什么样的人适合转管理"></a>什么样的人适合转管理</h3><ul>
<li>喜欢和人打交道  </li>
<li>会经营、有眼光、有干劲  </li>
<li>能够承受压力  </li>
<li>有远大抱负</li>
</ul>
<h3 id="转不转管理呢？"><a href="#转不转管理呢？" class="headerlink" title="转不转管理呢？"></a>转不转管理呢？</h3><ul>
<li>管理的临界级别确实比个人岗要高1~2个级别  </li>
<li>无论是不是转管理，临界级别在那里，成长都是有瓶颈的  </li>
<li>程序员要有专攻的方向，比如业务，比如架构  </li>
<li>无论是否转管理，越成长，越需要交流，获取信息，整合信息</li>
</ul>
<h2 id="加入创业公司"><a href="#加入创业公司" class="headerlink" title="加入创业公司"></a>加入创业公司</h2><h3 id="认清创业公司"><a href="#认清创业公司" class="headerlink" title="认清创业公司"></a>认清创业公司</h3><ul>
<li>做项目变现的公司“不是”  </li>
<li>小公司“不一定是”  </li>
<li>创造新事物的公司才“是”</li>
</ul>
<h3 id="加入创业公司，需要权衡哪些事情？"><a href="#加入创业公司，需要权衡哪些事情？" class="headerlink" title="加入创业公司，需要权衡哪些事情？"></a>加入创业公司，需要权衡哪些事情？</h3><ul>
<li>提前算好收支这笔账  </li>
<li>选择公司就是选择团队  </li>
<li>认可创始人  </li>
<li>亲兄弟，明算账  </li>
<li>准备好强大的精神和肉体  </li>
<li>能持续跟得上公司的发展</li>
</ul>
<h3 id="创业VS普通工作"><a href="#创业VS普通工作" class="headerlink" title="创业VS普通工作"></a>创业VS普通工作</h3><ul>
<li>创业是Hell难度，工作的Normal难度  </li>
<li>其实创业是一种心态，在普通工作中，如果用创业的心态工作，依然可以收获更多的回报  </li>
<li>创业即使失败，也可以帮助认清自己，收获一段难忘的回忆</li>
</ul>
<h1 id="职场情商篇"><a href="#职场情商篇" class="headerlink" title="职场情商篇"></a>职场情商篇</h1><h2 id="升职"><a href="#升职" class="headerlink" title="升职"></a>升职</h2><h3 id="升职的逻辑"><a href="#升职的逻辑" class="headerlink" title="升职的逻辑"></a>升职的逻辑</h3><ul>
<li>先达到下个级别的能力，公司才回考虑升职  </li>
<li>稳定输出工作成果，而不是时而做得好，时而做得不行  </li>
<li>技术上不仅要绝活，更要能全面掌握工作需要的技术  </li>
<li>资历是升值必须考虑的因素，也是对老员工各种积累和软能力的认可</li>
</ul>
<h3 id="程序员的三个阶段"><a href="#程序员的三个阶段" class="headerlink" title="程序员的三个阶段"></a>程序员的三个阶段</h3><ul>
<li>写出好代码不再是问题  </li>
<li>稳稳的搞定一个系统，清楚系统的方方面面，各种细节，系统的能力的边界等  </li>
<li>了解系统所解决的问题领域，可以让系统发展的一个更高的层面</li>
</ul>
<h3 id="升职的经理视角"><a href="#升职的经理视角" class="headerlink" title="升职的经理视角"></a>升职的经理视角</h3><ul>
<li>符合升值逻辑  </li>
<li>和经理彼此不对付的人，大概率不会得到升职  </li>
<li>离职可能性高的人，升职的概率会低</li>
</ul>
<h2 id="职场政治"><a href="#职场政治" class="headerlink" title="职场政治"></a>职场政治</h2><h3 id="为什么一定会有职场政治"><a href="#为什么一定会有职场政治" class="headerlink" title="为什么一定会有职场政治"></a>为什么一定会有职场政治</h3><ul>
<li>人少总是小而美，利益分配很简单  </li>
<li>人多就会有“江湖”，职场政治就是帮忙搞定职场利益分配的</li>
</ul>
<h3 id="一般公司里的那些职场政治"><a href="#一般公司里的那些职场政治" class="headerlink" title="一般公司里的那些职场政治"></a>一般公司里的那些职场政治</h3><ul>
<li>改组：必须要打破老的利益格局，发展才能有突破  </li>
<li>合作要考虑利益，要互惠互利，不要轻易动对方的蛋糕</li>
</ul>
<h3 id="程序员应该做什么"><a href="#程序员应该做什么" class="headerlink" title="程序员应该做什么"></a>程序员应该做什么</h3><ul>
<li>尊重职场政治  </li>
<li>懂得组织的利益所在</li>
</ul>
<h2 id="自上而下的技术更新"><a href="#自上而下的技术更新" class="headerlink" title="自上而下的技术更新"></a>自上而下的技术更新</h2><h3 id="自上而下所推动的技术更新，肯定是伴随利益变动的"><a href="#自上而下所推动的技术更新，肯定是伴随利益变动的" class="headerlink" title="自上而下所推动的技术更新，肯定是伴随利益变动的"></a>自上而下所推动的技术更新，肯定是伴随利益变动的</h3><h3 id="业界那些技术驱动型更新"><a href="#业界那些技术驱动型更新" class="headerlink" title="业界那些技术驱动型更新"></a>业界那些技术驱动型更新</h3><ul>
<li>亚马逊的SOA：能成为云计算老大的基础之一  </li>
<li>阿里巴巴公司的去IOE：用自己的核心技术，支撑起电商帝国  </li>
<li>京东从.Net平台换到Java平台：公司不同发展阶段的需要  </li>
<li>上云计算：解开了各个公司业务被计算资源的束缚</li>
</ul>
<h3 id="程序员如何应对"><a href="#程序员如何应对" class="headerlink" title="程序员如何应对"></a>程序员如何应对</h3><ul>
<li>了解变化的原因和目的，变化都是取舍的艺术  </li>
<li>看清和自己相关技术的发展和趋势，做好应对准备  </li>
<li>必须积极应对：或全力以赴的履行自己的职责，或明哲保身换个地方</li>
</ul>
<h2 id="向同事请教问题"><a href="#向同事请教问题" class="headerlink" title="向同事请教问题"></a>向同事请教问题</h2><h3 id="顺畅沟通的内核：尊重"><a href="#顺畅沟通的内核：尊重" class="headerlink" title="顺畅沟通的内核：尊重"></a>顺畅沟通的内核：尊重</h3><h3 id="输出式沟通"><a href="#输出式沟通" class="headerlink" title="输出式沟通"></a>输出式沟通</h3><ul>
<li>尊重被输出人的自主意愿  </li>
<li>不要打断别人解决问题的过程  </li>
<li>是在帮助别人，而不是在显摆自己</li>
</ul>
<h3 id="请教式沟通"><a href="#请教式沟通" class="headerlink" title="请教式沟通"></a>请教式沟通</h3><ul>
<li>没人有义务帮你，所以请尊重别人的时间和精力  </li>
<li>自己能搞定的问题不要麻烦别人  </li>
<li>探索式的问题更受人欢迎</li>
</ul>
<h3 id="请教式沟通小技巧"><a href="#请教式沟通小技巧" class="headerlink" title="请教式沟通小技巧"></a>请教式沟通小技巧</h3><ul>
<li>不要问相同的问题  </li>
<li>请教后积极总结归纳，如果收获很多，可以总结出文档  </li>
<li>需要大量帮助时，可以向经理申请专门的人帮助自己</li>
</ul>
<h3 id="向上沟通"><a href="#向上沟通" class="headerlink" title="向上沟通"></a>向上沟通</h3><ul>
<li>先准备好数据，要言之有物  </li>
<li>汇报工作时，先说成果和问题  </li>
<li>申请资源时，要给出详尽的数据和前因后果  </li>
<li>请求帮忙做决策时，要带着解决方案来，不要只带着问题来</li>
</ul>
<h1 id="技术成长篇"><a href="#技术成长篇" class="headerlink" title="技术成长篇"></a>技术成长篇</h1><h2 id="技术舒适区"><a href="#技术舒适区" class="headerlink" title="技术舒适区"></a>技术舒适区</h2><h3 id="程序员的技术舒适区，就是自己的技术领地"><a href="#程序员的技术舒适区，就是自己的技术领地" class="headerlink" title="程序员的技术舒适区，就是自己的技术领地"></a>程序员的技术舒适区，就是自己的技术领地</h3><h3 id="为什么程序员必须一直学习"><a href="#为什么程序员必须一直学习" class="headerlink" title="为什么程序员必须一直学习"></a>为什么程序员必须一直学习</h3><ul>
<li>技术要么发展，要么被淘汰  </li>
<li>学到手的技术会一直贬值，不学习，自己就跟着技术一起贬值</li>
</ul>
<h3 id="技术骨架的构成"><a href="#技术骨架的构成" class="headerlink" title="技术骨架的构成"></a>技术骨架的构成</h3><ul>
<li>核心架构设计：这个技术有哪些核心的架构设计  </li>
<li>功能模型：这个技术有哪些功能，功能的接口是什么  </li>
<li>状态模型：系统在运行时有哪些状态，状态之间的变化原因是什么  </li>
<li>数据模型：这个技术是怎么组织数据的，是怎么处理数据的  </li>
<li>线程模型：这个技术有哪些线程，分别是做什么的</li>
</ul>
<h3 id="程序员的舒适状态"><a href="#程序员的舒适状态" class="headerlink" title="程序员的舒适状态"></a>程序员的舒适状态</h3><ul>
<li>在工作中寻找能提供正反馈的学习目标，工作中有想当比例的时间在学习  </li>
<li>关注行业发展，了解新技术的基本情况，但是不主动出击去深入学习用不到的技术  </li>
<li>没事不找事，遇事不怕事，工作中遇到任何技术问题，都抽时间搞定它  </li>
<li>深入学习新技术时，搭建技术骨架，用新知识点缀自己的技术骨架</li>
</ul>
<h2 id="技术观"><a href="#技术观" class="headerlink" title="技术观"></a>技术观</h2><h3 id="软件工程师是要用技术把事情做成"><a href="#软件工程师是要用技术把事情做成" class="headerlink" title="软件工程师是要用技术把事情做成"></a>软件工程师是要用技术把事情做成</h3><h3 id="吃透技术"><a href="#吃透技术" class="headerlink" title="吃透技术"></a>吃透技术</h3><ul>
<li>熟练使用  </li>
<li>精准掌控  </li>
<li>知根知底</li>
</ul>
<h3 id="需求至上"><a href="#需求至上" class="headerlink" title="需求至上"></a>需求至上</h3><ul>
<li>技术的目的是满足需求  </li>
<li>技术的价值是支撑业务  </li>
<li>技术要解决用户的问题，而不是证明技术本身更高明</li>
</ul>
<h2 id="错误的技术观点"><a href="#错误的技术观点" class="headerlink" title="错误的技术观点"></a>错误的技术观点</h2><h3 id="技术不扎实，不思进取"><a href="#技术不扎实，不思进取" class="headerlink" title="技术不扎实，不思进取"></a>技术不扎实，不思进取</h3><ul>
<li>我们都是从小白做起  </li>
<li>积极主动学习，补齐短板</li>
</ul>
<h3 id="技术洁癖，满眼问题"><a href="#技术洁癖，满眼问题" class="headerlink" title="技术洁癖，满眼问题"></a>技术洁癖，满眼问题</h3><ul>
<li>每个项目都有各种不尽如人意的外部条件  </li>
<li>软件工程师存在的价值，面对这些问题，继续把项目向最好的方向推进  </li>
<li>先证明自己的能力和价值，再提更多的条件</li>
</ul>
<h3 id="使用不必要的技术手段"><a href="#使用不必要的技术手段" class="headerlink" title="使用不必要的技术手段"></a>使用不必要的技术手段</h3><ul>
<li>技术存在的目的是解决问题，其余都不重要  </li>
<li>拿公司试验场：学了新技术，内心很骚动，不用不爽  </li>
<li>故步自封的遗老遗少：无视技术的创新和发展</li>
</ul>
<h2 id="软件系统架构师"><a href="#软件系统架构师" class="headerlink" title="软件系统架构师"></a>软件系统架构师</h2><h3 id="软件架构师就是构造一个世界，让业务可以在这个世界里运转"><a href="#软件架构师就是构造一个世界，让业务可以在这个世界里运转" class="headerlink" title="软件架构师就是构造一个世界，让业务可以在这个世界里运转"></a>软件架构师就是构造一个世界，让业务可以在这个世界里运转</h3><h3 id="软件系统架构师做什么"><a href="#软件系统架构师做什么" class="headerlink" title="软件系统架构师做什么"></a>软件系统架构师做什么</h3><ul>
<li>理解要解决的问题  </li>
<li>摸清解决问题能使用的资源  </li>
<li>定义解决问题的模型  </li>
<li>给出模型各个模块的详细设计</li>
</ul>
<h3 id="如何一步步成为架构师"><a href="#如何一步步成为架构师" class="headerlink" title="如何一步步成为架构师"></a>如何一步步成为架构师</h3><ul>
<li>每个程序员都或多或少在做架构师的事情  </li>
<li>务实技术实力  </li>
<li>注重自己架构能力的培养  </li>
<li>主动学习架构，注重自己架构师能力的培养  </li>
<li>保持开放的心态，不能固守己见</li>
</ul>
<h3 id="架构师的核心能力"><a href="#架构师的核心能力" class="headerlink" title="架构师的核心能力"></a>架构师的核心能力</h3><ul>
<li>来自实践和技术的积累  </li>
<li>对行业和技术的产生有自己的理解，形成自己的视界</li>
</ul>
<h2 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h2><h3 id="系统集成为什么最难"><a href="#系统集成为什么最难" class="headerlink" title="系统集成为什么最难"></a>系统集成为什么最难</h3><ul>
<li>实际情况可能没有预料到，也可能发生了变化  </li>
<li>系统集成既意味着有交互，所有没落实的细节问题都会在这里暴露出来  </li>
<li>系统集成是要产出结果，要得到别人的认可</li>
</ul>
<h3 id="软件系统集成的常见问题"><a href="#软件系统集成的常见问题" class="headerlink" title="软件系统集成的常见问题"></a>软件系统集成的常见问题</h3><ul>
<li>内部子模块之间架构不统一  </li>
<li>对外部系统的假设不成立  </li>
<li>外部系统配置问题  </li>
<li>用户输入数据问题  </li>
<li>外部系统传输的数据问题</li>
</ul>
<h3 id="软件系统集成的应对方法"><a href="#软件系统集成的应对方法" class="headerlink" title="软件系统集成的应对方法"></a>软件系统集成的应对方法</h3><ul>
<li>架构要统一  </li>
<li>不做假设，尽早验证外部依赖  </li>
<li>做系统集成的边界，充分的记录log</li>
</ul>
<h1 id="加餐"><a href="#加餐" class="headerlink" title="加餐"></a>加餐</h1><h2 id="沟通中的冲突"><a href="#沟通中的冲突" class="headerlink" title="沟通中的冲突"></a>沟通中的冲突</h2><h3 id="处理冲突的双方要对等"><a href="#处理冲突的双方要对等" class="headerlink" title="处理冲突的双方要对等"></a>处理冲突的双方要对等</h3><ul>
<li>自己说了不算的事情，不要作出承诺  </li>
<li>很多和利益相关的冲突，我们程序员只是打辅助，不需要主动参与</li>
</ul>
<h3 id="程序员应该如何应对冲突"><a href="#程序员应该如何应对冲突" class="headerlink" title="程序员应该如何应对冲突"></a>程序员应该如何应对冲突</h3><ul>
<li>找到大家的共识  </li>
<li>以共识为基础，把事情向前推进  </li>
<li>做事情的方式方法可以妥协  </li>
<li>目标必须坚持</li>
</ul>
<h3 id="程序员工作中的那些共识"><a href="#程序员工作中的那些共识" class="headerlink" title="程序员工作中的那些共识"></a>程序员工作中的那些共识</h3><ul>
<li>代码偏好：findbugs等行业标准  </li>
<li>接口设计：接口设计应该包含  </li>
<li>系统架构：大家对问题的理解要统一  </li>
<li>新功能：理解新需求、升级架构、以支持新功能</li>
</ul>
<h3 id="冲突的价值"><a href="#冲突的价值" class="headerlink" title="冲突的价值"></a>冲突的价值</h3><ul>
<li>相互切磋，不打不相识  </li>
<li>逼迫自己深入思考自己的观点  </li>
<li>磨合团队，达成默契</li>
</ul>
<h3 id="程序员一定不要逃避冲突，逃避冲突只能让问题对自己来说更麻烦"><a href="#程序员一定不要逃避冲突，逃避冲突只能让问题对自己来说更麻烦" class="headerlink" title="程序员一定不要逃避冲突，逃避冲突只能让问题对自己来说更麻烦"></a>程序员一定不要逃避冲突，逃避冲突只能让问题对自己来说更麻烦</h3><h2 id="如何应对加班"><a href="#如何应对加班" class="headerlink" title="如何应对加班"></a>如何应对加班</h2><h3 id="任务太多"><a href="#任务太多" class="headerlink" title="任务太多"></a>任务太多</h3><ul>
<li>分析是否当前的效率低下  </li>
<li>提升效率：升级系统，开发自动化工具  </li>
<li>不要习惯低效率工作，要发挥自己的才能</li>
</ul>
<h3 id="出现了紧急的事情"><a href="#出现了紧急的事情" class="headerlink" title="出现了紧急的事情"></a>出现了紧急的事情</h3><ul>
<li>避免线上问题：增强监控，规范上线流程  </li>
<li>紧急的项目：如果收获可观，可以考虑阶段性的付出时间</li>
</ul>
<h3 id="公司强制加班"><a href="#公司强制加班" class="headerlink" title="公司强制加班"></a>公司强制加班</h3><ul>
<li>学习和探索新技术  </li>
<li>修复大家都在抱怨的小痛点  </li>
<li>去遗留系统里淘金，理解系统处理的业务  </li>
<li>准备好为系统升级</li>
</ul>
<h3 id="加班的时间，也是我们自己的时间，要利用加班的时间做能提升自己的事情，不要浪费自己的时间。"><a href="#加班的时间，也是我们自己的时间，要利用加班的时间做能提升自己的事情，不要浪费自己的时间。" class="headerlink" title="加班的时间，也是我们自己的时间，要利用加班的时间做能提升自己的事情，不要浪费自己的时间。"></a>加班的时间，也是我们自己的时间，要利用加班的时间做能提升自己的事情，不要浪费自己的时间。</h3><h2 id="程序员怎么越干越努力"><a href="#程序员怎么越干越努力" class="headerlink" title="程序员怎么越干越努力"></a>程序员怎么越干越努力</h2><h3 id="如何应对焦虑感"><a href="#如何应对焦虑感" class="headerlink" title="如何应对焦虑感"></a>如何应对焦虑感</h3><ul>
<li>习惯焦虑，让焦虑感督促自己持续学习和进步  </li>
<li>找到适合自己的发展道路</li>
</ul>
<h3 id="前期职业？后期职业？"><a href="#前期职业？后期职业？" class="headerlink" title="前期职业？后期职业？"></a>前期职业？后期职业？</h3><ul>
<li>任何职业的从业者都很多，而能脱颖而出的都是少数  </li>
<li>任何职业，都需要努力，选择不能代替努力</li>
</ul>
<h3 id="软件行业确实不一样"><a href="#软件行业确实不一样" class="headerlink" title="软件行业确实不一样"></a>软件行业确实不一样</h3><ul>
<li>新兴行业，缺人不缺钱  </li>
<li>软件公司危机感  </li>
<li>程序员必须有创新的精神，有斗志，不安于现状</li>
</ul>
<h3 id="不同类型的职业"><a href="#不同类型的职业" class="headerlink" title="不同类型的职业"></a>不同类型的职业</h3><ul>
<li>技术简单，产出明确，工作流程可以规范化  </li>
<li>产出成果的过程复杂，人才无法批量培养，需要经验积累和发挥自己的主观能动性</li>
</ul>
<h3 id="程序员如何应对-1"><a href="#程序员如何应对-1" class="headerlink" title="程序员如何应对"></a>程序员如何应对</h3><ul>
<li>持续学习技术  </li>
<li>持续思考业务  </li>
<li>吃掉更多的资源，积累自己的经验</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="做系统，数据比软件更重要"><a href="#做系统，数据比软件更重要" class="headerlink" title="做系统，数据比软件更重要"></a>做系统，数据比软件更重要</h3><ul>
<li>数据是软件系统的根本，就好像经济活动里的钱和账，抓住数据就能看清根本  </li>
<li>数据升级和迁移，相比软件升级要难的多，风险也大的多，对于系统的数据架构设计，值得多花点心思  </li>
<li>数据被删了，会损失惨重，程序代码被删了，只要不造成数据问题，基本没什么长期影响  </li>
<li>数据是新时代的“土地”，什么都要靠它，而且很难买到，自己积累则要费力更费时</li>
</ul>
<h3 id="与人沟通，没数据，莫开口"><a href="#与人沟通，没数据，莫开口" class="headerlink" title="与人沟通，没数据，莫开口"></a>与人沟通，没数据，莫开口</h3><ul>
<li>先说数据，再说自己的分析，没有数据支撑，大家很难达成共识或得出结论  </li>
<li>注明使用数据的出处，方便你从数据源验证更多的数据  </li>
<li>如果有可能，交叉验证，从不同的角度获取相同意义的数据进行比对和验证</li>
</ul>
]]></content>
      <categories>
        <category>Work-Career</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>职场</tag>
        <tag>生存指南</tag>
      </tags>
  </entry>
  <entry>
    <title>兴隆湖半日游</title>
    <url>/2020/05/16/xing-long-hu-half-a-day-trip/</url>
    <content><![CDATA[<p>今天和女朋友计划去兴隆湖游玩。  </p>
<p>由于住的地方比较远，倒两趟公交，所以吃过午饭就准备出发了。  </p>
<p>到达目的地后，第一感受是这里人真少，空气很清新，我俩在湖边慢悠悠的散着步，看着有小朋友们玩滑板，还有小姐姐在练舞蹈。  </p>
<p>期间女朋友突然肚子饿了，去一家超市买辣条，明明上面标着是3元&#x2F;袋，店家说要4.5元，女朋友二话不说就扫码付款，我提出的疑惑后，店家连声说抱歉，给我女朋友退了1.5元。所以以后遇到困惑还是需要提出质疑的哦。  </p>
<p>兴隆湖逛完了，又把旁边的鹿溪河生态区逛了逛，不得不说，安安静静的坐在椅子上，听着鸟叫的声音也是一种享受呢。  </p>
<p>晚上到家准备买些菜，毕竟领了成都的4张线下消费劵。买了很多的菜和水果，女朋友想吃烧烤，于是在一家路边摊点烧烤，md没有问老板烤串的价格，等选完了付款告诉我说是83元，我去，我让他再算一遍，他给我说荤的是6元，素的是2元，有些是3元的，加了一遍又是83元，行吧，我是觉得平时再怎么点也不会超过50的，算理亏了，店家的数学应该还过得去，只能暗自表示下次一定别再来吃了。  </p>
<p>就这样，结束了一天的行程。远离了喧嚣，人与人之间的勾心斗角，这样的感觉真好。  </p>
<p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing1.jpg">  </p>
<p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing2.jpg">  </p>
<p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing3.jpg"></p>
]]></content>
      <categories>
        <category>Travel-notes</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>烧烤</tag>
      </tags>
  </entry>
  <entry>
    <title>YApi的安装与部署</title>
    <url>/2022/02/14/yapi-install-and-deploy/</url>
    <content><![CDATA[<h1 id="什么是Yapi"><a href="#什么是Yapi" class="headerlink" title="什么是Yapi"></a>什么是Yapi</h1><p>YApi 是由去哪儿移动架构组推出的一款开源项目，是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。  </p>
<p>官网：<a href="https://yapi.ymfe.org/%EF%BC%8CYapi%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7">https://yapi.ymfe.org/，Yapi具有以下功能特性</a>  </p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>扁平化权限设计，即保证了大型企业级项目的管理，又保证了易用性。  </p>
<h2 id="可视化接口管理"><a href="#可视化接口管理" class="headerlink" title="可视化接口管理"></a>可视化接口管理</h2><p>基于 websocket 的多人协作接口编辑功能和类 postman 测试工具，让多人协作成倍提升开发效率。  </p>
<h2 id="Mock-Server"><a href="#Mock-Server" class="headerlink" title="Mock Server"></a>Mock Server</h2><p>易用的 Mock Server，MockServer 除支持普通的随机 mock 外，还增加了 Mock 期望功能，根据设置的请求过滤规则，返回期望数据。  </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>完善的接口自动化测试，保证数据的正确性，支持对 Response 断言。  </p>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>接口支持导入 swagger, postman, har 数据格式，方便迁移旧项目。  </p>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>强大的插件机制，满足各类业务需求。  </p>
<h1 id="个人为什么选择会用它"><a href="#个人为什么选择会用它" class="headerlink" title="个人为什么选择会用它"></a>个人为什么选择会用它</h1><ul>
<li>多人协作管理接口，避免满屏幕的txt、word文档  </li>
<li>内网部署，避免数据泄露  </li>
<li>图形化操作，好用  </li>
<li>以服务的形式来部署，新建一个账号一个团队即可使用  </li>
<li>外加Postman的测试接口功能</li>
</ul>
<h1 id="环境-nodejs-7-6-mongo-2-6"><a href="#环境-nodejs-7-6-mongo-2-6" class="headerlink" title="环境  nodejs(7.6+)  mongo(2.6+)"></a>环境  nodejs(7.6+)  mongo(2.6+)</h1><p><code>nodejs</code>安装  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ curl -sL https://deb.nodesource.com/setup_9.x | sudo -E bash -</span><br><span class="line">$ sudo apt install -y nodejs</span><br></pre></td></tr></table></figure>

<p><code>npm</code>安装  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt -y npm</span><br></pre></td></tr></table></figure>

<p>注：建议再安装<code>nvm</code>，方便管理<code>node</code>版本  </p>
<p>mongodb安装  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install mongodb</span><br><span class="line">$ mongo version</span><br><span class="line">MongoDB shell version: 2.6.10</span><br></pre></td></tr></table></figure>

<p>启动mongo  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service mongodb start</span><br></pre></td></tr></table></figure>

<p>测试mongodb是否启动成功<br>访问<code>http://localhost:27017/</code>，页面显示  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure>

<h1 id="安装YApi"><a href="#安装YApi" class="headerlink" title="安装YApi"></a>安装YApi</h1><h2 id="官方推荐的可视化部署方式"><a href="#官方推荐的可视化部署方式" class="headerlink" title="官方推荐的可视化部署方式"></a>官方推荐的可视化部署方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g yapi-cli --registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">//启动yapi server</span><br><span class="line">$ yapi server</span><br><span class="line">在浏览器打开 http://0.0.0.0:9090 访问。非本地服务器，请将 0.0.0.0 替换成指定的域名或ip</span><br></pre></td></tr></table></figure>

<p>显示部署页面<br><img src="/2022/02/14/yapi-install-and-deploy/yapi%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2.png">  </p>
<p>点击开始部署  </p>
<p>部署完成后访问<code>http://localhost:3000</code><br>登录账号<code>admin@admin.com</code><br>密码<code>ymfe.org</code>  </p>
<h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><p><a href="https://cloud.tencent.com/developer/article/1823050">docker部署安装yapi框架</a>  </p>
<h2 id="Yaml文件部署"><a href="#Yaml文件部署" class="headerlink" title="Yaml文件部署"></a>Yaml文件部署</h2><p>将下面的示例复制粘贴下来命名为 <code>docker-compose.yml</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">yapi-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jayfong/yapi-x:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">yapi-web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">40001</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_ADMIN_ACCOUNT=admin@docker.yapi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_ADMIN_PASSWORD=adm1n</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_CLOSE_REGISTER=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_DB_SERVERNAME=yapi-mongo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_DB_PORT=27017</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_DB_DATABASE=yapi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_MAIL_ENABLE=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_LDAP_LOGIN_ENABLE=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">YAPI_PLUGINS=[]</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yapi-mongo</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yapi-mongo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">  <span class="attr">yapi-mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">yapi-mongo</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/db:/data/db</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<p>使用命令<code>docker-compose up -d</code>运行后，通过<code>http://localhost:40001</code>即可访问 YApi-X。  </p>
<p>部署成功后，显示：  </p>
<p><img src="/2022/02/14/yapi-install-and-deploy/yapi.png">  </p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Cannot-find-module-‘fs-extra’"><a href="#Cannot-find-module-‘fs-extra’" class="headerlink" title="Cannot find module ‘fs-extra’"></a>Cannot find module ‘fs-extra’</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &gt; yapi-vendor@1.9.2 install-server &gt; node server/install.js</span><br><span class="line">Error: internal/modules/cjs/loader.js:800 throw err; ^ Error: Cannot find module &#x27;fs-extra&#x27; Require stack: - /home/neo/my-yapi/vendors/server/install.js at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15) at Function.Module._load (internal/modules/cjs/loader.js:690:27) at Module.require (internal/modules/cjs/loader.js:852:19) at require (internal/modules/cjs/helpers.js:74:18) at Object.&lt;anonymous&gt; (/home/neo/my-yapi/vendors/server/install.js:1:12) at Module._compile (internal/modules/cjs/loader.js:959:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10) at Module.load (internal/modules/cjs/loader.js:815:32) at Function.Module._load (internal/modules/cjs/loader.js:727:14) at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10) &#123; code: &#x27;MODULE_NOT_FOUND&#x27;, requireStack: [ &#x27;/home/neo/my-yapi/vendors/server/install.js&#x27; ] &#125; </span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/YMFE/yapi/issues/16#issuecomment">YApi 安装出现问题请看这里</a><br><a href="http://blog.itjsz.com/%E9%97%AE%E9%A2%98-error-cannot-find-module-fs-extra/">Error Cannot find module ‘fs-extra’</a><br><a href="https://hellosean1025.github.io/yapi/documents/index.html">YApi教程</a>  </p>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>接口管理</tag>
        <tag>yapi</tag>
      </tags>
  </entry>
  <entry>
    <title>一朝沐杏雨，终身念师恩</title>
    <url>/2021/09/10/yi-zhao-mu-xing-yu-zhong-shen-nian-shi-en/</url>
    <content><![CDATA[<p>转眼间，又是一年一度的教师节，在此记录那些年我遇到的好老师给予的鼓励与帮助。  </p>
<h2 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h2><p>小学记不清了，唯一记得是二年级那会，冬天下着大雪，我课间玩耍，吸入了太多的冷空气，肠子扭在了一起，下午上课疼的馒头都是汗，脸色很不对，走路都不行，于是我的班主任就把我一步一步的，在大雪中把我背回了家。然后父母把我送到医院，打了一针就好了。  </p>
<p>这件事令我着实感动，让我第一次对老师这个职业不再感到有所畏惧。（可能是小时候不经常写作业吧，看到老师就很怕…）  </p>
<h2 id="初中"><a href="#初中" class="headerlink" title="初中"></a>初中</h2><p>初中的班主任很负责，个子不高，但说话还是字正腔圆，一听就是有主见的人。  </p>
<p>后来考大学填报专业，我还特意咨询了她，是生物专业&#x2F;工商管理专业&#x2F;计算机专业好一些呢，她耐心的听完我对这些专业的解读，给出了她的建议，最终我选了计算机专业，至少目前看来，我没有选错。  </p>
<p>另一位老师是姓刘的数学女老师，记得当时我数学很差，总是粗心，她就一步一步的教我如何分析，最终我克服了自己对数学的恐惧感。  </p>
<h2 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h2><p>高中反而和班主任联系不大，唯一联系较深的反而是我的高一物理老师，当时记得很清楚，我和凡儿和她，三个人在雪地里，绕着操场走了一圈又一圈，跟好朋友似的聊学业、聊困惑、聊对未来的期望…我现在已经想不起我们当时到底都聊了什么，但至少每次聊完，我所有的负面情绪都会一扫而空，也许那时我就明白，能有个人像树洞一样，耐心吞噬着你所有的不开心，也是一件很幸福的事呢。  </p>
<p>另一位就是高一英语李老师，口语发音很标准，知识渊博，为了让我们能记住英语单词，会举办各种比赛和活动，所以上她的课就是边玩边学会了英语，还有小奖励…只是今年过年回去，意外得到她早已得癌症去世的消息，心中还是有些难受的。  </p>
<h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p><img src="/2021/09/10/yi-zhao-mu-xing-yu-zhong-shen-nian-shi-en/talk.jpg">  </p>
<p>大一的时候，用我从励志书上学到的理论，去对抗班主任那从社会上学到的现实经验，最终我败了。但他并没有高高在上，而是语重心长的告诉我：多看看外面的世界，不要把眼光局限于校园内。——这是他告诉我的第一句话；  </p>
<p>大三的时候，是我学业最黑暗的时期，想不明白的事情很多，我问他还有机会吗？他说：想改变这个世界之前，先学会适应这个世界所制定的法则。——这是他告诉我的第二句话。  </p>
<p>最终，我没有能改变这个世界，但却学会了如何适应这个世界。  </p>
<p>先活下去，再伺机而动，寻求转机。  </p>
<p>我恍然大悟。  </p>
<h2 id="父母"><a href="#父母" class="headerlink" title="父母"></a>父母</h2><p>父母是陪伴我人生路上最长的老师。  </p>
<p>小时候教会我吃饭、走路；慢慢的教会我如何保护自己，树立基本的价值观；再大一些，父亲教会我一些酒桌文化，带我见识各种老板的饭局（虽然当时一直只顾吃），锻炼我的酒量和心理承受能力；母亲教我生存的基本技能，遇事不要慌，温柔待人，但也要有自己的底线。  </p>
<h2 id="一朝沐杏雨，终身念师恩"><a href="#一朝沐杏雨，终身念师恩" class="headerlink" title="一朝沐杏雨，终身念师恩"></a>一朝沐杏雨，终身念师恩</h2><p>这是我今天在朋友圈看到的一句话，觉得蛮不错，就借用了，也将作为本文的结束语。  </p>
<p>教师是一个辛苦的职业，就像《乡村教师》的描述——他们有一种个体，有一定数量，分布于这个种群的各个角落，这类个体充当两代生命体之间知识传递的媒介。  </p>
<p>他们在这块古老的土地上，用微博的力量，传递那确实存在的希望。  </p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>老师</tag>
        <tag>教师节</tag>
      </tags>
  </entry>
  <entry>
    <title>知识星球Go项目实战爬虫项目总结</title>
    <url>/2019/06/16/zsxq-go-project-action-crawler-summary/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>知识星球<code>Go项目实战</code>的第一个实战项目—&gt;爬虫。<br>本文记录直播内容和相关细节。  </p>
<h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><p>DOM，CSS选择器，jQuery  </p>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>前端：Bootstrap和jQuery</li>
<li>后端：Go</li>
<li>数据库：MySQL</li>
</ul>
<h3 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h3><ul>
<li>job_info 表：我们计划抓取猎聘、Boss直聘和拉钩网三个网站的 Go 语言相关职位信息。通过分析三个网站上的职位信息数据，结合咱们的目标，设计了 job_info 表；  </li>
<li>crawl_rule 表：针对 job_info 表的设计，我们希望在网站职位的详情页能够获取到相应信息。因为每个网站页面结构不同，抓取策略也会不一样，因此有了此表；  </li>
<li>auto_crawl_rule 表：crawl_rule 表是针对一个职位详情页的，但我们不可能手动一个页面一个页面抓取，而是希望能够提供一些信息将某个网站上相关职位信息批量抓取。此表用于抓取职位列表信息，进而抓取一个个职位信息；</li>
</ul>
<h3 id="数据库设计原则和注意事项-重点"><a href="#数据库设计原则和注意事项-重点" class="headerlink" title="数据库设计原则和注意事项(重点)"></a>数据库设计原则和注意事项(重点)</h3><p>1，字段不允许 NULL 且提供默认值，即 NOT NULL DEFAULT xx；<br>2，选择合适的最小数据类型；<br>3，确保是非负数的字段，加上 unsigned;<br>4，使用 COMMENT 给字段加备注；<br>5，表一般应该有 created_at 字段；<br>6，没特殊情况，请使用 InnoDB 引擎；<br>7，字符编码使用 utf8mb4；<strong>不要用utf8</strong><br>8，VARCHAR 类型的长度值使用 2 的幂次方减1或减2，比如 varchar(127) varchar(255) varchar(510) 因为 510 这个数字（长度）本身需要 2 个字节存储。（也就是长度超过 255 之后，用两个字节存储长度，所以减 2）；<br>9，根据查询条件，建立必要的索引；<br>10，NOT NULL，确保它一定不是NULL；  </p>
<h3 id="项目结构和代码组织"><a href="#项目结构和代码组织" class="headerlink" title="项目结构和代码组织"></a>项目结构和代码组织</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd  //项目入口，主程序</span><br><span class="line">│   └── crawler</span><br><span class="line">│       ├── background.go</span><br><span class="line">│       ├── crawler</span><br><span class="line">│       └── main.go</span><br><span class="line">├── config  //配置信息</span><br><span class="line">│   └── config.yaml</span><br><span class="line">├── dao  //数据访问对象，直接和数据存储打交道</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── auto_crawl_rule_test.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   ├── db.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── docs  //文档</span><br><span class="line">│   └── db.sql</span><br><span class="line">├── global  //全局信息，初始化</span><br><span class="line">│   ├── app.go</span><br><span class="line">│   ├── error.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── http  //</span><br><span class="line">│   ├── controller  //MVC 的 controller</span><br><span class="line">│   │   ├── job_handler.go</span><br><span class="line">│   │   └── job_handler_test.go</span><br><span class="line">│   ├── middleware  //http的中间件</span><br><span class="line">│   │   ├── logger.go</span><br><span class="line">│   │   └── recover.go</span><br><span class="line">│   └── routes.go</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logic  //业务逻辑</span><br><span class="line">│   ├── crawler</span><br><span class="line">│   │   ├── colly.go</span><br><span class="line">│   │   ├── goquery.go</span><br><span class="line">│   │   ├── parser.go</span><br><span class="line">│   │   └── work.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── model  //映射的结构体</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   └── job_info.go</span><br><span class="line">├── README.md</span><br><span class="line">├── template  //模板</span><br><span class="line">│   ├── detail.html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── util  //辅助工具</span><br><span class="line">    ├── file.go</span><br><span class="line">    ├── http.go</span><br><span class="line">    ├── int.go</span><br><span class="line">    └── ip.go</span><br></pre></td></tr></table></figure>

<h3 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h3><p>1，写死，保底<br>2，通过配置拿到数据，两种形式，读取配置文件和命令行参数传递过来<br>3，读环境变量  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本项目主要熟悉和培养用Go设计项目的框架，同时也把前段时间学习的知识点做了综合运用。下面记录下一些关键信息：    </p>
<ul>
<li>熟悉<code>go mod</code>  </li>
<li>执行数据库语句的代码和数据库语句最好分开来操作  </li>
<li>数据量很大的时候，最好不要随意改变数据表中的字段，不然服务会挂  </li>
<li>项目中还有待完善的部分，例如<code>Colly</code>的实现，结构体转数据表或数据表转结构体，选择分析器的部分</li>
</ul>
<h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>Q1:cmd下为什么要有crawler文件夹<br>如果cmd下放main.go，编译出来的文件名叫什么？—cmd  </p>
<p>Q2:并发版爬虫？什么时候成分布式的啊<br>抓的太频繁，会被封。</p>
<p>Q3:測試 controller 會直接對 db 調用，不知道這樣好嗎 </p>
<p>Q4:http 为什么要加 recover ？ 默认没有么  </p>
]]></content>
      <categories>
        <category>Learn-go</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>爬虫</tag>
        <tag>Go</tag>
        <tag>知识星球</tag>
      </tags>
  </entry>
</search>
